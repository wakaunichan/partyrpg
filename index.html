<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>しゅりんく・だんじょん・がーるず</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>

<body class="bg-green-100 flex items-center justify-center min-h-screen">
    <div id="game-container" class="w-full max-w-4xl mx-auto bg-green-200 rounded-2xl shadow-2xl overflow-hidden relative aspect-[4/3] sm:aspect-[16/9] flex flex-col">
        <!-- タイトル画面 -->
        <div id="title-screen" class="absolute inset-0 bg-cover bg-center flex flex-col items-center justify-center z-20 p-8" style="background-image: url('https://image.pollinations.ai/prompt/fantasy%20rpg%20dungeon,%20dark,%20mysterious,%20glowing%20runes,%20stone%20columns,%20roots,%20moss,%20pathway,%20digital%20painting');">
            <div class="bg-black/60 p-8 rounded-xl text-center shadow-lg">
                <h1 class="text-4xl sm:text-5xl font-bold text-white mb-8" style="text-shadow: 2px 2px 4px #000;">しゅりんく・だんじょん・がーるず</h1>
                <div class="flex flex-col sm:flex-row gap-4 justify-center">
                    <button id="load-button" class="action-button bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg hidden">つづきから</button>
                    <button id="start-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg">はじめから</button>
                    <button id="what-if-button" class="action-button bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg">もしもの物語</button>
                    <button id="rule-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg">ルール説明</button>
                </div>
            </div>
            <div id="debug-controls" class="absolute bottom-4 right-4 bg-black/50 p-2 rounded-lg flex flex-col gap-2 text-xs z-30">
                <button id="debug-saint-button" class="text-white p-1 rounded"></button>
                <button id="debug-treasure-button" class="text-white p-1 rounded"></button>
                <button id="debug-summer-button" class="text-white p-1 rounded"></button>
                <button id="debug-belles-button" class="text-white p-1 rounded"></button>
            </div>
        </div>

        <!-- ゲーム画面 -->
        <div id="dungeon-view" class="hidden flex-grow bg-cover bg-center relative flex flex-col justify-between p-4" style="background-image: url('https://image.pollinations.ai/prompt/fantasy%20rpg%20dungeon,%20dark,%20mysterious,%20glowing%20runes,%20stone%20columns,%20roots,%20moss,%20pathway,%20digital%20painting');">
            <p id="floor-display" class="hidden absolute top-4 left-4 text-white font-bold text-lg" style="text-shadow: 1px 1px 3px #000;"></p>
            <div id="menu-area" class="absolute top-4 right-4 z-30 flex flex-col items-end gap-2">
                <button id="menu-button" class="action-button bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-lg shadow-lg">メニュー</button>
                <button id="emergency-button" class="action-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg" title="戦闘が止まった時に押してください">緊急</button>
            </div>
            <div id="log-container" class="w-full max-w-2xl mx-auto rounded-lg p-2 text-center log-gradient shadow-md">
                <p id="log-message" class="text-gray-800 font-bold text-sm md:text-base"></p>
            </div>
            <div id="enemy-container" class="flex justify-center items-end gap-4 h-1/2"></div>
        </div>

        <!-- ログ履歴ツールチップ -->
        <div id="log-tooltip" class="hidden absolute bottom-24 left-1/2 -translate-x-1/2 w-full max-w-2xl bg-black/80 text-white text-sm rounded-lg p-4 shadow-lg z-40">
            <!-- ログ履歴がここに挿入される -->
        </div>

        <div id="hud" class="hidden w-full p-2 sm:p-4 hud-gradient shadow-inner">
            <div id="party-container" class="flex flex-wrap justify-center gap-2 sm:gap-4"></div>
        </div>

        <div id="command-container" class="hidden bg-gray-800/80 p-4 text-white flex justify-center items-center">
            <div id="dungeon-commands" class="flex gap-4">
                <button id="next-floor-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">次のフロアへ</button>
            </div>
            <div id="battle-commands" class="hidden w-full">
                <p id="command-message" class="text-center font-bold mb-2"></p>
                <div id="action-buttons" class="grid grid-cols-2 sm:grid-cols-4 gap-2"></div>
            </div>
        </div>

        <div id="modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-sm w-full">
                <h2 id="modal-title" class="text-3xl font-bold mb-4"></h2>
                <p id="modal-text" class="mb-6"></p>
                <button id="modal-button" class="action-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">タイトルに戻る</button>
            </div>
        </div>

        <!-- 願い星イベントモーダル -->
        <div id="wishing-star-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 id="wishing-star-modal-title" class="text-3xl font-bold mb-2 text-center text-cyan-600">願い星</h2>
                <p id="wishing-star-modal-prompt" class="mb-6 text-center">願い事をする仲間を一人選んでください。</p>
                <div id="wishing-star-char-select" class="grid grid-cols-2 sm:grid-cols-4 gap-4"></div>
                <div id="wishing-star-options" class="hidden grid grid-cols-1 md:grid-cols-2 gap-4"></div>
            </div>
        </div>

        <!-- 調合イベントモーダル -->
        <div id="alchemy-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 class="text-3xl font-bold mb-2 text-center text-purple-600">調合</h2>
                <p class="mb-6 text-center">手持ちのアイテムを組み合わせて、新たなアイテムを作り出せそうだ。<br>何を作りますか？</p>
                <div id="alchemy-options" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <!-- 調合選択肢がここに挿入される -->
                </div>
                <div class="text-center">
                    <button id="alchemy-cancel-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">やめる</button>
                </div>
            </div>
        </div>

        <!-- 身長固定確認モーダル -->
        <div id="height-lock-confirm-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <p id="height-lock-confirm-text" class="mb-6"></p>
                <button id="height-lock-confirm-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg mr-4">はい</button>
                <button id="height-lock-cancel-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">いいえ</button>
            </div>
        </div>

        <!-- 汎用イベントモーダル (テキスト＋選択肢) -->
        <div id="general-event-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 id="general-event-title" class="text-2xl font-bold mb-4"></h2>
                <p id="general-event-text" class="mb-6 whitespace-pre-wrap"></p>
                <div id="general-event-buttons" class="flex flex-col sm:flex-row justify-center gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <div id="item-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-40 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-md w-full">
                <h2 class="text-2xl font-bold mb-4">アイテム</h2>
                <div id="item-list" class="max-h-64 overflow-y-auto mb-4"></div><button id="item-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">閉じる</button></div>
        </div>

        <div id="level-up-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 class="text-3xl font-bold mb-4 text-center">勝利！</h2>
                <p class="mb-6 text-center">強化するキャラクターを一人選んでください。</p>
                <div id="level-up-party-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4"></div>
            </div>
        </div>

        <div id="rule-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-lg w-full">
                <h2 class="text-2xl font-bold mb-4">ルール説明</h2>
                <div class="space-y-2 text-gray-700 max-h-96 overflow-y-auto pr-2">
                    <p class="font-bold">目的:</p>
                    <p>ダンジョンの最深部(30階)にいるボスを倒すとゲームクリアです。</p>
                    <p class="font-bold">探索:</p>
                    <p>「次のフロアへ」進むと、敵との戦闘やランダムなイベントが発生します。「会話する」で仲間との会話を楽しめます。</p>
                    <p class="font-bold">戦闘:</p>
                    <p>素早さの順に行動します。戦闘に勝利すると、仲間を一人強化できます。</p>
                    <p class="font-bold">身長システム:</p>
                    <p>身長が変わるとステータスが変動します。高くなると攻撃力・防御力が上がり、低くなると素早さが上がります。敵からの狙われやすさ(ヘイト)も身長に影響されます。</p>
                </div>
                <div class="text-right mt-4">
                    <button id="rule-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">閉じる</button></div>
            </div>
        </div>

        <div id="select-team-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-2xl w-full relative">
                <h2 class="text-2xl font-bold mb-2">選抜チーム</h2>
                <button id="random-select-button" class="absolute top-6 right-6 action-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg text-sm">ランダム選択</button>
                <p id="selection-prompt" class="mb-4 text-gray-600">共に冒険する仲間を2～4人選んでください。</p>
                <div id="team-selection-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6 max-h-72 overflow-y-auto pr-2">
                    <!-- キャラクター選択肢がここに挿入されます -->
                </div>
                <div class="flex justify-between items-center">
                    <button id="select-team-back-button" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">戻る</button>
                    <div>
                        <span id="selection-counter" class="text-gray-600 mr-4">0 人選択中</span>
                        <button id="start-selection-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg opacity-50 cursor-not-allowed" disabled>冒険を始める</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="what-if-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-lg w-full">
                <h2 class="text-2xl font-bold mb-4">もしもの物語</h2>
                <p class="mb-2 text-gray-600">特別な設定で冒険を始めます。どの物語を体験しますか？</p>
                <div class="mb-2 p-2 bg-blue-50 border border-blue-200 rounded-lg flex items-center justify-between">
                    <label for="toggle-select-team" class="font-bold text-blue-700 cursor-pointer">好きな仲間で冒険する</label>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="toggle-select-team" id="toggle-select-team" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" />
                        <label for="toggle-select-team" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <!-- タブコンテナ -->
                <div id="what-if-tabs" class="flex border-b mb-4">
                    <button class="what-if-tab active-tab" data-tab="basic">基本</button>
                    <button class="what-if-tab" data-tab="challenge">挑戦</button>
                    <button class="what-if-tab" data-tab="story">物語</button>
                    <button class="what-if-tab" data-tab="endgame">終焉</button>
                </div>

                <!-- コンテンツコンテナ -->
                <div id="what-if-contents" class="max-h-60 overflow-y-auto pr-2">
                    <!-- 基本タブ -->
                    <div id="what-if-content-basic" class="what-if-content space-y-3">
                        <button data-mode="enjoy" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-sky-700">エンジョイ</strong><span class="block text-sm text-gray-600">味方が戦闘不能になっても、即座にHPが全回復する。ゲームオーバーにならずに最後まで遊べる。</span></button>
                        <button data-mode="trial" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-blue-700">腕試し</strong><span class="block text-sm text-gray-600">通常ルールで冒険を開始する。</span></button>
                        <button data-mode="random_party" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-teal-700">運命の出会い</strong><span class="block text-sm text-gray-600">共に冒険する仲間がランダムに4人選ばれる。誰と出会うかは運命次第。</span></button>
                    </div>
                    <!-- 挑戦タブ -->
                    <div id="what-if-content-challenge" class="what-if-content space-y-3 hidden">
                        <button data-mode="indecent" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-pink-700">痴態騒ぎ</strong><span class="block text-sm text-gray-600">全員が脱衣状態で開始。服は手に入らず、恥ずかしさに慣れることもない。ナイトとサムライは参加不可。</span></button>
                        <button data-mode="dwarves" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-green-700">小人族の戦い</strong><span class="block text-sm text-gray-600">全員の身長が10cmの状態で冒険を開始する。</span></button>
                        <button data-mode="unstable_bodies" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-cyan-700">流転の体躯</strong><span class="block text-sm text-gray-600">戦闘に勝利するたび、生存者全員の身長が-50cm～+50cmの範囲でランダムに変動する。</span></button>
                        <button data-mode="veterans" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-purple-700">歴戦の勇者たち</strong><span class="block text-sm text-gray-600">全員レベル4の状態で冒険を開始する。</span></button>
                        <button data-mode="solo" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-yellow-700">孤独な闘い</strong><span class="block text-sm text-gray-600">好きな仲間を一人選び、強化された状態で冒険に出る。</span></button>
                        <button data-mode="brawl" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-red-700">武闘の宴</strong><span class="block text-sm text-gray-600">2フロアごとに必ず戦闘が発生する。</span></button>
                        <button data-mode="monster_march" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-red-800">魔物の行軍</strong><span class="block text-sm text-gray-600">全てのフロアで戦闘が発生する。勝利する度にレベルアップし、アイテムを獲得する。50階踏破を目指せ。</span></button>
                        <button data-mode="endless" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-slate-700">無限への挑戦</strong><span class="block text-sm text-gray-600">全滅するまでダンジョンを進み続ける。30階ごとにボスが出現し、倒すと試練が訪れる。</span></button>
                        <button data-mode="uninhibited_souls" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-orange-700">奔放な魂</strong><span class="block text-sm text-gray-600">探索中、コマンドで味方を「脱衣」させたり、身長を自由に操作したりできる。</span></button>
                        <button data-mode="peaceful_dungeon" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-lime-700">平和？なダンジョン</strong><span class="block text-sm text-gray-600">全員の身長が初期身長で固定され、変動しない。</span></button>
                    </div>
                    <!-- 物語タブ -->
                    <div id="what-if-content-story" class="what-if-content space-y-3 hidden">
                        <button data-mode="saint_march" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-yellow-500">聖女の行進</strong><span class="block text-sm text-gray-600">特別なジョブ「聖女」ひとりで30階の踏破を目指す。彼女はターン開始時にHPとMPが回復し、脱衣を無効化する。</span></button>
                        <button data-mode="treasure_map" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-lime-700">秘宝の地図</strong><span class="block text-sm text-gray-600">特別なジョブ「トレジャーハンター」ひとりで30階の踏破を目指す。彼女は魔物に変身する能力を持つ。</span></button>
                        <button data-mode="little_panic" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-yellow-600">リトルパニック！</strong><span class="block text-sm text-gray-600">ソーサラー、アルケミスト、トラブルメーカーが幼い姿に！彼女たちを守るため、シスターが本気を出す。</span></button>
                        <button data-mode="brawling_belles" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-rose-500">闘争令嬢</strong><span class="block text-sm text-gray-600">特別なジョブ「アンドロイド」と「メイド」の2人で30階の踏破を目指す。クリアすると選抜チームに2人が追加される。</span></button>
                        <button data-mode="summer_live" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-sky-500">サマータイム・スペシャルライブ！</strong><span class="block text-sm text-gray-600">リリカ、ユイ、ミコ、リリィの4人で、ビーチと温泉を巡る特別な冒険に出る。60階踏破を目指せ。</span></button>
                        <button data-mode="secret_night" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-indigo-700">ヒミツの夜</strong><span class="block text-sm text-gray-600">リリカ、ユイ、ミコ、リリィ、フローラの誰かひとりで、静まったダンジョンを裸で歩く。物語重視のモード。</span></button>
                        <button data-mode="tensei_kikou" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-slate-500">外界：転生紀行</strong><span class="block text-sm text-gray-600">特別なジョブ「転生者」ひとりで無限のダンジョンを進む。彼女はイベントを通じて仲間たちのスキルを学習していく。</span></button>
                        <button data-mode="size_up_gamble" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-orange-700">サイズアップ・ギャンブル！</strong><span class="block text-sm text-gray-600">ルナとコハルで、身長1000cmを目指すギャンブルに挑む。</span></button>
                    </div>
                    <!-- 終焉タブ -->
                    <div id="what-if-content-endgame" class="what-if-content space-y-3 hidden">
                        <button id="tensei-rinne-button" data-mode="tensei_rinne" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition hidden"><strong class="text-indigo-700">顕現：転生輪廻</strong><span class="block text-sm text-gray-600">記憶を引き継いだシロとランダムな仲間3人(Lv10)で30階踏破を目指す。戦闘勝利時にシロの能力が上昇し、終了時に能力が保存される。</span></button>
                        <button id="endgame-plus-button" data-mode="endgame_plus" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition hidden"><strong class="text-red-900">終焉の呼び声</strong><span class="block text-sm text-gray-600">超高難易度モード。選ばれし者のみが挑戦できる。90階に潜む「終刻の魔王」を討伐せよ。</span></button>
                        <button data-mode="endgame" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-gray-700">おわりから</strong><span class="block text-sm text-gray-600">1フロア目に最終ボスが登場する。</span></button>
                    </div>
                </div>
                <div class="text-right mt-6">
                    <button id="what-if-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">戻る</button></div>
            </div>
        </div>

        <div id="challenge-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-sm w-full">
                <h2 class="text-3xl font-bold mb-4">怪しげな祭壇</h2>
                <p class="mb-6">祭壇に何かを捧げますか？<br>幸運が舞い込むか、災いが降りかかるかは分かりません…</p>
                <button id="challenge-accept-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg mr-4">捧げる</button>
                <button id="challenge-decline-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">立ち去る</button>
            </div>
        </div>

        <div id="event-choice-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 class="text-2xl font-bold mb-4">道が二手に分かれている…</h2>
                <p class="mb-6">どちらの道へ進みますか？</p>
                <div id="event-choice-buttons" class="flex flex-col gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <div id="scan-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 shadow-2xl max-w-3xl w-full flex gap-6">
                <div id="scan-modal-image-container" class="hidden w-1/2 relative rounded-lg overflow-hidden">
                    <!-- 立ち絵がここに挿入されます -->
                </div>
                <div id="scan-modal-text-content" class="w-full md:w-1/2">
                    <h2 id="scan-modal-title" class="text-2xl font-bold mb-4">調査結果</h2>
                    <div id="scan-modal-content" class="space-y-3 text-gray-700 max-h-96 overflow-y-auto pr-2">
                        <!-- 調査結果がここに挿入されます -->
                    </div>
                    <style>
                        /* スキャンモーダルの立ち絵表示用 */
                        
                        #scan-modal-image-container>div {
                            background-image: var(--char-bg-image);
                        }
                    </style>
                    <div class="text-right mt-4">
                        <button id="scan-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">閉じる</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 聖女イベントモーダル -->
        <div id="celestia-event-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 id="celestia-event-title" class="text-2xl font-bold mb-4"></h2>
                <p id="celestia-event-text" class="mb-6 whitespace-pre-wrap"></p>
                <div id="celestia-event-buttons" class="flex justify-center gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <!-- 無限モードボーナス選択モーダル -->
        <div id="endless-bonus-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-2xl w-full">
                <h2 class="text-2xl font-bold mb-2">勝利ボーナス！</h2>
                <p class="mb-6">生存者全員がレベルアップした！<br>さらに、以下のボーナスから一つを選択してください。</p>
                <div id="endless-bonus-buttons" class="grid grid-cols-2 gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <!-- 無限モード呪い選択モーダル -->
        <div id="endless-curse-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-2xl w-full">
                <h2 class="text-2xl font-bold mb-2 text-red-700">試練の刻</h2>
                <p class="mb-6">ボスを打ち破った代償として、避けられぬ呪いを一つ選ばなければならない。</p>
                <div id="endless-curse-buttons" class="grid grid-cols-2 gap-4">
                    <!-- 呪いボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <!-- 解放イベントモーダル -->
        <div id="liberation-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 class="text-3xl font-bold mb-4">解放の刻</h2>
                <p class="mb-6">聖結晶と邪結晶が共鳴し、強大な魔力の気配が空間を歪ませている。<br>結晶を捧げ、古の英雄の幻影に挑戦しますか？</p>
                <button id="liberation-accept-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg mr-4">挑戦する</button>
                <button id="liberation-decline-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">立ち去る</button>
            </div>
        </div>


        <!-- 怪しい装置イベントモーダル -->
        <div id="device-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 class="text-2xl font-bold mb-4">怪しい装置</h2>
                <p class="mb-6">研究室のような部屋で、人が二人入れる奇妙な装置を見つけた。<br>装置にはいくつかのボタンが付いている…。</p>
                <div id="device-buttons" class="grid grid-cols-1 gap-4">
                    <div class="p-3 border rounded-lg">
                        <button id="device-red-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg w-full">赤いボタン</button>
                        <p class="text-sm text-gray-600 mt-2">一人目が二人目の身長を吸収し、二人目を1cmにする。</p>
                    </div>
                    <div class="p-3 border rounded-lg">
                        <button id="device-blue-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg w-full">青いボタン</button>
                        <p class="text-sm text-gray-600 mt-2">二人の身長を平均化する。</p>
                    </div>
                    <div id="device-green-button-container" class="hidden p-3 border rounded-lg">
                        <button id="device-green-button" class="action-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg w-full">緑のボタン</button>
                        <p class="text-sm text-gray-600 mt-2">味方ひとりの身長を100cm伸ばす。</p>
                    </div>
                    <div id="device-white-button-container" class="hidden p-3 border rounded-lg">
                        <button id="device-white-button" class="action-button bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-6 rounded-lg shadow-lg w-full">白いボタン</button>
                        <p class="text-sm text-gray-600 mt-2">味方ひとりの能力を永続的に強化する。</p>
                    </div>
                    <button id="device-ignore-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg mt-2">無視する</button>
                </div>
            </div>
        </div>

        <!-- 2人選択モーダル -->
        <div id="two-member-select-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 id="two-member-select-title" class="text-2xl font-bold mb-4 text-center">対象を2人選んでください</h2>
                <div id="two-member-select-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6"></div>
                <div class="text-center"><button id="two-member-select-confirm" class="action-button bg-gray-400 text-white font-bold py-2 px-6 rounded-lg shadow-lg opacity-50 cursor-not-allowed" disabled>決定</button></div>
            </div>
        </div>

        <!-- 迷いの石像イベントモーダル -->
        <div id="statue-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 class="text-2xl font-bold mb-4">迷いの石像</h2>
                <p class="mb-6">怪しいオーラを放つ石像がある。<br>触れると何かが起こりそうだ…。</p>
                <div id="statue-buttons" class="flex justify-center gap-4">
                    <button id="statue-touch-button" class="action-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg">触れる</button>
                    <button id="statue-leave-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">立ち去る</button>
                </div>
            </div>
        </div>

        <!-- 1人選択モーダル -->
        <div id="one-member-select-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 id="one-member-select-title" class="text-2xl font-bold mb-4 text-center">対象を1人選んでください</h2>
                <div id="one-member-select-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4"></div>
            </div>
        </div>

        <!-- 数値選択モーダル -->
        <div id="amount-choice-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 id="amount-choice-title" class="text-2xl font-bold mb-4">量を選択</h2>
                <p id="amount-choice-text" class="mb-6">どのくらい変化させますか？</p>
                <div id="amount-choice-buttons" class="flex justify-center gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <!-- 神々の試練モーダル -->
        <div id="blessing-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 id="blessing-modal-title" class="text-3xl font-bold mb-2 text-center text-amber-600">神々の祝福</h2>
                <p id="blessing-modal-prompt" class="mb-6 text-center">祝福を授ける仲間を一人選んでください。</p>
                <div id="blessing-char-select-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4"></div>
                <div id="blessing-options-list" class="hidden grid grid-cols-1 md:grid-cols-3 gap-4"></div>
            </div>
        </div>
        <div id="menu-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-xs w-full">
                <h2 class="text-2xl font-bold mb-6">メニュー</h2>
                <div class="flex flex-col gap-4">
                    <button id="save-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">セーブ</button>
                    <button id="menu-return-title-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">タイトルに戻る</button>
                    <button id="menu-modal-close" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg mt-4">閉じる</button>
                </div>
            </div>
        </div>
    </div>
    <style>
        /* トグルスイッチのスタイル */
        
        .toggle-checkbox:checked {
            right: 0;
            border-color: #4f46e5;
            /* indigo-600 */
        }
        
        .toggle-checkbox:checked+.toggle-label {
            background-color: #4f46e5;
            /* indigo-600 */
        }
    </style>

        <script src="data.js"></script>
    <script>
        
        document.addEventListener('DOMContentLoaded', () => {
                    const gameContainer = document.getElementById('game-container');
                    const logMessage = document.getElementById('log-message');
                    const partyContainer = document.getElementById('party-container');
                    const enemyContainer = document.getElementById('enemy-container');
                    const logContainer = document.getElementById('log-container');
                    const dungeonCommands = document.getElementById('dungeon-commands');
                    const dungeonView = document.getElementById('dungeon-view');
                    const hud = document.getElementById('hud');
                    const commandContainer = document.getElementById('command-container');
                    const battleCommands = document.getElementById('battle-commands');
                    const commandMessage = document.getElementById('command-message');
                    const actionButtons = document.getElementById('action-buttons');
                    const nextFloorButton = document.getElementById('next-floor-button');
                    const talkButton = document.createElement('button'); // 会話ボタンを生成
                    const modal = document.getElementById('modal');
                    const modalTitle = document.getElementById('modal-title');
                    const modalText = document.getElementById('modal-text');
                    const modalButton = document.getElementById('modal-button');
                    const itemModal = document.getElementById('item-modal');
                    const itemList = document.getElementById('item-list');
                    const itemModalClose = document.getElementById('item-modal-close');
                    const levelUpModal = document.getElementById('level-up-modal');
                    const levelUpPartyList = document.getElementById('level-up-party-list');
                    const titleScreen = document.getElementById('title-screen');
                    const startButton = document.getElementById('start-button');
                    const loadButton = document.getElementById('load-button');
                    const ruleButton = document.getElementById('rule-button');
                    const ruleModal = document.getElementById('rule-modal');
                    const ruleModalClose = document.getElementById('rule-modal-close');
                    const whatIfButton = document.getElementById('what-if-button');
                    const whatIfModal = document.getElementById('what-if-modal');
                    const whatIfModalClose = document.getElementById('what-if-modal-close');
                    const selectTeamModal = document.getElementById('select-team-modal');
                    const tenseiRinneButton = document.getElementById('tensei-rinne-button');
                    const endgamePlusButton = document.getElementById('endgame-plus-button');
                    const teamSelectionList = document.getElementById('team-selection-list');
                    const selectionCounter = document.getElementById('selection-counter');
                    const selectionPrompt = document.getElementById('selection-prompt');
                    const startSelectionButton = document.getElementById('start-selection-button');
                    const selectTeamBackButton = document.getElementById('select-team-back-button');
                    const randomSelectButton = document.getElementById('random-select-button');
                    const floorDisplay = document.getElementById('floor-display');
                    const scanModal = document.getElementById('scan-modal');
                    const scanModalClose = document.getElementById('scan-modal-close');
                    const menuButton = document.getElementById('menu-button');
                    const menuModal = document.getElementById('menu-modal');
                    const saveButton = document.getElementById('save-button');
                    const menuReturnTitleButton = document.getElementById('menu-return-title-button');
                    const menuModalClose = document.getElementById('menu-modal-close');

                    const emergencyButton = document.getElementById('emergency-button');
                    const challengeModal = document.getElementById('challenge-modal');
                    const challengeAcceptButton = document.getElementById('challenge-accept-button');
                    const challengeDeclineButton = document.getElementById('challenge-decline-button');

                    const eventChoiceModal = document.getElementById('event-choice-modal');
                    const eventChoiceButtons = document.getElementById('event-choice-buttons');

                    const celestiaEventModal = document.getElementById('celestia-event-modal');
                    const celestiaEventTitle = document.getElementById('celestia-event-title');
                    const celestiaEventText = document.getElementById('celestia-event-text');
                    const celestiaEventButtons = document.getElementById('celestia-event-buttons');

                    const endlessBonusModal = document.getElementById('endless-bonus-modal');
                    const endlessBonusButtons = document.getElementById('endless-bonus-buttons');

                    const endlessCurseModal = document.getElementById('endless-curse-modal');
                    const endlessCurseButtons = document.getElementById('endless-curse-buttons');

                    // 解放イベント用
                    const liberationModal = document.getElementById('liberation-modal');
                    const liberationAcceptButton = document.getElementById('liberation-accept-button');
                    const liberationDeclineButton = document.getElementById('liberation-decline-button');

                    // 怪しい装置イベント用
                    const deviceModal = document.getElementById('device-modal');
                    const deviceRedButton = document.getElementById('device-red-button');
                    const deviceBlueButton = document.getElementById('device-blue-button');
                    const deviceIgnoreButton = document.getElementById('device-ignore-button');
                    const deviceGreenButtonContainer = document.getElementById('device-green-button-container');
                    const deviceGreenButton = document.getElementById('device-green-button');
                    const deviceWhiteButtonContainer = document.getElementById('device-white-button-container');
                    const deviceWhiteButton = document.getElementById('device-white-button');
                    const twoMemberSelectModal = document.getElementById('two-member-select-modal');
                    const twoMemberSelectList = document.getElementById('two-member-select-list');
                    const twoMemberSelectConfirm = document.getElementById('two-member-select-confirm');

                    // 迷いの石像イベント用
                    const statueModal = document.getElementById('statue-modal');
                    const statueTouchButton = document.getElementById('statue-touch-button');
                    const statueLeaveButton = document.getElementById('statue-leave-button');
                    const oneMemberSelectModal = document.getElementById('one-member-select-modal');
                    const oneMemberSelectList = document.getElementById('one-member-select-list');

                    // 奔放な魂モード用
                    const amountChoiceModal = document.getElementById('amount-choice-modal');
                    const amountChoiceTitle = document.getElementById('amount-choice-title');
                    const amountChoiceText = document.getElementById('amount-choice-text');
                    const amountChoiceButtons = document.getElementById('amount-choice-buttons');

                    // 神々の試練モーダル
                    const blessingModal = document.getElementById('blessing-modal');
                    const blessingModalTitle = document.getElementById('blessing-modal-title');
                    const blessingModalPrompt = document.getElementById('blessing-modal-prompt');
                    const blessingCharSelectList = document.getElementById('blessing-char-select-list');
                    const blessingOptionsList = document.getElementById('blessing-options-list');

                    // 願い星イベントモーダル
                    const wishingStarModal = document.getElementById('wishing-star-modal');
                    const wishingStarModalPrompt = document.getElementById('wishing-star-modal-prompt');
                    const wishingStarCharSelect = document.getElementById('wishing-star-char-select');
                    const wishingStarOptions = document.getElementById('wishing-star-options');

                    // 調合イベントモーダル
                    const alchemyModal = document.getElementById('alchemy-modal');
                    const alchemyOptions = document.getElementById('alchemy-options');
                    const alchemyCancelButton = document.getElementById('alchemy-cancel-button');
                    // 汎用イベントモーダル
                    const generalEventModal = document.getElementById('general-event-modal');
                    const generalEventTitle = document.getElementById('general-event-title');
                    const generalEventText = document.getElementById('general-event-text');
                    const generalEventButtons = document.getElementById('general-event-buttons');
                    const heightLockConfirmModal = document.getElementById('height-lock-confirm-modal');
                    // ログ履歴ツールチップ
                    const logTooltip = document.getElementById('log-tooltip');

                    // 背景画像のURLを定数化
                    const DEFAULT_DUNGEON_BG = "url('https://image.pollinations.ai/prompt/fantasy%20rpg%20dungeon,%20dark,%20mysterious,%20glowing%20runes,%20stone%20columns,%20roots,%20moss,%20pathway,%20digital%20painting')";
                    const SUMMER_BEACH_BG = "url('https://image.pollinations.ai/prompt/beautiful%20anime%20style%20beach,%20sparkling%20ocean,%20white%20sand,%20blue%20sky,%20summer,%20palm%20trees,%20digital%20painting')";
                    const SUMMER_ONSEN_BG = "url('https://image.pollinations.ai/prompt/Japanese%20open-air%20onsen,%20steam%20rising%20from%20the%20water,%20bamboo%20fences,%20stone%20lanterns,%20night,%20starry%20sky,%20anime%20style,%20digital%20painting')";
                    const FANTASY_FOREST_BG = "url('https://image.pollinations.ai/prompt/fantasy%20forest,%20glowing%20mushrooms,%20ancient%20trees,%20mysterious,%20misty,%20digital%20painting')";

                    let gameState = {
                        floor: 0,
                        party: [],
                        enemies: [],
                        turnOrder: [],
                        currentTurnIndex: 0,
                        inBattle: false,
                        gameOver: false,
                        inventory: [],
                        golem: null, // ファイター, ソーサラー, ナイト, メディック
                        foundEquipment: [],
                        killCount: 0, // ネクロマンサー用
                        walls: [], // ガーディアン用
                        gameMode: 'normal', // normal, veterans, dwarves, brawl, solo, endgame, endless, indecent, enjoy, saint_march, fixed_path, uninhibited_souls, random_party, divine_trial, treasure_map, secret_night, size_up_gamble
                        triggeredSpecialConvos: [],
                        dungeonBackground: DEFAULT_DUNGEON_BG, // 背景画像をgameStateで管理
                        bellesPrivateCostumeEventTriggered: false, // 闘争令嬢プライベート衣装イベント用フラグ
                        summerBeachAllLiberatedTriggered: false, // サマーライブビーチ全員解放イベント用フラグ
                        summerOnsenAllLiberatedTriggered: false, // サマーライブ温泉全員解放イベント用フラグ
                        bellesReviveEventTriggered: false, // 闘争令嬢復活イベント用フラグ
                        wishingStarNoClothes: false, // 願い星イベントで服発見を無効化するフラグ
                        greatHoleEventTriggered: false, // 「大穴になあれ」イベント発生フラグ
                        greatHoleEventFloor: 0, // 「大穴になあれ」発生階層
                        wishPrayEventTriggered: false, // 「願い/祈りの少女」イベント発生フラグ
                        nextBattleIsImitation: false, // 模倣の呪いフラグ
                        drunkenMonsterEventTriggered: false, // 「酒豪の怪物」イベント発生フラグ
                        mazeOfShadeEventTriggered: false, // 「木陰の迷宮」イベント発生フラグ
                        shiroInherited: false, // 転生紀行で能力を引き継いだかどうかのフラグ
                        sizeUpGambleGoalReached: false, // サイズアップ・ギャンブルの目標達成フラグ
                        nextBattleIsGambleMaster: false, // サイズアップ・ギャンブルのボス戦フラグ
                    };


                    const characterBlueprints = allCharacterBlueprints.slice(0, 4); // 初期パーティ


                    function getRemainingEquipment() {
                        const allEquipmentIds = Object.keys(equipmentBlueprints);
                        return allEquipmentIds.filter(id => !gameState.foundEquipment.includes(id));
                    }

                    function addItemToInventory(itemId, quantity = 1) {
                        const existingItem = gameState.inventory.find(item => item.id === itemId);
                        if (existingItem) existingItem.quantity += quantity;
                        else gameState.inventory.push({
                            id: itemId,
                            quantity
                        });
                    }




                    function applyLevelUp(character, levels = 1) {
                        let bonusGrowthInfo = null;
                        for (let i = 0; i < levels; i++) {
                            // 基本成長
                            character.maxHp += 5;
                            character.maxMp += 3; // ファイター, ソーサラー
                            character.atk += 1;
                            character.def += 1;
                            character.agi += 1; // ファイター, ソーサラー
                            character.level += 1;

                            // 追加成長
                            if (character.growthBonus) {
                                if (character.growthBonus.type === 'random') {
                                    const stats = ['maxHp', 'maxMp', 'atk', 'def'];
                                    const randomStat = stats[Math.floor(Math.random() * stats.length)];
                                    const growthValue = (randomStat === 'maxHp') ? 5 : (randomStat === 'maxMp') ? 3 : 2;
                                    character[randomStat] += growthValue;
                                    bonusGrowthInfo = {
                                        stat: randomStat,
                                        value: growthValue
                                    };
                                } else {
                                    const {
                                        stat,
                                        value
                                    } = character.growthBonus;
                                    character[stat] += value;
                                    bonusGrowthInfo = {
                                        stat,
                                        value
                                    };
                                }
                            }

                            // スキル威力成長
                            character.skills.forEach(skill => {
                                if (skill.power) skill.power = parseFloat((skill.power * 1.05).toFixed(2));
                            });

                            // スキル習得
                            if (character.level === 2 && character.unlockableSkill) character.skills.push(character.unlockableSkill);
                            if (character.level === 4 && character.unlockableSkillLv4) character.skills.push(character.unlockableSkillLv4);
                        }
                        // 成長情報を返す
                        return bonusGrowthInfo;
                    }

                    function generateConversation() {
                        if (gameState.inBattle) return;

                        // --- 「サマータイム・スペシャルライブ！」モード専用会話 ---
                        if (gameState.gameMode === 'summer_live') {
                            const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                            if (aliveParty.length < 2) { // 会話相手がいない場合
                                log("会話できる相手がいない…");
                                return;
                            }

                            dungeonCommands.classList.add('hidden');
                            let conversationFound = false;

                            // --- 優先度1: 全員解放状態の4人会話 ---
                            const liberatedMembers = aliveParty.filter(p => p.isLiberatedStripped);
                            if (liberatedMembers.length === 4) {
                                const situation = gameState.floor <= 30 ? 'summer_beach_all_liberated' : 'summer_onsen_all_liberated';
                                const partyConvos = conversations[situation];
                                const partyConvo = partyConvos[Math.floor(Math.random() * partyConvos.length)];
                                let delay = 0;
                                partyConvo.chars.forEach((charName, index) => {
                                    setTimeout(() => {
                                        log(`${charName}「${partyConvo.lines[index]}」`);
                                    }, delay);
                                    delay += 2000;
                                });
                                setTimeout(() => dungeonCommands.classList.remove('hidden'), delay);
                                return;
                            }

                            // --- 優先度2: 通常の4人会話 (20%の確率で試行) ---
                            if (aliveParty.length === 4 && Math.random() < 0.2) { // ファイター, ソーサラー, ナイト, メディック
                                const situation = gameState.floor <= 30 ? 'summer_beach_party' : 'summer_onsen_party';
                                const partyConvos = conversations[situation];
                                const partyConvo = partyConvos[Math.floor(Math.random() * partyConvos.length)];
                                if (partyConvo) {
                                    let delay = 0;
                                    partyConvo.chars.forEach((charName, index) => { // ファイター, ソーサラー, ナイト, メディック
                                        setTimeout(() => {
                                            log(`${charName}「${partyConvo.lines[index]}」`);
                                        }, delay);
                                        delay += 2000;
                                    });
                                    setTimeout(() => dungeonCommands.classList.remove('hidden'), delay);
                                    return;
                                }
                            }

                            // --- 優先度3: 解放状態の2人会話 (40%の確率で試行) ---
                            if (liberatedMembers.length >= 2 && Math.random() < 0.4) {
                                const char1 = liberatedMembers[0];
                                const char2 = liberatedMembers[1];
                                const situation = gameState.floor <= 30 ? 'summer_beach_liberated_pair' : 'summer_onsen_liberated_pair';
                                const possibleConvos = conversations[situation].filter(c => c.chars.includes(char1.name) && c.chars.includes(char2.name));
                                const pairConvo = possibleConvos.length > 0 ? possibleConvos[Math.floor(Math.random() * possibleConvos.length)] : null;
                                if (pairConvo) {
                                    log(`${char1.name}「${pairConvo.lines[0]}」`);
                                    setTimeout(() => {
                                        log(`${char2.name}「${pairConvo.lines[1]}」`);
                                        setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000);
                                    }, 2000);
                                    return;
                                }
                            }

                            // --- 優先度4: 通常脱衣状態の2人会話 (30%の確率で試行) ---
                            const strippedMembers = aliveParty.filter(p => p.statusEffects.stripped && !p.isLiberatedStripped);
                            if (strippedMembers.length >= 2 && Math.random() < 0.3) {
                                const char1 = strippedMembers[0];
                                const char2 = strippedMembers[1];
                                const situation = gameState.floor <= 30 ? 'summer_beach_stripped_pair' : 'summer_onsen_stripped_pair';
                                const possibleConvos = conversations[situation].filter(c => c.chars.includes(char1.name) && c.chars.includes(char2.name));
                                const pairConvo = possibleConvos.length > 0 ? possibleConvos[Math.floor(Math.random() * possibleConvos.length)] : null;
                                if (pairConvo) {
                                    log(`${char1.name}「${pairConvo.lines[0]}」`);
                                    setTimeout(() => {
                                        log(`${char2.name}「${pairConvo.lines[1]}」`);
                                        setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000);
                                    }, 2000);
                                    return;
                                }
                            }

                            // --- 優先度5: 通常の2人掛け合い会話 ---
                            const situation = gameState.floor <= 30 ? 'summer_beach_pair' : 'summer_onsen_pair';
                            const char1 = getRandomPartyMember();
                            const otherParty = aliveParty.filter(p => p !== char1);
                            const char2 = otherParty[Math.floor(Math.random() * otherParty.length)];
                            const possibleConvos = conversations[situation].filter(c => c.chars.includes(char1.name) && c.chars.includes(char2.name));
                            const pairConvo = possibleConvos.length > 0 ? possibleConvos[Math.floor(Math.random() * possibleConvos.length)] : null;

                            if (pairConvo) {
                                // char1が会話のどちらの順番かを確認して、正しいセリフを割り当てる
                                const char1Index = pairConvo.chars.indexOf(char1.name);
                                const char2Index = 1 - char1Index; // 0なら1, 1なら0

                                const firstSpeaker = char1Index === 0 ? char1 : char2;
                                const secondSpeaker = char1Index === 0 ? char2 : char1;
                                const firstLine = pairConvo.lines[0];
                                const secondLine = pairConvo.lines[1];

                                log(`${firstSpeaker.name}「${firstLine}」`);
                                setTimeout(() => {
                                    log(`${secondSpeaker.name}「${secondLine}」`);
                                    setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000);
                                }, 2000);
                            } else {
                                // フォールバック（もし掛け合いが見つからなければ単独のセリフ）
                                const fallbackSituation = gameState.floor <= 30 ? 'summer_beach' : 'summer_onsen';
                                const line = conversations[char1.name][fallbackSituation][Math.floor(Math.random() * conversations[char1.name][fallbackSituation].length)];
                                log(`${char1.name}「${line}」`);
                                setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000);
                            }
                            return; // 専用会話を実行したらここで終了
                        }

                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length < 2) {
                            log("会話できる相手がいない…");
                            return;
                        }

                        // ダンサーまたはガーディアンが巨大で、他が全員小さい場合の特別会話
                        const potentialSpeakers = aliveParty.filter(char =>
                            (char.role === 'ダンサー' || char.role === 'ガーディアン') &&
                            char.height >= 100 &&
                            aliveParty.length > 1 && // 他のメンバーがいないとeveryはtrueになるため
                            aliveParty.filter(p => p !== char).every(p => p.height < 10)
                        );

                        if (potentialSpeakers.length > 0) {
                            const speaker = potentialSpeakers[Math.floor(Math.random() * potentialSpeakers.length)];
                            const lines = conversations[speaker.name] && conversations[speaker.name].giant_among_tinies;
                            if (lines && lines.length > 0) {
                                const line = lines[Math.floor(Math.random() * lines.length)];
                                dungeonCommands.classList.add('hidden');
                                let conversationDelay = 2000;

                                log(`${speaker.name}「${line}」`);

                                // ダンサー(リリカ)の発言時にメディック(ユイ)がいる場合、追加の会話を発生
                                const hasMedic = aliveParty.some(p => p.role === 'メディック');
                                if (speaker.role === 'ダンサー' && hasMedic) {
                                    const yuiLines = [
                                        "わぁ、リリカさん、とっても大きいですね！見上げちゃいます！",
                                        "リリカさんがこんなに大きいなんて…！まるで巨人アイドルの特別公演みたいです！",
                                        "すごいです、リリカさん！こんなに大きいリリカさんを一番近くで見られるなんて、私、ファンとして幸せです！",
                                        "おっきなリリカさん、とっても素敵です！サインください！"
                                    ];
                                    const yuiLine = yuiLines[Math.floor(Math.random() * yuiLines.length)];
                                    setTimeout(() => {
                                        log(`ユイ「${yuiLine}」`);
                                    }, conversationDelay);
                                    conversationDelay += 2000;
                                }

                                setTimeout(() => {
                                    dungeonCommands.classList.remove('hidden');
                                }, conversationDelay);
                                return; // 特別会話を実行して終了
                            }
                        }


                        // 特別な会話の条件をチェック
                        let specialConvoSet = null;
                        let specialConvoKey = null;

                        // 1. 29階の会話
                        if (gameState.floor === 29) {
                            specialConvoKey = 'before_boss';
                        }
                        // 2. 全員身長1cm
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.height === 1)) {
                            specialConvoKey = 'all_tiny';
                        }
                        // 3. 全員同じ身長 (100cm以上)
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.height === aliveParty[0].height && p.height >= 100)) {
                            specialConvoKey = 'same_height';
                        }
                        // 4. 全員が脱衣状態
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.statusEffects.stripped)) {
                            specialConvoKey = 'all_stripped';
                        }
                        // 5. 全員の身長が初期値より高い
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.height > p.initialHeight)) {
                            specialConvoKey = 'all_grown';
                        }
                        // 6. 特定の4人パーティ
                        else if (aliveParty.length === 4) {
                            const partySets = {
                                initial_party: [
                                    ['アカリ', 'ヒカリ', 'シズカ', 'ユイ'],
                                    ['ベアトリス', 'リリカ', 'サクヤ', 'シャオメイ'],
                                    ['エリザ', 'ルナ', 'クロエ', 'ミコ'],
                                    ['レンカ', 'イオリ', 'コハル', 'オリビア'],
                                    ['ユイ', 'シャオメイ', 'ルナ', 'オリビア'], // 回復チーム
                                    ['シズカ', 'リリカ', 'ミコ', 'イオリ'], // 守護チーム
                                    ['イオリ', 'ユイ', 'ミコ', 'クロエ'] // ちびっこチーム
                                ],
                            };
                            const currentPartyNames = aliveParty.map(p => p.name).sort();
                            const isMatch = partySets.initial_party.some(partySet =>
                                JSON.stringify(partySet.sort()) === JSON.stringify(currentPartyNames));
                            if (isMatch) {
                                specialConvoKey = 'initial_party';
                            }
                        }

                        if (specialConvoKey) {
                            const availableConvos = specialConversations[specialConvoKey].map((convo, index) => ({...convo,
                                id: `${specialConvoKey}-${index}`
                            })).filter(convo => {
                                // 会話に必要なキャラが全員パーティにいるかチェック
                                const hasAllChars = convo.chars.every(charName => aliveParty.some(p => p.name === charName));
                                // 既に発生した会話でないかチェック
                                const notTriggered = !gameState.triggeredSpecialConvos.includes(convo.id);
                                return hasAllChars && notTriggered;
                            });

                            if (availableConvos.length > 0) {
                                const conversation = availableConvos[Math.floor(Math.random() * availableConvos.length)]; // 発生可能な会話からランダムに選択
                                gameState.triggeredSpecialConvos.push(conversation.id); // 発生した会話を記録
                                dungeonCommands.classList.add('hidden');
                                let delay = 0;
                                conversation.chars.forEach((charName, index) => {
                                    setTimeout(() => {
                                        log(`${charName}「${conversation.lines[index]}」`);
                                    }, delay);
                                    delay += 2000;
                                });
                                setTimeout(() => {
                                    dungeonCommands.classList.remove('hidden');
                                }, delay);
                                return; // 特別な会話を実行したので終了
                            }
                        }


                        // --- ここから通常の2人会話のロジック ---

                        // パーティで一人だけ身長10cm以下かつ脱衣状態の場合の特別会話
                        const tinyStrippedChars = aliveParty.filter(p => p.height <= 10 && p.statusEffects.stripped);
                        if (tinyStrippedChars.length === 1) {
                            const char = tinyStrippedChars[0];
                            const charConvos = conversations[char.name];
                            const soloLines = charConvos ? charConvos.solo_stripped_tiny : null;

                            if (soloLines && soloLines.length > 0) {
                                const line = soloLines[Math.floor(Math.random() * soloLines.length)];
                                dungeonCommands.classList.add('hidden');
                                log(`${char.name}「${line}」`);
                                setTimeout(() => {
                                    dungeonCommands.classList.remove('hidden');
                                }, 2000);
                                return; // 特別会話を実行して終了
                            }
                        }

                        // キャラクターの状況を判断するヘルパー関数
                        const getCharacterSituation = (char) => {
                            // 特別衣装の状態を最優先でチェック
                            if (char.costume && gameState.gameMode !== 'summer_live') {
                                // 解放状態のセリフを追加
                                if (char.isLiberatedStripped) {
                                    const liberatedKey = `liberated_${char.costume}`;
                                    // 専用セリフがあればそれを、なければ通常の解放セリフ
                                    return conversations[char.name][liberatedKey] ? liberatedKey : 'liberated';
                                }
                                const situationKey = `${char.costume}_costume`;
                                if (char.currentHp / char.maxHp < 0.4) return `${situationKey}_lowHp`;
                                if (char.statusEffects.stripped) return `${situationKey}_stripped`;
                                if (char.height > char.initialHeight * 1.15) return `${situationKey}_grown`;
                                if (char.height < char.initialHeight * 0.7) return `${situationKey}_shrunk`;
                                return situationKey;
                            }
                            // 解放状態をチェック
                            if (char.isLiberatedStripped) {
                                if (char.costume === 'beach' && conversations[char.name].liberated_beach) {
                                    return 'liberated_beach';
                                }
                                if (char.costume === 'onsen' && conversations[char.name].liberated_onsen) {
                                    return 'liberated_onsen';
                                }
                                return 'liberated';
                            }
                            // 最優先でフェアリーシロップの状態をチェック
                            if (char.heightLocked && char.height === 1) return 'fairy_shrunk';

                            if (char.currentHp / char.maxHp < 0.4) return 'lowHp';
                            if (char.statusEffects.stripped && char.statusEffects.stripped.turns < 6) { // 行動不能確率が0%でない場合
                                if (char.height < char.initialHeight * 0.7) return 'stripped_shrunk'; // 身長が初期値の70%未満
                            }
                            if (char.height > char.initialHeight * 1.15) return 'grown'; // 15%以上大きくなったら
                            if (char.height === 1) return 'shrunk_1';
                            if (char.height < 10) return 'shrunk_10';
                            if (char.height < 30) return 'shrunk_30';
                            if (char.height < 50) return 'shrunk_50';
                            if (char.height < 70) return 'shrunk_70';
                            if (char.height < 100) return 'shrunk_100';
                            if (char.height < char.initialHeight * 0.7) return 'shrunk';
                            if (char.statusEffects.stripped) return 'stripped'; // stripped_shrunkにならなかったstripped状態
                            return 'normal';
                        };

                        // 会話する2人を選ぶ
                        let char1 = getRandomPartyMember();
                        let otherParty = aliveParty.filter(p => p !== char1);
                        let char2 = otherParty[Math.floor(Math.random() * otherParty.length)];

                        // 特定ペアの専用会話を優先的にチェック (50%の確率で発生)
                        const pairKey1 = `pair_${char2.name}`;
                        const pairKey2 = `pair_${char1.name}`;
                        if (conversations[char1.name] && conversations[char1.name][pairKey1] && conversations[char2.name] && conversations[char2.name][pairKey2] && Math.random() < 0.5) {
                            const line1 = conversations[char1.name][pairKey1][Math.floor(Math.random() * conversations[char1.name][pairKey1].length)];
                            const line2 = conversations[char2.name][pairKey2][Math.floor(Math.random() * conversations[char2.name][pairKey2].length)];

                            dungeonCommands.classList.add('hidden');
                            log(`${char1.name}「${line1}」`);
                            setTimeout(() => {
                                log(`${char2.name}「${line2}」`);
                                setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000);
                            }, 2000);
                            return; // 専用会話を実行したらここで終了
                        }

                        let situation1 = getCharacterSituation(char1);
                        let situation2 = getCharacterSituation(char2);

                        // 会話状況の優先順位を定義
                        const situationPriorities = [
                            'fairy_shrunk',
                            'stripped_shrunk', 'stripped_pair', 'stripped', // 脱衣関連
                            'lowHp', // HPが低い,
                            'shrunk_10', 'shrunk_30', 'shrunk_50', 'shrunk_70', 'shrunk_100', 'shrunk', 'shrunk_pair', // 小さい関連 (より具体的->一般的)
                            'grown' // 大きい
                        ];

                        // 小さいキャラ同士の会話を優先
                        if (char1.height < char1.initialHeight * 0.5 && char2.height < char2.initialHeight * 0.5) {
                            situation1 = 'shrunk_pair';
                        }
                        // 脱衣状態のキャラ同士の会話を優先 (シズカは脱衣にならないため、この条件は他の3人の組み合わせで発動)
                        else if ((getCharacterSituation(char1) === 'stripped' || getCharacterSituation(char1) === 'stripped_shrunk') &&
                            (getCharacterSituation(char2) === 'stripped' || getCharacterSituation(char2) === 'stripped_shrunk')) {
                            situation1 = 'stripped_pair';
                        } else {
                            // 優先順位に基づいて、会話のターゲットとなるキャラを探す
                            let priorityTarget = null;
                            for (const prioSit of situationPriorities) {
                                priorityTarget = aliveParty.find(p => getCharacterSituation(p) === prioSit);
                                if (priorityTarget) break;
                            }

                            // 優先ターゲットが見つかった場合、char1とchar2を入れ替える
                            if (priorityTarget && priorityTarget !== char1) {
                                [char1, char2] = [char2, priorityTarget];
                            }

                            if (priorityTarget && priorityTarget !== char1) {
                                char2 = priorityTarget; // 会話相手をターゲットに設定
                                situation2 = getCharacterSituation(char2);

                                // char1の状況を「仲間の状況」に上書き
                                if (situation2 === 'lowHp') {
                                    situation1 = 'allyLowHp';
                                } else if (situation2.startsWith('shrunk')) {
                                    // 相手の身長状況に応じて、自分のセリフを変える
                                    const allyShrunkSituation = `ally${situation2.charAt(0).toUpperCase() + situation2.slice(1)}`;
                                    situation1 = allyShrunkSituation;
                                } else if (situation2 === 'stripped_shrunk') {
                                    situation1 = 'allyStripped_shrunk';
                                } else if (situation2 === 'stripped') {
                                    situation1 = 'allyStripped';
                                } else if (situation2.startsWith('liberated')) { // 解放状態の相手への反応
                                    situation1 = 'allyLiberated';
                                } else if (situation2 === 'grown') {
                                    situation1 = 'allyGrown';
                                }
                            } else {
                                // 優先ターゲットがない場合、通常の状況を再評価
                                situation1 = getCharacterSituation(char1);
                                situation2 = getCharacterSituation(char2);
                            }
                        }

                        // 状況に合ったセリフを選ぶ
                        const getLine = (char, sit, otherChar) => {
                            // パーティにいないキャラのセリフは参照しない (initGameでパーティが確定した後に呼ばれる)
                            const partyMemberNames = gameState.party.map(p => p.name);
                            if (!partyMemberNames.includes(char.name)) {
                                return ""; // 空文字を返す
                            }
                            const charConvos = conversations[char.name] || {
                                default: ["..."]
                            };

                            const otherPartyNames = gameState.party.map(p => p.name).filter(n => n !== char.name);

                            // allyShrunk_100 のようなキーが存在しない場合、allyShrunk -> shrunk -> default の順にフォールバック
                            let lines = charConvos[sit] ||
                                (sit.startsWith('liberated') && charConvos['liberated']) ||
                                (sit.startsWith('summer_beach_costume') && charConvos['summer_beach_costume']) ||
                                (sit.startsWith('private_costume') && charConvos['private_costume']) ||
                                (sit.startsWith('summer_onsen_costume') && charConvos['summer_onsen_costume']) ||
                                (sit === 'fairy_shrunk' && charConvos['fairy_shrunk']) ||
                                (sit === 'stripped_shrunk' && charConvos['stripped_shrunk']) ||
                                (sit === 'cracked_rock_break' && charConvos['cracked_rock_break']) ||
                                (sit === 'dollhouse_explore' && charConvos['dollhouse_explore']) ||
                                (sit === 'allyStripped_shrunk' && charConvos['allyStripped_shrunk']) ||
                                (sit === 'stripped_pair' && charConvos['stripped_pair']) ||
                                (sit === 'allyLiberated' && charConvos['allyLiberated']) ||
                                (sit === 'allyStripped' && charConvos['allyStripped']) ||
                                (sit === 'allyGrown' && charConvos['allyGrown']) ||
                                (sit.startsWith('allyShrunk') && charConvos['allyShrunk']) ||
                                (sit.startsWith('shrunk') && charConvos['shrunk']) ||
                                charConvos['default'];

                            // 会話の文脈に合わないセリフを除外する
                            // 1. パーティにいないキャラクターの名前が含まれているセリフを除外
                            // 2. 話し相手以外のキャラクターの名前が含まれているセリフを除外 (例: アカリがユイに話しかけているのに、ヒカリの名前が入ったセリフ)
                            let filteredLines = lines.filter(line => {
                                // 話し手(char)と話し相手(otherChar)以外の名前を探す
                                const thirdPartyName = allCharacterBlueprints
                                    .map(c => c.name)
                                    .find(name => name !== char.name && name !== otherChar.name && line.includes(name));
                                if (thirdPartyName) {
                                    return false; // 第三者の名前が含まれていたら、そのセリフは除外
                                }
                                return true; // 問題なければセリフを候補に残す
                            });
                            // フィルター後の候補がなくなってしまった場合は、元のリストから選ぶ
                            if (filteredLines.length === 0) filteredLines = lines;

                            let line = filteredLines[Math.floor(Math.random() * filteredLines.length)];
                            return line.replace(/{name}/g, otherChar.name);
                        };

                        const line1 = getLine(char1, situation1, char2);
                        const line2 = getLine(char2, situation2, char1);

                        // 会話をログに表示
                        dungeonCommands.classList.add('hidden'); // 会話中はボタンを非表示
                        log(`${char1.name}「${line1}」`);
                        setTimeout(() => {
                            log(`${char2.name}「${line2}」`);
                            setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000); // ボタンを再表示
                        }, 2000);
                    }

                    function initGame(selectedMembers = null, fromSave = false) {
                        gameState.floor = 0;
                        gameState.gameOver = false; // ゲームオーバーフラグをリセット
                        gameState.triggeredSpecialConvos = []; // 発生済み会話をリセット
                        gameState.bellesPrivateCostumeEventTriggered = false; // イベントフラグをリセット
                        gameState.bellesReviveEventTriggered = false; // 復活イベントフラグをリセット
                        // ソロクリア情報を読み込む
                        gameState.sizeUpGambleGoalReached = false; // モード専用フラグをリセット
                        const soloClearFlags = fromSave ? {} : JSON.parse(localStorage.getItem('sizeDungeonSoloClearFlags') || '{}');

                        // fromSaveがtrueの場合、gameStateの大部分はロード済みなので、ここで処理を中断
                        if (fromSave) return;

                        gameState.summerBeachAllLiberatedTriggered = false; // サマーライブイベントフラグをリセット
                        gameState.summerOnsenAllLiberatedTriggered = false; // サマーライブイベントフラグをリセット
                        gameState.wishingStarNoClothes = false; // 願い星フラグをリセット
                        const blueprintsToUse = selectedMembers ?
                            selectedMembers.map(name => allCharacterBlueprints.find(c => c.name === name)) :
                            characterBlueprints;

                        gameState.party = blueprintsToUse.map(blueprint => ({
                            ...blueprint,
                            maxHp: blueprint.hp,
                            currentHp: blueprint.hp,
                            maxMp: blueprint.mp,
                            currentMp: blueprint.mp,
                            initialHeight: blueprint.height,
                            costume: null, // 衣装フラグを追加
                            buffs: {}, // ファイター, ソーサラー, ナイト, メディック
                            heightLocked: false, // 追加
                            blessings: {}, // 祝福用
                            level: 1,
                            isDefending: false,
                            hate: 0, // ファイター, ソーサラー, ナイト, メディック
                            statusEffects: {}, // 状態異常
                            liberationCooldown: 0, // 解放イベント拒否クールダウン
                            chargeCount: 0, // チャージ回数
                        }));

                        // ソロクリア特典を適用
                        gameState.party.forEach(char => {
                            if (soloClearFlags[char.name]) {
                                char.maxHp += 10;
                                char.maxMp += 5;
                                char.atk += 2;
                                char.def += 2;
                            }
                        });

                        gameState.party.forEach(p => p.heightLocked = false); // 身長固定フラグを初期化
                        gameState.golem = null;
                        gameState.inventory = [];

                        // 初期アイテムの配布
                        if (!fromSave) {
                            addItemToInventory('potion', gameState.party.length);
                            addItemToInventory('milk', 1); // ファイター, ソーサラー, ナイト, メディック
                            addItemToInventory('mana_potion', 1);
                        }

                        // もしもの物語モードの適用
                        if (gameState.gameMode === 'veterans') {
                            gameState.party.forEach(char => {
                                applyLevelUp(char, 3); // Lv1 -> Lv4
                            });
                        } else if (gameState.gameMode === 'dwarves') {
                            gameState.party.forEach(char => {
                                char.height = 10;
                            });
                        } else if (gameState.gameMode === 'peaceful_dungeon') {
                            gameState.party.forEach(char => {
                                char.height = char.initialHeight;
                                char.heightLocked = true;
                            });
                        }

                        // HP/MPを全快させる
                        gameState.party.forEach(char => {
                            char.currentHp = char.maxHp; // ファイター, ソーサラー, ナイト, メディック
                            char.currentMp = char.maxMp;
                        });

                        if (gameState.gameMode === 'indecent') {
                            gameState.party.forEach(char => {
                                // ナイトとサムライは選択不可なのでチェック不要
                                char.statusEffects.stripped = {
                                    turns: 0
                                };
                            });
                        }
                        if (gameState.gameMode === 'solo' && gameState.party.length === 1) {
                            const soloChar = gameState.party[0];
                            if (!fromSave) {
                                soloChar.maxHp *= 2;
                                soloChar.maxMp *= 2;
                                soloChar.atk = Math.floor(soloChar.atk * 1.5);
                                soloChar.def = Math.floor(soloChar.def * 1.5);
                                applyLevelUp(soloChar, 1); // Lv1 -> Lv2
                            }
                        }

                        // HP/MPを全快させる
                        gameState.party.forEach(char => {
                            char.currentHp = char.maxHp; // ファイター, ソーサラー, ナイト, メディック
                            char.currentMp = char.maxMp;
                            // isLiberatedStripped フラグを初期化
                            if (char.isLiberatedStripped) {
                                delete char.isLiberatedStripped;
                            }
                        });
                        // 転生紀行モードの初期スキル設定
                        if (gameState.gameMode === 'endless' && gameState.party.some(p => p.role === '転生者') && !fromSave) {
                            const shiro = gameState.party.find(p => p.name === 'シロ');
                            if (shiro) {
                                const lilyTransformSkills = ['サキュバスモード', 'フェアリーモード', 'アルラウネモード'];
                                const shiroSkillNames = shiro.skills.map(s => s.name);

                                const skillPool = allCharacterBlueprints
                                    .flatMap(c => [...c.skills, c.unlockableSkill, c.unlockableSkillLv4])
                                    .filter(skill =>
                                        skill &&
                                        !lilyTransformSkills.includes(skill.name) &&
                                        !shiroSkillNames.includes(skill.name)
                                    );

                                if (skillPool.length > 0) {
                                    const randomSkill = skillPool[Math.floor(Math.random() * skillPool.length)];
                                    shiro.skills.push(randomSkill);
                                }
                            }
                        }
                        // ヒミツの夜モードの初期設定
                        if (gameState.gameMode === 'secret_night' && gameState.party.length === 1) {
                            const char = gameState.party[0];
                            char.statusEffects.stripped = {
                                turns: 0
                            }; // 脱衣状態で開始
                            // 衣装設定
                            if (char.name === 'フローラ') {
                                char.bgClass = 'bg-char-flora-a';
                            } else if (char.name === 'リリカ') {
                                char.bgClass = 'bg-char-ririka-a';
                            } else if (char.name === 'ユイ') {
                                char.bgClass = 'bg-char-yui-a';
                            } else if (char.name === 'ミコ') {
                                char.bgClass = 'bg-char-miko-a';
                            } else if (char.name === 'リリィ') {
                                char.bgClass = 'bg-char-lily-a';
                            }
                        }



                    }
                    

                    function applyShiroTenseiData(data) {
                        const shiro = gameState.party.find(p => p.role === '転生者');
                        if (shiro) {
                            shiro.maxHp = data.maxHp;
                            shiro.currentHp = data.maxHp;
                            shiro.maxMp = data.maxMp;
                            shiro.currentMp = data.maxMp;
                            shiro.atk = data.atk;
                            shiro.def = data.def;
                            shiro.agi = data.agi;
                            shiro.height = data.height;
                            shiro.skills = data.skills;
                            shiro.blessings = data.blessings || {};
                            gameState.shiroInherited = true; // 引き継ぎフラグを立てる
                            updatePartyStatus();
                            log("シロは過去の記憶を取り戻し、その力を継承した！");
                        }
                        generalEventModal.classList.add('hidden');
                    }

                    function setupDungeonUI() {
                        updateFloorDisplay();
                        modal.classList.add('hidden');

                        // 会話ボタンのセットアップ
                        talkButton.id = 'talk-button';
                        talkButton.className = 'action-button bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                        talkButton.textContent = '会話する';
                        if (!dungeonCommands.querySelector('#talk-button')) {
                            dungeonCommands.insertBefore(talkButton, nextFloorButton.nextSibling);
                        }

                        // アイテムボタンのセットアップ
                        const itemButton = document.getElementById('dungeon-item-button') || document.createElement('button');
                        itemButton.id = 'dungeon-item-button';
                        itemButton.className = 'action-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                        itemButton.textContent = 'アイテム';
                        itemButton.onclick = () => {
                            cancelScanMode(); // アイテムモーダルを開く前に調べるモードを終了
                            showItemModal();
                        };
                        if (!dungeonCommands.querySelector('#dungeon-item-button')) {
                            dungeonCommands.insertBefore(itemButton, talkButton.nextSibling);
                        }

                        // 調べるボタンのセットアップ
                        const scanButton = document.getElementById('dungeon-scan-button') || document.createElement('button');
                        scanButton.id = 'dungeon-scan-button';
                        scanButton.className = 'action-button bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                        scanButton.textContent = '調べる';
                        scanButton.onclick = () => {
                            showScanTargetSelection();
                        };
                        if (!dungeonCommands.querySelector('#dungeon-scan-button')) {
                            dungeonCommands.insertBefore(scanButton, itemButton.nextSibling);
                        }

                        // 「奔放な魂」モード専用コマンド
                        if (gameState.gameMode === 'uninhibited_souls') {
                            const stripButton = document.createElement('button');
                            stripButton.id = 'uninhibited-strip-button';
                            stripButton.className = 'action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                            stripButton.textContent = '脱ぐ';
                            stripButton.onclick = () => {
                                showOneMemberSelectionModal(char => {
                                    const immuneRoles = ['ナイト', 'サムライ', '聖女', 'アンドロイド'];
                                    if (immuneRoles.includes(char.role)) {
                                        log(`${char.name}は恥じらいを覚えず、何も起こらなかった。`);
                                    } else {
                                        char.statusEffects.stripped = {
                                            turns: 0
                                        };
                                        log(`${char.name}は服を脱ぎ捨て、脱衣状態になった！`);
                                        updatePartyStatus();
                                    }
                                });
                            };
                            dungeonCommands.appendChild(stripButton);

                            const shrinkButton = document.createElement('button');
                            shrinkButton.id = 'uninhibited-shrink-button';
                            shrinkButton.className = 'action-button bg-blue-700 hover:bg-blue-800 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                            shrinkButton.textContent = '縮小化薬';
                            shrinkButton.onclick = () => {
                                showOneMemberSelectionModal(char => {
                                    if (char.heightLocked) {
                                        // 身長が固定されている場合の処理
                                        const unlockChoices = [{
                                            text: '固定を解除する',
                                            value: 'unlock'
                                        }, {
                                            text: 'やめる',
                                            value: 'cancel'
                                        }, ];
                                        showAmountChoiceModal('固定解除', `${char.name}の身長は1cmで固定されています。固定を解除しますか？`, unlockChoices, (value) => {
                                            if (value === 'unlock') {
                                                char.heightLocked = false;
                                                log(`${char.name}の身長固定が解除された！`);
                                                updatePartyStatus();
                                            }
                                        });
                                    } else {
                                        // 通常の縮小処理
                                        const choices = [{
                                            text: '30 cm',
                                            value: 30
                                        }, {
                                            text: '100 cm',
                                            value: 100
                                        }, {
                                            text: '999 cm',
                                            value: 999
                                        }, {
                                            text: '1cmに固定',
                                            value: 'lock_one'
                                        }];
                                        showAmountChoiceModal('縮小化薬', `${char.name}をどうしますか？`, choices, (value) => {
                                            if (value === 'lock_one') {
                                                animateStatChange(char, 'height', 1 - char.height, 'decrease');
                                                char.heightLocked = true;
                                                log(`${char.name}の体が妖精のように小さくなり、その姿で固定された！`);
                                            } else {
                                                animateStatChange(char, 'height', -value, 'decrease');
                                                log(`${char.name}の身長が${value}cm縮んだ！`);
                                            }
                                        });
                                    }
                                });
                            };
                            dungeonCommands.appendChild(shrinkButton);

                            const growButton = document.createElement('button');
                            growButton.id = 'uninhibited-grow-button';
                            growButton.className = 'action-button bg-red-700 hover:bg-red-800 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                            growButton.textContent = '巨大化薬';
                            growButton.onclick = () => {
                                showOneMemberSelectionModal(char => { // 対象を選択
                                    const choices = [{
                                            text: '30 cm',
                                            value: 30
                                        }, {
                                            text: '100 cm',
                                            value: 100
                                        }, {
                                            text: '999 cm',
                                            value: 999
                                        }, {
                                            text: '2000 cm',
                                            value: 2000
                                        } // 新しい選択肢
                                    ];
                                    showAmountChoiceModal('巨大化薬', `${char.name}の身長をどれだけ伸ばしますか？`, choices, (amount) => {
                                        if (char.heightLocked) {
                                            log(`${char.name}の体は変化を拒んだ！`);
                                            return;
                                        }
                                        animateStatChange(char, 'height', amount, 'increase');
                                        log(`${char.name}の身長が${amount}cm伸びた！`);
                                    });
                                });
                            };
                            dungeonCommands.appendChild(growButton);
                        } else {
                            // 他モードではボタンを削除
                            ['#uninhibited-strip-button', '#uninhibited-shrink-button', '#uninhibited-grow-button'].forEach(sel => {
                                const element = document.querySelector(sel);
                                if (element) {
                                    element.remove();
                                }
                            });
                        }
                    }
                    async function playConversation(conversation) {
                        dungeonCommands.classList.add('hidden');
                        for (const part of conversation) {
                            const speaker = gameState.party.find(p => p.name === part.char);
                            // システムメッセージの場合
                            if (part.char === 'システム' || !speaker) {
                                log(part.line);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                            } else if (speaker.currentHp > 0) {
                                log(`${part.char}「${part.line}」`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                            }
                        }
                        dungeonCommands.classList.remove('hidden');
                    }
                    // playConversationの直後に配置
                    conversations['システム'] = {
                        default: [""]
                    };

                    function updateFloorDisplay() {
                        if (!gameState.inBattle && gameState.floor > 0) {
                            floorDisplay.textContent = `第 ${gameState.floor} 層`;
                            floorDisplay.classList.remove('hidden');
                        } else floorDisplay.classList.add('hidden');
                    }

                    let logHistory = [];
                    let logQueue = [];
                    let isProcessingLog = false;

                    function log(message) {
                        return new Promise(resolve => {
                            logQueue.push({
                                message,
                                resolve
                            });
                            if (!isProcessingLog) {
                                processLogQueue();
                            }
                        });
                    }

                    function addLogToHistory(message) {
                        logHistory.push(message);
                        if (logHistory.length > 20) { // 履歴は最大20件まで保持
                            logHistory.shift();
                        }
                    }
                    // Refactored updatePartyStatus to update existing elements or create new ones
                    function processLogQueue() {
                        if (logQueue.length === 0) {
                            isProcessingLog = false;
                            return;
                        }
                        isProcessingLog = true;
                        const {
                            message,
                            resolve
                        } = logQueue.shift();
                        addLogToHistory(message);
                        logMessage.textContent = message;

                        setTimeout(() => {
                            resolve(); // Promiseを解決して、呼び出し元のawaitを解放
                            processLogQueue(); // 次のログ処理へ
                        }, 700); // 0.7秒の遅延
                    }

                    function updatePartyStatus() {
                        gameState.party.forEach((char, index) => {
                            let card = document.getElementById(`party-card-${index}`);
                            if (!card) {
                                // If card doesn't exist, create it (initial setup)
                                card = document.createElement('div');
                                card.id = `party-card-${index}`;
                                card.onclick = () => playerSelectAlly(index);
                                partyContainer.appendChild(card);

                                // Initial render of the inner structure
                                card.innerHTML = `
                            <div class="golem-status-container"></div>
                            <div class="wall-status-container"></div>
                            <div class="character-stats w-full">
                                <div class="stat-name" data-char-name="${char.name}">
                                    <p class="font-bold text-xs truncate text-${char.themeColor}-700">${char.name}</p>
                                    <p class="text-[11px] text-gray-600">Lv.${char.level} ${char.role}</p>
                                </div>
                                <p class="text-[10px] stat-hp">HP: <span class="font-semibold">${char.currentHp}</span>/${char.maxHp}</p>
                                <div class="w-full bg-gray-300 rounded-full h-1.5 my-0.5"><div class="hp-bar-inner bg-red-500 h-1.5 rounded-full" style="width: ${Math.max(0, char.currentHp / char.maxHp * 100)}%"></div></div>
                                <p class="text-[10px] stat-mp">MP: <span class="font-semibold">${char.currentMp}</span>/${char.maxMp}</p>
                                <div class="w-full bg-gray-300 rounded-full h-1.5 my-0.5"><div class="mp-bar-inner bg-blue-500 h-1.5 rounded-full" style="width: ${Math.max(0, char.currentMp / char.maxMp * 100)}%"></div></div>
                                <p class="text-[11px] stat-height">身長: <span class="font-semibold">${char.height}cm</span> (${char.height - char.initialHeight >= 0 ? '+' : ''}${char.height - char.initialHeight})</p>
                                <!-- 攻撃力と防御力の表示を追加 -->
                                <p class="text-[11px] stat-atk">攻撃: <span class="font-semibold">0</span></p>
                                <p class="text-[11px] stat-def">防御: <span class="font-semibold">0</span></p>
                                <p class="text-[11px] stat-agi">素早: <span class="font-semibold">0</span></p>
                                <div class="stat-statuses text-xs"></div>
                            </div>
                        `;
                            }
                            card.onclick = () => playerSelectAlly(index); // onclickを常に再設定
                            // Update card classes
                            card.className = `character-card w-full sm:w-1/5 p-1 rounded-lg shadow-md border-4 border-${char.themeColor}-400 ${char.currentHp <= 0 ? 'opacity-50' : ''} ${char.bgClass || ''}`;

                            // 身長に応じて背景の立ち絵を調整
                            const heightRatio = char.height / char.initialHeight;
                            let bgSize = 'auto 100%'; // デフォルトサイズ（coverに近い挙動）
                            let bgPosition = 'center bottom'; // デフォルト位置（下揃え）

                            if (heightRatio < 1.0) {
                                // 身長が初期値より低い場合、立ち絵を縮小して下揃え
                                const sizePercentage = Math.max(20, 100 * heightRatio); // 最低でも20%のサイズ
                                bgSize = `auto ${sizePercentage}%`;
                            } else if (heightRatio > 1.0) {
                                // 身長が初期値より高い場合、少しだけ大きく見せる
                                const sizePercentage = Math.min(130, 100 * heightRatio); // 最大130%
                                bgSize = `auto ${sizePercentage}%`;
                            }

                            card.style.setProperty('--char-bg-size', bgSize);
                            card.style.setProperty('--char-bg-position', bgPosition);
                            card.style.setProperty('background-repeat', 'no-repeat'); // 繰り返しを無効にする設定をJSで直接指定

                            // Update specific elements within the card
                            // The animateStatChange function will handle the number and bar updates during animation.
                            // This updatePartyStatus call ensures consistency after animations or for non-animated changes.

                            const nameElement = card.querySelector('.stat-name');
                            if (nameElement) {
                                let statusHtml = '';
                                if (char.statusEffects.poison) statusHtml += '<span class="status-icon" title="毒">🤢</span>';
                                if (char.statusEffects.paralysis) statusHtml += '<span class="status-icon" title="麻痺">⚡️</span>';
                                if (char.statusEffects.slow) statusHtml += '<span class="status-icon" title="鈍化">🐌</span>';
                                if (char.statusEffects.stripped) statusHtml += '<span class="status-icon" title="脱衣">😳</span>';
                                if (char.statusEffects.regeneration) statusHtml += '<span class="status-icon" title="自然治癒">✨</span>';

                                // nameElement is now a div, so we set its children
                                const nameP = nameElement.querySelector('p:first-child'); // The <p> with the name
                                const roleP = nameElement.querySelector('p:last-child'); // The <p> with the role
                                if (nameP) nameP.innerHTML = `${char.name} ${statusHtml}`;
                                if (roleP) roleP.textContent = `Lv.${char.level} ${char.role}`;
                            }

                            // Update HP (only if not currently animating, or to ensure final state)
                            const hpSpan = card.querySelector('.stat-hp > .font-semibold');
                            if (hpSpan) hpSpan.textContent = char.currentHp;
                            // Update max HP text
                            const hpTextElement = card.querySelector('.stat-hp');
                            if (hpTextElement) {
                                hpTextElement.innerHTML = `HP: <span class="font-semibold">${char.currentHp}</span>/${char.maxHp}`; // text-[11px]は親要素で指定済み
                            }

                            const hpBarInner = card.querySelector('.hp-bar-inner');
                            if (hpBarInner) hpBarInner.style.width = `${Math.max(0, char.currentHp / char.maxHp * 100)}%`;

                            // Update MP
                            const mpSpan = card.querySelector('.stat-mp > .font-semibold');
                            if (mpSpan) mpSpan.textContent = char.currentMp;
                            const mpBarInner = card.querySelector('.mp-bar-inner');
                            // Update max MP text
                            const mpTextElement = card.querySelector('.stat-mp');
                            if (mpTextElement) {
                                mpTextElement.innerHTML = `MP: <span class="font-semibold">${char.currentMp}</span>/${char.maxMp}`; // text-[11px]は親要素で指定済み
                            }
                            if (mpBarInner) mpBarInner.style.width = `${Math.max(0, char.currentMp / char.maxMp * 100)}%`;

                            // Update Height
                            const heightSpan = card.querySelector('.stat-height .font-semibold');
                            if (heightSpan) heightSpan.textContent = `${char.height}cm`;
                            const heightDiffElement = card.querySelector('.stat-height'); // This is the parent <p>
                            if (heightDiffElement) {
                                const diff = char.height - char.initialHeight;
                                heightDiffElement.innerHTML = `身長: <span class="font-semibold">${char.height}cm</span> (${diff >= 0 ? '+' : ''}${diff})`; // text-[11px]は親要素で指定済み
                            }

                            // 攻撃力と防御力の表示を更新
                            const effectiveStats = getEffectiveStats(char);
                            const heightDiff = char.height - char.initialHeight; // 身長差
                            let atkHeightBonus = 0;
                            let defHeightBonus = 0;
                            let agiHeightBonus = 0;

                            // getEffectiveStatsのロジックに合わせてボーナス値を計算
                            if (char.role === 'リーパー') {
                                if (heightDiff > 0) atkHeightBonus = Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                            } else if (char.role === 'サキュバス') {
                                atkHeightBonus = Math.floor(char.atk * (heightDiff / char.initialHeight * 1.2));
                                defHeightBonus = Math.floor(char.def * (heightDiff / char.initialHeight * 1.2));
                            } else if (char.role === 'アルラウネ') {
                                atkHeightBonus = Math.floor(char.atk * (heightDiff / char.initialHeight * 1.0));
                                defHeightBonus = Math.floor(char.def * (heightDiff / char.initialHeight * 1.0));
                            } else if (char.role === 'フェアリー') {
                                if (heightDiff > 0) atkHeightBonus = Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                            } else {
                                // 上記以外の通常ジョブ
                                atkHeightBonus = Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                            }

                            // 防御ボーナスはサキュバスとアルラウネ以外は共通
                            if (char.role !== 'サキュバス' && char.role !== 'アルラウネ') {
                                defHeightBonus = Math.floor(char.def * (heightDiff / char.initialHeight * 0.8));
                            }

                            // 素早さボーナス
                            if (char.role === 'フェアリー') {
                                agiHeightBonus = Math.floor(char.agi * (heightDiff / char.initialHeight * -3.0));
                            } else {
                                agiHeightBonus = Math.floor(char.agi * (heightDiff / char.initialHeight * -1.5));
                            }

                            const atkElement = card.querySelector('.stat-atk');
                            if (atkElement) {
                                atkElement.innerHTML = `攻撃: <span class="font-semibold">${effectiveStats.atk}</span> <span class="text-gray-500">(${atkHeightBonus >= 0 ? '+' : ''}${atkHeightBonus})</span>`;
                            }

                            const defElement = card.querySelector('.stat-def');
                            if (defElement) {
                                defElement.innerHTML = `防御: <span class="font-semibold">${effectiveStats.def}</span> <span class="text-gray-500">(${defHeightBonus >= 0 ? '+' : ''}${defHeightBonus})</span>`;
                            }

                            const agiElement = card.querySelector('.stat-agi');
                            if (agiElement) {
                                agiElement.innerHTML = `素早: <span class="font-semibold">${effectiveStats.agi}</span> <span class="text-gray-500">(${agiHeightBonus >= 0 ? '+' : ''}${agiHeightBonus})</span>`;
                            }

                            // ゴーレムのステータス表示
                            const golemContainer = card.querySelector('.golem-status-container');
                            if (golemContainer) {
                                if (char.role === 'サモナー' && gameState.golem && gameState.golem.hp > 0) {
                                    golemContainer.innerHTML = `
                                <div class="golem-card-inner text-white text-center">
                                    <p class="font-bold text-xs">ゴーレム HP: ${gameState.golem.hp}/${gameState.golem.maxHp}</p>
                                    <div class="w-full bg-gray-500 rounded-full h-1.5"><div class="bg-yellow-500 h-1.5 rounded-full" style="width: ${Math.max(0, gameState.golem.hp / gameState.golem.maxHp * 100)}%"></div></div>
                                </div>
                            `;
                                } else {
                                    golemContainer.innerHTML = '';
                                }
                            }

                            // ウォールのステータス表示
                            const wallContainer = card.querySelector('.wall-status-container');
                            if (wallContainer) {
                                const wall = gameState.walls.find(w => w.targetId === index);
                                if (wall) {
                                    wallContainer.innerHTML = `
                                <div class="wall-card-inner text-white text-center">
                                    <p class="font-bold text-xs">防壁 HP: ${wall.hp}/${wall.maxHp}</p>
                                    <div class="w-full bg-gray-500 rounded-full h-1.5"><div class="bg-stone-500 h-1.5 rounded-full" style="width: ${Math.max(0, wall.hp / wall.maxHp * 100)}%"></div></div>
                                </div>`;
                                } else {
                                    wallContainer.innerHTML = '';
                                }
                            }
                        });
                    }

                    function updateEnemyStatus() {
                        gameState.enemies.forEach((enemy, index) => {
                            if (enemy.currentHp > 0) {
                                let card = document.getElementById(`enemy-card-${index}`);
                                if (!card) {
                                    card = document.createElement('div');
                                    card.id = `enemy-card-${index}`;
                                    enemyContainer.appendChild(card);
                                }
                                card.className = `enemy-card bg-gray-900/70 p-2 rounded-lg text-white text-center w-32 border-2 border-transparent`;
                                card.innerHTML = `
                            <p class="font-bold text-sm">${enemy.name}</p>
                            <p class="text-xs">HP: ${enemy.currentHp}/${enemy.maxHp}</p>
                            <div class="w-full bg-gray-500 rounded-full h-2 mt-1"><div class="bg-red-500 h-2 rounded-full" style="width: ${Math.max(0, enemy.currentHp / enemy.maxHp * 100)}%"></div></div>
                        `;
                                card.classList.add('cursor-pointer', 'hover:border-red-500');
                                card.onclick = () => playerSelectTarget(index);
                            }
                        });
                    }

                    function getEffectiveStats(char) {
                        if (char.isEnemy) {
                            let atk = char.atk;
                            let pDef = char.pDef;
                            let mDef = char.mDef;
                            // テンションアップ効果
                            if (char.buffs && char.buffs.tension_up) {
                                atk += 10;
                                pDef += 10;
                                mDef += 10;
                            }
                            if (char.statusEffects && char.statusEffects.stat_down) {
                                atk *= 0.5;
                                pDef *= 0.5;
                                mDef *= 0.5;
                            } else if (char.buffs && char.buffs.atk_down) {
                                atk *= 0.5;
                                pDef *= 0.5;
                                mDef *= 0.5;
                            }
                            return {
                                atk: Math.floor(atk),
                                pDef: Math.floor(pDef),
                                mDef: Math.floor(mDef),
                                agi: char.agi
                            };
                        }
                        const heightDiff = char.height - char.initialHeight;
                        let atk = char.atk;
                        let def = char.def;
                        let agi = char.agi; // リーパーのみ、身長が縮んでも攻撃力が低下しない
                        // テンションアップ効果
                        // 戦闘中のみ身長を1cmにするデバフ
                        if (char.statusEffects && char.statusEffects.shrunkToOne) {
                            char.height = 1;
                        }

                        if (char.buffs && char.buffs.tension_up) {
                            atk += 10;
                        }

                        if (char.role === 'リーパー') {
                            if (heightDiff > 0) { // 身長が高い場合は通常通り攻撃力が上がる
                                atk += Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                            }
                        } else if (char.role === 'サキュバス') {
                            // サキュバスは身長ボーナスが高い
                            atk += Math.floor(char.atk * (heightDiff / char.initialHeight * 1.2));
                            def += Math.floor(char.def * (heightDiff / char.initialHeight * 1.2));
                        } else if (char.role === 'アルラウネ') {
                            // アルラウネは全体的にステータスボーナスが高い
                            atk += Math.floor(char.atk * (heightDiff / char.initialHeight * 1.0));
                            def += Math.floor(char.def * (heightDiff / char.initialHeight * 1.0));
                        } else if (char.role === 'フェアリー') {
                            // フェアリーは身長が低くてもステータスが低下しない
                            if (heightDiff > 0) {
                                atk += Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                            }
                        } else {
                            atk += Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                        }
                        def += Math.floor(char.def * (heightDiff / char.initialHeight * 0.8));
                        if (char.role === 'フェアリー') {
                            // フェアリーは素早さボーナスが倍
                            agi += Math.floor(char.agi * (heightDiff / char.initialHeight * -3.0));
                        } else if (char.role === 'アルラウネ') {
                            agi += Math.floor(char.agi * (heightDiff / char.initialHeight * -1.0)); // 素早さ低下は少し緩やか
                        } else {
                            agi += Math.floor(char.agi * (heightDiff / char.initialHeight * -1.5)); // 小さいほど素早い
                        }

                        if (char.buffs && char.buffs.agi_up) agi *= 1.5;
                        if (char.buffs && char.buffs.atk_up) atk *= 1.5;
                        if (char.buffs && char.buffs.protect) def *= 1.5;
                        if (char.buffs && char.buffs.def_down) {
                            if (char.isEnemy) {
                                char.pDef *= 0.7;
                                char.mDef *= 0.7;
                            } else {
                                def *= 0.7;
                            }
                        }

                        // 脱衣状態の場合
                        if ((char.statusEffects && char.statusEffects.stripped) || char.isLiberatedStripped) {
                            if (char.role === 'サキュバス') {
                                // サキュバスは脱衣で攻撃力が上がる
                                atk *= 1.5;
                            } else if (char.role === 'リーパー') {
                                // リーパーは脱衣状態に非常に弱い
                                atk *= 0.5; // 攻撃力半減
                                def *= 0.5; // 防御力半減
                            } else if (char.role !== 'トレジャーハンター' && char.role !== 'フェアリー' && char.role !== 'アルラウネ') {
                                def *= 0.8; // 他のジョブは防御力20%減少
                            }
                        }
                        // 解放状態の場合、素早さにボーナス
                        if (char.isLiberatedStripped) {
                            agi *= 1.2;
                            // リーパーとサキュバス以外は攻撃力に5%のボーナス
                            if (char.role !== 'リーパー' && char.role !== 'サキュバス') {
                                atk *= 1.05;
                            }
                        }

                        return {
                            atk: Math.floor(atk),
                            def: Math.floor(def),
                            agi: Math.max(0, Math.floor(agi)) // 素早さの下限を0に設定
                        };
                    }

                    function updateHate() {
                        gameState.party.forEach(char => {
                            const standardHeight = 150; // ヘイト計算の基準となる身長(cm)
                            // 基準身長(150cm)に対する現在の身長の比率でヘイトを計算
                            const heightRatio = char.height / standardHeight;
                            // 比率の3乗に比例してヘイトが変動。大きいと急増し、小さいと急減する。
                            char.hate = Math.pow(heightRatio, 3) * 100;
                            if (char.role === 'ナイト') char.hate *= 1.5;
                            if (char.buffs.provoke) {
                                char.hate *= 3;
                                // ダンサーが挑発中に縮んでいても、最低限のヘイトを保証
                                if (char.role === 'ダンサー') {
                                    char.hate = Math.max(char.hate, 150); // 最低ヘイト値を150に設定
                                }
                            }
                        });
                    }

                    async function advanceFloor() {
                        gameState.party.forEach(p => {
                            // 祝福「肥大する心身」「捻じ曲がった記憶」の効果
                            if (!p.isEnemy && p.currentHp > 0 && !p.heightLocked) {
                                if (p.blessings && p.blessings.twisted_memory) {
                                    const newHeight = Math.max(1, Math.floor(p.height / 2));
                                    const change = newHeight - p.height;
                                    if (change !== 0) {
                                        log(`${p.name}の捻じ曲がった記憶が、その体を蝕む…！`);
                                        animateStatChange(p, 'height', change, 'decrease');
                                    }
                                }
                            }
                        });

                        gameState.party.forEach(p => {
                            if (p.liberationCooldown > 0) {
                                p.liberationCooldown--;
                            }
                        });

                        gameState.floor++;
                        updateFloorDisplay();

                        // --- 1階の導入イベント (最優先でチェック) ---
                        const isTenseiKikou = gameState.party.some(p => p.role === '転生者');
                        if (gameState.floor === 1) {
                            const tenseiKikouConversations = { floor1: [{ char: 'シロ', line: 'ここが、新しい世界…。今度は、どこまで行けるかな。' }], floor1_inherited: [{ char: 'シロ', line: '見知った世界、見知った力…。今度こそ、この先に辿り着いてみせる。' }] };
                            // 「はじめから」モードの場合のみ導入会話を再生
                            // 転生紀行モードの1階イベント
                            if (gameState.gameMode === 'endless' && isTenseiKikou) {
                                await playConversation(tenseiKikouConversations.floor1);
                                return;
                            }
                            if (gameState.gameMode === 'normal' || gameState.gameMode === 'trial') {
                                await playConversation(normalModeConversations.floor1);
                                return; // 導入会話を再生したら、他のイベントは発生させずに終了
                            }
                            if (gameState.gameMode === 'summer_live') {
                                await playConversation(summerLiveConversations.floor1);
                                return;
                            }
                            // サイズアップ・ギャンブル！ 1階イベント
                            if (gameState.gameMode === 'size_up_gamble') {
                                await playConversation(sizeUpGambleConversations.floor1);
                            }
                            // --- little_panic モードの会話イベント ---
                            if (gameState.gameMode === 'little_panic') {
                                await playConversation(littlePanicConversations.floor1);
                                return; // イベントを発生させてターン終了
                            }
                        }
                        // 転生者モードの2階イベント
                        if (isTenseiKikou && gameState.floor === 2) {
                            executeEvent(foundAdaptation);
                            return;
                        }
                        // 11階の固定イベント
                        if (gameState.floor === 11 && gameState.gameMode === 'summer_live') {
                            await triggerKanpaiJuiceEvent();
                            return; // イベントを発生させてターン終了
                        }

                        // サイズアップ・ギャンブル！ 目標達成後イベント
                        if (gameState.gameMode === 'size_up_gamble' && gameState.sizeUpGambleGoalReached) {
                            await triggerSizeUpGambleGoalEvent();
                            gameState.sizeUpGambleGoalReached = false; // イベントは一度きりなのでフラグをリセット
                            return;
                        }
                        // --- little_panic モードの会話イベント ---
                        if (gameState.gameMode === 'little_panic') {
                            if (gameState.floor === 5) { // 6階に到達する前
                                await playConversation(littlePanicConversations.floor6);
                            } else if (gameState.floor === 11) { // 12階に到達する前 // ファイター, ソーサラー, ナイト, メディック
                                await playConversation(littlePanicConversations.floor12);
                            } else if (gameState.floor === 23) { // 24階に到達する前 // ファイター, ソーサラー, ナイト, メディック
                                await playConversation(littlePanicConversations.floor24);
                            } else if (gameState.floor === 28) { // 29階に到達する前 // ファイター, ソーサラー, ナイト, メディック
                                await playConversation(littlePanicConversations.floor29);
                            }
                        }

                        // --- saint_march モードの会話イベント ---
                        if (gameState.gameMode === 'saint_march' && gameState.floor === 1) {
                            await playConversation(saintMarchConversations.floor1);
                            return; // イベントを発生させてターン終了
                        }

                        // --- treasure_map モードの会話イベント ---
                        if (gameState.gameMode === 'treasure_map') {
                            if (gameState.floor === 1) {
                                await playConversation(treasureMapConversations.floor1);
                                return; // イベントを発生させてターン終了
                            } else if (gameState.floor === 5) { // 6階に到達する前
                                const lily = gameState.party[0]; // リリィは常にパーティの0番目
                                const conversationKey = lily.isTransformed ?
                                    `floor6_${lily.role.toLowerCase()}` :
                                    'floor6_normal';
                                if (treasureMapConversations[conversationKey]) {
                                    await playConversation(treasureMapConversations[conversationKey]);
                                }
                            }
                        }

                        // --- サイズアップ・ギャンブル！ 特殊ゲームオーバー ---
                        if (gameState.gameMode === 'size_up_gamble' && gameState.party.every(p => p.height === 1)) {
                            await triggerSizeUpGambleGameOverEvent();
                            return;
                        }


                        // --- サマータイム・スペシャルライブ！ 32階イベント ---
                        if (gameState.floor === 32 && gameState.gameMode === 'summer_live') {
                            await playConversation(summerLiveConversations.floor32);
                            return;
                        }

                        // --- ヒミツの夜 独り言イベント ---
                        if (gameState.gameMode === 'secret_night') {
                            const secretNightFloors = [1, 6, 11, 16, 21, 29]; // イベント発生階層
                            if (secretNightFloors.includes(gameState.floor)) {
                                const char = gameState.party[0];
                                let conversationKey = `secret_night_${gameState.floor}`; // 基本のキー

                                // ミコの場合、specialConversationsから会話データを取得してconversationsオブジェクトにマージする
                                if (char.name === 'ミコ' && specialConversations['ミコ']) {
                                    if (!conversations['ミコ']) {
                                        conversations['ミコ'] = {};
                                    }
                                    // specialConversationsの内容をconversations['ミコ']にコピー
                                    Object.assign(conversations['ミコ'], specialConversations['ミコ']);
                                    // specialConversationsからミコのデータを削除して、二重処理を防ぐ
                                    delete specialConversations['ミコ'];
                                }

                                // 16階以降で身長が半分以下の場合、会話を分岐
                                if (gameState.floor >= 16 && char.height <= char.initialHeight / 2) {
                                    const shrunkConversationKey = `secret_night_${gameState.floor}_shrunk`;
                                    // 専用の会話が存在するかチェック
                                    if (conversations[char.name] && conversations[char.name][shrunkConversationKey]) {
                                        conversationKey = shrunkConversationKey;
                                    } else if (conversations[char.name] && conversations[char.name]['secret_night_16_shrunk']) {
                                        // 16階以降で共通の縮小会話があればそれを使う
                                        conversationKey = 'secret_night_16_shrunk';
                                    }
                                }
                                const conversation = conversations[char.name][conversationKey];
                                if (conversation) {
                                    await playConversation(conversation.map(line => ({
                                        char: char.name,
                                        line
                                    })));
                                    return; // 専用イベントを発生させたら、以降の処理は行わない
                                }
                            }
                        }
                        // --- 闘争令嬢 復活イベント ---
                        if (gameState.gameMode === 'brawling_belles' && !gameState.bellesReviveEventTriggered) {
                            const noel = gameState.party.find(p => p.name === 'ノエル');
                            const flora = gameState.party.find(p => p.name === 'フローラ');
                            if (noel && flora) {
                                if ((noel.currentHp <= 0 && flora.currentHp > 0) || (flora.currentHp <= 0 && noel.currentHp > 0)) {
                                    triggerBellesReviveEvent(noel, flora);
                                    return; // 専用イベントを発生させたら、以降の処理は行わない
                                }
                            }
                        }


                        // --- 闘争令嬢 6階イベント ---
                        if (gameState.floor === 6 && gameState.gameMode === 'brawling_belles') {
                            const noel = gameState.party.find(p => p.name === 'ノエル');
                            const flora = gameState.party.find(p => p.name === 'フローラ');
                            if (noel && flora && noel.currentHp > 0 && flora.currentHp > 0) {
                                if ((noel.height === 1 && flora.height !== 1) || (flora.height === 1 && noel.height !== 1)) {
                                    triggerBellesFloor6Event(noel, flora);
                                    return; // 専用イベントを発生させたら、以降の処理は行わない
                                }
                            }
                        }


                        // --- 闘争令嬢 29階イベント ---
                        if (gameState.floor === 29 && gameState.gameMode === 'brawling_belles') {
                            triggerBellesFloor29Event();
                            return; // 専用イベントを発生させたら、以降の処理は行わない
                        }

                        // --- サマータイム・スペシャルライブ！ 29階イベント ---
                        if (gameState.floor === 29 && gameState.gameMode === 'summer_live') {
                            triggerSummerLiveRirikaEvent();
                            return; // 専用イベントを発生させたら、以降の処理は行わない
                        }


                        const floor = gameState.floor;
                        const mode = gameState.gameMode;

                        // 特別な衣装変更イベントのチェック
                        if (floor === 1) {
                            // 闘争令嬢プライベート衣装イベント
                            const hasNoel = gameState.party.some(p => p.name === 'ノエル');
                            const hasFlora = gameState.party.some(p => p.name === 'フローラ');
                            if (hasNoel && hasFlora && gameState.gameMode !== 'brawling_belles' && !gameState.bellesPrivateCostumeEventTriggered) {
                                gameState.bellesPrivateCostumeEventTriggered = true;
                                triggerBellesPrivateCostumeEvent();
                                return;
                            }
                            const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                            const partyNames = gameState.party.map(p => p.name).sort();
                            const requiredNames = ['リリカ', 'ユイ', 'ミコ', 'リリィ'].sort();
                            const isSpecialParty = JSON.stringify(partyNames) === JSON.stringify(requiredNames);

                            if (clearFlags.summerLiveCleared && isSpecialParty && mode !== 'summer_live') {
                                triggerSpecialCostumeEvent();
                                return; // 専用イベントを発生させたら、以降の処理は行わない
                            }
                        }


                        // --- ボス戦の判定 ---
                        // 聖女パーティでの29階イベント (サマーライブ中は発生しない)
                        const hasCelestia = gameState.party.some(p => p.role === '聖女');
                        if (floor === 29 && hasCelestia && gameState.party.length >= 2 && mode !== 'summer_live' && mode !== 'tensei_rinne') {
                            celestiaEventTitle.textContent = "最後の問い";
                            celestiaEventText.textContent = "セレスティアが、静かにあなたを見つめている。\nその瞳は、これから待ち受ける運命について、覚悟を問うているようだ。\n\n「…この先に待つ元凶は、計り知れないほどの穢れを溜め込んでいます。仲間と共に挑めば、その穢れはさらに増し、想像を絶する脅威となるでしょう。それでも、あなたはこの道を進みますか？」";
                            celestiaEventButtons.innerHTML = `
            <button id="celestia-accept" class="action-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg">覚悟を決める</button>
            <button id="celestia-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">今はまだ…</button>
        `;
                            celestiaEventModal.classList.remove('hidden');
                            document.getElementById('celestia-accept').onclick = () => {
                                celestiaEventModal.classList.add('hidden');
                                startBattle(true, true); // 強化ボス戦
                            };
                            document.getElementById('celestia-decline').onclick = () => {
                                celestiaEventModal.classList.add('hidden');
                                startBattle(true, false); // 通常ボス戦
                            };
                            return;
                        }

                        // サマータイム・スペシャルライブ！のボス戦
                        if (mode === 'summer_live' && (floor === 30 || floor === 60)) {
                            startBattle(true);
                            return;
                        }
                        if (mode === 'endgame_plus' && (floor === 30 || floor === 60 || floor === 90)) {
                            startBattle(true);
                            return;
                        }

                        // 闘争令嬢モードの30階ボス
                        if (mode === 'brawling_belles' && floor === 30) {
                            startBattle(true, 'phantom_hero');
                            return;
                        }

                        // 通常の30階ボス
                        if (floor === 30 && mode !== 'endless' && mode !== 'monster_march' && mode !== 'size_up_gamble' && mode !== 'summer_live') {
                            startBattle(true);
                            return;
                        }
                        // その他のモードでのボス戦
                        if ((mode === 'endgame' && floor === 1) ||
                            (mode === 'size_up_gamble' && gameState.nextBattleIsGambleMaster) ||
                            (mode === 'monster_march' && (floor === 30 || floor === 50)) ||
                            (mode === 'endless' && floor > 0 && floor % 30 === 0)) {
                            startBattle(true);
                            return;
                        }

                        // サマータイム・スペシャルライブ！の後半パートへの移行
                        if (mode === 'summer_live' && floor === 31) {
                            triggerSummerLivePart2();
                            return; // イベントを発生させてターン終了
                        }

                        // --- 通常戦闘の判定 ---
                        if ((mode === 'monster_march') ||
                            (mode === 'brawl' && floor % 2 === 0) || (mode !== 'secret_night' && floor % 5 === 0)) {
                            startBattle();
                            return;
                        }

                        // --- イベントの判定 ---
                        // サマータイム・スペシャルライブ！の全員解放イベントチェック
                        if (gameState.gameMode === 'summer_live') {
                            const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                            const allLiberated = aliveParty.length > 0 && aliveParty.every(p => p.isLiberatedStripped);

                            // ビーチでの全員解放イベント
                            if (floor <= 30 && allLiberated && !gameState.summerBeachAllLiberatedTriggered) {
                                gameState.summerBeachAllLiberatedTriggered = true;
                                executeEvent(foundLiberatedPlay);
                                return;
                            }
                            // 温泉での全員解放イベント
                            if (floor > 30 && allLiberated && !gameState.summerOnsenAllLiberatedTriggered) {
                                gameState.summerOnsenAllLiberatedTriggered = true;
                                executeEvent(foundLiberatedPlay);
                                return;
                            }
                        }

                        // 25%の確率でイベント選択モーダルを表示
                        if (Math.random() < 0.25) {
                            triggerSelectableEvent();
                        } else if (gameState.gameMode !== 'endgame_plus' || Math.random() < 0.7) {
                            triggerRandomEvent();
                        } else {
                            // どのイベントも発生しなかった場合
                            nothingHappened();
                        }
                        updatePartyStatus();
                    }

                    async function triggerSummerLivePart2() {
                        log("ビーチでのライブを終えた一行は、打ち上げのために温泉へとやってきた！");
                        gameState.dungeonBackground = SUMMER_ONSEN_BG;
                        dungeonView.style.backgroundImage = gameState.dungeonBackground;
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        // 場面転換時に全員の脱衣・解放状態を解除
                        gameState.party.forEach(p => {
                            if (p.statusEffects.stripped) {
                                delete p.statusEffects.stripped;
                            }
                            if (p.isLiberatedStripped) {
                                delete p.isLiberatedStripped;
                            }
                        });

                        log("後半戦は、温泉ステージでスタート！");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        // 全員の立ち絵をバスタオルに変更
                        gameState.party.forEach(char => {
                            if (char.name === 'リリカ') char.bgClass = 'bg-char-ririka-b';
                            if (char.name === 'ユイ') char.bgClass = 'bg-char-yui-b';
                            if (char.name === 'ミコ') char.bgClass = 'bg-char-miko-b';
                            if (char.name === 'リリィ') char.bgClass = 'bg-char-lily-b';
                        });

                        // リリィの変身解除とスキル変更
                        const lily = gameState.party.find(p => p.name === 'リリィ');
                        if (lily) {
                            // 変身解除
                            if (lily.originalState) {
                                lily.role = lily.originalState.role;
                                lily.skills = lily.originalState.skills;
                                delete lily.originalState;
                                delete lily.isTransformed;
                            }
                            // 身長を初期値に戻す
                            lily.height = lily.initialHeight;

                            // スキルを温泉モード用に変更
                            lily.skills = [{
                                name: 'ジュエルショット',
                                cost: 10,
                                type: 'treasure_hunter_attack',
                                targetType: 'enemy',
                                description: '敵単体にダメージを与え、自身の攻撃力が上がるかMPが大きく回復する。'
                            }, {
                                name: 'ホットウェーブ',
                                cost: 15,
                                type: 'physical',
                                targetType: 'enemies',
                                power: 2.8,
                                description: '熱波で敵全体に物理ダメージを与える。'
                            }, {
                                name: 'リラックスタイム',
                                cost: 10,
                                type: 'self_wall',
                                targetType: 'self',
                                description: '自身に最大HPの100%の耐久値を持つ防壁を生成する。'
                            }, {
                                name: 'マジックオーラ',
                                cost: 20,
                                type: 'party_mp_regen_special',
                                targetType: 'party',
                                description: '味方全体を2ターンMP自動回復状態にする。ただし、自身は脱衣状態になる(既に脱衣状態なら鈍化)。'
                            }];
                        }

                        updatePartyStatus();
                        // 次のフロアへ進むボタンなどを再表示
                        dungeonCommands.classList.remove('hidden');
                    }

                    async function triggerKanpaiJuiceEvent() {
                        dungeonCommands.classList.add('hidden');
                        log("ビーチでのライブ前半戦、お疲れ様！");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("リリィ「みんな、お疲れ様！ここでちょっと休憩しよっか！」");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("リリカ「いいね！リリカ、特製のカンパイジュース持ってきたんだ！」");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("一行は特製ジュースで乾杯した！");
                        addItemToInventory('kanpai_juice', 1);
                        log("「カンパイジュース」を1個手に入れた！");
                        await new Promise(resolve => setTimeout(resolve, 1000)); // ログ表示のための待機
                        dungeonCommands.classList.remove('hidden');
                    }

                    function changeCostume(type) {
                        const costumeMap = {
                            'beach': {
                                'リリカ': 'bg-char-ririka-a',
                                'ユイ': 'bg-char-yui-a',
                                'ミコ': 'bg-char-miko-a', // 通常リリィの水着
                                'リリィ': 'bg-char-lily-a',
                                'サキュバス': 'bg-char-lily-succubus-a', // 通常リリィの水着
                                'フェアリー': 'bg-char-lily-fairy-a',
                                'アルラウネ': 'bg-char-lily-alraune-a' // 通常リリィの水着
                            },
                            'onsen': {
                                'リリカ': 'bg-char-ririka-b',
                                'ユイ': 'bg-char-yui-b',
                                'ミコ': 'bg-char-miko-b',
                                'リリィ': 'bg-char-lily-b', // 通常リリィの温泉
                                'サキュバス': 'bg-char-lily-succubus-b',
                                'フェアリー': 'bg-char-lily-fairy-b',
                                'アルラウネ': 'bg-char-lily-alraune-b'
                            }
                        };

                        const selectedCostumes = costumeMap[type];
                        if (!selectedCostumes) return;

                        gameState.party.forEach(char => {
                            if (selectedCostumes[char.name]) {
                                char.bgClass = selectedCostumes[char.name];
                                char.costume = type; // 衣装フラグを設定
                            }
                            // リリィの変身形態にも適用
                            if (char.name === 'リリィ' && char.transforms) {
                                if (selectedCostumes['サキュバス']) char.transforms.succubus.bgClass = selectedCostumes['サキュバス'];
                                if (selectedCostumes['フェアリー']) char.transforms.fairy.bgClass = selectedCostumes['フェアリー'];
                                if (selectedCostumes['アルラウネ']) char.transforms.alraune.bgClass = selectedCostumes['アルラウネ'];
                            }
                        });

                        log(`パーティは思い出の${type === 'beach' ? '水着' : '温泉スタイル'}に着替えた！`);
                        updatePartyStatus();
                        celestiaEventModal.classList.add('hidden');

                        // 通常のイベントフローを再開
                        if (gameState.gameMode === 'fixed_path') {
                            triggerSelectableEvent();
                        } else {
                            triggerRandomEvent();
                        }
                    }

                    function triggerSpecialCostumeEvent() {
                        celestiaEventTitle.textContent = "特別な絆";
                        celestiaEventText.textContent = "この4人でいると、あの夏の特別な冒険を思い出す…\n\n彼女たちの絆が共鳴し、思い出の姿に変わることができるようだ。";
                        celestiaEventButtons.innerHTML = `
                            <button id="costume-beach" class="action-button bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg">水着になる</button>
                            <button id="costume-onsen" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg">温泉スタイルになる</button>
                            <button id="costume-cancel" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg">何もしない</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('costume-beach').onclick = () => changeCostume('beach');
                        document.getElementById('costume-onsen').onclick = () => changeCostume('onsen');
                        document.getElementById('costume-cancel').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行は思い出を胸に、冒険を続ける。");
                            gameState.party.forEach(p => p.costume = null); // 衣装フラグをリセット
                            // 通常のイベントフローを再開
                            if (gameState.gameMode === 'fixed_path') {
                                triggerSelectableEvent();
                            } else {
                                triggerRandomEvent();
                            }
                        };
                    }

                    function triggerBellesPrivateCostumeEvent() {
                        celestiaEventTitle.textContent = "束の間の休息";
                        celestiaEventText.textContent = "フローラ「皆様、少し休憩にいたしませんこと？せっかくですもの、少し楽な格好に着替えたいですわ」\nノエル「賛成です。現在の服装は戦闘用であり、リラックスするには不向きです」\n\n二人はプライベートな服装に着替えたがっているようだ…";
                        celestiaEventButtons.innerHTML = `
                            <button id="belles-costume-change" class="action-button bg-rose-500 hover:bg-rose-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg">着替える</button>
                            <button id="belles-costume-cancel" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg">やめておく</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('belles-costume-change').onclick = () => {
                            const noel = gameState.party.find(p => p.name === 'ノエル');
                            const flora = gameState.party.find(p => p.name === 'フローラ');
                            if (noel) {
                                noel.bgClass = 'bg-char-noel-a';
                                noel.costume = 'private'; // 会話用のフラグ
                            }
                            if (flora) {
                                flora.bgClass = 'bg-char-flora-a';
                                flora.costume = 'private'; // 会話用のフラグ
                            }
                            log("二人は普段着に着替えた！少しだけ、戦士の顔つきが和らいだように見える。");
                            updatePartyStatus();
                            celestiaEventModal.classList.add('hidden');
                            triggerRandomEvent(); // 通常のイベントフローを再開
                        };

                        document.getElementById('belles-costume-cancel').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行は休憩を終え、気を引き締めて冒険を続ける。");
                            triggerRandomEvent(); // 通常のイベントフローを再開
                        };
                    }

                    async function triggerBellesFloor29Event() {
                        dungeonCommands.classList.add('hidden'); // コマンドを隠す
                        const noel = gameState.party.find(p => p.name === 'ノエル');
                        const flora = gameState.party.find(p => p.name === 'フローラ');

                        if (!noel || !flora || noel.currentHp <= 0 || flora.currentHp <= 0) {
                            log("決戦を前に、二人のうちどちらかが倒れている…。");
                            dungeonCommands.classList.remove('hidden');
                            return;
                        }

                        log("ノエル「フローラ、いよいよですね。この先に、元凶がいます」");
                        await new Promise(resolve => setTimeout(resolve, 2500));
                        log("フローラ「はい、ノエル様。わたくしたちの力を合わせれば、きっと…！」");
                        await new Promise(resolve => setTimeout(resolve, 2500));
                        log("ノエル「ええ。必ず、このダンジョンを制圧します」");
                        await new Promise(resolve => setTimeout(resolve, 2500));

                        // 身長比較による会話分岐
                        const heightDifference = noel.height - flora.height;

                        if (heightDifference > 50) { // ノエルが50cm以上大きい
                            log("ノエル「…それにしても、フローラ。あなたは本当に小さいですね。愛らしいです」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「まあ、ノエル様。からかわないでくださいまし。ノエル様が大きすぎるのですわ」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「ふふ、そうかもしれませんね。ですが、この体格差があるからこそ、私はあなたを完璧に守れます」");
                        } else if (heightDifference < -50) { // フローラが50cm以上大きい
                            log("フローラ「ふふっ。ノエル様、わたくしの方が見晴らしが良いですわね」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「…少し、悔しいです。ですが、フローラが頼もしいのは良いことです」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「まあ、戯れですわ。どんな姿であろうと、わたくしはノエル様にお仕えするメイドですもの」");
                        } else { // 身長差が50cm以内
                            log("ノエル「フローラ。いつの間にか、あなたと私の目線が同じくらいになりましたね」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「本当ですわね。なんだか、本当の姉妹のようですわ」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「姉妹…悪くない響きです。さあ、最後の戦いです。姉妹の力、見せてあげましょう」");
                        }

                        await new Promise(resolve => setTimeout(resolve, 2500));
                        log("二人の決意が共鳴し、HPとMPが全回復した！");
                        await animateStatChange(noel, 'hp', noel.maxHp, 'increase');
                        await animateStatChange(flora, 'hp', flora.maxHp, 'increase');
                        await animateStatChange(noel, 'mp', noel.maxMp, 'increase');
                        await animateStatChange(flora, 'mp', flora.maxMp, 'increase');

                        dungeonCommands.classList.remove('hidden'); // コマンドを再表示
                    }

                    async function triggerBellesFloor6Event(noel, flora) {
                        dungeonCommands.classList.add('hidden'); // コマンドを隠す

                        if (noel.height === 1) {
                            // ノエルが小さい場合の会話
                            log("フローラ「まあ、ノエル様！なんて可愛らしいお姿に…！」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「…フローラ、あまりジロジロ見ないでください。これは戦術的縮小です」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「ふふ、わかっておりますわ。ですが、思わずポケットに入れてしまいたくなるくらい愛らしいですもの」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「さあ、わたくしの手の中に。はぐれてしまったら大変ですわ」");
                        } else {
                            // フローラが小さい場合の会話
                            log("ノエル「フローラ、そのサイズは…危険です。私の手のひらに乗っていてください」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「きゃっ、ノエル様！だ、大丈夫ですわ！わたくし、これでも戦えますもの！」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「いえ、許可できません。万が一あなたに何かあれば、私は…」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「さあ、こちらへ。マスターの命令です」");
                        }

                        dungeonCommands.classList.remove('hidden'); // コマンドを再表示
                    }

                    async function triggerBellesReviveEvent(noel, flora) {
                        gameState.bellesReviveEventTriggered = true; // イベント発生フラグを立てる
                        dungeonCommands.classList.add('hidden');

                        const fallenChar = noel.currentHp <= 0 ? noel : flora;
                        const survivor = noel.currentHp > 0 ? noel : flora;

                        log(`${survivor.name}は倒れた${fallenChar.name}を必死に揺り動かす…`);
                        await new Promise(resolve => setTimeout(resolve, 2500));

                        fallenChar.currentHp = 1;
                        updatePartyStatus(); // HP1で復活したのをUIに反映

                        log(`${fallenChar.name}「…うぅん…」`);
                        await new Promise(resolve => setTimeout(resolve, 2500));

                        if (fallenChar.name === 'ノエル') {
                            // ノエルが倒れていた場合
                            log(`フローラ「ノエル様！よかった…！目が覚めたのですね…！」`);
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log(`フローラ「わたくし、ノエル様がこのまま目覚めないのかと…！もう、無茶はなさらないでくださいまし…！」`);
                        } else {
                            // フローラが倒れていた場合
                            log(`ノエル「フローラ！よかった…意識が戻ったのですね」`);
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log(`ノエル「あなたが倒れた時、私の全機能が停止するかと思いました…。もう、私の側を離れないでください」`);
                        }

                        dungeonCommands.classList.remove('hidden');
                    }
                    // 身長固定確認モーダルのボタンにイベントリスナーを追加
                    const heightLockConfirmButton = document.getElementById('height-lock-confirm-button');
                    const heightLockCancelButton = document.getElementById('height-lock-cancel-button');

                    heightLockConfirmButton.addEventListener('click', () => {
                        // 「はい」がクリックされたときの処理をここに記述
                        // 例: handleHeightLockConfirm(true);
                        document.getElementById('height-lock-confirm-modal').classList.add('hidden');
                    });

                    heightLockCancelButton.addEventListener('click', () => {
                        // 「いいえ」がクリックされたときの処理をここに記述
                        document.getElementById('height-lock-confirm-modal').classList.add('hidden');
                    });

                    async function triggerSummerLiveRirikaEvent() {
                        dungeonCommands.classList.add('hidden');
                        const ririka = gameState.party.find(p => p.name === 'リリカ');

                        if (!ririka || ririka.currentHp <= 0) {
                            log("決戦を前に、リリカは倒れてしまっていた…。");
                            dungeonCommands.classList.remove('hidden');
                            return;
                        }

                        let conversationKey;
                        if (ririka.isLiberatedStripped) {
                            conversationKey = 'summer_live_29_liberated';
                        } else if (ririka.statusEffects.stripped) {
                            conversationKey = 'summer_live_29_stripped';
                        } else {
                            conversationKey = 'summer_live_29_normal';
                        }

                        const conversation = conversations['リリカ'][conversationKey];
                        if (conversation) {
                            await playConversation(conversation);
                        }

                        await new Promise(resolve => setTimeout(resolve, 1000));
                        log("リリカの歌声がパーティの心に響き渡り、力がみなぎる！");
                        for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                            await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.5), 'increase');
                            await animateStatChange(p, 'mp', Math.ceil(p.maxMp * 0.5), 'increase');
                            p.buffs.atk_up = 3;
                        }
                        log("全員のHPとMPが回復し、攻撃力が上昇した！");

                        dungeonCommands.classList.remove('hidden');
                    }

                    function triggerSelectableEvent() {
                        // 4つのグループからランダムに1つを選ぶ（神々の試練はここでは発生しないようにする）
                        const groups = ['merit', 'random_special', 'demerit'];
                        const selectedGroup = groups[Math.floor(Math.random() * groups.length)];

                        // 選ばれたグループから、重み付け抽選で2つの異なるイベントを選ぶ
                        const event1 = getRandomEvent(selectedGroup);
                        let event2 = getRandomEvent(selectedGroup);

                        // 2つのイベントが同じ場合は、異なるイベントが選ばれるまで再抽選する
                        // ただし、グループ内のイベントが1つしかない場合は無限ループを避ける
                        const groupEvents = getEventPool(selectedGroup);
                        while (groupEvents.length > 1 && event1.name === event2.name) {
                            event2 = getRandomEvent(selectedGroup);
                        }

                        eventChoiceButtons.innerHTML = ''; // ボタンをクリア

                        [event1, event2].forEach(event => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                            button.textContent = event.name;
                            button.onclick = () => {
                                eventChoiceModal.classList.add('hidden');
                                executeEvent(event.func);
                            };
                            eventChoiceButtons.appendChild(button);
                        });

                        eventChoiceModal.classList.remove('hidden');
                    }

                    function getEventPool(group) {
                        const isAnyoneStripped = gameState.party.some(p => p.statusEffects.stripped);
                        const remainingEquipment = getRemainingEquipment();

                        // 「神々の試練」を別のプールに分離
                        const divineTrialEvent = { name: "神々の試練", func: foundDivineTrial, weight: 1 /* レアイベント */ };
                        const meritEvents = [{
                            name: "宝箱",
                            func: foundTreasure,
                            weight: 5
                        }, {
                            name: "泉",
                            func: foundFountain,
                            weight: 2
                        }, {
                            name: "服を発見",
                            func: foundClothes, // 解放状態のキャラがいない場合のみ発生,
                            weight: (isAnyoneStripped && gameState.gameMode !== 'indecent' && !gameState.party.some(p => p.isLiberatedStripped) && !gameState.wishingStarNoClothes) ? 5 : 0
                        }, {
                            name: "吟遊詩人",
                            func: foundBard,
                            weight: 1
                        }, {
                            name: "守護の壁",
                            func: foundProtectiveWall,
                            weight: 2
                        }, {
                            name: "魔力の結晶",
                            func: foundMagicCrystal,
                            weight: gameState.gameMode === 'endless' ? 1 : 0 // 無限モードでのみ出現
                        }, {
                            name: "祈りのほこら",
                            func: foundShrineOfPrayer,
                            weight: 3
                        }];

                        if (remainingEquipment.length > 0) {
                            meritEvents.push({
                                name: "装備発見",
                                func: foundEquipment,
                                weight: 3
                            });
                        }

                        const baseSpecialEvents = [{
                            name: "怪しげな祭壇",
                            func: foundAltar,
                            weight: gameState.gameMode === 'endgame_plus' ? 3 : 2 // 終焉モードでは少し出やすい
                        }, {
                            name: "装備発見",
                            func: foundEquipment,
                            weight: remainingEquipment.length > 0 ? 3 : 0
                        }, {
                            name: "怪しい装置",
                            func: foundSuspiciousDevice,
                            weight: gameState.party.length >= 2 ? (gameState.gameMode === 'endgame_plus' ? 1 : 2) : 0
                        }, {
                            name: "迷いの石像",
                            func: foundBewilderingStatue,
                            weight: 2
                        }, {
                            name: "人形の家",
                            func: foundDollhouse,
                            weight: 2
                        }, {
                            name: "ひび割れた巨岩",
                            func: foundCrackedRock,
                            weight: 2
                        }, {
                            name: "高所のネズミ穴",
                            func: foundHighMouseHole,
                            weight: gameState.party.some(p => p.height >= 200) && gameState.party.some(p => p.height <= 10) ? 2 : 0 // 大きいキャラと小さいキャラがいる場合のみ
                        }, {
                            name: "願い星",
                            func: foundWishingStar,
                            weight: gameState.gameMode === 'endgame_plus' ? 0 : 1 // 終焉モードでは発生しない
                        }, {
                            name: "調合",
                            func: foundAlchemyEvent,
                            weight: gameState.party.some(p => p.role === 'アルケミスト' || p.role === 'ドクター') ? 2 : 0
                        }, {
                            name: "ダブル『サイズ』アップ",
                            func: foundDoubleSizeUp,
                            weight: gameState.party.length > 0 ? 2 : 0 // パーティがいないと発生しない
                        }, {
                            name: "財宝の間",
                            func: foundTreasureRoom,
                            // トレジャーハンターがおらず、パーティが2人以上いる場合に低確率で発生
                            weight: !gameState.party.some(p => p.role === 'トレジャーハンター') && gameState.party.length >= 2 ? 1 : 0
                        }, {
                            name: "研ぎ澄まされた五感",
                            func: foundLiberatedSenses,
                            weight: gameState.party.some(p => p.isLiberatedStripped) ? 2 : 0 // 解放状態のキャラがいる場合のみ
                        }];
                        // サイズアップ・ギャンブルモードでは発生率を上げる
                        const isTenseiKikou = gameState.party.some(p => p.role === '転生者');
                        // 2択イベント用のスペシャルイベントプールを初期化
                        let specialEvents = [...baseSpecialEvents, divineTrialEvent];
                                                // 転生者モードの専用イベント
                        if (isTenseiKikou) {
                            specialEvents.push({
                                name: "順応",
                                func: foundAdaptation,
                                weight: 2 + Math.floor(gameState.killCount / 5) // 5キルごとに重みが1増加
                            }, {
                                name: "覚醒",
                                func: foundAwakening,
                                weight: 3
                            });
                        }
                        if (gameState.gameMode === 'size_up_gamble') {
                            baseSpecialEvents.find(e => e.name === "ダブル『サイズ』アップ").weight = 10;
                            // 他のイベントの発生率を下げるか、0にする
                            baseSpecialEvents.find(e => e.name === "財宝の間").weight = 0;
                            baseSpecialEvents.find(e => e.name === "研ぎ澄まされた五感").weight = 0;
                            baseSpecialEvents.find(e => e.name === "怪しげな祭壇").weight = 1;
                            baseSpecialEvents.find(e => e.name === "怪しい装置").weight = 1;
                            baseSpecialEvents.find(e => e.name === "迷いの石像").weight = 1;
                        }

                        const hasHolyCrystal = gameState.inventory.some(item => item.id === 'holy_crystal' && item.quantity > 0);
                        const hasEvilCrystal = gameState.inventory.some(item => item.id === 'evil_crystal' && item.quantity > 0);
                        if (gameState.gameMode === 'endless' && hasHolyCrystal && hasEvilCrystal) {
                            specialEvents.push({
                                name: "解放の祭壇",
                                func: triggerLiberationEvent,
                                weight: 5
                            });
                        }
                        // 「大穴になあれ」イベントの条件チェック

                        const hasFairySyrupForHole = gameState.inventory.some(item => item.id === 'fairy_syrup' && item.quantity >= 2);
                        const hasNoAlchemistOrDoctor = !gameState.party.some(p => p.role === 'アルケミスト' || p.role === 'ドクター');
                        if (!gameState.greatHoleEventTriggered && hasFairySyrupForHole && hasNoAlchemistOrDoctor) {
                            specialEvents.push({
                                name: "大穴になあれ",
                                func: foundGreatHole,
                                weight: 1 // 低確率で発生
                            });
                        }
                        // 「願いの少女」「祈りの少女」イベントの条件チェック
                        const canTriggerWishPray = gameState.greatHoleEventTriggered &&
                            gameState.floor >= gameState.greatHoleEventFloor + 30 &&
                            gameState.party.some(p => p.height === 1) &&
                            !gameState.wishPrayEventTriggered;
                        if (canTriggerWishPray) {
                            specialEvents.push({
                                name: "再会",
                                func: foundWishPrayGirl,
                                weight: 1 // 低確率で発生
                            });
                        }
                        // 「酒豪の怪物」イベントの条件チェック
                        const hasGigantesAle = gameState.inventory.some(item => item.id === 'gigantes_ale' && item.quantity >= 2);
                        const hasTallChar = gameState.party.some(p => p.currentHp > 0 && p.height >= 500);
                        if (!gameState.drunkenMonsterEventTriggered && hasGigantesAle && hasTallChar) {
                            specialEvents.push({
                                name: "酒豪の怪物",
                                func: foundDrunkenMonster,
                                weight: 1 // 低確率で発生
                            });
                        }
                        // 「木陰の迷宮」イベントの条件チェック
                        const isAllTinyAndLocked = gameState.party.length > 0 && gameState.party.every(p => p.currentHp > 0 && p.height === 1 && p.heightLocked);
                        if (!gameState.mazeOfShadeEventTriggered && isAllTinyAndLocked) {
                            specialEvents.push({
                                name: "木陰の迷宮",
                                func: foundMazeOfShade,
                                weight: 1 // 低確率で発生
                            });
                        }

                        if (gameState.gameMode === 'secret_night') {
                            meritEvents.find(e => e.name === '服を発見').weight = 0;
                        }



                        // 2択イベント用のスペシャルイベントプール

                        const demeritEvents = [{
                            name: "身長が縮む罠",
                            func: triggerShrinkTrap,
                            weight: gameState.gameMode === 'endgame_plus' ? 4 : 2 // 終焉モードでは出やすい
                        }, {
                            name: "身長が伸びる罠",
                            func: triggerGrowTrap,
                            weight: gameState.gameMode === 'endgame_plus' ? 2 : 1
                        }, {
                            name: "ダメージの罠",
                            func: triggerDamageTrap,
                            weight: 3
                        }, {
                            name: "羞恥の張り付け",
                            func: foundShamePillory,
                            weight: isAnyoneStripped && gameState.gameMode !== 'summer_live' ? (gameState.gameMode === 'endgame_plus' ? 4 : 3) : 0
                        }, {
                            name: "なにもない",
                            func: nothingHappened,
                            weight: 5
                        }];

                        const summerEvents = {
                            name: "解放の祭壇",
                            func: triggerLiberationEvent,
                            // 無限モードで両方の結晶を持っている場合にのみ候補になる
                            weight: (gameState.gameMode === 'endless' && hasHolyCrystal && hasEvilCrystal) ? 5 : 0
                        };

                        // 新しいイベントの定義（サマーライブ専用）
                        const liberatedMonsterAttackEvent = {
                            name: "魔物の奇襲",
                            func: foundLiberatedMonsterAttack,
                            weight: 0
                        };
                        const liberatedTeaseEvent = {
                            name: "仲間との会話",
                            func: foundLiberatedTease,
                            weight: 0
                        };
                        const liberatedPlayEvent = {
                            name: "解放のじゃれあい",
                            func: foundLiberatedPlay,
                            weight: 0
                        };
                        // サマータイム・スペシャルライブ！専用イベントをプールに追加
                        if (gameState.gameMode === 'summer_live') {
                            if (gameState.floor <= 30) {
                                // ビーチイベント
                                specialEvents.push({
                                    name: "スイカ割り",
                                    func: foundWatermelonSmash,
                                    weight: 5
                                }, {
                                    name: "砂の城作り",
                                    func: foundSandcastle,
                                    weight: 5
                                }, {
                                    name: "ビーチの熱気",
                                    func: foundBeachLiberation,
                                    weight: 4
                                });
                            } else {
                                // 温泉イベント
                                specialEvents.push({
                                    name: "温泉卓球",
                                    func: foundOnsenPingPong,
                                    weight: 5
                                }, {
                                    name: "温泉でリラックス",
                                    func: foundHotSpringsSoak,
                                    weight: 5
                                }, {
                                    name: "タオルトラブル！",
                                    func: foundOnsenTowelTrouble,
                                    weight: 5
                                }, {
                                    name: "温泉の誘惑",
                                    func: foundOnsenLiberation,
                                    weight: 5
                                });
                            }
                            // イベントをプールに追加
                            specialEvents.push(liberatedMonsterAttackEvent, liberatedTeaseEvent, liberatedPlayEvent);

                            // 解放状態のキャラがいる場合、特別イベントの発生確率を設定
                            const isLiberated = gameState.party.some(p => p.isLiberatedStripped);
                            specialEvents.find(e => e.name === "魔物の奇襲").weight = isLiberated ? 5 : 0;
                            specialEvents.find(e => e.name === "仲間との会話").weight = isLiberated ? 5 : 0;
                            // 「解放のじゃれあい」は解放状態のキャラが2人以上いる場合に発生するよう重みを設定
                            specialEvents.find(e => e.name === "解放のじゃれあい").weight = gameState.party.filter(p => p.isLiberatedStripped && p.currentHp > 0).length >= 2 ? 5 : 0;
                        }

                        switch (group) {
                            case 'merit':
                                return meritEvents.filter(e => e.weight > 0);
                            case 'random_special': // ランダムイベント用のスペシャルプール
                                return baseSpecialEvents.filter(e => e.weight > 0);
                            case 'special':
                                return specialEvents.filter(e => e.weight > 0);
                            case 'demerit':
                                return demeritEvents.filter(e => e.weight > 0);
                            default: // 全てのイベントを結合
                                // ランダムイベントでは神々の試練は発生しない
                                return [...meritEvents, ...baseSpecialEvents, ...demeritEvents].filter(e => e.weight > 0);
                        }
                    }

                    function getRandomEvent(group = null) {
                        const filteredEvents = getEventPool(group);
                        const totalWeight = filteredEvents.reduce((sum, event) => sum + event.weight, 0);
                        let random = Math.random() * totalWeight;
                        for (const event of filteredEvents) {
                            random -= event.weight;
                            if (random <= 0) return event;
                        }
                        return filteredEvents[filteredEvents.length - 1];
                    }

                    function foundEquipment() {
                        // パーティ内に未発見の装備を持つキャラがいるかチェック
                        const partyRolesWithRemainingEquipment = gameState.party
                            .filter(p => p.currentHp > 0)
                            .map(p => p.role)
                            .filter((role, index, self) => self.indexOf(role) === index)
                            .filter(role => getRemainingEquipment().some(id => equipmentBlueprints[id] && equipmentBlueprints[id].targetRole === role));

                        if (partyRolesWithRemainingEquipment.length === 0) {
                            // 装備を見つけられるキャラがいない場合は別のイベントを再抽選
                            const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                            if (aliveParty.length > 0) {
                                const targetCharacter = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                                const statsToUpgrade = ['atk', 'def', 'agi'];
                                const statToUpgrade = statsToUpgrade[Math.floor(Math.random() * statsToUpgrade.length)];
                                const statJp = {
                                    'atk': '攻撃力',
                                    'def': '防御力',
                                    'agi': '素早さ'
                                };

                                targetCharacter[statToUpgrade] += 1;

                                log(`宝箱は空だったが、${targetCharacter.name}は鍛錬の末、${statJp[statToUpgrade]}が1上がった！`);
                                flashCard(targetCharacter, 'yellow');
                                updatePartyStatus();

                            } else {
                                nothingHappened();
                            }
                            dungeonCommands.classList.remove('hidden');
                            return; // ここで処理を終了
                        }

                        // 装備を見つけられる可能性のあるロールからランダムに一つ選ぶ
                        const targetRole = partyRolesWithRemainingEquipment[Math.floor(Math.random() * partyRolesWithRemainingEquipment.length)];
                        const availableEquipmentForRole = getRemainingEquipment().filter(id => equipmentBlueprints[id].targetRole === targetRole);
                        const foundId = availableEquipmentForRole[Math.floor(Math.random() * availableEquipmentForRole.length)];
                        const equipment = equipmentBlueprints[foundId];
                        const targetCharacter = gameState.party.find(p => p.role === targetRole && p.currentHp > 0);

                        if (targetCharacter) {
                            log(`古い宝箱から ${equipment.name} を見つけた！ ${equipment.description}`);
                            targetCharacter[equipment.stat] += equipment.value;
                            gameState.foundEquipment.push(foundId);
                            flashCard(targetCharacter, 'yellow');
                            updatePartyStatus();
                        } else {
                            // 対象キャラが見つからなかった場合（戦闘不能など）
                            nothingHappened();
                        }
                    }

                    async function executeEvent(eventFunc) {
                        dungeonCommands.classList.add('hidden');
                        try {
                            await eventFunc();
                        } finally {
                            // モーダルが表示されている場合や戦闘中の場合を除き、コマンドを再表示
                            if (!modal.classList.contains('hidden') || !itemModal.classList.contains('hidden') || !levelUpModal.classList.contains('hidden') || !challengeModal.classList.contains('hidden') || !eventChoiceModal.classList.contains('hidden') || gameState.inBattle) {
                                // 何もしない
                            } else {
                                dungeonCommands.classList.remove('hidden');
                            }
                        }
                    }

                    function triggerRandomEvent() {
                        const chosenEvent = getRandomEvent();
                        executeEvent(chosenEvent.func);
                    }

                    async function foundGreatHole() {
                        gameState.greatHoleEventTriggered = true; // イベントは一度しか発生しない
                        gameState.greatHoleEventFloor = gameState.floor; // 発生階層を記録
                        log("道の脇で、二人の冒険者の少女が泣いている…。");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        celestiaEventTitle.textContent = "大穴になあれ";
                        celestiaEventText.textContent = "少女「うぅ…大事なペンダントを、この小さな穴に落としちゃったの…」\n少女「小さくならないと取れないよぉ…」\n\n彼女たちにフェアリーシロップを2個渡しますか？";
                        celestiaEventButtons.innerHTML = `
                            <button id="greathole-give" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">渡す</button>
                            <button id="greathole-leave" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">通り過ぎる</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('greathole-give').onclick = async() => {
                            celestiaEventModal.classList.add('hidden');
                            // フェアリーシロップを2個消費
                            const syrup = gameState.inventory.find(item => item.id === 'fairy_syrup');
                            syrup.quantity -= 2;

                            log("フェアリーシロップを渡すと、少女たちは嬉しそうにそれを飲んだ！");
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log("二人の体はみるみる小さくなり、穴の中に飛び込んでいった。");
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log("しばらくして、ペンダントを抱えた二人が穴から出てきた。");
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log("少女「ありがとう！お姉さんたちのおかげだよ！お礼に、どっちか好きな方をあげる！」");

                            eventChoiceButtons.innerHTML = `
                                <button id="choice-elixir" class="action-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">エリクサー</button>
                                <button id="choice-gigant" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">ギガントシロップ</button>
                            `;
                            eventChoiceModal.classList.remove('hidden');

                            document.getElementById('choice-elixir').onclick = () => {
                                eventChoiceModal.classList.add('hidden');
                                addItemToInventory('elixir', 1);
                                log("「エリクサー」を手に入れた！");
                                dungeonCommands.classList.remove('hidden');
                            };
                            document.getElementById('choice-gigant').onclick = () => {
                                eventChoiceModal.classList.add('hidden');
                                addItemToInventory('gigant_syrup', 1);
                                log("「ギガントシロップ」を手に入れた！");
                                dungeonCommands.classList.remove('hidden');
                            };
                        };

                        document.getElementById('greathole-leave').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行は少女たちを後にして、先へ進んだ。");
                            dungeonCommands.classList.remove('hidden');
                        };
                    }

                    async function foundWishPrayGirl() {
                        gameState.wishPrayEventTriggered = true; // イベントは一度しか発生しない
                        const isWishGirl = Math.random() < 0.5;
                        const girlName = isWishGirl ? "願いの少女" : "祈りの少女";
                        const blessingId = isWishGirl ? "wish_girl" : "pray_girl";
                        const blessing = blessings[blessingId];

                        log("どこかで見覚えのある、小さな少女が駆け寄ってきた。");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        celestiaEventTitle.textContent = "再会、そして…";
                        celestiaEventText.textContent = `少女「あ、あの時のお姉さんたち！また会えて嬉しいな！」\n少女「私も、お姉さんたちみたいに強くなりたいの！お願い、一緒に冒険させて！」\n\n身長1cmの少女が、同行を申し出てきた。`;
                        celestiaEventButtons.innerHTML = `
                            <button id="wishpray-accept" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">受け入れる</button>
                            <button id="wishpray-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">断る</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('wishpray-accept').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log(`少女は嬉しそうに跳ねると、一人の仲間の方へ駆け寄った。`);

                            showOneMemberSelectionModal(char => {
                                log(`少女は${char.name}の肩にちょこんと乗り、その身に不思議な力を与えた！`);
                                blessing.effect(char);
                                log(`${char.name}は祝福「${blessing.name}」を授かった！`);
                                flashCard(char, 'green');
                                updatePartyStatus();
                                dungeonCommands.classList.remove('hidden');
                            }, `少女が力を貸したい仲間を選んでください。`);
                        };

                        document.getElementById('wishpray-decline').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("少女は少し寂しそうにしたが、笑顔で手を振って見送ってくれた。");
                            dungeonCommands.classList.remove('hidden');
                        };
                    }

                    async function foundDrunkenMonster() {
                        gameState.drunkenMonsterEventTriggered = true;
                        log("ダンジョンの奥から、巨大な魔物がふらふらと歩いてきた…。");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        celestiaEventTitle.textContent = "酒豪の怪物";
                        celestiaEventText.textContent = "巨大な魔物「おぉ…お前さんたち、ギガンテスエールを…持っとらんか…？」\n\nギガンテスエールを2個、譲りますか？";
                        celestiaEventButtons.innerHTML = `
                            <button id="drunken-monster-give" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">譲る</button>
                            <button id="drunken-monster-refuse" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">断る</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('drunken-monster-give').onclick = async() => {
                            celestiaEventModal.classList.add('hidden');
                            const aleItem = gameState.inventory.find(item => item.id === 'gigantes_ale');
                            aleItem.quantity -= 2;

                            const tallestChar = gameState.party.filter(p => p.currentHp > 0).sort((a, b) => b.height - a.height)[0];
                            if (!tallestChar) {
                                log("しかし、パーティに誰もいなかったため、魔物は寂しそうに去っていった。");
                                dungeonCommands.classList.remove('hidden');
                                return;
                            }

                            log(`魔物は嬉しそうにギガンテスエールを受け取ると、${tallestChar.name}に差し出した！`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log(`二人は豪快にギガンテスエールで乾杯し、親睦を深めた！`);
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            if (!tallestChar.heightLocked) {
                                await animateStatChange(tallestChar, 'height', 100, 'increase');
                                log(`${tallestChar.name}の身長が100cm伸びた！`);
                            } else {
                                log(`${tallestChar.name}の身長は固定されており、変化しなかった！`);
                            }
                            await new Promise(resolve => setTimeout(resolve, 1000));

                            const blessing = blessings.giant_grounding;
                            blessing.effect(tallestChar);
                            log(`機嫌を良くした魔物から、${tallestChar.name}は祝福「${blessing.name}」を授かった！`);
                            flashCard(tallestChar, 'green');
                            updatePartyStatus();
                            dungeonCommands.classList.remove('hidden');
                        };

                        document.getElementById('drunken-monster-refuse').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行はギガンテスエールを譲らず、魔物は不機嫌そうに去っていった…。");
                            dungeonCommands.classList.remove('hidden');
                        };
                    }

                    async function foundMazeOfShade() {
                        gameState.mazeOfShadeEventTriggered = true;
                        log("ダンジョンに突風が吹き荒れ、小さな一行は木の葉のように舞い上がった！");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("気づくと、一行は見知らぬ木陰に着地していた。目の前には、小さな獣道が続いている…。");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        celestiaEventTitle.textContent = "木陰の迷宮";
                        celestiaEventText.textContent = "この先に何があるかはわからない…。\n小道に入りますか？";
                        celestiaEventButtons.innerHTML = `
                            <button id="maze-enter" class="action-button bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg">入る</button>
                            <button id="maze-leave" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">やめておく</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('maze-enter').onclick = async() => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行は覚悟を決め、小さな迷宮へと足を踏み入れた。");
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            let failedAttempts = 0;
                            for (let i = 0; i < 3; i++) {
                                log(`探索中… (${i + 1}/3)`);
                                await new Promise(resolve => setTimeout(resolve, 1500));
                                if (Math.random() < 0.5) { // 50%でアイテム獲得
                                    const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                    const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                                    addItemToInventory(foundItemId);
                                    log(`キラリと光るものを見つけた！「${itemBlueprints[foundItemId].name}」を手に入れた！`);
                                    flashCard(getRandomPartyMember(), 'yellow');
                                } else {
                                    log("物音に気づき身構えたが、何も見つからなかった…。");
                                    failedAttempts++;
                                }
                                await new Promise(resolve => setTimeout(resolve, 1500));
                            }

                            if (failedAttempts > 0) {
                                log(`探索を終えようとしたその時、背後から${failedAttempts}体の小さな気配が迫る！`);
                                await new Promise(resolve => setTimeout(resolve, 2000));
                                startBattle(false, false, 'micro', failedAttempts); // 特殊な敵との戦闘
                            } else {
                                log("幸運にも、危険なことにはならずに迷宮を抜け出すことができた。");
                                dungeonCommands.classList.remove('hidden');
                            }
                        };

                        document.getElementById('maze-leave').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行は危険を察知し、小道には入らずに元の道へ戻った。");
                            dungeonCommands.classList.remove('hidden');
                        };
                    }

                    function getLineForHole(char, situation, otherChar) {
                        const charConvos = conversations[char.name];
                        if (charConvos && charConvos[situation] && charConvos[situation].length > 0) {
                            const lines = charConvos[situation];
                            let line = lines[Math.floor(Math.random() * lines.length)];
                            return line.replace(/{name}/g, otherChar.name);
                        }
                        // デフォルトのセリフ
                        return situation === 'high_mouse_hole_giant' ? "肩を貸すよ。" : "行ってくる！";
                    }


                    async function foundLiberatedMonsterAttack() {
                        const liberatedMembers = gameState.party.filter(p => p.currentHp > 0 && p.isLiberatedStripped);
                        if (liberatedMembers.length === 0) {
                            nothingHappened();
                            return;
                        }

                        const victim = liberatedMembers[Math.floor(Math.random() * liberatedMembers.length)];
                        log(`その無防備な姿に惹かれたのか、物陰から魔物が${victim.name}に襲いかかった！`);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        const debuffType = ['atk_down', 'def_down', 'slow'][Math.floor(Math.random() * 3)];
                        let debuffMessage = '';
                        if (debuffType === 'atk_down') {
                            victim.buffs.atk_down = 3;
                            debuffMessage = '攻撃力が下がってしまった！';
                        } else if (debuffType === 'def_down') {
                            victim.buffs.def_down = 3;
                            debuffMessage = '防御力が下がってしまった！';
                        } else {
                            victim.statusEffects.slow = {
                                turns: 3
                            };
                            debuffMessage = '動きが鈍くなってしまった！';
                        }

                        flashCard(victim, 'red');
                        log(`${victim.name}はなんとか魔物を追い払ったが、${debuffMessage}`);
                        updatePartyStatus();
                    }

                    async function foundLiberatedTease() {
                        const liberatedMembers = gameState.party.filter(p => p.currentHp > 0 && p.isLiberatedStripped);
                        const normalMembers = gameState.party.filter(p => p.currentHp > 0 && !p.isLiberatedStripped);

                        if (liberatedMembers.length === 0 || normalMembers.length === 0) {
                            nothingHappened();
                            return;
                        }

                        const victim = liberatedMembers[Math.floor(Math.random() * liberatedMembers.length)];
                        const teaser = normalMembers[Math.floor(Math.random() * normalMembers.length)];

                        const teaseLines = {
                            'リリカ': [`あら、${victim.name}ちゃん、大胆だねー！ファンサービス？`, `その格好、ステージ衣装より目立ってるんじゃない？`],
                            'ユイ': [`きゃっ！${victim.name}さん、そのお姿は…！か、風邪をひいてしまいます！`, `だ、だめです！ちゃんと隠さないと…！`],
                            'ミコ': [`わー、${victim.name}ちゃん、すごい格好だね！モコがびっくりしてるよ！`, `${victim.name}ちゃん、寒くないの？ミコのマント貸してあげようか？`],
                            'リリィ': [`へぇ、${victim.name}ちゃん、やるじゃん。冒険にそのくらいの気合は必要だよね！`, `いいよー、その調子！隠すより、見せつけちゃいなよ！`]
                        };

                        const victimLines = {
                            'リリカ': [`ち、違うの！これはアクシデントで…！`, `もー、${teaser.name}ちゃんのいじわる！`],
                            'ユイ': [`ふぇぇ…！${teaser.name}さん、そんなに見ないでくださいぃ…！`, `うぅ…恥ずかしいですぅ…`],
                            'ミコ': [`わわっ、これはその…！事故なの！`, `モコちゃんまでそんな目で見ないでー！`],
                            'リリィ': [`こ、これは…！戦術的な判断だから！`, `べ、別に好きでやってるわけじゃないんだからね！`]
                        };

                        log(`${teaser.name}「${teaseLines[teaser.name][Math.floor(Math.random() * teaseLines[teaser.name].length)]}」`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log(`${victim.name}「${victimLines[victim.name][Math.floor(Math.random() * victimLines[victim.name].length)]}」`);
                    }

                    async function foundLiberatedPlay() {
                        const liberatedMembers = gameState.party.filter(p => p.currentHp > 0 && p.isLiberatedStripped);
                        if (liberatedMembers.length < 2) {
                            nothingHappened();
                            return;
                        }

                        // 2人を選ぶ
                        const char1 = liberatedMembers[Math.floor(Math.random() * liberatedMembers.length)];
                        const otherLiberated = liberatedMembers.filter(p => p !== char1);
                        const char2 = otherLiberated[Math.floor(Math.random() * otherLiberated.length)];

                        // 身長による分岐
                        if (char1.height === 1 && char2.height === 1) {
                            const convos = conversations['summer_all_tiny_play'];
                            const possibleConvos = convos.filter(c => c.chars.includes(char1.name) && c.chars.includes(char2.name));
                            if (possibleConvos.length > 0) {
                                const convo = possibleConvos[Math.floor(Math.random() * possibleConvos.length)];
                                log(`${char1.name}と${char2.name}は、小さな体でじゃれ合っている…`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                                log(`${convo.chars[0]}「${convo.lines[0]}」`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                                log(`${convo.chars[1]}「${convo.lines[1]}」`);
                                return;
                            }
                        } else if (char1.height > 140 && char2.height > 140) {
                            const convos = conversations['summer_all_grown_play'];
                            const possibleConvos = convos.filter(c => c.chars.includes(char1.name) && c.chars.includes(char2.name));
                            if (possibleConvos.length > 0) {
                                const convo = possibleConvos[Math.floor(Math.random() * possibleConvos.length)];
                                log(`${char1.name}と${char2.name}は、大きな体でじゃれ合っている…`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                                log(`${convo.chars[0]}「${convo.lines[0]}」`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                                log(`${convo.chars[1]}「${convo.lines[1]}」`);
                                return;
                            }
                        }


                        // 通常のじゃれあい
                        const playLines = {
                            'リリカ': [
                                `ねえ、${char2.name}ちゃん…。なんだか、体が火照っちゃって…。ちょっとだけ、触ってもいい…？`,
                                `ふふっ、${char2.name}ちゃんのここ、すっごく敏感なんだね。かわいい…。もっと、いじめてあげたくなっちゃうな…。`
                            ],
                            'ユイ': [
                                `はぅぅ…${char2.name}さん…。なんだか、変な気分ですぅ…。こ、この気持ち、確かめたくて…！`,
                                `ひゃっ…！そ、そこは…！だめぇ…！でも、${char2.name}さんがしてくれるなら…もっと…。`
                            ],
                            'ミコ': [
                                `わわっ、${char2.name}ちゃん、あったかいね…。モコみたいに、すりすりしたくなっちゃう…。`,
                                `んんっ…！${char2.name}ちゃん、そこはミコの弱点なんだよぉ…。でも、なんだか気持ちいいかも…。`
                            ],
                            'リリィ': [
                                `へぇ、${char2.name}ちゃん、いい体してんじゃん。ちょっと、冒険の成果、確かめさせてよ。`,
                                `くっ…！やるじゃない、${char2.name}ちゃん…！でも、私だって負けないんだから…！ほら、こっちも…！`
                            ]
                        };

                        const playLinesAll = {
                            'リリカ': `ふふっ、みんな、とっても大胆…。最高のステージになりそうね…！`,
                            'ユイ': `はぅぅ…！皆さん、こんな…こんなことになっちゃって…！でも、なんだかドキドキします…！`,
                            'ミコ': `わーい！みんなおんなじだね！なんだか、秘密のパーティみたいで楽しい！`,
                            'リリィ': `いいね、いいね！全員でさらけ出してこそ、最高のライブでしょ！さあ、もっとアツくなろうよ！`
                        };

                        // 4人全員が解放状態の場合、30%の確率で4人イベントに分岐
                        if (liberatedMembers.length === 4 && Math.random() < 0.3) {
                            log("解放された4人の衝動が共鳴し、互いを求め合う…！");
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const situation = gameState.floor <= 30 ? 'beach' : 'onsen';
                            const convos = summerAllLiberatedPlayConversations[situation];
                            const selectedConvo = convos[Math.floor(Math.random() * convos.length)];

                            for (let i = 0; i < selectedConvo.chars.length; i++) {
                                const charName = selectedConvo.chars[i];
                                const line = selectedConvo.lines[i];
                                log(`${charName}「${line}」`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                            }
                            return;
                        }
                        // 4人用のイベントが発生しなかった場合は、通常の2人用イベントに進む




                        log(`${char1.name}は解放された衝動のまま、${char2.name}の体にそっと触れた…。`);
                        await new Promise(resolve => setTimeout(resolve, 2500));
                        log(`${char1.name}「${playLines[char1.name][0]}」`);
                        await new Promise(resolve => setTimeout(resolve, 2500));
                        log(`${char2.name}「${playLines[char2.name][1]}」`);
                    }


                    function foundTreasure() {
                        // 5%の確率でレアアイテムが出現
                        if (Math.random() < 0.05) {
                            const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                            const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                            addItemToInventory(foundItemId);
                            log(`なんと、宝箱からとても珍しい「${itemBlueprints[foundItemId].name}」を見つけた！`);
                            flashCard(gameState.party[0], 'yellow');
                        } else {
                            // 通常のアイテム
                            const itemCount = Math.floor(Math.random() * 3) + 1; // 1〜3個のアイテム
                            const foundItems = [];
                            // レア・特殊アイテムを除外
                            const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].battleOnly && !itemBlueprints[id].rare && !itemBlueprints[id].special);

                            for (let i = 0; i < itemCount; i++) {
                                const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                                addItemToInventory(foundItemId);
                                foundItems.push(itemBlueprints[foundItemId].name);
                            }
                            log(`宝箱を見つけた！ ${foundItems.join('、')} を手に入れた！`);
                            flashCard(gameState.party[0], 'yellow');
                        }
                    }

                    async function foundFountain() {
                        const effects = [{
                            text: "HPが少し回復した。",
                            stat: 'hp',
                            ratio: 0.3
                        }, {
                            text: "MPが少し回復した。",
                            stat: 'mp',
                            ratio: 0.3
                        }, {
                            text: "HPとMPが全回復した！",
                            stat: 'both',
                            ratio: 1.0
                        }, ];
                        const effect = effects[Math.floor(Math.random() * effects.length)];
                        log(`一行は不思議な泉を見つけた。${effect.text}`);
                        for (const char of gameState.party) {
                            if (effect.stat === 'hp' || effect.stat === 'both') await animateStatChange(char, 'hp', Math.floor(char.maxHp * effect.ratio), 'increase');
                            if (effect.stat === 'mp' || effect.stat === 'both') await animateStatChange(char, 'mp', Math.floor(char.maxMp * effect.ratio), 'increase');
                            flashCard(char, 'green');
                        }
                    }

                    async function triggerShrinkTrap() {
                        const target = getRandomPartyMember();
                        if (target.heightLocked) {
                            log(`${target.name}は不思議な力で守られており、罠の効果を受けなかった！`);
                            return;
                        }
                        const shrinkAmount = Math.floor(Math.random() * 11) + 10; // 10〜20cm縮む
                        const finalShrink = gameState.gameMode === 'endgame_plus' ? shrinkAmount * 2 : shrinkAmount;
                        await animateStatChange(target, 'height', -finalShrink, 'decrease');
                        flashCard(target, 'yellow'); // Flash the card itself
                        log(`奇妙な罠が作動した！ ${target.name}の体が縮んでしまった！(身長-${finalShrink}cm)`);
                    }

                    async function triggerGrowTrap() {
                        const target = getRandomPartyMember();
                        if (target.heightLocked) {
                            log(`${target.name}は不思議な力で守られており、光の影響を受けなかった！`);
                            return;
                        }
                        const growAmount = Math.floor(Math.random() * 11) + 10; // 10〜20cm伸びる
                        const finalGrow = gameState.gameMode === 'endgame_plus' ? growAmount * 2 : growAmount;
                        await animateStatChange(target, 'height', finalGrow, 'increase');
                        flashCard(target, 'yellow');
                        log(`不思議な光が降り注いだ！ ${target.name}の体が巨大化してしまった！(身長+${finalGrow}cm)`);
                    }

                    async function triggerDamageTrap() {
                        const target = getRandomPartyMember();
                        let damage = Math.ceil(target.maxHp * 0.1); // 最大HPの10%ダメージ
                        if (gameState.gameMode === 'endgame_plus') damage *= 2; // 終焉モードではダメージ2倍
                        let messages;

                        if (target.height <= 10) {
                            messages = [
                                `${target.name}は小さすぎて、仲間に気づかれず踏まれてしまった！`,
                                `${target.name}は小さな水たまりで溺れかけてしまった！`,
                                `${target.name}は強風に煽られて壁にぶつかってしまった！`,
                            ];
                        } else {
                            messages = [
                                `${target.name}は足をもつらせて転んでしまった！`,
                                `${target.name}は隠された罠を踏んでしまった！`,
                            ];
                        }
                        log(messages[Math.floor(Math.random() * messages.length)]);
                        await dealDamage(target, damage);
                    }

                    function foundAltar() {
                        log("一行は怪しげな祭壇を見つけた…");
                        challengeModal.classList.remove('hidden');
                        const challengeAcceptButton = document.getElementById('challenge-accept-button');
                        const challengeDeclineButton = document.getElementById('challenge-decline-button');


                        challengeAcceptButton.onclick = () => {
                            challengeModal.classList.add('hidden');
                            if (Math.random() < 0.3) { // 30%で成功
                                const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                                addItemToInventory(foundItemId);
                                log(`祭壇が輝き、なんと「${itemBlueprints[foundItemId].name}」を手に入れた！`);
                                flashCard(getRandomPartyMember(), 'green');
                                dungeonCommands.classList.remove('hidden'); // コマンドを再表示
                            } else { // 70%で失敗
                                const availableItems = gameState.inventory.filter(item => item.quantity > 0);
                                if (availableItems.length > 0) {
                                    const lostItem = availableItems[Math.floor(Math.random() * availableItems.length)];
                                    lostItem.quantity--;
                                    log(`祭壇は禍々しい光を放ち、「${itemBlueprints[lostItem.id].name}」を一つ失ってしまった…`);
                                    flashCard(getRandomPartyMember(), 'red');
                                } else {
                                    log("祭壇に捧げるものがなく、何も起こらなかった。");
                                }
                                dungeonCommands.classList.remove('hidden'); // コマンドを再表示
                            }
                        };
                        challengeDeclineButton.onclick = () => {
                            challengeModal.classList.add('hidden');
                            log("一行は怪しげな祭壇を後にして、先へ進んだ。");
                            dungeonCommands.classList.remove('hidden'); // コマンドを再表示
                        };
                    }

                    function foundBard() {
                        log(`陽気な吟遊詩人に出会った。彼の歌声に、パーティの士気が上がる！`);
                        gameState.party.forEach(char => {
                            if (char.currentHp > 0) {
                                char.buffs.atk_up = 3; // 3ターン攻撃力アップ
                                flashCard(char, 'yellow');
                            }
                        });
                        log(`全員の攻撃力が一時的に上昇した！`);
                    }

                    async function foundClothes() {
                        const strippedMembers = gameState.party.filter(p => p.statusEffects.stripped);
                        if (strippedMembers.length > 0) {
                            // 衣装状態に応じてメッセージを変更
                            const firstStrippedMember = strippedMembers[0];
                            let foundMessage = "一行はきれいな服が落ちているのを見つけた！";
                            let dressedMessage = "は服を着て、元の状態に戻った！";

                            if (firstStrippedMember.costume === 'beach') {
                                foundMessage = "一行は替えの水着が落ちているのを見つけた！";
                                dressedMessage = "は新しい水着に着替えて、元の状態に戻った！";
                            } else if (firstStrippedMember.costume === 'onsen') {
                                foundMessage = "一行は替えのタオルが落ちているのを見つけた！";
                                dressedMessage = "は新しいタオルを巻いて、元の状態に戻った！";
                            }

                            log(foundMessage);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            strippedMembers.forEach(member => {
                                delete member.statusEffects.stripped;
                                // 解放状態も同時に解除
                                if (member.isLiberatedStripped) {
                                    delete member.isLiberatedStripped;
                                }
                                log(`${member.name}${dressedMessage}`);
                                flashCard(member, 'yellow');
                            });
                        }
                    }

                    async function foundDollhouse() {
                        const tinyMembers = gameState.party.filter(p => p.currentHp > 0 && p.height <= 10);

                        if (tinyMembers.length === 0) {
                            log("目の前に精巧な作りの小さな家があるが、小さすぎて誰も入れなさそうだ。");
                            return;
                        }

                        const explorer = tinyMembers[Math.floor(Math.random() * tinyMembers.length)];
                        // 探索者の身長に応じてセリフセットを切り替える
                        const conversationKey = explorer.height === 1 ? 'dollhouse_explore_giant' : 'dollhouse_explore';
                        let conversationLine = "探検してみよう！"; // デフォルトのセリフ
                        const explorerConvos = conversations[explorer.name];
                        if (explorerConvos && explorerConvos[conversationKey] && explorerConvos[conversationKey].length > 0) {
                            const lines = explorerConvos[conversationKey];
                            conversationLine = lines[Math.floor(Math.random() * lines.length)];
                        }

                        log(`目の前に精巧な作りの家がある！ ${explorer.name}が中を調べてみるようだ。`);
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        log(`${explorer.name}「${conversationLine}」`);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        const foundItems = [];
                        const allItemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].special); // 特殊アイテムを除外
                        for (let i = 0; i < 2; i++) {
                            const foundItemId = allItemIds[Math.floor(Math.random() * allItemIds.length)];
                            addItemToInventory(foundItemId);
                            foundItems.push(itemBlueprints[foundItemId].name);
                        }
                        log(`${explorer.name}は家の中から ${foundItems.join('と')} を見つけてきた！`);
                    }

                    async function foundCrackedRock() {
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        const allTiny = aliveParty.length > 0 && aliveParty.every(p => p.height === 1);

                        if (allTiny) {
                            // 全員が1cmの場合の新しいシナリオ
                            const explorer = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                            let conversationLine = "この隙間、何かありそう！"; // デフォルト
                            const explorerConvos = conversations[explorer.name];
                            if (explorerConvos && explorerConvos.cracked_rock_tiny && explorerConvos.cracked_rock_tiny.length > 0) {
                                const lines = explorerConvos.cracked_rock_tiny;
                                conversationLine = lines[Math.floor(Math.random() * lines.length)];
                            }

                            log(`目の前に巨大な岩が道を塞いでいる！しかし、よく見ると小さな隙間がたくさん空いている…`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`${explorer.name}が隙間の中を調べてみるようだ。`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`${explorer.name}「${conversationLine}」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const foundItems = [];
                            const itemCount = Math.floor(Math.random() * 2) + 2; // 2〜3個のアイテム
                            const allItemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].special); // 特殊アイテムを除外
                            for (let i = 0; i < itemCount; i++) {
                                const foundItemId = allItemIds[Math.floor(Math.random() * allItemIds.length)];
                                addItemToInventory(foundItemId);
                                foundItems.push(itemBlueprints[foundItemId].name);
                            }
                            log(`${explorer.name}は岩の隙間から ${foundItems.join('と')} を見つけてきた！`);

                        } else {
                            // 従来のシナリオ
                            const giantMembers = aliveParty.filter(p => p.height >= 300);
                            if (giantMembers.length === 0) {
                                log("目の前にひび割れた巨岩があるが、誰も壊せそうにない。");
                                return;
                            }

                            const breaker = giantMembers[Math.floor(Math.random() * giantMembers.length)];
                            let conversationLine = "この岩、壊せそうだ！"; // デフォルト
                            const breakerConvos = conversations[breaker.name];
                            if (breakerConvos && breakerConvos.cracked_rock_break && breakerConvos.cracked_rock_break.length > 0) {
                                const lines = breakerConvos.cracked_rock_break;
                                conversationLine = lines[Math.floor(Math.random() * lines.length)];
                            }

                            log(`目の前に巨大な岩が道を塞いでいる！しかし、よく見ると大きなひびが入っている…`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`${breaker.name}がその巨体で岩を破壊するようだ！`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`${breaker.name}「${conversationLine}」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log(`ゴゴゴ…！ ${breaker.name}は巨岩を粉々に打ち砕いた！`);
                            levelUpCharacter(breaker, false); // UIは表示せずにレベルアップ
                        }
                        dungeonCommands.classList.remove('hidden');
                    }

                    async function foundBeachLiberation() {
                        // 10%の確率で全員解放イベントに分岐
                        if (Math.random() < 0.1) {
                            celestiaEventTitle.textContent = "ビーチの熱狂";
                            celestiaEventText.textContent = "ライブの熱気は最高潮に達し、パーティ全体を巻き込もうとしている…！\n\n全員で、全てを解き放ちますか？";
                            celestiaEventButtons.innerHTML = `
                                <button id="liberation-all-accept" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">全員解放する</button>
                                <button id="liberation-all-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">理性を保つ</button>
                            `;
                            celestiaEventModal.classList.remove('hidden');

                            document.getElementById('liberation-all-accept').onclick = async() => {
                                celestiaEventModal.classList.add('hidden');
                                log("パーティ全員がビーチの熱気に身を任せ、解放状態になった！");
                                await new Promise(resolve => setTimeout(resolve, 2500));

                                // 追加の会話を再生
                                const partyConvos = conversations['summer_beach_all_liberated'];
                                const partyConvo = partyConvos[Math.floor(Math.random() * partyConvos.length)];
                                for (let i = 0; i < partyConvo.chars.length; i++) {
                                    log(`${partyConvo.chars[i]}「${partyConvo.lines[i]}」`);
                                    await new Promise(resolve => setTimeout(resolve, 2500));
                                }

                                gameState.party.forEach(p => { // ファイター, ソーサラー, ナイト, メディック
                                    dungeonCommands.classList.remove('hidden');
                                    if (p.currentHp > 0 && !p.statusEffects.stripped && !p.isLiberatedStripped) {
                                        p.statusEffects.stripped = {
                                            turns: 0
                                        };
                                        p.isLiberatedStripped = true;
                                    }
                                });
                                updatePartyStatus();
                            };
                            document.getElementById('liberation-all-decline').onclick = () => {
                                celestiaEventModal.classList.add('hidden');
                                log("一行はなんとか理性を保ち、熱狂を抑え込んだ。");
                                dungeonCommands.classList.remove('hidden');
                            };
                            return; // 全員解放イベントを実行したらここで終了
                        }

                        dungeonCommands.classList.add('hidden');
                        const potentialTargets = gameState.party.filter(p => p.currentHp > 0 && !p.statusEffects.stripped && !p.isLiberatedStripped && (!p.liberationCooldown || p.liberationCooldown <= 0));
                        if (potentialTargets.length === 0) {
                            nothingHappened();
                            return;
                        }
                        const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
                        const promptLine = (conversations[target.name] && conversations[target.name].beach_liberation_prompt && conversations[target.name].beach_liberation_prompt[0]) || "なんだか、全部脱ぎ捨てたくなっちゃった！";

                        celestiaEventTitle.textContent = "ビーチの熱気";
                        celestiaEventText.textContent = `${target.name}「${promptLine}」\n\n${target.name}はライブの熱気にあてられ、大胆になっているようだ…！`;
                        celestiaEventButtons.innerHTML = `
                            <button id="liberation-accept" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">脱がせる</button>
                            <button id="liberation-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">止める</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('liberation-accept').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            target.statusEffects.stripped = {
                                turns: 0
                            };
                            target.isLiberatedStripped = true;
                            log(`${target.name}は自ら服を脱ぎ捨て、解放状態になった！`);
                            updatePartyStatus();
                            dungeonCommands.classList.remove('hidden');
                        };
                        document.getElementById('liberation-decline').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            const stopLine = (conversations[target.name] && conversations[target.name].beach_liberation_stop && conversations[target.name].beach_liberation_stop[0]) || "ちぇっ、つまんないの。";
                            log(`${target.name}「${stopLine}」`);
                            dungeonCommands.classList.remove('hidden');
                            target.liberationCooldown = 5; // 5フロアのクールダウンを設定
                        };
                    }

                    async function foundOnsenLiberation() {
                        // 10%の確率で全員解放イベントに分岐
                        if (Math.random() < 0.1) {
                            celestiaEventTitle.textContent = "温泉の狂騒";
                            celestiaEventText.textContent = "温泉の心地よさが極限に達し、パーティ全体に伝播していく…！\n\n全員で、身も心も解き放ちますか？";
                            celestiaEventButtons.innerHTML = `
                                <button id="liberation-all-accept" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">全員解放する</button>
                                <button id="liberation-all-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">自制心を保つ</button>
                            `;
                            celestiaEventModal.classList.remove('hidden');

                            document.getElementById('liberation-all-accept').onclick = async() => {
                                celestiaEventModal.classList.add('hidden');
                                log("パーティ全員が温泉の心地よさに身を委ね、解放状態になった！");
                                await new Promise(resolve => setTimeout(resolve, 2500));

                                // 追加の会話を再生
                                const partyConvos = conversations['summer_onsen_all_liberated'];
                                const partyConvo = partyConvos[Math.floor(Math.random() * partyConvos.length)];
                                for (let i = 0; i < partyConvo.chars.length; i++) {
                                    log(`${partyConvo.chars[i]}「${partyConvo.lines[i]}」`);
                                    await new Promise(resolve => setTimeout(resolve, 2500));
                                }

                                gameState.party.forEach(p => { // ファイター, ソーサラー, ナイト, メディック
                                    dungeonCommands.classList.remove('hidden');
                                    if (p.currentHp > 0 && !p.statusEffects.stripped && !p.isLiberatedStripped) {
                                        p.statusEffects.stripped = {
                                            turns: 0
                                        };
                                        p.isLiberatedStripped = true;
                                    }
                                });
                                updatePartyStatus();
                            };
                            document.getElementById('liberation-all-decline').onclick = () => {
                                celestiaEventModal.classList.add('hidden');
                                log("一行はなんとか自制心を保ち、のぼせるのを防いだ。");
                                dungeonCommands.classList.remove('hidden');
                            };
                            return; // 全員解放イベントを実行したらここで終了
                        }

                        dungeonCommands.classList.add('hidden');
                        const potentialTargets = gameState.party.filter(p => p.currentHp > 0 && !p.statusEffects.stripped && !p.isLiberatedStripped && (!p.liberationCooldown || p.liberationCooldown <= 0));
                        if (potentialTargets.length === 0) {
                            nothingHappened();
                            return;
                        }
                        const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
                        const promptLine = (conversations[target.name] && conversations[target.name].onsen_liberation_prompt && conversations[target.name].onsen_liberation_prompt[0]) || "この心地よさ…もう何もかもどうでもよくなっちゃいそう。";

                        celestiaEventTitle.textContent = "温泉の誘惑";
                        celestiaEventText.textContent = `${target.name}「${promptLine}」\n\n${target.name}は温泉の心地よさに、身も心もとろけているようだ…！`;
                        celestiaEventButtons.innerHTML = `
                            <button id="liberation-accept" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">タオルを取る</button>
                            <button id="liberation-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">止める</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('liberation-accept').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            target.statusEffects.stripped = {
                                turns: 0
                            };
                            target.isLiberatedStripped = true;
                            log(`${target.name}はタオルを外し、解放状態になった！`);
                            updatePartyStatus();
                            dungeonCommands.classList.remove('hidden');
                        };
                        document.getElementById('liberation-decline').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            const stopLine = (conversations[target.name] && conversations[target.name].onsen_liberation_stop && conversations[target.name].onsen_liberation_stop[0]) || "うん、わかった。もうちょっとだけこのままでいさせて。";
                            log(`${target.name}「${stopLine}」`);
                            dungeonCommands.classList.remove('hidden');
                            target.liberationCooldown = 5; // 5フロアのクールダウンを設定
                            log(`（${target.name}はしばらくの間、大胆な気分にはならないだろう…）`);
                        };
                    }

                    function foundMagicCrystal() {
                        if (Math.random() < 0.5) {
                            addItemToInventory('holy_crystal');
                            log(`足元で輝く魔力の結晶を見つけた！「聖結晶」を手に入れた！`);
                        } else {
                            addItemToInventory('evil_crystal');
                            log(`足元で禍々しく光る魔力の結晶を見つけた！「邪結晶」を手に入れた！`);
                        }
                        flashCard(getRandomPartyMember(), 'yellow');
                    }

                    async function foundOnsenTowelTrouble() {
                        log("温泉の熱気にあてられて、少しのぼせてしまったようだ…");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        const immuneRoles = ['ナイト', 'サムライ', '聖女', 'アンドロイド'];
                        const potentialVictims = gameState.party.filter(p => p.currentHp > 0 && !immuneRoles.includes(p.role) && !p.statusEffects.stripped);

                        if (potentialVictims.length === 0) {
                            log("…が、特に何も起こらなかった。");
                            return;
                        }

                        const victim = potentialVictims[Math.floor(Math.random() * potentialVictims.length)];
                        log(`ふらついた拍子に、${victim.name}のタオルがはだけてしまった！`);
                        victim.statusEffects.stripped = {
                            turns: 0
                        };
                        flashCard(victim, 'red');
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        const line = conversations[victim.name].onsen_towel_trouble[0];
                        log(`${victim.name}「${line}」`);
                        dungeonCommands.classList.remove('hidden');
                    }

                    // --- サマータイム・スペシャルライブ！専用イベント ---
                    async function foundWatermelonSmash() {
                        log("ビーチといえばスイカ割り！みんなで楽しむことにした。");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        const blindfolded = getRandomPartyMember();
                        log(`${blindfolded.name}が目隠しをして、スイカ割りに挑戦！`);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        if (Math.random() < 0.7) { // 70%で成功
                            log(`「そっちじゃない！もっと右！」「行き過ぎ！」「そこだー！」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log(`パッカーン！ 見事にスイカは命中！`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log("甘くて冷たいスイカを食べて、全員のHPが少し回復した！");
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.2), 'increase');
                            }
                        } else { // 30%で失敗
                            dungeonCommands.classList.remove('hidden');
                            const victim = gameState.party.filter(p => p.currentHp > 0 && p !== blindfolded)[Math.floor(Math.random() * (gameState.party.length - 1))];
                            log(`「こっちだよー！」という${victim.name}の声の方へ、${blindfolded.name}は進んでいき…`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log(`ゴツン！ ${blindfolded.name}の振り下ろした棒が、${victim.name}の頭にクリーンヒット！`);
                            await dealDamage(victim, 10);
                        }
                    }


                    async function foundSandcastle() {
                        log("みんなで砂の城を作ることにした。");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("力を合わせて、立派な城を築き上げる！");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        const quality = Math.random();
                        if (quality < 0.3) {
                            log("城は完成したが、波にさらわれてすぐに崩れてしまった…。");
                        } else if (quality < 0.8) {
                            log("立派な砂の城が完成した！達成感でパーティの士気が上がる！(3ターン攻撃力アップ)");
                            gameState.party.forEach(p => {
                                if (p.currentHp > 0) p.buffs.atk_up = 3;
                            });
                        } else {
                            log("あまりに完璧な城が完成し、砂の精霊が祝福を与えてくれた！");
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log("全員のHPとMPが完全に回復した！");
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                await animateStatChange(p, 'mp', p.maxMp, 'increase');
                            }
                        }
                        dungeonCommands.classList.remove('hidden');
                    }

                    async function foundOnsenPingPong() {
                        log("温泉といえば卓球！トーナメント戦が始まった！");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        const winner = gameState.party.filter(p => p.currentHp > 0).sort((a, b) => getEffectiveStats(b).agi - getEffectiveStats(a).agi)[0];
                        log(`激しいラリーの末、最も素早い${winner.name}が優勝した！`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log(`${winner.name}は温泉卓球マスターの称号を得て、ステータスが永続的に上昇した！`);
                        winner.atk += 1;
                        winner.def += 1;
                        winner.agi += 1;
                        flashCard(winner, 'green');
                        dungeonCommands.classList.remove('hidden');
                    }

                    async function foundHotSpringsSoak() {
                        log("一行は温泉にゆっくりと浸かり、冒険の疲れを癒した。");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("全員のHPとMPが回復し、状態異常も治った。");
                        for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                            await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.5), 'increase');
                            await animateStatChange(p, 'mp', Math.ceil(p.maxMp * 0.5), 'increase');
                            p.statusEffects = {}; // 脱衣以外をリセット
                        }
                        dungeonCommands.classList.remove('hidden');
                    }

                    async function foundHighMouseHole() {
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        const allTiny = aliveParty.length > 0 && aliveParty.every(p => p.height === 1);

                        if (allTiny) {
                            // 全員が1cmの場合の新しいシナリオ
                            log(`壁の高い位置に、小さなネズミ穴を見つけた！`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`しかし、全員小さすぎて、どうやっても届きそうにない…。`);
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const char1 = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                            const otherParty = aliveParty.filter(p => p !== char1);
                            const char2 = otherParty.length > 0 ? otherParty[Math.floor(Math.random() * otherParty.length)] : char1;

                            const getLine = (char) => {
                                const charConvos = conversations[char.name];
                                if (charConvos && charConvos.high_mouse_hole_all_tiny && charConvos.high_mouse_hole_all_tiny.length > 0) {
                                    const lines = charConvos.high_mouse_hole_all_tiny;
                                    return lines[Math.floor(Math.random() * lines.length)];
                                }
                                return "うーん、届かないね…";
                            };

                            log(`${char1.name}「${getLine(char1)}」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            if (char1 !== char2) {
                                log(`${char2.name}「${getLine(char2)}」`);
                                await new Promise(resolve => setTimeout(resolve, 2000));
                            }
                            // コマンドを再表示する処理を追加
                            dungeonCommands.classList.remove('hidden');
                        } else {
                            // 従来のシナリオ
                            const giantMembers = aliveParty.filter(p => p.height >= 200);
                            const tinyMembers = aliveParty.filter(p => p.height <= 10);

                            if (giantMembers.length === 0 || tinyMembers.length === 0) {
                                log("壁の高い位置にネズミ穴があるが、協力できそうな仲間がいなかった。");
                                return;
                            }

                            const giant = giantMembers[Math.floor(Math.random() * giantMembers.length)];
                            const tiny = tinyMembers[Math.floor(Math.random() * tinyMembers.length)];

                            log(`壁の高い位置に、小さなネズミ穴を見つけた！`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`これは一人では届かないし、小さすぎて入れない…。`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`${giant.name}と${tiny.name}が協力して調べるようだ。`);
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const giantLine = getLineForHole(giant, 'high_mouse_hole_giant', tiny);
                            const tinyLine = getLineForHole(tiny, 'high_mouse_hole_tiny', giant);

                            log(`${giant.name}「${giantLine}」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log(`${tiny.name}「${tinyLine}」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                            const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                            addItemToInventory(foundItemId);
                            log(`${tiny.name}は穴の中から、とても珍しい「${itemBlueprints[foundItemId].name}」を見つけてきた！`);
                            flashCard(giant, 'yellow');
                            dungeonCommands.classList.remove('hidden');
                            flashCard(tiny, 'yellow');
                        }
                    }

                    function foundProtectiveWall() {
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length === 0) {
                            nothingHappened();
                            return;
                        }
                        const target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                        const targetId = gameState.party.indexOf(target);

                        log("どこからか岩が集まり、防壁を形成した！");

                        // 耐久値は対象の最大HPの50%とする
                        const wallHp = Math.ceil(target.maxHp * 0.5);
                        gameState.walls.push({
                            targetId: targetId,
                            hp: wallHp,
                            maxHp: wallHp
                        });
                        log(`${target.name}の前に、耐久値${wallHp}の防壁が現れた！`);
                        flashCard(target, 'yellow');
                        dungeonCommands.classList.remove('hidden');
                    }

                    function nothingHappened() {
                        log('なにも見つからなかった。');
                    }

                    function foundSuspiciousDevice() {
                        log("一行は研究室のような部屋で、人が二人入れる奇妙な装置を見つけた…");

                        // ボタンの表示状態をリセット
                        deviceRedButton.parentElement.classList.remove('hidden');
                        deviceBlueButton.parentElement.classList.remove('hidden');
                        deviceGreenButtonContainer.classList.add('hidden');
                        deviceWhiteButtonContainer.classList.add('hidden');

                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);

                        // 赤いボタンの条件チェック
                        const nonOneCmChars = aliveParty.filter(p => p.height !== 1 && !p.heightLocked);
                        if (nonOneCmChars.length < 2) {
                            deviceRedButton.parentElement.classList.add('hidden');
                            deviceGreenButtonContainer.classList.remove('hidden');
                        }

                        // 青いボタンの条件チェック
                        if (aliveParty.length >= 2) {
                            const heights = aliveParty.map(p => p.height);
                            const maxHeight = Math.max(...heights);
                            const minHeight = Math.min(...heights);
                            if (maxHeight - minHeight < 30 && Math.random() < 0.5) {
                                deviceBlueButton.parentElement.classList.add('hidden');
                                deviceWhiteButtonContainer.classList.remove('hidden');
                            }
                        }

                        deviceModal.classList.remove('hidden');

                        deviceRedButton.onclick = () => {
                            deviceModal.classList.add('hidden');
                            showTwoMemberSelectionModal("身長を吸収するキャラと、されるキャラを順に選んでください。", (char1, char2) => {
                                log(`装置に${char1.name}と${char2.name}が入り、赤いボタンを押した！`);
                                if (char1.heightLocked || char2.heightLocked) {
                                    log("しかし、装置はうんともすんとも言わない。不思議な力で守られているようだ。");
                                    return;
                                }
                                const growthAmount = char2.height - 1;
                                const shrinkAmount = 1 - char2.height;

                                animateStatChange(char1, 'height', growthAmount, 'increase');
                                animateStatChange(char2, 'height', shrinkAmount, 'decrease');
                                log(`眩い光の後、${char1.name}の身長は${growthAmount}cm伸び、${char2.name}の身長は1cmになった！`);
                                dungeonCommands.classList.remove('hidden');
                            });
                        };

                        deviceBlueButton.onclick = () => {
                            deviceModal.classList.add('hidden');
                            showTwoMemberSelectionModal("身長を平均化するキャラを2人選んでください。", (char1, char2) => {
                                log(`装置に${char1.name}と${char2.name}が入り、青いボタンを押した！`);
                                if (char1.heightLocked || char2.heightLocked) {
                                    log("しかし、装置はうんともすんとも言わない。不思議な力で守られているようだ。");
                                    return;
                                }
                                const totalHeight = char1.height + char2.height;
                                const newHeight = Math.floor(totalHeight / 2);

                                const change1 = newHeight - char1.height;
                                const change2 = newHeight - char2.height;

                                animateStatChange(char1, 'height', change1, change1 >= 0 ? 'increase' : 'decrease');
                                animateStatChange(char2, 'height', change2, change2 >= 0 ? 'increase' : 'decrease');
                                log(`装置が作動し、二人の身長は平均化され、共に${newHeight}cmになった！`);
                                dungeonCommands.classList.remove('hidden');
                            });
                        };

                        deviceGreenButton.onclick = () => {
                            deviceModal.classList.add('hidden');
                            showOneMemberSelectionModal(char => {
                                log(`${char.name}が装置に入り、緑のボタンを押した！`);
                                if (char.heightLocked) {
                                    log("しかし、装置はうんともすんとも言わない。不思議な力で守られているようだ。");
                                    return;
                                }
                                animateStatChange(char, 'height', 100, 'increase');
                                log(`装置から光が溢れ、${char.name}の身長が100cm伸びた！`);
                                dungeonCommands.classList.remove('hidden');
                            }, "身長を伸ばすキャラを1人選んでください。");
                        };

                        deviceWhiteButton.onclick = () => {
                            deviceModal.classList.add('hidden');
                            showOneMemberSelectionModal(char => {
                                log(`${char.name}が装置に入り、白いボタンを押した！`);
                                const stats = ['atk', 'def', 'maxHp'];
                                const statToUpgrade = stats[Math.floor(Math.random() * stats.length)];
                                let upgradeAmount = 0;
                                if (statToUpgrade === 'atk') upgradeAmount = 2;
                                else if (statToUpgrade === 'def') upgradeAmount = 2;
                                else if (statToUpgrade === 'maxHp') upgradeAmount = 10;

                                char[statToUpgrade] += upgradeAmount;
                                flashCard(char, 'green');
                                log(`装置が作動し、${char.name}の${statToUpgrade === 'maxHp' ? '最大HP' : statToUpgrade === 'atk' ? '攻撃力' : '防御力'}が永続的に${upgradeAmount}上昇した！`);
                                dungeonCommands.classList.remove('hidden');
                            }, "強化するキャラを1人選んでください。");
                        };

                        deviceIgnoreButton.onclick = () => {
                            deviceModal.classList.add('hidden');
                            log("一行は怪しい装置を無視して、先へ進んだ。");
                            dungeonCommands.classList.remove('hidden');
                        };
                    }

                    async function foundLiberatedSenses() {
                        const liberatedMembers = gameState.party.filter(p => p.currentHp > 0 && p.isLiberatedStripped);
                        if (liberatedMembers.length === 0) {
                            nothingHappened(); // 念の為のフォールバック
                            return;
                        }
                        const explorer = liberatedMembers[Math.floor(Math.random() * liberatedMembers.length)];

                        log(`${explorer.name}は解放されたことで五感が研ぎ澄まされている…`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log(`「…！この先に、何かいいものの気配がする！」`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                        const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                        addItemToInventory(foundItemId);
                        log(`${explorer.name}は気配を頼りに、とても珍しい「${itemBlueprints[foundItemId].name}」を見つけ出した！`);
                        flashCard(explorer, 'green');
                        dungeonCommands.classList.remove('hidden');
                    }

                    function foundDivineTrial() {
                        log("目の前に荘厳な祭壇が現れ、神々しい声が響き渡る…\n「汝らに試練と、祝福を与えん…」");

                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length === 0) {
                            log("しかし、誰もいなかったため声は消えていった。");
                            return;
                        }

                        const target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                        const specialBlessings = ['fairy_grace', 'dragon_god_grace', 'swelling_body', 'twisted_memory'];
                        const chosenBlessingId = specialBlessings[Math.floor(Math.random() * specialBlessings.length)];
                        const chosenBlessing = blessings[chosenBlessingId];

                        setTimeout(() => {
                            log(`声は${target.name}を選び、その身に大いなる力を注ぎ込んだ！`);
                            chosenBlessing.effect(target);
                            flashCard(target, 'green');
                            log(`${target.name}は祝福「${chosenBlessing.name}」を授かった！`);
                            dungeonCommands.classList.remove('hidden');
                        }, 2000);
                    }


                    function foundWishingStar() {
                        log("壁に空いた穴から、綺麗な光が差し込んでいる…\n「あなたの願い事、聞いてあげる」という声が響いた。");

                        wishingStarCharSelect.innerHTML = '';
                        wishingStarOptions.innerHTML = '';
                        wishingStarCharSelect.classList.remove('hidden');
                        wishingStarOptions.classList.add('hidden');
                        wishingStarModalPrompt.textContent = '願い事をする仲間を一人選んでください。';

                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);

                        aliveParty.forEach(char => {
                            const card = document.createElement('div');
                            card.className = 'p-4 border rounded-lg cursor-pointer hover:bg-cyan-100 hover:shadow-lg transition';
                            card.innerHTML = `<p class="font-bold text-lg text-${char.themeColor}-700">${char.name}</p><p class="text-sm text-gray-600">${char.role}</p>`;
                            card.onclick = () => presentWishingStarChoices(char);
                            wishingStarCharSelect.appendChild(card);
                        });

                        wishingStarModal.classList.remove('hidden');
                    }

                    function presentWishingStarChoices(char) {
                        wishingStarCharSelect.classList.add('hidden');
                        wishingStarOptions.classList.remove('hidden');
                        wishingStarModalPrompt.textContent = `${char.name}は何を願いますか？`;

                        const immuneToStripRoles = ['ナイト', 'サムライ', '聖女', 'アンドロイド'];

                        const wishPool = [{
                                id: 'level_up',
                                text: '強くなりたい',
                                description: 'レベルが1上がる。',
                                effect: (c) => {
                                    levelUpCharacter(c, false);
                                    log(`${c.name}は星に願った…「強くなりたい！」`);
                                },
                                condition: (c) => true
                            }, {
                                id: 'full_recover',
                                text: '元気になりたい',
                                description: '全員のHPとMPが全回復する。',
                                effect: async(c) => {
                                    log(`${c.name}は星に願った…「みんなが元気になりますように！」`);
                                    for (const p of gameState.party) {
                                        if (p.currentHp > 0) {
                                            await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                            await animateStatChange(p, 'mp', p.maxMp, 'increase');
                                        }
                                    }
                                },
                                condition: (c) => true
                            }, {
                                id: 'permanent_stats',
                                text: '装備を整えたい',
                                description: '攻撃力と防御力が永続的に2ずつ上がる。',
                                effect: (c) => {
                                    c.atk += 2;
                                    c.def += 2;
                                    log(`${c.name}は星に願った…「もっといい装備が欲しい！」\n星の光が${c.name}の体を包み、力がみなぎる！`);
                                },
                                condition: (c) => true
                            }, {
                                id: 'become_doll',
                                text: 'お人形さんになりたい',
                                description: '身長が20cmになる。(身長固定は解除)',
                                effect: async(c) => {
                                    c.heightLocked = false;
                                    await animateStatChange(c, 'height', 20 - c.height, 'decrease');
                                    log(`${c.name}は星に願った…「お人形さんみたいになりたい！」\n体が小さくなり、身長が20cmになった！`);
                                },
                                condition: (c) => true
                            }, {
                                id: 'grow_big',
                                text: '大きくなりたい',
                                description: '身長が2倍になる。',
                                effect: async(c) => {
                                    await animateStatChange(c, 'height', c.height, 'increase');
                                    log(`${c.name}は星に願った…「大きくなりたい！」\n体がぐんぐん伸びて、身長が2倍になった！`);
                                },
                                condition: (c) => c.height > c.initialHeight / 2 && !c.heightLocked
                            }, {
                                id: 'grow_reset',
                                text: '大きくなりたい',
                                description: '身長が初期身長まで戻る。',
                                effect: async(c) => {
                                    const growth = c.initialHeight - c.height;
                                    await animateStatChange(c, 'height', growth, 'increase');
                                    log(`${c.name}は星に願った…「元の大きさに戻りたい！」\n体がぐんぐん伸びて、元の身長に戻った！`);
                                },
                                condition: (c) => c.height <= c.initialHeight / 2 && !c.heightLocked
                            }, {
                                id: 'liberate',
                                text: 'すべてさらけ出したい',
                                description: '解放状態になり、今後、服発見イベントが発生しなくなる。',
                                effect: (c) => {
                                    c.statusEffects.stripped = {
                                        turns: 0
                                    };
                                    c.isLiberatedStripped = true;
                                    gameState.wishingStarNoClothes = true;
                                    log(`${c.name}は星に願った…「すべてをさらけ出したい！」\n${c.name}は自ら服を脱ぎ捨て、解放状態になった！`);
                                    dungeonCommands.classList.remove('hidden');
                                },
                                condition: (c) => !immuneToStripRoles.includes(c.role) && !c.isLiberatedStripped
                            }, {
                                id: 'all_tiny',
                                text: '違う世界が見たい',
                                description: '全員の身長が1cmになる。',
                                effect: async(c) => {
                                    log(`${c.name}は星に願った…「違う世界が見たい！」\n星の光がパーティを包み、全員の身長が1cmになった！`);
                                    for (const p of gameState.party) {
                                        if (p.currentHp > 0) await animateStatChange(p, 'height', 1 - p.height, 'decrease');
                                    }
                                    dungeonCommands.classList.remove('hidden');
                                },
                                condition: (c) => !gameState.party.some(p => p.heightLocked)
                            }, {
                                id: 'get_supplies',
                                text: '強敵に備えたい',
                                description: 'ポーションx3, マナポーションx3, リバイブハーブx2を入手。',
                                effect: (c) => {
                                    addItemToInventory('potion', 3);
                                    addItemToInventory('mana_potion', 3);
                                    addItemToInventory('revive_herb', 2);
                                    dungeonCommands.classList.remove('hidden');
                                    log(`${c.name}は星に願った…「強敵に備えたい！」\n足元に便利なアイテムがたくさん現れた！`);
                                },
                                condition: (c) => true
                            }, {
                                id: 'get_ale',
                                text: 'エールで乾杯したい',
                                description: 'ギガンテスエールをパーティの人数分入手する。',
                                effect: (c) => {
                                    const count = gameState.party.filter(p => p.currentHp > 0).length;
                                    addItemToInventory('gigantes_ale', count);
                                    log(`${c.name}は星に願った…「みんなでエールで乾杯したい！」\n人数分のギガンテスエールを手に入れた！`);
                                    dungeonCommands.classList.remove('hidden');
                                },
                                condition: (c) => true
                            }, {
                                id: 'get_crystals',
                                text: '英雄と手合わせ願いたい',
                                description: '聖結晶と邪結晶を1個ずつ入手する。',
                                effect: (c) => {
                                    addItemToInventory('holy_crystal', 1);
                                    addItemToInventory('evil_crystal', 1);
                                    log(`${c.name}は星に願った…「英雄と手合わせ願いたい！」\n聖と邪、二つの結晶が目の前に現れた！`);
                                    dungeonCommands.classList.remove('hidden');
                                },
                                condition: (c) => gameState.gameMode === 'endless'
                            }, {
                                id: 'hp_to_mp',
                                text: '未来を夢見たい',
                                description: '現在の強さを記憶に刻み、新たな旅に出る。',
                            effect: (c) => saveShiroTenseiData(c, false),
                                condition: (c) => c.role === '転生者'
                            },


                            {
                                id: 'hp_to_mp',
                                text: '魔力と一体化したい',
                                description: '最大HPが半分になり、その分最大MPが上昇する。',
                                effect: (c) => {
                                    const hpLoss = Math.floor(c.maxHp / 2);
                                    c.maxHp -= hpLoss;
                                    c.currentHp = Math.min(c.currentHp, c.maxHp);
                                    c.maxMp += hpLoss;
                                    dungeonCommands.classList.remove('hidden');
                                    log(`${c.name}は星に願った…「魔力と一体になりたい！」\n${c.name}の生命力が魔力に変換された！`);
                                },
                                condition: (c) => c.maxHp > 1
                            }, {
                                id: 'mp_to_hp',
                                text: '強靭な肉体を手にしたい',
                                description: '最大MPが半分になり、その分最大HPが上昇する。',
                                effect: (c) => {
                                    const mpLoss = Math.floor(c.maxMp / 2);
                                    c.maxMp -= mpLoss;
                                    c.currentMp = Math.min(c.currentMp, c.maxMp);
                                    c.maxHp += mpLoss;
                                    dungeonCommands.classList.remove('hidden');
                                    log(`${c.name}は星に願った…「強靭な肉体が欲しい！」\n${c.name}の魔力が生命力に変換された！`);
                                },
                                condition: (c) => c.maxMp > 1
                            }, {
                                id: 'get_blessing',
                                text: '才能が欲しい',
                                description: 'ランダムな祝福を一つ授かる。',
                                effect: (c) => {
                                    const available = Object.values(blessings).filter(b => !Object.values(c.blessings).some(owned => owned.name === b.name));
                                    if (available.length > 0) {
                                        const chosenBlessing = available[Math.floor(Math.random() * available.length)];
                                        chosenBlessing.effect(c);
                                        log(`${c.name}は星に願った…「新しい才能が欲しい！」\n${c.name}は祝福「${chosenBlessing.name}」を授かった！`);
                                    } else {
                                        log(`${c.name}は既に全ての祝福を授かっていた！代わりにレベルが上がった！`);
                                        levelUpCharacter(c, false);
                                        dungeonCommands.classList.remove('hidden');
                                    }
                                },
                                condition: (c) => true
                            }, {
                                id: 'fight_observer',
                                text: 'あなたを超える',
                                description: 'そこにメリットはない。',
                                effect: (c) => {
                                    log(`${c.name}は星に願った…「お前を超えてやる！」\n声の主は不敵に笑い、姿を現した！`);
                                    startBattle(true, 'star_observer');
                                },
                                condition: (c) => true
                            }, {
                                id: 'average_all_height',
                                text: 'みんなと同じになりたい',
                                description: 'パーティ全員の身長が平均化される。',
                                effect: async(c) => {
                                    const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                                    const totalHeight = aliveParty.reduce((sum, p) => sum + p.height, 0);
                                    const avgHeight = Math.floor(totalHeight / aliveParty.length);
                                    log(`${c.name}は星に願った…「みんなと同じになりたい！」\n星の光がパーティを包み、全員の身長が${avgHeight}cmになった！`);
                                    for (const p of aliveParty) {
                                        const change = avgHeight - p.height;
                                        if (change !== 0) {
                                            await animateStatChange(p, 'height', change, change >= 0 ? 'increase' : 'decrease');
                                        }
                                        dungeonCommands.classList.remove('hidden');
                                    }
                                },
                                condition: (c) => {
                                    const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                                    return aliveParty.length >= 2 && !aliveParty.some(p => p.heightLocked) && !aliveParty.every(p => p.height === aliveParty[0].height);
                                }
                            },
                        ];

                        const choices = [];
                        const availableWishes = wishPool.filter(w => w.condition(char));

                        while (choices.length < 4 && availableWishes.length > 0) {
                            const randomIndex = Math.floor(Math.random() * availableWishes.length);
                            const chosenWish = availableWishes.splice(randomIndex, 1)[0];
                            choices.push(chosenWish);
                        }

                        choices.forEach(wish => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg text-left';
                            button.innerHTML = `<strong class="text-lg">${wish.text}</strong><span class="block text-sm text-cyan-100 mt-1">${wish.description}</span>`;
                            button.onclick = async() => {
                                wishingStarModal.classList.add('hidden');
                                await wish.effect(char);
                                updatePartyStatus();
                                // dungeonCommands.classList.remove('hidden'); // 各effect内で個別に対応
                                dungeonCommands.classList.remove('hidden');
                            };

                            wishingStarOptions.appendChild(button);
                        });
                    }

                    function showTwoMemberSelectionModal(prompt, callback) {
                        twoMemberSelectList.innerHTML = '';
                        let selectedChars = [];

                        document.getElementById('two-member-select-title').textContent = prompt;
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);

                        aliveParty.forEach(char => {
                            const card = document.createElement('div');
                            card.className = 'p-4 border-2 border-gray-200 rounded-lg cursor-pointer hover:bg-gray-100 transition';
                            card.innerHTML = `<p class="font-bold text-lg">${char.name}</p><p class="text-sm text-gray-600">${char.role}</p>`;

                            card.addEventListener('click', () => {
                                const index = selectedChars.indexOf(char);
                                if (index > -1) {
                                    selectedChars.splice(index, 1);
                                    card.classList.remove('border-indigo-500', 'bg-indigo-50');
                                } else if (selectedChars.length < 2) {
                                    selectedChars.push(char);
                                    card.classList.add('border-indigo-500', 'bg-indigo-50');
                                }

                                const isReady = selectedChars.length === 2;
                                twoMemberSelectConfirm.disabled = !isReady;
                                twoMemberSelectConfirm.classList.toggle('opacity-50', !isReady);
                                twoMemberSelectConfirm.classList.toggle('cursor-not-allowed', !isReady);
                            });
                            twoMemberSelectList.appendChild(card);
                        });

                        twoMemberSelectConfirm.onclick = () => {
                            if (selectedChars.length === 2) {
                                twoMemberSelectModal.classList.add('hidden');
                                callback(selectedChars[0], selectedChars[1]);
                            }
                        };

                        twoMemberSelectModal.classList.remove('hidden');
                    }

                    function foundBewilderingStatue() {
                        log("一行は、怪しいオーラを放つ石像を見つけた…");
                        statueModal.classList.remove('hidden');

                        statueTouchButton.onclick = () => {
                            statueModal.classList.add('hidden');
                            showOneMemberSelectionModal(char => {
                                log(`${char.name}は、おそるおそる石像に触れた…！`);

                                const effects = [{
                                        type: 'atk_up',
                                        weight: 30
                                    }, {
                                        type: 'def_up',
                                        weight: 30
                                    }, {
                                        type: 'regen',
                                        weight: 30
                                    }, {
                                        type: 'level_up',
                                        weight: 5
                                    }, // 当たり (低確率)
                                    {
                                        type: 'shrink_to_one',
                                        weight: 5
                                    }, // ハズレ (低確率)
                                    {
                                        type: 'average_height',
                                        weight: 20
                                    } // ハズレ (低確率)
                                ];

                                const totalWeight = effects.reduce((sum, e) => sum + e.weight, 0);
                                let random = Math.random() * totalWeight;
                                let chosenEffect = null;

                                for (const effect of effects) {
                                    random -= effect.weight;
                                    if (random <= 0) {
                                        chosenEffect = effect.type;
                                        break;
                                    }
                                }

                                switch (chosenEffect) {
                                    case 'atk_up':
                                        char.buffs.atk_up = 10;
                                        flashCard(char, 'yellow');
                                        log(`石像が輝き、${char.name}の体に力がみなぎる！(10ターン攻撃力アップ)`);
                                        break;
                                    case 'def_up':
                                        char.buffs.protect = 10;
                                        flashCard(char, 'yellow');
                                        log(`石像が輝き、${char.name}の体が硬質化していく！(10ターン防御力アップ)`);
                                        break;
                                    case 'regen':
                                        char.statusEffects.regeneration = {
                                            turns: 10
                                        };
                                        flashCard(char, 'green');
                                        log(`石像が輝き、${char.name}の傷が癒え始めた！(10ターン自動回復)`);
                                        break;
                                    case 'level_up':
                                        log(`石像から溢れ出た光が${char.name}を包み込む！ なんとレベルアップした！`);
                                        dungeonCommands.classList.remove('hidden');
                                        levelUpCharacter(char, false);
                                        break;
                                    case 'shrink_to_one':
                                        if (char.heightLocked) {
                                            log(`石像は禍々しい光を放ったが、${char.name}の体は変化を拒んだ！`);
                                        } else {
                                            log(`石像が禍々しい光を放ち、${char.name}の体がみるみる縮んでいく！`);
                                            animateStatChange(char, 'height', 1 - char.height, 'decrease');
                                            dungeonCommands.classList.remove('hidden');
                                        }
                                        break;
                                    case 'average_height':
                                        {
                                            const otherMembers = gameState.party.filter(p => p !== char && p.currentHp > 0);
                                            if (otherMembers.length > 0) {
                                                const totalHeight = otherMembers.reduce((sum, p) => sum + p.height, 0);
                                                const avgHeight = Math.floor(totalHeight / otherMembers.length);
                                                const change = avgHeight - char.height;
                                                log(`石像のオーラが${char.name}を包み込み、仲間たちの平均身長になった！`);
                                                animateStatChange(char, 'height', change, change >= 0 ? 'increase' : 'decrease');
                                                dungeonCommands.classList.remove('hidden');
                                            } else {
                                                // 他にメンバーがいない場合
                                                const change = char.initialHeight - char.height;
                                                log(`石像のオーラが${char.name}を包み込み、元の身長に戻った！`);
                                                if (change !== 0) {
                                                    dungeonCommands.classList.remove('hidden');
                                                    animateStatChange(char, 'height', change, change >= 0 ? 'increase' : 'decrease');
                                                }
                                            }
                                            break;
                                        }
                                }
                            });
                        };

                        statueLeaveButton.onclick = () => {
                            statueModal.classList.add('hidden');
                            log("一行は不気味な石像を無視して、先へ進んだ。");
                            dungeonCommands.classList.remove('hidden');
                        };
                    }

                    function showOneMemberSelectionModal(callback, prompt = "対象を1人選んでください") {
                        oneMemberSelectList.innerHTML = '';
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);

                        document.getElementById('one-member-select-title').textContent = prompt;
                        aliveParty.forEach(char => {
                            const card = document.createElement('div');
                            card.className = 'p-4 border-2 border-gray-200 rounded-lg cursor-pointer hover:bg-indigo-100 transition';
                            card.innerHTML = `<p class="font-bold text-lg">${char.name}</p><p class="text-sm text-gray-600">${char.role}</p>`;

                            card.addEventListener('click', () => {
                                oneMemberSelectModal.classList.add('hidden');
                                callback(char);
                            });
                            oneMemberSelectList.appendChild(card);
                        });

                        oneMemberSelectModal.classList.remove('hidden');
                    }

                    async function foundShamePillory() {
                        log("部屋の中央に、一枚の透明なガラス板が立っている…");
                        const strippedMembersCheck = gameState.party.filter(p => p.currentHp > 0 && p.statusEffects.stripped);
                        if (strippedMembersCheck.length === 0) {
                            // 対象がいない場合は別のイベントを再抽選
                            triggerRandomEvent();
                            return;
                        }

                        await new Promise(resolve => setTimeout(resolve, 1500));
                        const strippedMembers = gameState.party.filter(p => p.currentHp > 0 && p.statusEffects.stripped);
                        const victim = strippedMembers[Math.floor(Math.random() * strippedMembers.length)];

                        log(`突然、床から現れた無数の触手が、${victim.name}に絡みついた！`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log(`${victim.name}は抵抗する間もなく、ガラス板に強く押し付けられてしまった！`);
                        flashCard(victim, 'red');
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        // ?. 演算子が使えない環境のための代替コード
                        let conversationLine = "いやっ…！離して…！"; // デフォルト値を先に設定
                        const victimConvos = conversations[victim.name];
                        if (victimConvos && victimConvos.shame_pillory && victimConvos.shame_pillory.length > 0) {
                            const lines = victimConvos.shame_pillory;
                            conversationLine = lines[Math.floor(Math.random() * lines.length)];
                        }

                        log(`${victim.name}「${conversationLine}」`);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        log(`${victim.name}は羞恥心から精神が乱れ、弱ってしまった…`);
                        victim.buffs.def_down = 3; // 3ターン防御力ダウン
                        const mpLoss = Math.ceil(victim.maxMp * 0.3);
                        dungeonCommands.classList.remove('hidden');
                        await animateStatChange(victim, 'mp', -mpLoss, 'decrease');


                        log(`(${victim.name}の防御力が下がり、MPが${mpLoss}減少した)`);
                    }

                    async function foundShrineOfPrayer() {
                        log("一行は、静かで神聖な空気が漂う小さなほこらを見つけた。");
                        await new Promise(resolve => setTimeout(resolve, 1500));

                        const prayer = getRandomPartyMember();
                        log(`${prayer.name}が代表して、静かに祈りを捧げた…`);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        let message = '';
                        switch (prayer.role) {
                            case 'ファイター':
                            case 'サムライ':
                            case 'モンク':
                                message = "戦いの神が応え、全員の体に力がみなぎる！(3ターン攻撃力アップ)";
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) p.buffs.atk_up = 3;
                                });
                                break;
                            case 'ナイト':
                            case 'ガーディアン':
                                message = "守護の神が応え、全員の体が硬質化していく！(3ターン防御力アップ)";
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) p.buffs.protect = 3;
                                });
                                break;
                            case 'ソーサラー':
                            case 'アルケミスト':
                            case 'ネクロマンサー':
                                message = "魔力の源が共鳴し、全員のMPが少し回復した！";
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) await animateStatChange(p, 'mp', Math.ceil(p.maxMp * 0.3), 'increase');
                                }
                                break;
                            case 'メディック':
                            case 'ドクター':
                                message = "癒やしの女神が微笑み、全員の傷が癒えた！";
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.3), 'increase');
                                }
                                break;
                            case 'ダンサー':
                            case 'ギャンブラー':
                                message = "幸運の女神が微笑み、全員の足取りが軽くなった！(3ターン素早さアップ)";
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) p.buffs.agi_up = 3;
                                });
                                break;
                            case 'リーパー':
                            case 'サモナー':
                                message = "精霊たちが集まり、贈り物を置いていった！";
                                addItemToInventory('potion', 2);
                                addItemToInventory('mana_potion', 1);
                                message += " (ポーションx2、マナポーションx1 を手に入れた)";
                                break;
                            case 'トラブルメーカー':
                                message = "コハルの祈りが天に通じたのか、なぜかレアなアイテムが見つかった！";
                                const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                                addItemToInventory(foundItemId);
                                message += ` (${itemBlueprints[foundItemId].name} を手に入れた)`;
                                break;
                            case 'シスター':
                                message = "慈愛の祈りが届き、全員に再生の祝福が与えられた！(3ターン自動回復)";
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) p.statusEffects.regeneration = {
                                        turns: 3
                                    };
                                });
                                break;
                            case '聖女':
                                message = "聖なる祈りがほこらを光で満たし、全員のHPとMPが完全に回復した！";
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) {
                                        await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                        await animateStatChange(p, 'mp', p.maxMp, 'increase');
                                    }
                                }
                                break;
                            case 'トレジャーハンター':
                            case 'サキュバス':
                            case 'フェアリー':
                            case 'アルラウネ':
                                message = "お宝探しの勘が働き、ほこらの隠し場所から珍しいアイテムを見つけた！";
                                let foundItemIdForHunter;
                                if (prayer.isTransformed) {
                                    if (prayer.role === 'サキュバス') {
                                        foundItemIdForHunter = 'gigantes_ale';
                                    } else if (prayer.role === 'フェアリー') {
                                        foundItemIdForHunter = 'mana_element';
                                    } else if (prayer.role === 'アルラウネ') {
                                        foundItemIdForHunter = 'heart_element';
                                    }
                                } else {
                                    // 変身していない場合はランダムなレアアイテム
                                    const rareItemIdsForHunter = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                    foundItemIdForHunter = rareItemIdsForHunter[Math.floor(Math.random() * rareItemIdsForHunter.length)];
                                }
                                addItemToInventory(foundItemIdForHunter);
                                message += ` (${itemBlueprints[foundItemIdForHunter].name} を手に入れた)`;
                                break;
                            case 'アンドロイド':
                                message = "アンドロイドの祈りが、ほこらのシステムに共鳴する！";
                                await new Promise(resolve => setTimeout(resolve, 1500));
                                message += " システムが最適化され、全員のMPが少し回復した！";
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) await animateStatChange(p, 'mp', Math.ceil(p.maxMp * 0.3), 'increase');
                                }
                                break;
                            case 'メイド':
                                message = "フローラの清らかな祈りに応え、ほこらの周りに可憐な花が咲き乱れた！";
                                await new Promise(resolve => setTimeout(resolve, 1500));
                                message += " 花々の癒やしの香りで、全員のHPが少し回復した！";
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.3), 'increase');
                                }
                                break;
                            case '転生者':
                                const hpIncrease = 30;
                                prayer.maxHp += hpIncrease;
                                await animateStatChange(prayer, 'hp', hpIncrease, 'increase');
                                message = `シロの祈りが天に届き、その身に生命力が満ち溢れる！ (最大HP+${hpIncrease})`;
                                break;
                        }
                        dungeonCommands.classList.remove('hidden');
                        log(message);
                        gameState.party.forEach(p => {
                            if (p.currentHp > 0) flashCard(p, 'green');
                        });
                    }

                    function foundDoubleSizeUp() {
                        generalEventTitle.textContent = "ダブル『サイズ』アップ";
                        generalEventText.textContent = "敵意のない魔物が現れ、ニヤリと笑いながら言った。\n「よう、そこのお嬢さんたち。運試しに自分の『サイズ』を賭けてみないかい？」";
                        generalEventButtons.innerHTML = `
                            <button id="gamble-accept" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">賭ける</button>
                            <button id="gamble-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">断る</button>
                        `;
                        generalEventModal.classList.remove('hidden');

                        document.getElementById('gamble-accept').onclick = () => {
                            generalEventModal.classList.add('hidden');
                            showOneMemberSelectionModal(char => {
                                startSizeGamble(char);
                            }, "誰で勝負する？");
                        };

                        document.getElementById('gamble-decline').onclick = () => {
                            generalEventModal.classList.add('hidden');
                            log("一行は怪しい賭けに乗らず、先へ進んだ。");
                            dungeonCommands.classList.remove('hidden');
                        };
                    }

                    async function startSizeGamble(char, betHeight = 0, currentWin = 0) {
                        // ギャンブラーの特殊処理
                        if (char.role === 'ギャンブラー' && currentWin === 0) {
                            log(`ルナは不敵に笑った。「面白いじゃない。この勝負、乗ったわ！」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log(`ギャンブラーの血が騒ぎ、運命を手繰り寄せた！`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            const growthAmount = char.height * 4;
                            await animateStatChange(char, 'height', growthAmount, 'increase');
                            log(`ルナの身長はなんと5倍になった！`);
                            dungeonCommands.classList.remove('hidden');
                            return;
                        }

                        // ダブルアップではない初回、またはダブルアップをキャンセルした場合
                        if (betHeight === 0) {
                            const choices = [{
                                text: `半分 (${Math.floor(char.height / 2)}cm)`,
                                value: Math.floor(char.height / 2)
                            }, {
                                text: `全部 (${char.height}cm)`,
                                value: char.height
                            }];
                            showAmountChoiceModal('何を賭ける？', `${char.name}の身長を賭けて運試し！`, choices, (chosenBet) => {
                                startSizeGamble(char, chosenBet, 0); // 初回なのでcurrentWinは0
                            });
                            return;
                        }

                        log(`${char.name}は身長${betHeight}cmを賭けて勝負に挑んだ！`);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        if (Math.random() < 0.5) { // 勝利
                            const winAmount = betHeight;
                            const newCurrentWin = currentWin + winAmount;
                            log(`勝利！ 賭けた身長が倍になって返ってきた！ (身長+${winAmount}cm)`);
                            await animateStatChange(char, 'height', winAmount, 'increase');

                            // 2000cmの上限チェック
                            if (char.height + newCurrentWin >= 2000) {
                                log(`これ以上は体がもたないようだ…！勝負はここで打ち止めとなった。`);
                                dungeonCommands.classList.remove('hidden');
                                return;
                            }

                            // ダブルアップの選択
                            generalEventTitle.textContent = "ダブルアップ！";
                            generalEventText.textContent = `魔物「やるじゃないか！勝った分(${newCurrentWin}cm)を全部賭けて、もう一度勝負するかい？」`;
                            generalEventButtons.innerHTML = `
                                <button id="doubleup-accept" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">ダブルアップ！</button>
                                <button id="doubleup-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">やめておく</button>
                            `;
                            generalEventModal.classList.remove('hidden');

                            document.getElementById('doubleup-accept').onclick = () => {
                                generalEventModal.classList.add('hidden');
                                startSizeGamble(char, newCurrentWin, newCurrentWin);
                            };
                            document.getElementById('doubleup-decline').onclick = () => {
                                generalEventModal.classList.add('hidden');
                                log(`${char.name}は慎重に勝ち分を手にして、勝負を降りた。`);
                                dungeonCommands.classList.remove('hidden');
                            };

                        } else { // 敗北
                            log(`敗北…！ 賭けた身長を失ってしまった… (身長-${betHeight}cm)`);
                            await animateStatChange(char, 'height', -betHeight, 'decrease');
                            dungeonCommands.classList.remove('hidden');
                        }
                    }

                    async function foundTreasureRoom() {
                        log("突然、足元が大きく揺れた！ダンジョン全体が揺れているようだ！");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("ゴゴゴ…！ 近くの壁が崩れ、隠されていた扉が現れた！");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("扉の奥には、まばゆいばかりの財宝が山積みになっている！");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        // 分岐条件：身長が初期身長の80%以上で、脱衣状態でないキャラが2人以上いるか
                        const capableMembers = gameState.party.filter(p =>
                            p.currentHp > 0 &&
                            p.height >= p.initialHeight * 0.8 &&
                            !p.statusEffects.stripped
                        );

                        if (capableMembers.length >= 2) {
                            // アイテムを大量に取得する処理
                            log("動ける者たちで手分けして、持ちきれるだけの財宝をバッグに詰めた！");
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const itemsToGet = [{
                                id: 'potion',
                                quantity: 3
                            }, {
                                id: 'mana_potion',
                                quantity: 2
                            }, {
                                id: 'cure_mist',
                                quantity: 1
                            }, {
                                id: 'revive_herb',
                                quantity: 1
                            }];

                            itemsToGet.forEach(item => addItemToInventory(item.id, item.quantity));

                            const itemNames = itemsToGet.map(item => `${itemBlueprints[item.id].name}x${item.quantity}`).join('、');
                            log(`大量のアイテムを手に入れた！ (${itemNames})`);
                            gameState.party.forEach(p => flashCard(p, 'yellow'));

                        } else {
                            // 休憩する処理
                            log("しかし、財宝を運び出せる状態の者がおらず、一行は山積みの財宝を前にしばし休憩することにした…。");
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log("全員のHPとMPが少し回復した。");
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.2), 'increase');
                                await animateStatChange(p, 'mp', Math.ceil(p.maxMp * 0.2), 'increase');
                            }
                        }
                        dungeonCommands.classList.remove('hidden');
                    }

                    function getRandomPartyMember(aliveOnly = true) {
                        const available = aliveOnly ? gameState.party.filter(p => p.currentHp > 0) : gameState.party;
                        return available[Math.floor(Math.random() * available.length)];
                    }

                    function startBattle(isBoss = false, isEnhancedBoss = false, specialEnemyType = null, enemyCountOverride = null) {
                        log(isBoss ? "ボスの気配がする…！" : "敵が現れた！");
                        gameState.inBattle = true;
                        dungeonCommands.classList.add('hidden');
                        emergencyButton.classList.add('battle-active'); // 緊急ボタンを有効化
                        // 模倣の呪いチェック
                        if (gameState.nextBattleIsImitation) {
                            startImitationBattle();
                            gameState.nextBattleIsImitation = false; // フラグをリセット // ファイター, ソーサラー, ナイト, メディック
                            return;
                        } else if (isBoss && isEnhancedBoss === 'star_observer') {
                            startBattle(true, 'star_observer');
                            return;
                        }
                        floorDisplay.classList.add('hidden');
                        gameState.golem = null; // 戦闘開始時にゴーレムをリセット
                        battleCommands.classList.remove('hidden');

                        // 敵の数を計算（サマータイム・スペシャルライブ！では最大3体）
                        let maxEnemyCount = gameState.party.length + 2; // 味方の数 + 2 を上限とする
                        if (gameState.gameMode === 'summer_live') maxEnemyCount = 3;
                        // サイズアップ・ギャンブル！では敵の数を調整
                        if (gameState.gameMode === 'size_up_gamble') {
                            // 1-2体にする
                            maxEnemyCount = 2;
                            // ボス戦フラグが立っている場合はボスを生成
                            if (gameState.nextBattleIsGambleMaster) isBoss = true;
                        }
                        const baseEnemyCount = Math.floor(Math.random() * 2) + 1 + Math.floor(gameState.floor / 10); // 敵の数を計算
                        let enemyCount = enemyCountOverride ? enemyCountOverride : (isBoss ? 1 : Math.min(baseEnemyCount, maxEnemyCount));
                        if (gameState.gameMode === 'secret_night') {
                            enemyCount = 1; // ヒミツの夜モードでは敵は常に1体
                        }

                        gameState.enemies = [];
                        if (isBoss && isEnhancedBoss === 'phantom_hero') {
                            gameState.enemies.push(createEnemy(true, 'phantom_hero'));
                        } else {
                            if (gameState.nextBattleIsGambleMaster) {
                                gameState.enemies.push(createEnemy(true, 'gamble_master'));
                            }
                            for (let i = 0; i < enemyCount; i++) gameState.enemies.push(createEnemy(isBoss, isEnhancedBoss, specialEnemyType));
                        }
                        updateEnemyStatus();

                        const combatants = [...gameState.party.filter(p => p.currentHp > 0), ...gameState.enemies];
                        gameState.turnOrder = combatants.sort((a, b) => {
                            const agiA = a.isEnemy ? a.agi : getEffectiveStats(a).agi;
                            const agiB = b.isEnemy ? b.agi : getEffectiveStats(b).agi;
                            return agiB - agiA;
                        });
                        gameState.currentTurnIndex = 0;

                        setTimeout(() => {
                            nextTurn();
                        }, 1000); // メッセージ表示のための待機
                    }

                    function startImitationBattle() {
                        log("不気味な気配と共に、見慣れた姿の敵が現れた！");
                        gameState.inBattle = true;
                        dungeonCommands.classList.add('hidden');
                        emergencyButton.classList.add('battle-active');
                        floorDisplay.classList.add('hidden');
                        gameState.golem = null;
                        battleCommands.classList.remove('hidden');

                        gameState.enemies = [createImitationEnemy()];
                        updateEnemyStatus();

                        const combatants = [...gameState.party.filter(p => p.currentHp > 0), ...gameState.enemies];
                        gameState.turnOrder = combatants.sort((a, b) => {
                            const agiA = a.isEnemy ? a.agi : getEffectiveStats(a).agi;
                            const agiB = b.isEnemy ? b.agi : getEffectiveStats(b).agi;
                            return agiB - agiA;
                        });
                        gameState.currentTurnIndex = 0;

                        setTimeout(() => {
                            nextTurn();
                        }, 1000);
                    }

                    function createImitationEnemy() {
                        const floor = gameState.floor;
                        const nonUnlockableRoles = ['聖女', 'トレジャーハンター', 'アンドロイド', 'メイド'];
                        const targetBlueprints = allCharacterBlueprints.filter(c => !nonUnlockableRoles.includes(c.role));
                        const blueprint = targetBlueprints[Math.floor(Math.random() * targetBlueprints.length)];

                        const imitation = {
                            name: `模倣体：${blueprint.name}`,
                            maxHp: 1000 + floor * 25,
                            currentHp: 1000 + floor * 25,
                            atk: 35 + Math.floor(floor * 1.5),
                            pDef: 20 + floor,
                            mDef: 20 + floor,
                            agi: 15 + Math.floor(floor / 2),
                            isEnemy: true,
                            isBoss: true, // ボス扱い
                            buffs: {},
                            statusEffects: {},
                            skills: blueprint.skills.map(s => ({...s,
                                originalType: s.type
                            })), // 元のスキル情報を保持
                            specialAIType: 'imitation',
                            originalBlueprint: blueprint, // AIで参照するために元のブループリントを保持
                        };
                        return imitation;
                    }

                    function createEnemy(isBoss, isEnhanced = false, specialEnemyType = null) {
                        let floor = gameState.floor;

                        // パーティ人数による敵ステータスの補正計算 (1人減るごとに10%低下)
                        // 終焉モードでは敵のステータス補正を2倍にする
                        if (gameState.gameMode === 'endgame_plus') {
                            floor *= 2;
                        }

                        const partySize = gameState.party.length;
                        const reductionFactor = Math.max(0, (4 - partySize) * 0.1);
                        let statMultiplier = 1 - reductionFactor;

                        // 特定モードでのフロア補正
                        if (gameState.gameMode === 'summer_live' || gameState.gameMode === 'tensei_rinne') {
                            // ボス階層の判定を正しく行うため、gameState.floorを直接参照
                            // 通常敵の強さ調整は、この後の処理で行う（statMultiplierを調整）
                            floor = gameState.floor;
                        }

                        // ヒミツの夜モードでの敵ステータス弱体化
                        if (gameState.gameMode === 'secret_night') {
                            statMultiplier *= 0.3;
                        }
                        // 転生輪廻モードでの敵ステータス強化
                        if (gameState.gameMode === 'tensei_rinne') {
                            statMultiplier *= 1.2; // 敵のステータスを20%強化
                        }


                        if (isBoss && isEnhanced === 'phantom_hero') {
                            return {
                                name: '英雄の幻影', // ファイター, ソーサラー, ナイト, メディック
                                maxHp: 2000 + floor * 30,
                                currentHp: 2000 + floor * 30,
                                atk: 50 + Math.floor(floor * 1.8),
                                pDef: 25 + floor,
                                mDef: 25 + floor,
                                agi: 25 + Math.floor(floor / 2),
                                height: 180,
                                buffs: {},
                                isEnemy: true,
                                isBoss: true,
                                statusEffects: {},
                                skills: [{
                                    name: 'フォーカス',
                                    func: focusSkill
                                }, {
                                    name: 'チェインロック',
                                    func: chainLockSkill
                                }, {
                                    name: 'ヒロイックエンド',
                                    func: heroicEndSkill
                                }, ],
                                specialAIType: 'phantom_hero'
                            };
                        }
                        if (isBoss && isEnhanced === 'gamble_master') {
                            return {
                                name: 'ギャンブルマスター',
                                maxHp: 3000 + floor * 40,
                                currentHp: 3000 + floor * 40,
                                atk: 60 + Math.floor(floor * 2.0),
                                pDef: 30 + floor,
                                mDef: 30 + floor,
                                agi: 30 + Math.floor(floor / 2),
                                height: 500,
                                buffs: {},
                                isEnemy: true,
                                isBoss: true,
                                statusEffects: {},
                                skills: [{
                                        name: 'オールイン',
                                        func: (enemy, target) => handleTroubleMakerBox(enemy, true)
                                    }, // 敵用のハプニングボックス
                                    {
                                        name: 'ハイリスク・ハイリターン',
                                        func: highRiskHighReturnSkill
                                    }
                                ],
                            };
                        }
                        if (isBoss && isEnhanced === 'star_observer') {
                            return {
                                name: '星の観測者',
                                maxHp: 1500 + floor * 25,
                                currentHp: 1500 + floor * 25,
                                atk: 45 + Math.floor(floor * 1.6),
                                pDef: 22 + floor,
                                mDef: 22 + floor,
                                agi: 28 + Math.floor(floor / 2),
                                height: 500, // 巨大な存在
                                isEnemy: true,
                                isBoss: true,
                                buffs: {},
                                statusEffects: {},
                                specialAIType: 'star_observer',
                                turnCount: 0, // ターンカウントを追加
                                skills: [ // スキルを追加
                                    {
                                        name: '瞬き',
                                        func: blinkSkill
                                    }, {
                                        name: 'ブラックホール',
                                        func: blackholeSkill
                                    }
                                ]
                            };
                        }
                        if (isBoss && gameState.gameMode === 'endgame_plus' && gameState.floor === 90) {
                            return {
                                name: '終刻の魔王',
                                maxHp: 9999,
                                currentHp: 9999,
                                atk: 80 + Math.floor(floor * 2.0),
                                pDef: 50 + floor,
                                mDef: 50 + floor,
                                agi: 35 + Math.floor(floor / 2),
                                height: 9999, // 計測不能
                                buffs: {},
                                isEnemy: true,
                                isBoss: true,
                                statusEffects: {},
                                skills: [{
                                    name: '終末の宣告',
                                    func: finalBossSkill
                                }],
                                specialAIType: 'final_boss'
                            };
                        }

                        if (isBoss) {
                            if (isEnhanced) {
                                return {
                                    name: '【覚醒】ダンジョンマスター',
                                    maxHp: 1200 + floor * 20,
                                    currentHp: 1200 + floor * 20,
                                    atk: 40 + Math.floor(floor * 1.5),
                                    pDef: 30 + Math.floor(floor * 1.0),
                                    mDef: 20 + Math.floor(floor * 1.0),
                                    agi: 20,
                                    height: 250,
                                    isEnemy: true,
                                    buffs: {},
                                    statusEffects: {},
                                    skills: [{
                                        name: 'フォーカス',
                                        func: focusSkill
                                    }, {
                                        name: 'チェインロック',
                                        func: chainLockSkill
                                    }, {
                                        name: 'カタストロフィ',
                                        func: sweepAttack,
                                        type: 'physical'
                                    }, {
                                        name: '縮小ビーム',
                                        func: shrinkBeam,
                                        type: 'utility'
                                    }, ],
                                    usedFocus: false, // フォーカス使用フラグ
                                    usedHeroicEnd: false, // ヒロイックエンド使用フラグ
                                };
                            }
                            const bossBlueprints = [{
                                name: 'ダンジョンマスター',
                                maxHp: 750,
                                atk: 30,
                                pDef: 25,
                                mDef: 15,
                                agi: 15,
                                height: 200,
                                skills: [{
                                    name: '縮小ビーム',
                                    func: shrinkBeam,
                                    type: 'utility'
                                }, {
                                    name: 'なぎ払い',
                                    func: sweepAttack,
                                    type: 'physical'
                                }, ]
                            }, {
                                name: 'カオスゴーレム',
                                maxHp: 900,
                                atk: 35,
                                pDef: 35,
                                mDef: 5,
                                agi: 10,
                                height: 300,
                                skills: [{
                                    name: '状態異常攻撃',
                                    func: inflictStatusEffect,
                                    type: 'utility'
                                }, {
                                    name: 'なぎ払い',
                                    func: sweepAttack,
                                    type: 'physical'
                                }, ]
                            }, {
                                name: 'アークリッチ',
                                maxHp: 900, // HPを50%増加
                                atk: 25,
                                pDef: 10,
                                mDef: 30,
                                agi: 20,
                                height: 180,
                                skills: [{
                                    name: 'いたずら',
                                    type: 'utility'
                                }, ]
                            }];
                            const blueprint = bossBlueprints[Math.floor(Math.random() * bossBlueprints.length)];
                            const boss = {
                                ...blueprint,
                                isEnemy: true,
                                isBoss: true,
                                turnCount: 0, // ターンカウント用
                                buffs: {},
                                statusEffects: {},
                                regenUses: 0, // 自己再生の使用回数カウンター 
                            };

                            // ステータスに補正を適用
                            boss.maxHp = Math.ceil((boss.maxHp + floor * 15) * statMultiplier);
                            boss.currentHp = boss.maxHp;
                            boss.atk = Math.ceil((boss.atk + Math.ceil(floor * 1.2)) * statMultiplier);
                            boss.pDef = Math.ceil((boss.pDef + Math.ceil(floor * 0.8)) * statMultiplier);
                            boss.mDef = Math.ceil((boss.mDef + Math.ceil(floor * 0.8)) * statMultiplier);

                            // サマータイム・スペシャルライブ！または転生輪廻モードでのボス調整
                            if (gameState.gameMode === 'summer_live' || gameState.gameMode === 'tensei_rinne') {
                                boss.maxHp = Math.ceil(boss.maxHp * 0.8); // HPを20%削減
                                // 通常敵の強さ調整と同様に、フロア補正をここで行う
                                const modeMultiplier = gameState.gameMode === 'summer_live' ? 0.6 : 1.0;
                                const summerFloor = Math.floor(gameState.floor * modeMultiplier);
                                boss.maxHp = Math.ceil((boss.maxHp + summerFloor * 15) * statMultiplier);
                                boss.atk = Math.ceil((boss.atk + Math.ceil(summerFloor * 1.2)) * statMultiplier);

                                boss.currentHp = boss.maxHp;
                                boss.atk = Math.ceil(boss.atk * 0.85); // 攻撃力を15%削減
                            }
                            // agiは補正対象外

                            // サマータイム・スペシャルライブ！の専用ボス
                            // ボスのサイズバリエーション
                            if (gameState.floor >= 16) {
                                const variantRoll = Math.random();
                                if (variantRoll < 0.1) { // 10%で巨大化
                                    boss.name = `【巨体の】${boss.name}`;
                                    boss.height = Math.ceil(boss.height * 1.5);
                                    boss.atk = Math.ceil(boss.atk * 1.2);
                                    boss.pDef = Math.ceil(boss.pDef * 1.2);
                                    boss.mDef = Math.ceil(boss.mDef * 1.2);
                                    boss.agi = Math.ceil(boss.agi * 0.8);
                                } else if (variantRoll < 0.2) { // 10%で縮小化
                                    boss.name = `【幼体】${boss.name}`;
                                    boss.height = Math.ceil(boss.height * 0.5);
                                    boss.atk = Math.ceil(boss.atk * 0.8);
                                    boss.pDef = Math.ceil(boss.pDef * 0.8);
                                    boss.mDef = Math.ceil(boss.mDef * 0.8);
                                    boss.agi = Math.ceil(boss.agi * 1.2);
                                }
                            }
                            if (gameState.gameMode === 'summer_live') {
                                if (floor === 30) {
                                    boss.name = 'ビーチシャーク';
                                    boss.maxHp = Math.ceil(800 * statMultiplier);
                                    boss.currentHp = boss.maxHp;
                                    boss.atk = Math.ceil(32 * statMultiplier);
                                    boss.pDef = Math.ceil((25 + Math.floor(floor * 0.6) * 0.8) * 3.0 * statMultiplier); // 物理防御が極端に高い
                                    boss.mDef = Math.ceil(Math.max(1, (15 + Math.floor(floor * 0.6) * 0.8) * 0.1) * statMultiplier); // 魔法防御が非常に低い
                                    boss.agi = 18;
                                    boss.height = 250,
                                        boss.skills = []; // スキルなし
                                } else if (floor === 60) {
                                    boss.name = 'アクアドラゴン';
                                    boss.maxHp = Math.ceil(1500 * statMultiplier);
                                    boss.currentHp = boss.maxHp;
                                    boss.atk = Math.ceil(45 * statMultiplier);
                                    boss.pDef = Math.ceil((30 + Math.floor(floor * 0.6) * 1.0) * 0.5 * statMultiplier); // 物理防御が低い
                                    boss.mDef = Math.ceil((20 + Math.floor(floor * 0.6) * 1.0) * 1.0 * statMultiplier);
                                    boss.agi = 22;
                                    boss.height = 800,
                                        boss.skills = [{
                                            name: 'ミニマムシャワー',
                                            func: minimumShower
                                        }];
                                    boss.specialAIType = 'aqua_dragon'; // 特殊AIタイプを設定
                                }
                            }

                            // 終焉モードの固定ボス
                            if (gameState.gameMode === 'endgame_plus') {
                                if (floor === 30) {
                                    return createEnemy(true, 'phantom_hero');
                                } else if (floor === 60) {
                                    return createEnemy(true, 'star_observer');
                                } else if (floor === 90) {
                                    // 終刻の魔王は上で定義済み
                                }
                            }

                            return boss;
                        }
                        const enemyBlueprints = [{
                                name: 'スライム',
                                pDefRatio: 0.8, // 物理に弱く、魔法に強い
                                mDefRatio: 1.2,
                                baseAgi: 14, // 普通
                                height: 50
                            }, // 物理に弱く、魔法に強い
                            {
                                name: 'ゴブリン',
                                pDefRatio: 1.2, // 物理に強く、魔法に弱い
                                mDefRatio: 0.8,
                                baseAgi: 8, // 遅い
                                height: 100
                            }, // 物理に強く、魔法に弱い
                            {
                                name: 'コウモリ',
                                pDefRatio: 1.0, // 平均的
                                mDefRatio: 1.0,
                                baseAgi: 20, // 速い
                                height: 30
                            }, // 平均的
                            {
                                name: 'スケルトン',
                                pDefRatio: 1.5, // 物理にとても強く、魔法にとても弱い
                                mDefRatio: 0.5,
                                baseAgi: 9, // 遅い
                                height: 170
                            }, // 物理にとても強く、魔法にとても弱い
                            {
                                name: 'ウィスプ',
                                pDefRatio: 0.7, // 状態異常を使う
                                mDefRatio: 1.5,
                                baseAgi: 22, // 速い
                                height: 40
                            }, // 状態異常を使う
                            {
                                name: 'リトルメイジ',
                                pDefRatio: 0.8,
                                mDefRatio: 1.2,
                                baseAgi: 15, // 普通
                                height: 120
                            }, {
                                name: 'インプ',
                                pDefRatio: 0.9,
                                mDefRatio: 1.1,
                                baseAgi: 18, // 速い
                                height: 80
                            }, {
                                name: 'リトルデーモン',
                                pDefRatio: 1.1,
                                mDefRatio: 1.1,
                                baseAgi: 16, // 少し速め
                                height: 60,
                                skills: [{
                                    name: 'ミニマムレイ',
                                    func: shrinkToOneSkill
                                }]
                            },
                        ];

                        let availableBlueprints = enemyBlueprints;
                        // 5階の戦闘ではスキルを持たない敵のみ出現させる
                        if (floor === 5) {
                            availableBlueprints = enemyBlueprints.filter(bp => bp.name !== 'ウィスプ' && bp.name !== 'リトルメイジ' && bp.name !== 'インプ');
                        }
                        const blueprint = availableBlueprints[Math.floor(Math.random() * availableBlueprints.length)];
                        const baseDef = 5 + floor * 0.8;
                        // 敵の素早さに揺らぎを追加
                        const agiFluctuation = Math.floor(Math.random() * 5) - 2; // -2から+2の揺らぎ
                        const finalAgi = Math.max(1, blueprint.baseAgi + agiFluctuation);

                        // ステータスに補正を適用
                        const finalMaxHp = Math.ceil((45 + Math.ceil(floor * 8)) * statMultiplier);
                        const finalAtk = Math.ceil((10 + Math.ceil(floor * 1.2)) * statMultiplier);
                        const finalPDef = Math.ceil(Math.max(1, Math.ceil(baseDef * blueprint.pDefRatio)) * statMultiplier);
                        const finalMDef = Math.ceil(Math.max(1, Math.ceil(baseDef * blueprint.mDefRatio)) * statMultiplier);

                        // 特定モードでの通常敵の強さ調整
                        if (gameState.gameMode === 'summer_live' || gameState.gameMode === 'tensei_rinne') {
                            const modeMultiplier = gameState.gameMode === 'summer_live' ? 0.6 : 1.0;
                            floor = Math.floor(gameState.floor * modeMultiplier);
                        }

                        const enemy = {
                            name: blueprint.name,
                            maxHp: finalMaxHp,
                            currentHp: finalMaxHp,
                            atk: finalAtk,
                            pDef: finalPDef,
                            mDef: finalMDef,
                            agi: finalAgi,
                            height: blueprint.height,
                            isEnemy: true,
                            buffs: {},
                            skills: (blueprint.name === 'ウィスプ') ? [{
                                    name: '状態異常攻撃',
                                    func: inflictStatusEffect
                                }] :
                                (blueprint.name === 'リトルメイジ') ? [{
                                    name: '縮小ビーム',
                                    func: shrinkBeam
                                }] :
                                (blueprint.name === 'インプ') ? [{
                                    name: 'いたずら' // funcはenemyTurnで直接処理
                                }] : [],
                            statusEffects: {},
                            // インプ専用フラグ
                            mischiefUsed: false,
                            focusedTargetId: null,
                        };

                        // 16階以降でサイズバリエーションを追加
                        if (gameState.floor >= 16) {
                            const variantRoll = Math.random() * 100; // 0-100の乱数
                            if (variantRoll < 5) { // 5%
                                enemy.name = `【狂暴な】${enemy.name}`;
                                enemy.atk = Math.ceil(enemy.atk * 1.5);
                                enemy.pDef = Math.ceil(enemy.pDef * 0.7);
                                enemy.mDef = Math.ceil(enemy.mDef * 0.7);
                            } else if (variantRoll < 10) { // 5%
                                enemy.name = `【堅牢な】${enemy.name}`;
                                enemy.pDef = Math.ceil(enemy.pDef * 1.5);
                                enemy.mDef = Math.ceil(enemy.mDef * 1.5);
                                enemy.agi = Math.ceil(enemy.agi * 0.7);
                            } else if (variantRoll < 15) { // 5%
                                enemy.name = `【俊敏な】${enemy.name}`;
                                enemy.agi = Math.ceil(enemy.agi * 1.5);
                                enemy.atk = Math.ceil(enemy.atk * 0.7);
                            } else if (variantRoll < 20) { // 5%
                                enemy.name = `【毒纏い】${enemy.name}`;
                                // 特殊能力は enemyTurn で処理
                            } else if (variantRoll < 25) { // 5%
                                enemy.name = `【痺れる】${enemy.name}`;
                                // 特殊能力は enemyTurn で処理
                            } else if (variantRoll < 30) { // 5%
                                enemy.name = `【輝く】${enemy.name}`;
                                enemy.atk = Math.ceil(enemy.atk * 1.1);
                                enemy.pDef = Math.ceil(enemy.pDef * 1.1);
                                enemy.mDef = Math.ceil(enemy.mDef * 1.1);
                                enemy.agi = Math.ceil(enemy.agi * 1.1);
                                enemy.maxHp = Math.ceil(enemy.maxHp * 0.7);
                                enemy.currentHp = enemy.maxHp;
                            } else if (variantRoll < 35) { // 5%
                                enemy.name = `【巨大な】${enemy.name}`;
                                enemy.height = Math.ceil(enemy.height * 1.5);
                                enemy.atk = Math.ceil(enemy.atk * 1.2);
                                enemy.pDef = Math.ceil(enemy.pDef * 1.2);
                                enemy.mDef = Math.ceil(enemy.mDef * 1.2);
                                enemy.agi = Math.ceil(enemy.agi * 0.8);
                            } else if (variantRoll < 40) { // 5%
                                enemy.name = `【小さな】${enemy.name}`;
                                enemy.height = Math.ceil(enemy.height * 0.5);
                                enemy.atk = Math.ceil(enemy.atk * 0.8);
                                enemy.pDef = Math.ceil(enemy.pDef * 0.8);
                                enemy.mDef = Math.ceil(enemy.mDef * 0.8);
                                enemy.agi = Math.ceil(enemy.agi * 1.2);
                            }
                        }
                        return enemy;
                    }

                    // createEnemy の直後に配置
                    function applyMicroModification(enemy) {
                        enemy.name = `【ミクロ】${enemy.name}`;
                        enemy.atk = Math.max(1, Math.ceil(enemy.atk * 0.1));
                        enemy.pDef = Math.max(1, Math.ceil(enemy.pDef * 0.1));
                        enemy.mDef = Math.max(1, Math.ceil(enemy.mDef * 0.1));
                        enemy.agi = Math.ceil(enemy.agi * 3);
                        enemy.height = 1;
                    }

                    function shrinkBeam(enemy) {
                        const target = findTarget(enemy);
                        let shrinkAmount = Math.ceil(Math.random() * 10) + 5;
                        // 挑発中の相手には効果半減
                        if (target.buffs && target.buffs.provoke) {
                            shrinkAmount = Math.ceil(shrinkAmount / 2);
                            log(`${target.name}は挑発でビームの威力を弱めた！`);
                        }
                        animateStatChange(target, 'height', -shrinkAmount, 'decrease');
                        flashCard(target, 'yellow', 'enemy');
                        log(`${enemy.name}は${target.name}に縮小ビームを放った！身長が${shrinkAmount}cm縮んだ！`);
                        updatePartyStatus();
                    }

                    function focusSkill(enemy) {
                        enemy.buffs = enemy.buffs || {};
                        enemy.buffs.atk_up = 3;
                        flashCard(enemy, 'yellow');
                        log(`${enemy.name}は${enemy.skills[0].name}で精神を集中！攻撃力が大幅に上昇！`);
                    }

                    async function chainLockSkill(enemy) {
                        // 龍神の加護チェック (全体)
                        if (gameState.party.every(p => p.blessings && p.blessings.dragon_god_grace && p.height > 1000)) {
                            log(`${enemy.name}はチェインロックを放ったが、龍神の加護によって全員が鎖を弾き返した！`);
                            return;
                        }

                        const target = findTarget(enemy);
                        if (target.isWall || target === gameState.golem) {
                            log(`${enemy.name}はチェインロックを放ったが、無機物には効果がなかった！`);
                            return;
                        }
                        log(`${enemy.name}は${enemy.skills[1].name}を放った！`);
                        for (const target of gameState.party.filter(p => p.currentHp > 0)) {
                            if (target.blessings && target.blessings.dragon_god_grace && target.height > 1000) {
                                log(`${target.name}は龍神の加護によって鎖を弾き返した！`);
                                continue;
                            }
                            if (Math.random() < 0.5) { // 50%の確率で鈍化
                                target.statusEffects.slow = {
                                    turns: 3
                                };
                                log(`${target.name}は鎖に捕らえられ、動きが鈍くなった！`);
                            }
                        }
                    }

                    async function inflictStripped(enemy, target) {
                        // 対象がナイト、サムライ、聖女、または防御中の場合、スキルは失敗
                        // 龍神の加護チェック
                        if (target.blessings && target.blessings.dragon_god_grace && target.height > 1000) {
                            log(`${enemy.name}は${target.name}にいたずらを仕掛けたが、龍神の加護によって防がれた！`);
                            return false;
                        }

                        const immuneRoles = ['ナイト', 'サムライ', '聖女', 'アンドロイド'];
                        if (immuneRoles.includes(target.role) || target.isDefending || target.isWall || target === gameState.golem) {
                            const targetDisplayName = target.isWall ? '防壁' : target.name;
                            log(`${enemy.name}は${targetDisplayName}にいたずらを仕掛けたが、効果がなかった！`);
                            return false; // 行動しなかったことを示す
                        }

                        // 成功率の計算 (小さいほど成功しやすい)
                        let successRate = 0.1; // 基本成功率10%
                        const heightDiff = target.initialHeight - target.height;
                        enemy.mischiefUsed = true; // スキル使用済みフラグを立てる

                        if (heightDiff > 0) {
                            // 初期身長からどれだけ小さいかの割合に応じて成功率アップ
                            successRate += (heightDiff / target.initialHeight) * 0.2;
                        }
                        successRate = Math.min(0.3, successRate); // 上限30%

                        if (Math.random() < successRate) {
                            // 成功
                            target.statusEffects.stripped = {
                                turns: 0
                            };
                            enemy.focusedTargetId = gameState.party.indexOf(target); // ターゲットを固定
                            flashCard(target, 'yellow');
                            log(`${enemy.name}のいたずらが成功！ ${target.name}は恥ずかしい格好になってしまった！`);
                            log(`${enemy.name}は${target.name}に執着し始めたようだ…`);
                        } else {
                            // 失敗
                            log(`${enemy.name}はいたずらを仕掛けたが、${target.name}には通用しなかった！`);
                        }
                        updatePartyStatus();
                        return true; // 行動したことを示す
                    }

                    async function inflictStrippedForArchlich(enemy, target) {
                        // 対象がナイト、サムライ、聖女、または防御中の場合、スキルは失敗
                        // 龍神の加護チェック
                        if (target.blessings && target.blessings.dragon_god_grace && target.height > 1000) {
                            log(`${enemy.name}は${target.name}にいたずらを仕掛けたが、龍神の加護によって防がれた！`);
                            return;
                        }

                        const immuneRoles = ['ナイト', 'サムライ', '聖女', 'アンドロイド'];
                        if (immuneRoles.includes(target.role) || target.isDefending || target.isWall || target === gameState.golem) {
                            const targetDisplayName = target.isWall ? '防壁' : target.name;
                            log(`${enemy.name}は${targetDisplayName}にいたずらを仕掛けたが、効果がなかった！`);
                            return; // 何もせずターン終了
                        }

                        // 成功率の計算 (小さいほど成功しやすい、最大50%)
                        let successRate = 0.2; // 基本成功率20%
                        const heightDiff = target.initialHeight - target.height;
                        if (heightDiff > 0) {
                            // 初期身長からどれだけ小さいかの割合に応じて成功率アップ
                            successRate += (heightDiff / target.initialHeight) * 0.3;
                        }
                        successRate = Math.min(0.5, successRate); // 上限50%

                        if (Math.random() < successRate) {
                            // 成功
                            target.statusEffects.stripped = {
                                turns: 0
                            };
                            flashCard(target, 'yellow');
                            log(`${enemy.name}の邪悪ないたずらが成功！ ${target.name}は恥ずかしい格好になってしまった！`);
                        } else {
                            // 失敗
                            log(`${enemy.name}はいたずらを仕掛けたが、${target.name}には通用しなかった！`);
                        }
                        updatePartyStatus();
                    }

                    async function shrinkToOneSkill(enemy, target) {
                        if (target.isWall || target === gameState.golem) {
                            log(`${enemy.name}は${target.name}にミニマムレイを放ったが、効果がなかった！`);
                            return;
                        }
                        if (target.heightLocked) {
                            log(`${enemy.name}は${target.name}にミニマムレイを放ったが、不思議な力で防がれた！`);
                            return;
                        }

                        log(`${enemy.name}は${target.name}にミニマムレイを放った！`);

                        // 戦闘中のみ有効な身長変更デバフを付与
                        target.statusEffects.shrunkToOne = true;

                        flashCard(target, 'yellow');
                        log(`${target.name}の体がみるみる縮んで、身長が1cmになってしまった！`);
                    }

                    async function minimumShower(enemy) {
                        log(`${enemy.name}はミニマムシャワーを放った！パーティ全員の体が縮んでしまった！`);
                        const shrinkAmount = 50;
                        for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                            if (p.heightLocked) {
                                log(`${p.name}は不思議な力で守られ、体の変化を防いだ！`);
                                continue;
                            }
                            await animateStatChange(p, 'height', -shrinkAmount, 'decrease', 'enemy');
                        }
                    }

                    function inflictStatusEffect(enemy, target) {
                        // 龍神の加護チェック
                        if (target.blessings && target.blessings.dragon_god_grace && target.height > 1000) {
                            log(`${target.name}は龍神の加護によって状態異常を弾いた！`);
                            return;
                        }

                        const effect = ['poison', 'paralysis', 'slow'][Math.floor(Math.random() * 3)];
                        let effectName = '',
                            duration = 0;
                        switch (effect) {
                            case 'poison':
                                effectName = '毒';
                                duration = 3;
                                target.statusEffects.poison = {
                                    turns: duration
                                };
                                break;
                            case 'paralysis':
                                effectName = '麻痺';
                                target.statusEffects.paralysis = true;
                                break;
                            case 'slow':
                                effectName = '鈍化';
                                duration = 3;
                                target.statusEffects.slow = {
                                    turns: duration
                                };
                                break;
                        }
                        flashCard(target, 'yellow');
                        log(`${enemy.name}の攻撃！ ${target.name}は${effectName}状態になった！`);
                    }

                    async function inflictRegeneration(enemy) {
                        // この関数はインプから削除されたため、他の敵が使う可能性を考慮して残す
                        if (enemy.regenUses < 3) {
                            enemy.regenUses++;
                            enemy.statusEffects.regeneration = {
                                turns: 3
                            };
                            flashCard(enemy, 'green');
                            log(`${enemy.name}は傷が再生し始めた！`);
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        } else {
                            log(`${enemy.name}は自己再生しようとしたが、力を使い果たしていた！`);
                        }
                    }

                    async function sweepAttack(enemy) {
                        log(`${enemy.name}のなぎ払い！`);
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        const damagePromises = [];
                        for (const member of aliveParty) {
                            const damage = calculateDamage(enemy, member, {
                                power: 1.0,
                                type: 'physical'
                            });
                            damagePromises.push(dealDamage(member, damage));
                        }
                        // 全員へのダメージ処理を並行して実行し、完了を待つ
                        await Promise.all(damagePromises);
                    }

                    async function nextTurn() {
                        let currentActor = gameState.turnOrder[gameState.currentTurnIndex];

                        // HPが0以下のキャラクターは行動できない
                        if (currentActor.currentHp <= 0) {
                            gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                            nextTurn();
                            return;
                        }

                        // 祝福「肥大する心身」「捻じ曲がった記憶」の効果
                        if (!currentActor.isEnemy && currentActor.currentHp > 0 && !currentActor.heightLocked) {
                            if (currentActor.blessings && currentActor.blessings.twisted_memory) {
                                const newHeight = Math.max(1, Math.floor(currentActor.height / 2));
                                const change = newHeight - currentActor.height;
                                if (change !== 0) {
                                    log(`${currentActor.name}の捻じ曲がった記憶が、その体を蝕む…！`);
                                    await animateStatChange(currentActor, 'height', change, 'decrease');
                                }
                            } else if (currentActor.blessings && currentActor.blessings.swelling_body) {
                                const change = currentActor.height;
                                // 上限2000cm
                                if (currentActor.height + change > 2000) {
                                    const cappedChange = 2000 - currentActor.height;
                                    if (cappedChange > 0) {
                                        log(`${currentActor.name}の心身が肥大し、成長の限界に達した！`);
                                        await animateStatChange(currentActor, 'height', cappedChange, 'increase');
                                    }
                                } else {
                                    log(`${currentActor.name}の心身が肥大し、体が膨れ上がっていく…！`);
                                    await animateStatChange(currentActor, 'height', change, 'increase');
                                }
                            }
                        }


                        // テンションアップのダメージ
                        if (currentActor.buffs && currentActor.buffs.tension_up && currentActor.currentHp > 0) {
                            const damage = Math.max(1, Math.floor(currentActor.maxHp * 0.05));
                            log(`${currentActor.name}はテンションが上がりすぎて、少しダメージを受けた！`);
                            await dealDamage(currentActor, damage);
                            if (currentActor.currentHp <= 0) return; // ダメージで倒れたらターン終了
                        }

                        // 聖女のターン開始時回復
                        if (!currentActor.isEnemy && currentActor.role === '聖女' && currentActor.currentHp > 0) {
                            const hpHeal = Math.max(1, Math.floor(currentActor.maxHp * 0.05));
                            const mpHeal = Math.max(1, Math.floor(currentActor.maxMp * 0.05));
                            animateStatChange(currentActor, 'hp', hpHeal, 'increase');
                            animateStatChange(currentActor, 'mp', mpHeal, 'increase');
                        }

                        // ターン開始時MP回復 (聖女と変身中のトレジャーハンターを除く)
                        if (!currentActor.isEnemy && currentActor.role !== '聖女' && !currentActor.isTransformed && currentActor.currentMp < currentActor.maxMp) {
                            animateStatChange(currentActor, 'mp', 1, 'increase');
                        }

                        // 祝福「願いの少女」「祈りの少女」の効果
                        if (!currentActor.isEnemy && currentActor.blessings) {
                            if (currentActor.blessings.wish_girl) {
                                log(`${currentActor.name}の肩に乗った願いの少女が、星に願いをかける！`);
                                await new Promise(resolve => setTimeout(resolve, 1000));
                                const power = Math.max(0.1, (currentActor.height / 150) * 0.5); // 身長150cmで威力0.5
                                const damagePromises = [];
                                for (const enemy of gameState.enemies.filter(e => e.currentHp > 0)) {
                                    const damage = calculateDamage(currentActor, enemy, {
                                        type: 'physical',
                                        power: power
                                    });
                                    damagePromises.push(dealDamage(enemy, damage));
                                }
                                await Promise.all(damagePromises);
                                log(`流星群が敵全体を襲った！`);
                                if (gameState.enemies.every(e => e.currentHp <= 0)) {
                                    endBattle(true);
                                    return;
                                }
                            } else if (currentActor.blessings.pray_girl) {
                                log(`${currentActor.name}の肩に乗った祈りの少女が、天に祈りを捧げる！`);
                                await new Promise(resolve => setTimeout(resolve, 1000));
                                const power = Math.max(0.1, (150 / Math.max(1, currentActor.height)) * 1.5); // 身長1cmで威力225相当
                                const damagePromises = [];
                                for (const enemy of gameState.enemies.filter(e => e.currentHp > 0)) {
                                    const damage = calculateDamage(currentActor, enemy, {
                                        type: 'magic',
                                        power: power
                                    });
                                    damagePromises.push(dealDamage(enemy, damage));
                                }
                                await Promise.all(damagePromises);
                                log(`聖なる光が敵全体を浄化した！`);
                                if (gameState.enemies.every(e => e.currentHp <= 0)) {
                                    endBattle(true);
                                    return;
                                }
                            }
                        }

                        // バフのターン経過
                        if (currentActor.buffs) {
                            Object.keys(currentActor.buffs).forEach(key => {
                                currentActor.buffs[key]--; // ファイター, ソーサラー, ナイト, メディック
                                // MP自動回復効果
                                if (key === 'mp_regen_once' && currentActor.buffs[key] <= 0) {
                                    animateStatChange(currentActor, 'mp', Math.ceil(currentActor.maxMp * 0.2), 'increase');
                                }
                                if (currentActor.buffs[key] <= 0) {
                                    delete currentActor.buffs[key];
                                    if (!currentActor.isEnemy) {
                                        let buffName = '';
                                        if (key === 'protect') buffName = '防御アップ';
                                        else if (key === 'atk_up') buffName = '攻撃アップ';
                                        else if (key === 'provoke') buffName = '挑発';
                                        if (buffName) {
                                            flashCard(currentActor, 'yellow');
                                            log(`${currentActor.name}の${buffName}効果が切れた。`);
                                        }
                                    }
                                }
                            });
                        }
                        // 状態異常のターン経過
                        if (currentActor.statusEffects) {
                            // 脱衣状態の経過ターンを増やす
                            if (currentActor.statusEffects.stripped && gameState.gameMode !== 'indecent' && !currentActor.isLiberatedStripped) {
                                const failChance = Math.max(0, 0.3 - (currentActor.statusEffects.stripped.turns * 0.05));
                                if (failChance > 0) {
                                    currentActor.statusEffects.stripped.turns++;
                                    log(`${currentActor.name}はだんだん恥ずかしさに慣れてきた…`);
                                }
                            }
                            ['poison', 'slow', 'regeneration'].forEach(effect => {
                                if (currentActor.statusEffects[effect]) {
                                    currentActor.statusEffects[effect].turns--;
                                    if (currentActor.statusEffects[effect].turns <= 0) {
                                        delete currentActor.statusEffects[effect];
                                        if (!currentActor.isEnemy) {
                                            const effectName = effect === 'poison' ? '毒' : '鈍化';
                                            flashCard(currentActor, 'yellow');
                                            log(`${currentActor.name}の${effectName}が治った。`);
                                        }
                                    }
                                }
                            });
                        }

                        if (currentActor.isDefending) currentActor.isDefending = false;

                        if (gameState.enemies.every(e => e.currentHp <= 0)) {
                            endBattle(true);
                            return;
                        }
                        if (gameState.party.every(p => p.currentHp <= 0)) {
                            endBattle(false);
                            return;
                        }

                        let actor = gameState.turnOrder[gameState.currentTurnIndex];

                        // 脱衣チェック (ナイト、サムライ、モンク、トレジャーハンターとその変身は対象外)
                        const immuneToShameRoles = ['ナイト', 'サムライ', 'モンク', 'トレジャーハンター', 'サキュバス', 'フェアリー', 'アルラウネ'];

                        if (actor.statusEffects && actor.statusEffects.stripped && !immuneToShameRoles.includes(actor.role) && !actor.isLiberatedStripped) {
                            let failChance = 0;
                            if (gameState.gameMode === 'indecent') {
                                failChance = 0.3; // 確率が減少しない
                            } else {
                                failChance = Math.max(0, 0.3 - (actor.statusEffects.stripped.turns * 0.05)); // ターン経過で確率低下
                            }

                            if (Math.random() < failChance) {
                                const messages = ["は、恥ずかしくて動けない…！", "こ、こんな格好じゃ集中できない…！", "だ、だめ、見ないで…！"];
                                log(`${actor.name}「${messages[Math.floor(Math.random() * messages.length)]}」`);
                                flashCard(actor, 'yellow');
                                setTimeout(() => {
                                    gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                    nextTurn();
                                }, 1000);
                                return;
                            }
                        }

                        // 麻痺チェック
                        if (currentActor.statusEffects && currentActor.statusEffects.paralysis) {
                            log(`${currentActor.name}は体が痺れて動けない！`);
                            delete currentActor.statusEffects.paralysis; // 麻痺は1回で解除
                            flashCard(currentActor, 'yellow');
                            updatePartyStatus();
                            setTimeout(() => {
                                gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                nextTurn();
                            }, 1000);
                            return;
                        }

                        // 変身中のMP消費と特殊効果
                        if (currentActor.isTransformed) {
                            // サマータイム・スペシャルライブ！モードではMP消費なし
                            const shouldConsumeMp = gameState.gameMode !== 'summer_live';

                            if (shouldConsumeMp) {
                                const mpCost = 15;
                                if (currentActor.currentMp < mpCost) {
                                    log(`${currentActor.name}はMPが尽き、変身が解けてしまった！`);
                                    await handleTransform(currentActor, {
                                        type: 'transform_revert'
                                    });
                                    // 変身解除後は即座にターン終了
                                    setTimeout(() => {
                                        gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                        nextTurn();
                                    }, 1000);
                                    return;
                                } else {
                                    animateStatChange(currentActor, 'mp', -mpCost, 'decrease');
                                }
                            }
                        }

                        // 毒ダメージ処理 (ターン終了時)
                        // nextTurnの最後に移動させるため、ここでは何もしない

                        // ターン実行
                        if (actor.isEnemy) {
                            // 敵の思考時間として少し待機
                            setTimeout(() => enemyTurn(actor), 1000);
                        } else {
                            playerTurn(actor); // ファイター, ソーサラー, ナイト, メディック
                        }

                        updatePartyStatus(); // ターン開始時に状態表示を更新
                    }

                    function playerTurn(character) {
                        commandMessage.textContent = `${character.name}のターン`;
                        actionButtons.innerHTML = '';
                        // コマンドコンテナのレイアウトを縦並びに変更
                        actionButtons.className = 'flex flex-col gap-2';

                        // 上段の基本コマンド用コンテナ
                        const topRow = document.createElement('div');
                        topRow.className = 'grid grid-cols-2 sm:grid-cols-4 gap-2';

                        // 下段のスキル用コンテナ
                        const skillRow = document.createElement('div');
                        skillRow.className = 'grid grid-cols-2 sm:grid-cols-4 gap-2';

                        const attackBtn = document.createElement('button');
                        attackBtn.textContent = 'たたかう';
                        attackBtn.className = 'action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded';
                        attackBtn.onclick = () => playerAction(character, {
                            type: 'attack'
                        });
                        topRow.appendChild(attackBtn);

                        const defendBtn = document.createElement('button');
                        defendBtn.textContent = 'ぼうぎょ';
                        defendBtn.className = 'action-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded';
                        defendBtn.onclick = () => playerAction(character, {
                            type: 'defend'
                        });
                        topRow.appendChild(defendBtn);

                        const itemBtn = document.createElement('button');
                        itemBtn.textContent = 'アイテム';
                        itemBtn.className = `action-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded ${gameState.inventory.length === 0 ? 'opacity-50 cursor-not-allowed' : ''}`;
                        itemBtn.disabled = gameState.inventory.length === 0;
                        itemBtn.onclick = () => showItemModal(character);
                        topRow.appendChild(itemBtn);

                        const scanBtn = document.createElement('button');
                        scanBtn.textContent = '調べる';
                        scanBtn.className = 'action-button bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-4 rounded';
                        scanBtn.onclick = () => playerAction(character, {
                            type: 'scan'
                        });
                        topRow.appendChild(scanBtn);

                        character.skills.forEach(skill => {
                            const isSlowed = character.statusEffects && character.statusEffects.slow;
                            const isHpCostSkill = skill.type && skill.type.includes('hp_cost');
                            const isHeightCostSkill = skill.type === 'special_heal'; // 献身スキル
                            const isDisabled = (isHpCostSkill ? character.currentHp <= skill.cost : character.currentMp < skill.cost) || isSlowed;
                            const skillBtn = document.createElement('button');

                            let costText = '';
                            if (isHeightCostSkill) {
                                costText = `(身長:20)`;
                            } else {
                                costText = `(${isHpCostSkill ? 'HP' : 'MP'}:${skill.cost})`;
                            }
                            skillBtn.textContent = `${skill.name} ${costText}`;
                            skillBtn.className = `action-button bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}`;
                            if (isSlowed) skillBtn.title = "鈍化状態でスキルが使えない！";
                            skillBtn.disabled = isDisabled;
                            skillBtn.onclick = () => playerAction(character, {
                                type: 'skill',
                                skill: skill
                            });
                            skillRow.appendChild(skillBtn);
                        });

                        actionButtons.appendChild(topRow);
                        if (skillRow.hasChildNodes()) {
                            actionButtons.appendChild(skillRow);
                        }
                    }

                    let pendingAction = null;

                    function cancelPlayerActionSelection(message = "対象が違います。") {
                        log(message);
                        pendingAction = null;
                        document.querySelectorAll('.enemy-card, .character-card').forEach(c => c.classList.remove('targeted'));
                        // 現在のキャラクターのターンに戻す
                        const currentActor = gameState.turnOrder[gameState.currentTurnIndex];
                        if (currentActor && !currentActor.isEnemy) {
                            playerTurn(currentActor);
                        }
                    }

                    function playerAction(character, action) {
                        pendingAction = {
                            character,
                            action
                        };

                        const targetType = action.type === 'attack' ? 'enemy' : (action.type === 'scan' ? 'any' : (action.skill ? action.skill.targetType : (action.item ? itemBlueprints[action.item.id].target : 'self')));

                        if (targetType === 'enemy') {
                            const aliveEnemies = gameState.enemies.filter(e => e.currentHp > 0);
                            if (aliveEnemies.length === 1 && pendingAction.action.type !== 'scan') {
                                pendingAction.target = aliveEnemies[0];
                                executePlayerAction();
                            } else {
                                commandMessage.textContent = '誰を狙う？';
                                gameState.enemies.forEach((enemy, index) => {
                                    if (enemy.currentHp > 0) document.getElementById(`enemy-card-${index}`).classList.add('targeted');
                                });
                            }
                        } else if (targetType === 'ally') {
                            commandMessage.textContent = '誰に使う？';
                            const isReviveSkill = action.skill && action.skill.type === 'revive_full';
                            gameState.party.forEach((char, index) => {
                                if ((isReviveSkill && char.currentHp <= 0) || (!isReviveSkill && char.currentHp > 0)) {
                                    document.getElementById(`party-card-${index}`).classList.add('targeted');
                                }
                            });
                        } else if (targetType === 'any') {
                            commandMessage.textContent = '調べる対象を選択してください。';
                            gameState.enemies.forEach((enemy, index) => {
                                if (enemy.currentHp > 0) document.getElementById(`enemy-card-${index}`).classList.add('targeted');
                            });
                            gameState.party.forEach((char, index) => {
                                if (char.currentHp > 0) document.getElementById(`party-card-${index}`).classList.add('targeted');
                            });
                        } else {
                            // 敵全体、自分自身が対象の場合
                            if (targetType === 'enemies') {
                                pendingAction.target = gameState.enemies.filter(e => e.currentHp > 0);
                            }
                            executePlayerAction();
                        }

                    }

                    function playerSelectTarget(targetIndex) {
                        if (!pendingAction || gameState.enemies[targetIndex].currentHp <= 0) return;

                        const action = pendingAction.action;
                        const targetType = action.type === 'attack' ? 'enemy' : (action.skill ? action.skill.targetType : (action.item ? itemBlueprints[action.item.id].target : null));

                        // 敵を対象とするアクションかチェック
                        if (targetType === 'enemy' || targetType === 'enemies' || targetType === 'any' || (targetType === 'random_enemies' && action.type === 'skill')) {
                            pendingAction.target = gameState.enemies[targetIndex];
                            executePlayerAction();
                        } else if (action.type === 'scan') {
                            showScanResult(gameState.enemies[targetIndex]);
                        } else {
                            cancelPlayerActionSelection("そのアクションは敵には使えません。");
                        }
                    }

                    function playerSelectAlly(targetIndex) {
                        if (!pendingAction) return;

                        const targetCharacter = gameState.party[targetIndex];
                        const action = pendingAction.action;
                        const targetType = action.skill ? action.skill.targetType : (action.item ? itemBlueprints[action.item.id].target : null);

                        // 味方を対象とするアクションかチェック
                        if (targetType === 'ally' || targetType === 'party' || targetType === 'self' || targetType === 'any') {
                            // 復活スキル/アイテムの場合
                            if ((action.skill && action.skill.type === 'revive_full') || (action.item && itemBlueprints[action.item.id].effect === 'revive')) {
                                if (targetCharacter.currentHp <= 0) {
                                    pendingAction.target = targetCharacter;
                                    executePlayerAction();
                                } else {
                                    cancelPlayerActionSelection(`${targetCharacter.name}は戦闘不能ではありません。`);
                                }
                            } else if (targetCharacter.currentHp > 0) { // 通常の味方対象アクション
                                pendingAction.target = targetCharacter;
                                executePlayerAction();
                            } else {
                                cancelPlayerActionSelection("戦闘不能の仲間には使えません。");
                            }
                        } else if (action.type === 'scan') {
                            showScanResult(targetCharacter);
                        } else {
                            cancelPlayerActionSelection("そのアクションは味方には使えません。");
                        }
                    }

                    async function executePlayerAction() {
                        const {
                            character,
                            action,
                            target
                        } = pendingAction;
                        document.querySelectorAll('.enemy-card, .character-card').forEach(c => c.classList.remove('targeted'));

                        pendingAction = null;
                        document.querySelectorAll('.enemy-card').forEach(c => c.classList.remove('targeted'));
                        actionButtons.innerHTML = '<p>コマンド実行中...</p>';
                        // トレジャーハンターの通常攻撃
                        if (action.type === 'attack' && character.role === 'トレジャーハンター' && !character.isTransformed) {
                            await handleTreasureHunterAttack(character, target);
                            // ターン終了処理
                            setTimeout(() => {
                                // ターン終了時の毒ダメージなどの処理
                                if (gameState.inBattle) {
                                    gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                    setTimeout(nextTurn, 0); // 即座に次のターンへ
                                }
                            }, 1000);
                            return;
                        }
                        switch (action.type) {
                            case 'attack': // Player attack
                                const aliveEnemies = gameState.enemies.filter(e => e.currentHp > 0);
                                // 身長が500cmを超えている場合、全体攻撃になる
                                // 敵が2体以上いる場合のみ全体攻撃
                                if (character.height > 500 && aliveEnemies.length > 1) {
                                    log(`${character.name}はその巨体で敵全体をなぎ払った！`);
                                    const damagePromises = [];
                                    for (const enemy of aliveEnemies) {
                                        // 全体攻撃なので威力を少し下げる (0.7倍)
                                        const damage = calculateDamage(character, enemy, {
                                            power: 0.7,
                                            type: 'physical'
                                        });
                                        damagePromises.push(dealDamage(enemy, damage));
                                    }
                                    await Promise.all(damagePromises);
                                } else {
                                    // 通常の単体攻撃
                                    let damage = calculateDamage(character, target);
                                    let logMessageText = `${character.name}の攻撃！ ${target.name}に${damage}のダメージ！`;

                                    const mpRecoveryRoles = ['ソーサラー', 'メディック', 'モンク', 'ギャンブラー', 'サモナー', 'アルケミスト', 'ダンサー', 'ネクロマンサー'];
                                    if (mpRecoveryRoles.includes(character.role)) {
                                        // MP回復ジョブの処理
                                        const mpRecovery = Math.floor(character.maxMp * 0.1);
                                        if (mpRecovery > 0) {
                                            await animateStatChange(character, 'mp', mpRecovery, 'increase');
                                            log(`${character.name}は攻撃から魔力を吸収した！(MP+${mpRecovery})`);
                                        }
                                    } else if (character.role === 'ドクター') {
                                        // ドクターの特殊攻撃
                                        if (target.statusEffects && (target.statusEffects.poison || target.statusEffects.slow)) {
                                            damage = Math.floor(damage * 1.5);
                                            logMessageText = `${character.name}は弱った${target.name}に追撃！ ${damage}のダメージ！`;
                                        }
                                        // MP回復効果も追加
                                        const mpRecovery = Math.floor(character.maxMp * 0.1);
                                        if (mpRecovery > 0) await animateStatChange(character, 'mp', mpRecovery, 'increase');
                                    } else {
                                        // クリティカルヒット判定ジョブの処理
                                        const criticalRoles = ['ファイター', 'ナイト', 'サムライ', 'ガーディアン', 'トラブルメーカー'];
                                        if (criticalRoles.includes(character.role) && Math.random() < 0.2) { // 20%の確率でクリティカル
                                            damage = Math.ceil(damage * (character.blessings && character.blessings.critical_master ? 2.0 : 1.5));
                                            logMessageText = `会心の一撃！ ${target.name}に${damage}の大ダメージ！`;
                                        }
                                        // アンドロイドの通常攻撃クリティカル
                                        if (character.role === 'アンドロイド' && Math.random() < 0.25) { // 25%の確率でクリティカル
                                            damage = Math.ceil(damage * (character.blessings && character.blessings.critical_master ? 2.0 : 1.5));
                                            logMessageText = `会心の一撃！ ${target.name}に${damage}の大ダメージ！`;
                                        }
                                    }
                                    // 祝福: 双撃
                                    if (character.blessings && character.blessings.double_attack && Math.random() < 0.75) {
                                        log(`${character.name}は双撃の祝福で追撃！`);
                                        await new Promise(resolve => setTimeout(resolve, 500));
                                        const secondDamage = calculateDamage(character, target, {
                                            power: 0.6
                                        }); // 2撃目は威力0.6倍
                                        await dealDamage(target, secondDamage);
                                        log(`${target.name}に${secondDamage}のダメージ！`);
                                    }
                                    // メイドのHP吸収
                                    if (character.buffs && character.buffs.hp_absorb) {
                                        const absorbAmount = Math.ceil(damage * 0.2);
                                        log(`${character.name}は攻撃から生命力を吸収した！`);
                                        await dealDamage(character, -absorbAmount, true); // isHealをtrueにしてdealDamageを呼び出す
                                    }

                                    await dealDamage(target, damage); // Await the damage animation
                                    log(logMessageText); // Log after animation
                                } // ファイター, ソーサラー, ナイト, メディック
                                break;
                            case 'skill': // ファイター, ソーサラー, ナイト, メディック
                                if (action.skill.type && action.skill.type.includes('hp_cost')) { // HPコスト
                                    await animateStatChange(character, 'hp', -action.skill.cost, 'decrease'); // HP消費
                                } else if (action.skill.cost > 0 && action.skill.type !== 'mp_burst_magic') { // MPコスト
                                    let mpCost = action.skill.cost;
                                    // 「ばっちりチェック」中に「ハプニングボックス」を使うと消費MP半減
                                    if (action.skill.name === 'ハプニングボックス' && character.buffs.trouble_check) {
                                        mpCost = Math.ceil(mpCost / 2); // ファイター, ソーサラー, ナイト, メディック
                                        log("ばっちりチェックの効果で、消費MPが半減した！");
                                    }
                                    await animateStatChange(character, 'mp', -mpCost, 'decrease'); // MP消費
                                }
                                flashCard(character, 'yellow'); // MP消費
                                await handleSkill(character, target, action.skill);
                                // 祝福: 魔力残響
                                if (character.blessings && character.blessings.spell_echo && action.skill.type.includes('magic') && !action.skill.type.includes('status') && Math.random() < 0.3) {
                                    log(`魔力残響が${action.skill.name}を反響させる！`);
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                    // MP消費なしで同じスキルを再実行
                                    const secondTarget = action.skill.targetType === 'enemy' ?
                                        gameState.enemies.filter(e => e.currentHp > 0)[Math.floor(Math.random() * gameState.enemies.filter(e => e.currentHp > 0).length)] :
                                        target;
                                    if (secondTarget) {
                                        await handleSkill(character, secondTarget, action.skill);
                                    }
                                }
                                break;
                            case 'item':
                                // handleItemがtrueを返した場合のみアイテムを消費
                                const itemUsed = await handleItem(character, target, action.item);
                                if (itemUsed) action.item.quantity--;
                                break;
                            case 'defend':
                                character.isDefending = true;
                                log(`${character.name}は防御の構えをとった。`);
                                break;
                            case 'scan':
                                // このケースは playerSelect... で直接処理されるため、ここでは何もしない
                                // ターンを消費しないように、nextTurnを呼ばずにplayerTurnに戻る
                                playerTurn(character);
                                return;
                        }

                        updatePartyStatus(); // Refresh all cards after animations
                        updateEnemyStatus(); // Enemy status doesn't have number animation, so it can be updated immediately

                        if (gameState.inBattle) {
                            setTimeout(() => {
                                // ターン終了時の毒ダメージと祝福処理
                                if (character.currentHp > 0 && character.statusEffects && character.statusEffects.poison) {
                                    const poisonDamage = Math.max(1, Math.ceil(character.maxHp * 0.05));
                                    log(`${character.name}は毒のダメージを受けている！`);
                                    // dealDamageはasyncだが、ここでは待たずに次のターンへ進む
                                    dealDamage(character, poisonDamage);
                                    updatePartyStatus();
                                }
                                // ターン終了時の自然治癒と祝福
                                if (character.currentHp > 0 && (character.statusEffects.regeneration || (character.blessings && (character.blessings.hp_regen || character.blessings.mp_regen)))) {
                                    let healAmount = Math.max(1, Math.ceil(character.maxHp * 0.08));
                                    // 祝福の処理
                                    if (character.blessings && character.blessings.hp_regen) {
                                        healAmount += Math.max(1, Math.ceil(character.maxHp * 0.05)); // 祝福による回復を追加
                                    }
                                    if (character.blessings && character.blessings.mp_regen) {
                                        const mpHeal = Math.max(1, Math.ceil(character.maxMp * 0.05));
                                        animateStatChange(character, 'mp', mpHeal, 'increase');
                                    }
                                    // 聖女の行進モードでは回復量が2倍
                                    if (gameState.gameMode === 'saint_march') {
                                        healAmount *= 2;
                                    } // ファイター, ソーサラー, ナイト, メディック
                                    if (character.statusEffects.regeneration) {
                                        log(`${character.name}は傷が自然に回復していく！`);
                                        animateStatChange(character, 'hp', healAmount, 'increase');
                                    } else if (character.blessings && character.blessings.hp_regen) {
                                        log(`${character.name}は祝福の力でHPが回復した！`);
                                        animateStatChange(character, 'hp', healAmount, 'increase');
                                    }
                                }


                                gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                nextTurn();
                            }, 1000);
                        }
                    }

                    // 順応イベント専用スキル
                    const adaptationOnlySkills = [{
                        name: 'ソウルコンバート',
                        cost: 0, // MPコストは処理内で計算
                        type: 'soul_convert',
                        targetType: 'self',
                        description: '自身のMPを半分消費し、HPを全回復する。'
                    }, {
                        name: 'マギアコンバート',
                        cost: 0, // HPコストは処理内で計算
                        type: 'magia_convert',
                        targetType: 'self',
                        description: '自身のHPを半分消費し、MPを全回復する。'
                    }, {
                        name: 'ヘビースラッシュ',
                        cost: 15,
                        power: 2.5,
                        type: 'heavy_slash',
                        targetType: 'enemy',
                        description: '敵ひとりに高威力の物理攻撃。自身の身長が高いほどダメージにボーナス。'
                    }, {
                        name: 'チェインスペル',
                        cost: 15,
                        power: 4.5,
                        type: 'chain_spell',
                        targetType: 'enemy',
                        description: '敵ひとりに高威力の魔法攻撃。自身の身長が低いほどダメージにボーナス。'
                    }, {
                        name: 'メイクドール',
                        cost: 20,
                        power: 50, // 縮小量
                        type: 'make_doll',
                        targetType: 'enemy',
                        description: '敵ひとりの身長を縮め、攻撃力と防御力を低下させる。'
                    }, {
                        name: 'クラッシュハグ',
                        cost: 18,
                        power: 1.8,
                        type: 'crush_hug',
                        targetType: 'enemy',
                        description: '敵ひとりを抱きしめる物理攻撃。敵より身長が高いほどダメージにボーナス。'
                    }];

                    // 転生者専用イベント
                    function foundAdaptation() {
                        const shiro = gameState.party[0];
                        if (!shiro || shiro.role !== '転生者') {
                            nothingHappened();
                            return;
                        }

                        // リリィの変身スキルと、既に習得済みのスキルを除外
                        const lilyTransformSkills = ['サキュバスモード', 'フェアリーモード', 'アルラウネモード'];
                        const shiroSkillNames = shiro.skills.map(s => s.name);

                        const skillPool = allCharacterBlueprints
                            .flatMap(c => [...c.skills, c.unlockableSkill, c.unlockableSkillLv4])
                            .filter(skill =>
                                skill &&
                                !lilyTransformSkills.includes(skill.name) && // リリィの変身スキルを除外
                                !adaptationOnlySkills.some(s => s.name === skill.name) && // 順応スキルを重複させない
                                !shiroSkillNames.includes(skill.name)
                            );

                        if (skillPool.length < 3) {
                            log("シロは新たな力を感じ取れなかった…。");
                            return;
                        }
                        // 順応専用スキルをプールに追加
                        skillPool.push(...adaptationOnlySkills);
                        // 3つのユニークなスキルをランダムに選ぶ
                        const choices = []; // 選択肢を4つに増やす
                        while (choices.length < 4 && skillPool.length > 0) {
                            const randomIndex = Math.floor(Math.random() * skillPool.length);
                            choices.push(skillPool.splice(randomIndex, 1)[0]);
                        }

                        generalEventTitle.textContent = "順応";
                        generalEventText.textContent = "シロは周囲の魔力に順応し、新たな力を学習できそうだ。\nどの力を取り込みますか？";
                        generalEventButtons.innerHTML = ''; // ボタンをクリア
                        generalEventButtons.className = 'grid grid-cols-2 gap-4'; // 2列グリッドに変更

                        choices.forEach(skill => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-slate-500 hover:bg-slate-600 text-white font-bold py-4 px-4 rounded-lg shadow-lg text-center';
                            button.innerHTML = `<strong class="text-lg">${skill.name}</strong>`; // 説明を削除
                            button.onclick = async() => {
                                generalEventModal.classList.add('hidden');
                                if (shiro.skills.length >= 4) {
                                    // スキル交換処理
                                    const replaceableSkills = shiro.skills.filter(s => s.name !== 'ヴァニッシュ');
                                    const skillButtons = replaceableSkills.map(s => ({
                                        text: s.name,
                                        value: s.name,
                                    }));
                                    showAmountChoiceModal('スキル交換', `どのスキルと「${skill.name}」を交換しますか？`, skillButtons, async(skillNameToReplace) => {
                                        const skillIndex = shiro.skills.findIndex(s => s.name === skillNameToReplace);
                                        if (skillIndex !== -1) {
                                            shiro.skills[skillIndex] = skill;
                                            await log(`シロは「${skillNameToReplace}」を忘れ、新たに「${skill.name}」を習得した！`);
                                            await log("シロは新たな力を感じている…");
                                        }
                                        dungeonCommands.classList.remove('hidden');
                                    });
                                } else {
                                    // スキル追加処理
                                    shiro.skills.push(skill);
                                    await log(`シロは新たなスキル「${skill.name}」を習得した！`);
                                    await log("シロは新たな力を感じている…");
                                    dungeonCommands.classList.remove('hidden');
                                }
                            };
                            generalEventButtons.appendChild(button);
                        });

                        // 「何もしない」ボタン
                        const cancelButton = document.createElement('button');
                        cancelButton.className = 'action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg mt-2 col-span-2'; // 2列にまたがるように
                        cancelButton.textContent = '何もしない';
                        cancelButton.onclick = () => {
                            generalEventModal.classList.add('hidden');
                            log("シロは力の取り込みを見送った。");
                            dungeonCommands.classList.remove('hidden');
                        };
                        generalEventButtons.appendChild(cancelButton);

                        generalEventModal.classList.remove('hidden');
                    }

                    function foundAwakening() {
                        const shiro = gameState.party[0];
                        if (!shiro || shiro.role !== '転生者') {
                            nothingHappened();
                            return;
                        }
                        const stats = [{
                            name: '最大HP',
                            key: 'maxHp',
                            value: 45
                        }, {
                            name: '最大MP',
                            key: 'maxMp',
                            value: 30
                        }, {
                            name: '攻撃力',
                            key: 'atk',
                            value: 9
                        }, {
                            name: '防御力',
                            key: 'def',
                            value: 9
                        }];
                        const chosenStat = stats[Math.floor(Math.random() * stats.length)];

                        shiro[chosenStat.key] += chosenStat.value;
                        log(`シロはダンジョンの魔力を取り込み、覚醒した！\n${chosenStat.name}が永続的に${chosenStat.value}上昇した！`);
                        flashCard(shiro, 'green');
                    }

                    async function handleSkill(caster, target, skill) {
                        switch (skill.type) {
                            case 'growth_physical':
                                {
                                    const skillDamage = calculateDamage(caster, target, skill);
                                    await dealDamage(target, skillDamage);
                                    log(`${caster.name}は${skill.name}を放った！ ${target.name}に${skillDamage}のダメージ！`);
                                    // 永続的な威力上昇
                                    skill.power = parseFloat((skill.power + 0.1).toFixed(2));
                                    log(`${caster.name}の「${skill.name}」が少し強くなった！`);
                                    break;
                                }
                            case 'hp_cost_instant_death':
                                { // ヴァニッシュ
                                    if (caster.maxHp < 20) {
                                        log(`最大HPが足りず、${skill.name}を使えなかった！`);
                                        break;
                                    }
                                    // 消費HPを現在HPからではなく最大HPから引く
                                    caster.maxHp -= skill.cost;
                                    // 現在HPが最大HPを超えている場合は調整
                                    if (caster.currentHp > caster.maxHp) {
                                        caster.currentHp = caster.maxHp;
                                    }
                                    log(`${caster.name}は${skill.name}を放った…！`);
                                    flashCard(caster, 'red');
                                    await new Promise(resolve => setTimeout(resolve, 1000));
                                    log(`${target.name}は光の中に消滅した…`);
                                    await dealDamage(target, target.currentHp);
                                    break;
                                }
                            case 'soul_convert':
                                {
                                    const mpCost = Math.ceil(caster.currentMp / 2);
                                    if (caster.currentMp < 1) {
                                        log(`MPが足りず、${skill.name}を使えなかった！`);
                                        break;
                                    }
                                    await animateStatChange(caster, 'mp', -mpCost, 'decrease');
                                    await animateStatChange(caster, 'hp', caster.maxHp, 'increase');
                                    log(`${caster.name}は${skill.name}で魂を燃やし、HPを全回復した！`);
                                    break;
                                }
                            case 'magia_convert':
                                {
                                    const hpCost = Math.ceil(caster.currentHp / 2);
                                    if (caster.currentHp <= hpCost) {
                                        log(`HPが足りず、${skill.name}を使えなかった！`);
                                        break;
                                    }
                                    await animateStatChange(caster, 'hp', -hpCost, 'decrease');
                                    await animateStatChange(caster, 'mp', caster.maxMp, 'increase');
                                    log(`${caster.name}は${skill.name}で生命を魔力に変換し、MPを全回復した！`);
                                    break;
                                }
                            case 'heavy_slash':
                            case 'chain_spell':
                            case 'crush_hug':
                                {
                                    const damage = calculateDamage(caster, target, skill);
                                    await dealDamage(target, damage);
                                    log(`${caster.name}は${skill.name}を放った！ ${target.name}に${damage}のダメージ！`);
                                    break;
                                }
                            case 'make_doll':
                                {
                                    log(`${caster.name}は${skill.name}を放った！`);
                                    if (target.isBoss) {
                                        log(`しかし、${target.name}には効果がなかった！`);
                                    } else {
                                        target.height = Math.max(1, target.height - skill.power);
                                        target.buffs = target.buffs || {};
                                        target.buffs.atk_down = 3;
                                        target.buffs.def_down = 3;
                                        flashCard(target, 'red');
                                        log(`${target.name}は小さなお人形さんのようになり、弱体化した！`);
                                        // 敵の身長はUIに直接表示されないため、ログで通知
                                    }
                                    break;
                                }
                            case 'physical':
                            case 'magic':
                                {
                                    if (Array.isArray(target) && target.every(t => t.isEnemy)) { // 敵全体への攻撃の場合
                                        let modifiedSkill = skill;
                                        // 解放状態でのホットウェーブ強化
                                        if (skill.name === 'ホットウェーブ' && caster.isLiberatedStripped) {
                                            log(`${caster.name}の解放された熱情が、波をさらに熱くする！`);
                                            await new Promise(resolve => setTimeout(resolve, 500));
                                            modifiedSkill = {...skill,
                                                power: skill.power * 1.2
                                            };
                                        }
                                        // 解放状態でのプチウンディーネ強化
                                        if (skill.name === 'プチウンディーネ' && caster.isLiberatedStripped) {
                                            log(`${caster.name}の解放された魔力が、水の精霊を荒ぶらせる！`);
                                            await new Promise(resolve => setTimeout(resolve, 500));
                                            modifiedSkill = {...skill,
                                                power: skill.power * 2.5
                                            };
                                        }
                                        log(`${caster.name}は${skill.name}を放った！`);
                                        const damagePromises = [];
                                        for (const t of target) {
                                            // dealDamageを直接awaitせず、Promiseを配列に格納
                                            damagePromises.push(dealDamage(t, calculateDamage(caster, t, modifiedSkill)));
                                        }
                                        // 全てのダメージ処理アニメーションを並行して実行
                                        await Promise.all(damagePromises);
                                    } else { // 単体攻撃の場合
                                        let modifiedSkill = skill;
                                        // サマータイム・スペシャルライブ！の温泉エリアでのプチサラマンダー強化
                                        if (skill.name === 'プチサラマンダー' && gameState.gameMode === 'summer_live' && gameState.floor > 30) {
                                            log("温泉の熱気がサラマンダーの力を増幅させる！");
                                            await new Promise(resolve => setTimeout(resolve, 500)); // メッセージ表示のための短い待機
                                            modifiedSkill = {...skill,
                                                power: skill.power * 2.5
                                            };
                                        }
                                        const skillDamage = calculateDamage(caster, target, modifiedSkill);
                                        await dealDamage(target, skillDamage);
                                        log(`${caster.name}は${skill.name}を放った！ ${target.name}に${skillDamage}のダメージ！`);
                                        // 天の裁きの副作用
                                        if (skill.name === '天の裁き') {
                                            await handleHeavensJudgmentSideEffect(caster);
                                        }

                                    }
                                    break;
                                }
                            case 'heal':
                                {
                                    const skillHealAmount = skill.power + Math.ceil(getEffectiveStats(caster).atk * 0.5); // Calculate amount first
                                    await animateStatChange(target, 'hp', skillHealAmount, 'increase'); // Await HP animation
                                    flashCard(target, 'green'); // Flash the card itself
                                    showDamagePopup(target, skillHealAmount, true);
                                    log(`${caster.name}は${target.name}に${skill.name}を唱えた！ HPが${skillHealAmount}回復した。`);
                                    // メディックの「ヒール」の場合、状態異常を解除
                                    if (skill.name === 'ヒール' && caster.role === 'メディック') {
                                        let curedEffects = [];
                                        if (target.statusEffects.poison) {
                                            delete target.statusEffects.poison;
                                            curedEffects.push('毒');
                                        }
                                        if (target.statusEffects.paralysis) {
                                            delete target.statusEffects.paralysis;
                                            curedEffects.push('麻痺');
                                        }
                                        if (target.statusEffects.slow) {
                                            delete target.statusEffects.slow;
                                            curedEffects.push('鈍化');
                                        }
                                        if (curedEffects.length > 0) log(`さらに、${target.name}の${curedEffects.join('、')}が治った！`);
                                    }
                                    break;
                                }
                            case 'buff':
                                {
                                    if (skill.effect === 'atk_up') {
                                        target.buffs.atk_up = 3; // 3ターン攻撃力アップ
                                        flashCard(target, 'yellow');
                                        log(`${caster.name}は${target.name}に${skill.name}を唱えた！ 攻撃力が上がった！`);
                                    } else if (skill.effect === 'protect') {
                                        target.buffs.protect = 3; // 3ターン防御力アップ
                                        flashCard(target, 'yellow');
                                        log(`${caster.name}は${target.name}に${skill.name}を唱えた！ 防御力が上がった！`);
                                    } else if (skill.effect === 'def_down') {
                                        target.buffs.def_down = 3; // 3ターン防御力ダウン
                                        flashCard(target, 'yellow');
                                        log(`${caster.name}は${target.name}に${skill.name}を唱えた！ 防御力が下がった！`);
                                    }
                                    break;
                                }
                            case 'utility':
                                {
                                    flashCard(caster, 'yellow');
                                    caster.buffs.provoke = 3; // 挑発は自分自身が対象
                                    log(`${caster.name}は${skill.name}で敵の注意を引いた！`);
                                    break;
                                }
                            case 'charge':
                                { // チャージ
                                    caster.chargeCount = (caster.chargeCount || 0) + 1;
                                    flashCard(caster, 'yellow');
                                    // 挑発状態の場合、挑発ターンを1増やす
                                    if (caster.buffs && caster.buffs.provoke > 0) {
                                        caster.buffs.provoke++;
                                        log(`${caster.name}は挑発を継続し、さらに力を溜める！ (${caster.chargeCount}回目)`);
                                    } else {
                                        log(`${caster.name}は${skill.name}！力を溜めている…！ (${caster.chargeCount}回目)`);
                                    }
                                    break;
                                }
                            case 'special_heal':
                                { // 献身
                                    if (caster.heightLocked) {
                                        log(`${caster.name}は献身を使おうとしたが、体が変化を拒んだ！`);
                                        caster.currentMp += skill.cost; // MPを消費しない
                                        break;
                                    }
                                    const costHeight = Math.min(20, caster.height - 1);
                                    if (costHeight < 1) {
                                        log(`${caster.name}は献身を使おうとしたが、身長が足りなかった！`);
                                        break; // 身長が1cmだと使えない
                                    }
                                    // 献身使用後に身長が1cm未満になる場合は使用不可
                                    if (caster.height - costHeight < 1) {
                                        log(`${caster.name}は献身を使おうとしたが、これ以上身長を捧げられなかった！`);
                                        caster.currentMp += skill.cost; // MPを消費しない
                                        break;
                                    }
                                    await animateStatChange(caster, 'height', -costHeight, 'decrease');
                                    log(`${caster.name}は身長を${costHeight}cm捧げて、味方を癒した！`);
                                    // 味方全体のHPを40%回復
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        const healAmount = Math.ceil(p.maxHp * 0.4);
                                        await animateStatChange(p, 'hp', healAmount, 'increase');
                                    }
                                    break;
                                }
                                // 新しいLv4スキル
                            case 'height_power_physical':
                                { // ボディドロップ
                                    let modifiedSkill = skill;
                                    if (caster.isLiberatedStripped) {
                                        log(`${caster.name}の解放された肉体が、一撃の重みを増す！`);
                                        await new Promise(resolve => setTimeout(resolve, 500));
                                        modifiedSkill = {...skill,
                                            power: skill.power * 1.2
                                        };
                                    }
                                    const heightBonus = Math.max(0, (caster.height - caster.initialHeight) * 0.1);
                                    const bodyDropDamage = calculateDamage(caster, target, {
                                        ...skill,
                                        power: skill.power + heightBonus
                                    });
                                    await dealDamage(target, bodyDropDamage);
                                    log(`${caster.name}の${skill.name}！ ${target.name}に${bodyDropDamage}の超特大ダメージ！`);
                                    break;
                                }
                            case 'multi_hit_physical':
                                { // 乱舞
                                    const hitCount = Math.ceil(Math.random() * 3) + 4; // 4〜6回
                                    log(`${caster.name}の${skill.name}！`);
                                    await new Promise(resolve => setTimeout(resolve, 500)); // メッセージ表示のための短い待機
                                    log(`${hitCount}回攻撃！`);
                                    for (let i = 0; i < hitCount; i++) {
                                        const randomTarget = gameState.enemies.filter(e => e.currentHp > 0)[Math.floor(Math.random() * gameState.enemies.filter(e => e.currentHp > 0).length)];
                                        if (randomTarget) {
                                            const damage = calculateDamage(caster, randomTarget, {
                                                ...skill,
                                                power: 0.6
                                            }); // 1ヒットあたりの威力は調整
                                            // 連続攻撃なので、一体ずつ待機してダメージを与える
                                            await dealDamage(randomTarget, damage);
                                        }
                                    } // ファイター, ソーサラー, ナイト, メディック
                                    break;
                                }
                            case 'mp_burst_magic':
                                { // マジックバースト
                                    const damage = caster.currentMp * 4;
                                    await animateStatChange(caster, 'mp', -caster.currentMp, 'decrease');
                                    log(`${caster.name}は${skill.name}を放った！`);
                                    await dealDamage(target, damage);
                                    log(`${target.name}に${damage}の特大ダメージ！`);
                                    break;
                                }
                            case 'self_buff_special':
                                { // 堅守の構え
                                    log(`${caster.name}は${skill.name}をとった！`);
                                    caster.buffs.provoke = 3;
                                    caster.statusEffects.regeneration = {
                                        turns: 3
                                    };
                                    flashCard(caster, 'yellow');
                                    log(`${caster.name}は敵の注意を引きつけ、傷が再生し始めた！`);
                                    break;
                                }
                            case 'party_restore_growth':
                                { // サンクチュアリ
                                    log(`${caster.name}は${skill.name}を唱えた！聖なる光がパーティを包み込む！`);
                                    if (caster.heightLocked) {
                                        log(`しかし、${caster.name}の体は聖なる力による成長を受け付けなかった！`);
                                    }

                                    for (const p of gameState.party) {
                                        if (p.currentHp > 0) {
                                            await animateStatChange(p, 'hp', p.maxHp, 'increase'); // 全回復
                                            p.statusEffects = {}; // 状態異常回復
                                            if (p !== caster) await animateStatChange(p, 'height', skill.growth, 'increase'); // 身長アップ
                                        }
                                    }
                                    break;
                                }
                                // 新キャラクタースキル
                            case 'transform_succubus':
                            case 'transform_fairy':
                            case 'transform_alraune':
                                await handleTransform(caster, skill);
                                break;
                            case 'transform_revert':
                                await handleTransform(caster, skill);
                                break;
                            case 'treasure_hunter_attack':
                                { // ジュエルショット
                                    const jewelDamage = calculateDamage(caster, target, {
                                        ...skill,
                                        power: 1.5
                                    });
                                    await dealDamage(target, jewelDamage);
                                    log(`${caster.name}は${skill.name}を放った！ ${target.name}に${jewelDamage}のダメージ！`);
                                    if (Math.random() < 0.5) {
                                        caster.buffs.atk_up = 3;
                                        log(`${caster.name}の攻撃力が上がった！`);
                                    } else {
                                        const mpHeal = Math.ceil(caster.maxMp * 0.3);
                                        await animateStatChange(caster, 'mp', mpHeal, 'increase');
                                        log(`${caster.name}のMPが${mpHeal}回復した！`);
                                    }
                                    break;
                                }
                            case 'status_magic':
                                { // ポイズンミスト
                                    if (skill.effect === 'poison' && Array.isArray(target)) { // 敵全体
                                        log(`${caster.name}の${skill.name}！ 毒の霧が敵全体を包み込む！`);
                                        target.forEach(t => {
                                            t.statusEffects.poison = {
                                                turns: 3
                                            };
                                            flashCard(t, 'yellow');
                                        });
                                    } else if (skill.effect === 'poison') { // 敵単体 (念のため残す)
                                        target.statusEffects.poison = {
                                            turns: 3
                                        };
                                        flashCard(target, 'yellow');
                                        log(`${caster.name}の${skill.name}！ ${target.name}は毒状態になった！`);
                                    }
                                    break;
                                }
                            case 'evade_provoke':
                                { // スポットライト
                                    caster.buffs.provoke = 3;
                                    caster.buffs.evade_up = 3;
                                    flashCard(caster, 'yellow');
                                    log(`${caster.name}は${skill.name}を浴びて、敵の注目と視線を集めた！`);
                                    break;
                                }
                            case 'hp_cost_physical':
                                { // 居合, 無明の一閃
                                    const samuraiDamage = calculateDamage(caster, target, skill);
                                    await dealDamage(target, samuraiDamage);
                                    log(`${caster.name}は${skill.name}を放った！ ${target.name}に${samuraiDamage}のダメージ！`);
                                    break;
                                }
                            case 'drain_physical':
                                { // ハートドレイン
                                    const drainDamage = calculateDamage(caster, target, skill);
                                    const targetOriginalHp = target.currentHp;
                                    if (drainDamage === 'evaded') {
                                        log(`${target.name}は攻撃をかわした！`);
                                        showDamagePopup(target, '回避');
                                    } else {
                                        const drainHeal = Math.ceil(drainDamage * 0.5);
                                        await dealDamage(target, drainDamage);
                                        const isDefeated = target.currentHp <= 0;
                                        if (isDefeated) {
                                            const overkill = drainDamage - targetOriginalHp;
                                            const heightGain = Math.max(0, Math.floor(overkill / 2));
                                            if (heightGain > 0) {
                                                await animateStatChange(caster, 'height', heightGain, 'increase');
                                                log(`${caster.name}は過剰な生命力を吸収し、身長が${heightGain}cm伸びた！`);
                                            }
                                        }
                                        await animateStatChange(caster, 'hp', drainHeal, 'increase');
                                        log(`${caster.name}は${skill.name}で${target.name}に${drainDamage}のダメージを与え、HPを${drainHeal}回復した！`);
                                    }
                                    break;
                                }
                            case 'self_buff_samurai':
                                { // 明鏡止水
                                    caster.buffs.atk_up = 3;
                                    log(`${caster.name}は${skill.name}の構え。精神を研ぎ澄まし、攻撃力が上がった！`);
                                    break;
                                }
                            case 'def_ignore_physical':
                                { // 破砕拳
                                    const monkDamage = calculateDamage(caster, target, skill);
                                    await dealDamage(target, monkDamage);
                                    log(`${caster.name}の${skill.name}！ ${target.name}に${monkDamage}の防御無視ダメージ！`);
                                    break;
                                }
                            case 'growth_ally':
                                { // 成長促進剤
                                    if (target.heightLocked) {
                                        log(`${caster.name}は${target.name}に薬を投与したが、体が変化を拒んだ！`);
                                        caster.currentMp += skill.cost; // MPを消費しない
                                        break;
                                    }
                                    await animateStatChange(target, 'height', skill.power, 'increase');
                                    flashCard(target, 'yellow');
                                    log(`${caster.name}は${target.name}に${skill.name}を投与した！ ${target.name}の体が巨大化した！(身長+${skill.power}cm)`);
                                    break;
                                }
                            case 'shrink_ally':
                                { // 縮小薬
                                    if (target.heightLocked) {
                                        log(`${caster.name}は${target.name}に薬を投与したが、体が変化を拒んだ！`);
                                        caster.currentMp += skill.cost; // MPを消費しない
                                        break;
                                    }
                                    await animateStatChange(target, 'height', -skill.power, 'decrease');
                                    flashCard(target, 'yellow');
                                    log(`${caster.name}は${target.name}に${skill.name}を投与した！ 身長が${skill.power}cm縮んだ！`);
                                    break;
                                }
                            case 'status_ailment_multi':
                                { // パンデミック
                                    log(`${caster.name}は${skill.name}を散布した！`);
                                    const ailmentTargets = Array.isArray(target) ? target : [target];
                                    for (const t of ailmentTargets) {
                                        const effect = skill.effects[Math.floor(Math.random() * skill.effects.length)];
                                        let effectName = ''; // ファイター, ソーサラー, ナイト, メディック
                                        if (effect === 'poison') {
                                            t.statusEffects.poison = {
                                                turns: 3
                                            };
                                            effectName = '毒';
                                        } else if (effect === 'paralysis') {
                                            t.statusEffects.paralysis = true;
                                            effectName = '麻痺';
                                        } else if (effect === 'slow') {
                                            t.statusEffects.slow = {
                                                turns: 3
                                            };
                                            effectName = '鈍化';
                                        }
                                        flashCard(t, 'yellow');
                                        log(`${t.name}は${effectName}状態になった！`);
                                    }
                                    break;
                                }
                            case 'gambling_damage':
                                { // ダーツショット
                                    const roll = Math.random();
                                    let damageMultiplier = 1.0;
                                    let message = "";
                                    if (roll < 0.1) { // 10%でミス
                                        damageMultiplier = 0;
                                        message = "しかし、ダーツは大きく外れてしまった！"; // ファイター, ソーサラー, ナイト, メディック
                                    } else if (roll < 0.5) { // 40%で通常ヒット
                                        damageMultiplier = 1.5;
                                        message = `${target.name}にヒット！`;
                                    } else if (roll < 0.9) { // 40%でクリティカル // ファイター, ソーサラー, ナイト, メディック
                                        damageMultiplier = 3.0;
                                        message = `クリティカルヒット！ ${target.name}に大ダメージ！`;
                                    } else { // 10%でミラクルヒット
                                        damageMultiplier = 5.0;
                                        message = `ミラクルヒット！ ${target.name}に超特大ダメージ！`;
                                    }
                                    const gamblingDamage = calculateDamage(caster, target, {
                                        ...skill,
                                        power: damageMultiplier
                                    });
                                    log(`${caster.name}の${skill.name}！ ${message}`);
                                    if (gamblingDamage > 0) await dealDamage(target, gamblingDamage);
                                    break;
                                }
                            case 'gambling_support':
                                { // ラッキースター
                                    const supportRoll = Math.random();
                                    log(`${caster.name}は${target.name}に${skill.name}を祈った！`);
                                    const effects = [{
                                        name: 'HP回復',
                                        func: async() => {
                                            const healAmount = Math.ceil(target.maxHp * 0.5);
                                            await animateStatChange(target, 'hp', healAmount, 'increase');
                                            log(`${target.name}のHPが${healAmount}回復！`);
                                        }
                                    }, {
                                        name: 'MP回復',
                                        func: async() => {
                                            const mpAmount = Math.ceil(target.maxMp * 0.5);
                                            await animateStatChange(target, 'mp', mpAmount, 'increase');
                                            log(`${target.name}のMPが${mpAmount}回復！`);
                                        }
                                    }, {
                                        name: '攻撃力アップ',
                                        func: () => {
                                            target.buffs.atk_up = 3;
                                            log(`${target.name}の攻撃力がアップ！`);
                                        }
                                    }, {
                                        name: '防御力アップ',
                                        func: () => {
                                            target.buffs.protect = 3;
                                            log(`${target.name}の防御力がアップ！`);
                                        }
                                    }, {
                                        name: '状態異常回復',
                                        func: () => {
                                            target.statusEffects = {};
                                            log(`${target.name}の状態異常が回復！`);
                                        }
                                    }, ];
                                    // シャッフルして3つ選ぶ
                                    for (let i = effects.length - 1; i > 0; i--) {
                                        const j = Math.floor(Math.random() * (i + 1));
                                        [effects[i], effects[j]] = [effects[j], effects[i]];
                                    }
                                    const selectedEffects = effects.slice(0, 3);
                                    log(`幸運の星が輝き、${selectedEffects.map(e => e.name).join('、')}の効果が発動！`);
                                    for (const effect of selectedEffects) {
                                        await effect.func();
                                    }
                                    flashCard(target, 'yellow');
                                    break;
                                }
                            case 'gambling_all_in':
                                { // オールイン
                                    const allInRoll = Math.random();
                                    log(`${caster.name}は${skill.name}！全てを賭けた！`);
                                    if (allInRoll < 0.4) { // 40% 敵全体にダメージ
                                        log("賭けは成功！敵全体にダメージ！");
                                        for (const t of target) {
                                            const damage = calculateDamage(caster, t, {
                                                ...skill,
                                                power: 1.8
                                            });
                                            await dealDamage(t, damage);
                                        }
                                    } else if (allInRoll < 0.6) { // 20% 味方全体を小回復
                                        log("悪くない！味方全体が少し回復した！");
                                        for (const p of gameState.party) {
                                            if (p.currentHp > 0) await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.2), 'increase');
                                        }
                                    } else if (allInRoll < 0.9) { // 30% 何も起こらない
                                        log("…しかし、何も起こらなかった。");
                                    } else { // 10% 自分がダメージ
                                        log("賭けに負けた！術者にダメージ！");
                                        await dealDamage(caster, Math.ceil(caster.maxHp * 0.25));
                                    }
                                    break;
                                }
                            case 'gambling_jackpot':
                                { // ジャックポット
                                    log(`${caster.name}は${skill.name}を狙う！`);
                                    if (Math.random() < 0.2) { // 20%で成功
                                        log("大当たり！ジャックポット！パーティが完全に回復し、強化された！");
                                        for (const p of gameState.party) {
                                            if (p.currentHp > 0) {
                                                await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                                await animateStatChange(p, 'mp', p.maxMp, 'increase');
                                                p.buffs.atk_up = 3;
                                                p.buffs.protect = 3;
                                                flashCard(p, 'green');
                                            }
                                        }
                                    } else {
                                        log("…しかし、何も起こらなかった。MPだけが無駄になった！");
                                    }
                                    break;
                                }
                            case 'reaper_instant_death':
                                { // 魂狩り
                                    log(`${caster.name}は${skill.name}を唱えた…！`); // ファイター, ソーサラー, ナイト, メディック
                                    if (target.isBoss && Math.random() < 0.15) {
                                        log(`鎌がボスの魂に深く突き刺さった！`);
                                        const bossDamage = Math.ceil(target.maxHp * 0.5);
                                        await dealDamage(target, bossDamage);
                                    } else if (!target.isBoss && Math.random() < 0.15) { // 15%で即死
                                        log(`鎌が${target.name}の魂を捉えた！`);
                                        await dealDamage(target, target.currentHp);
                                    } else {
                                        log("…しかし、魂を狩るには至らなかった！");
                                        const failDamage = calculateDamage(caster, target, skill);
                                        await dealDamage(target, failDamage);
                                    }
                                    break;
                                }
                            case 'reaper_height_scaling':
                                { // 影の一撃
                                    const heightDiff = Math.max(0, caster.initialHeight - caster.height);
                                    const bonusDamageFromSelf = Math.ceil(heightDiff * 2); // 自身の身長によるボーナス
                                    let bonusDamageFromEnemy = 0;
                                    // 敵の身長が自分より大きい場合、追加ボーナス
                                    if (target.isEnemy && target.height > caster.height) {
                                        const enemyHeightDiff = target.height - caster.height;
                                        bonusDamageFromEnemy = Math.floor(enemyHeightDiff * 0.1); // 身長差1cmあたり0.1ダメージ追加
                                    }
                                    const baseDamage = calculateDamage(caster, target, skill);
                                    const totalDamage = baseDamage + bonusDamageFromSelf + bonusDamageFromEnemy;
                                    log(`${caster.name}の${skill.name}！`);
                                    await dealDamage(target, totalDamage);
                                    log(`${target.name}に${totalDamage}のダメージ！`);
                                    break;
                                }
                            case 'reaper_soul_exchange':
                                { // 魂の交換
                                    const hpCost = Math.ceil(caster.currentHp / 2);
                                    await dealDamage(caster, hpCost, false, true); // isHeal=false, isSelfDamage=true
                                    const soulHealAmount = Math.ceil(hpCost * 1.5); // 削ったHPの1.5倍回復
                                    const mpAmount = Math.ceil(hpCost * 1.0); // 削ったHPと同じだけMP回復
                                    log(`${caster.name}は${skill.name}で自らの魂を分け与えた！`);
                                    await animateStatChange(target, 'hp', soulHealAmount, 'increase');
                                    await animateStatChange(target, 'mp', mpAmount, 'increase');
                                    log(`${target.name}のHPとMPが回復した！`);
                                    break;
                                }
                            case 'reaper_height_scaling_multi':
                                { // 冥府の鎌
                                    log(`${caster.name}は${skill.name}を振るった！`);
                                    const heightDiffMulti = Math.max(0, caster.initialHeight - caster.height);
                                    const bonusDamageMulti = Math.ceil(heightDiffMulti * 1); // 全体攻撃なのでボーナスは少し控えめ
                                    const damagePromisesReaper = [];
                                    for (const t of target) {
                                        let bonusDamageFromEnemyMulti = 0;
                                        // 敵の身長が自分より大きい場合、追加ボーナス
                                        if (t.isEnemy && t.height > caster.height) {
                                            const enemyHeightDiff = t.height - caster.height;
                                            bonusDamageFromEnemyMulti = Math.floor(enemyHeightDiff * 0.05); // 全体攻撃なのでボーナスはさらに控えめ
                                        }
                                        const totalDamageMulti = calculateDamage(caster, t, skill) + bonusDamageMulti + bonusDamageFromEnemyMulti;
                                        damagePromisesReaper.push(dealDamage(t, totalDamageMulti));
                                    }
                                    await Promise.all(damagePromisesReaper);
                                    break;
                                }
                            case 'summon_golem':
                                { // ゴーレム召喚
                                    let golemHp = Math.ceil(caster.maxHp * skill.power);
                                    let golemMaxHp = golemHp;

                                    // 術者にウォールがあるかチェック
                                    const casterIndex = gameState.party.indexOf(caster);
                                    const wallIndex = gameState.walls.findIndex(w => w.targetId === casterIndex);
                                    if (wallIndex !== -1) {
                                        const wall = gameState.walls[wallIndex];
                                        log(`${caster.name}は自らの防壁を破壊し、ゴーレムの素材にした！`);
                                        golemHp += wall.hp;
                                        golemMaxHp += wall.maxHp;
                                        // ウォールを削除
                                        gameState.walls.splice(wallIndex, 1);
                                    }

                                    gameState.golem = {
                                        name: 'ゴーレム',
                                        hp: golemHp,
                                        maxHp: golemMaxHp
                                    };
                                    log(`${caster.name}は${skill.name}を唱えた！パーティの前にゴーレムが現れた！`);
                                    updatePartyStatus();
                                    flashCard(caster, 'yellow');
                                    break;
                                }
                                // ネクロマンサー
                            case 'necro_magic':
                                {
                                    const killBonus = Math.ceil(gameState.killCount / 2); // 2体倒すごとに威力アップ
                                    const necroSkill = {
                                        ...skill,
                                        power: skill.power + killBonus * 0.2
                                    };
                                    if (Array.isArray(target)) { // 全体攻撃
                                        const damagePromisesNecro = [];
                                        log(`${caster.name}は${skill.name}を放った！`);
                                        for (const t of target) {
                                            damagePromisesNecro.push(dealDamage(t, calculateDamage(caster, t, necroSkill)));
                                        }
                                        await Promise.all(damagePromisesNecro);
                                    } else { // 単体攻撃
                                        const damage = calculateDamage(caster, target, necroSkill);
                                        await dealDamage(target, damage);
                                        log(`${caster.name}は${skill.name}を放った！ ${target.name}に${damage}のダメージ！`);
                                    }
                                    break;
                                }
                            case 'revive_full':
                                { // リザレクション
                                    if (target.currentHp > 0) {
                                        log(`しかし、${target.name}は戦闘不能ではなかった！`);
                                        caster.currentMp += skill.cost; // MPを消費しない
                                        break;
                                    }
                                    log(`${caster.name}は${skill.name}を唱えた！`);
                                    await animateStatChange(target, 'hp', target.maxHp, 'increase');
                                    flashCard(target, 'green');
                                    log(`${target.name}は完全な状態で戦線に復帰した！`);
                                    break;
                                }
                                // ネクロマンサー MPドレイン
                            case 'mp_drain':
                                {
                                    const drainDamage = Math.ceil(calculateDamage(caster, target, skill));
                                    await dealDamage(target, drainDamage);
                                    const mpDrainAmount = Math.max(1, Math.ceil(drainDamage * 0.2));
                                    await animateStatChange(caster, 'mp', mpDrainAmount, 'increase');
                                    log(`${caster.name}は${skill.name}で${target.name}に${drainDamage}のダメージを与え、MPを${mpDrainAmount}吸収した！`);
                                    break;
                                }
                                // ガーディアン
                            case 'guardian_wall':
                                {
                                    const wallHp = Math.ceil(caster.maxHp * (caster.buffs.guardian_high ? skill.power * 1.5 : skill.power));
                                    // 対象がゴーレム持ちのサモナーかチェック
                                    if (target.role === 'サモナー' && gameState.golem && gameState.golem.hp > 0) {
                                        gameState.golem.hp += wallHp;
                                        gameState.golem.maxHp += wallHp;
                                        log(`${caster.name}は${target.name}のゴーレムに防壁の力を注ぎ込んだ！ ゴーレムのHPが強化された！`);
                                    } else {
                                        gameState.walls.push({
                                            targetId: gameState.party.indexOf(target),
                                            hp: wallHp,
                                            maxHp: wallHp
                                        });
                                        log(`${caster.name}は${target.name}の前に${skill.name}を展開した！`);
                                    }
                                    if (caster.buffs.guardian_high) delete caster.buffs.guardian_high;
                                    break;
                                }
                            case 'guardian_wall_party':
                                {
                                    log(`${caster.name}は${skill.name}を展開した！`);
                                    gameState.party.forEach((p, index) => {
                                        if (p.currentHp > 0) {
                                            const wallHp = Math.ceil(caster.maxHp * skill.power);
                                            // 対象がゴーレム持ちのサモナーかチェック
                                            if (p.role === 'サモナー' && gameState.golem && gameState.golem.hp > 0) {
                                                gameState.golem.hp += wallHp;
                                                gameState.golem.maxHp += wallHp;
                                                log(`${p.name}のゴーレムが防壁の力を吸収し、強化された！`);
                                            } else {
                                                gameState.walls.push({
                                                    targetId: index,
                                                    hp: wallHp,
                                                    maxHp: wallHp
                                                });
                                            }
                                        }
                                    });
                                    break;
                                }
                            case 'self_buff_guardian':
                                {
                                    caster.buffs.protect = 3;
                                    caster.buffs.guardian_high = true;
                                    log(`${caster.name}は${skill.name}を発動！防御力が上がり、次のウォールが強化される！`);
                                    break;
                                }
                                // トラブルメーカー
                            case 'trouble_maker_box':
                                {
                                    // 実装は handleTroubleMakerBox に集約
                                    await handleTroubleMakerBox(caster);
                                    break;
                                }
                            case 'trouble_maker_debuff':
                                {
                                    const debuffDamage = calculateDamage(caster, target, skill);
                                    await dealDamage(target, debuffDamage);
                                    log(`${caster.name}は${skill.name}で${target.name}に${debuffDamage}のダメージを与えた！`);
                                    if (Math.random() < 0.4) { // 40%の確率でデバフ発動
                                        if (Math.random() < 0.5) {
                                            target.buffs.atk_down = 3;
                                            log(`さらに${target.name}の攻撃力が下がった！`);
                                        } else {
                                            target.buffs.def_down = 3;
                                            log(`さらに${target.name}の防御力が下がった！`);
                                        }
                                        flashCard(target, 'yellow');
                                    }
                                    break;
                                }
                            case 'self_buff_trouble':
                                {
                                    caster.buffs.trouble_check = true;
                                    log(`${caster.name}は${skill.name}を開始！次のハプニングボックスはきっとうまくいく！`);
                                    break;
                                }
                            case 'trouble_maker_miracle':
                                {
                                    handleTroubleMakerMiracle(caster);
                                    break;
                                }
                                // シスター
                            case 'special_magic':
                                { // ワンダーカーニバル, ソーンウィップ
                                    if (skill.name === 'ワンダーカーニバル') {
                                        const heightDiff = Math.max(0, caster.initialHeight - caster.height);
                                        const powerBonus = heightDiff * 0.05; // 身長が低いほど威力ボーナス
                                        log(`${caster.name}は${skill.name}を放った！`);
                                        for (const t of target) {
                                            const attackerStats = getEffectiveStats(caster);
                                            const defenderStats = getEffectiveStats(t);
                                            const baseDamage = attackerStats.atk * (skill.power + powerBonus);
                                            const damage = Math.max(1, Math.ceil((baseDamage - Math.min(defenderStats.pDef, defenderStats.mDef)) * (Math.random() * 0.2 + 0.9)));
                                            await dealDamage(t, damage);
                                            if (Math.random() < 0.3) {
                                                t.statusEffects.poison = {
                                                    turns: 3
                                                };
                                                log(`${t.name}は毒状態になった！`);
                                            }
                                        }
                                    } else if (skill.name === 'ソーンウィップ') {
                                        caster.thornWhipUses = (caster.thornWhipUses || 0) + 1;
                                        const powerBonus = Math.pow(caster.thornWhipUses, 2) * 0.5; // 使用回数の2乗でボーナス増加
                                        log(`${caster.name}は${skill.name}を放った！`);
                                        for (const t of target) {
                                            const damage = calculateDamage(caster, t, { // ファイター, ソーサラー, ナイト, メディック
                                                ...skill,
                                                power: skill.power + powerBonus
                                            });
                                            await dealDamage(t, damage);
                                        }
                                    }
                                    break;
                                }
                            case 'special_heal_alraune':
                                { // グロウヒール
                                    log(`${caster.name}は${skill.name}を唱えた！`);
                                    await animateStatChange(target, 'hp', target.maxHp, 'increase');
                                    target.buffs.protect = 3;
                                    log(`${target.name}のHPが全回復し、防御力が上がった！`);
                                    if (target === caster) {
                                        addItemToInventory('potion', 1);
                                        log(`さらに、${caster.name}はポーションを1つ手に入れた！`);
                                    }
                                    break;
                                }
                            case 'regeneration_ally':
                            case 'regeneration_party':
                                { // ファイター, ソーサラー, ナイト, メディック
                                    log(`${caster.name}は${skill.name}を唱えた！`);
                                    const regenTargets = skill.targetType === 'party' ? gameState.party.filter(p => p.currentHp > 0) : [target];

                                    for (const t of regenTargets) {
                                        t.statusEffects.regeneration = {
                                            turns: 3
                                        };
                                        flashCard(t, 'green');
                                        log(`${t.name}は聖なる光に包まれ、傷が再生し始めた！`);
                                    }
                                    // 「祈りの円環」の場合、追加でMP回復効果
                                    if (skill.name === '祈りの円環') {
                                        log("円環の光が、味方全体の魔力を満たしていく！");
                                        regenTargets.forEach(t => t.buffs.mp_regen_once = 2); // 1ターン後(次の自分のターン開始時)に発動
                                    }
                                    break;
                                }
                            case 'dancer_buff_pair':
                                { // ラブステップ
                                    log(`${caster.name}は${target.name}と${skill.name}を踊った！`);
                                    [caster, target].forEach(p => {
                                        p.buffs.agi_up = {
                                            turns: 3,
                                            power: 1.5
                                        };
                                        p.buffs.evade_up = {
                                            turns: 3,
                                            fromLoveStep: true
                                        }; // ラブステップ由来の回避バフ
                                        flashCard(p, 'yellow');
                                    });
                                    log(`${caster.name}と${target.name}の素早さと回避率が上がった！`);

                                    // 身長300cm以上で全体攻撃を追加
                                    if (caster.height > 300 || target.height > 300) {
                                        const shaker = caster.height > 300 ? caster : target;
                                        log(`${shaker.name}は巨大な体でステップを踏み、地面を揺らした！`);
                                        await new Promise(resolve => setTimeout(resolve, 1000)); // メッセージ表示のための待機

                                        const aliveEnemies = gameState.enemies.filter(e => e.currentHp > 0);
                                        const damagePromises = [];
                                        for (const enemy of aliveEnemies) {
                                            // 術者（リリカ）の攻撃力に基づく物理ダメージ
                                            const damage = calculateDamage(caster, enemy, {
                                                power: 0.5,
                                                type: 'physical'
                                            });
                                            damagePromises.push(dealDamage(enemy, damage));
                                        }
                                        await Promise.all(damagePromises);
                                        log(`敵全体に衝撃が走った！`);
                                    }
                                    break;
                                }
                            case 'dancer_party_buff_height':
                                { // キューティチアー
                                    let power = 1.5;
                                    if (caster.height <= 10) {
                                        power = 3.0;
                                    } else if (caster.height < caster.initialHeight) {
                                        const heightRatio = caster.height / caster.initialHeight; // 1未満
                                        power += (1 - heightRatio) * 1.5; // 1.5から3.0の間で線形に増加
                                    }
                                    power = parseFloat(power.toFixed(2));

                                    log(`${caster.name}の${skill.name}！ 味方全体の攻撃力が${power}倍になった！`);
                                    gameState.party.forEach(p => {
                                        if (p.currentHp > 0) {
                                            p.buffs.atk_up = {
                                                turns: 3,
                                                power: power
                                            };
                                            flashCard(p, 'yellow');
                                        }
                                    });
                                    break;
                                }
                            case 'dancer_tension_up':
                                { // センターオブステージ
                                    log(`${caster.name}は${skill.name}に立った！ パーティのテンションが最高潮に！`);
                                    gameState.party.forEach(p => {
                                        if (p.currentHp > 0) p.buffs.tension_up = true; // 永続バフ
                                    });
                                    break;
                                }
                            case 'alchemist_craft':
                                { // マジッククラフト
                                    // レベル4ごとに最大作成数が1増える (Lv1-3: 1-2個, Lv4-7: 1-3個, ...)
                                    const maxQuantity = 2 + Math.floor((caster.level - 1) / 4);
                                    const quantity = Math.floor(Math.random() * maxQuantity) + 1;
                                    const itemToCraft = Math.random() < 0.5 ? 'glass_blade' : 'crazy_bomb';
                                    const itemName = itemBlueprints[itemToCraft].name;

                                    addItemToInventory(itemToCraft, quantity);

                                    log(`${caster.name}は${skill.name}でアイテムを錬成した！`);
                                    await new Promise(resolve => setTimeout(resolve, 1000));
                                    log(`「${itemName}」を${quantity}個手に入れた！`);
                                    flashCard(caster, 'yellow');
                                    break;
                                }
                            case 'samurai_counter_stance':
                                { // 後の先
                                    caster.buffs.go_no_sen = 2; // 次の自分のターンが来るまで有効
                                    caster.buffs.provoke = 2;
                                    flashCard(caster, 'yellow');
                                    log(`${caster.name}は${skill.name}の構えをとった！敵の攻撃を待ち受ける！`);
                                    break;
                                }
                            case 'doctor_debuff':
                                { // 衰弱ガス
                                    log(`${caster.name}は${skill.name}を散布した！`);
                                    target.statusEffects.poison = {
                                        turns: 3
                                    };
                                    target.buffs.atk_down = 3;
                                    target.buffs.def_down = 3;
                                    flashCard(target, 'yellow');
                                    log(`${target.name}は毒におかされ、攻撃力と防御力が低下した！`);
                                    break;
                                }
                            case 'saint_wall':
                                { // セイクリッドウォール
                                    caster.buffs.protect = 3;
                                    const wallHp = Math.ceil(caster.maxHp * 0.1);
                                    // 既存のウォールがあれば耐久値を加算、なければ新規作成
                                    const casterIndex = gameState.party.indexOf(caster);
                                    const existingWall = gameState.walls.find(w => w.targetId === casterIndex);
                                    if (existingWall) {
                                        existingWall.hp += wallHp;
                                        existingWall.maxHp += wallHp;
                                        log(`${caster.name}の防壁がさらに強化された！`);
                                    } else {
                                        gameState.walls.push({
                                            targetId: casterIndex,
                                            hp: wallHp,
                                            maxHp: wallHp
                                        });
                                        log(`${caster.name}は聖なる障壁を展開した！`);
                                    }
                                    flashCard(caster, 'yellow');
                                    break;
                                }
                            case 'divine_light':
                                {
                                    // 敵の最大HPに対する割合ダメージ
                                    const damage = Math.ceil(target.maxHp * skill.power);
                                    log(`${caster.name}は${skill.name}を放った！ ${target.name}に聖なる光が降り注ぐ！`);
                                    // dealDamageは固定ダメージを直接与える
                                    await dealDamage(target, damage);
                                    log(`${target.name}に${damage}の神聖なダメージ！`);
                                    break;
                                }
                            case 'cure_strip_party':
                                { // ビーチエール
                                    log(`${caster.name}は${skill.name}でみんなを元気づけた！`);
                                    let cured = false;
                                    // 解放状態も解除する
                                    gameState.party.forEach(p => {
                                        if (p.isLiberatedStripped) delete p.isLiberatedStripped;
                                    });

                                    gameState.party.forEach(p => {
                                        if (p.statusEffects.stripped) {
                                            delete p.statusEffects.stripped;
                                            cured = true;
                                        }
                                    });
                                    if (cured) log("全員の脱衣状態が治った！");
                                    else log("しかし、誰も脱衣状態ではなかった。");
                                    break;
                                }
                            case 'guardian_stomp':
                                { // タイタンスタンプ
                                    const casterIndex = gameState.party.indexOf(caster);
                                    const wall = gameState.walls.find(w => w.targetId === casterIndex);
                                    if (wall) {
                                        const damage = wall.hp * 2; // 防壁の残りHPの2倍のダメージ
                                        log(`${caster.name}は防壁を砕き、${skill.name}を放った！`);
                                        await dealDamage(target, damage);
                                        // 防壁を削除
                                        gameState.walls = gameState.walls.filter(w => w.targetId !== casterIndex);
                                    } else {
                                        // 防壁がない場合、身長に応じてダメージを計算
                                        const attackerStats = getEffectiveStats(caster);
                                        // (基本攻撃力 + 身長ボーナス) * 揺らぎ でダメージを計算
                                        const damage = Math.max(1, Math.ceil((attackerStats.atk + caster.height * 0.5) * (Math.random() * 0.2 + 0.9)));
                                        log(`${caster.name}はその巨体で${skill.name}を放った！`);
                                        await dealDamage(target, damage);
                                    }
                                    break;
                                }
                            case 'self_wall':
                                { // リラックスタイム
                                    const wallHp = Math.ceil(caster.maxHp * 1.0);
                                    const casterIndex = gameState.party.indexOf(caster);
                                    gameState.walls.push({
                                        targetId: casterIndex,
                                        hp: wallHp,
                                        maxHp: wallHp
                                    });
                                    log(`${caster.name}は${skill.name}でくつろぎ、強力な防壁を展開した！`);
                                    break;
                                }
                            case 'party_mp_regen_special':
                                { // マジックオーラ
                                    log(`${caster.name}は${skill.name}を放ち、味方全体の魔力を活性化させた！`);
                                    gameState.party.forEach(p => {
                                        if (p.currentHp > 0) {
                                            p.buffs.mp_regen_once = 3; // 2ターン後まで効果持続
                                        }
                                    });

                                    if (caster.statusEffects.stripped) {
                                        caster.statusEffects.slow = {
                                            turns: 2
                                        };
                                        log(`しかし、${caster.name}はのぼせてしまい、動きが鈍くなった！`);
                                    } else {
                                        caster.statusEffects.stripped = {
                                            turns: 0
                                        };
                                        log(`しかし、${caster.name}は熱気にあてられ、タオルがはだけてしまった！`);
                                    }
                                    break;
                                }
                            case 'party_heal':
                                { // パッションハート
                                    log(`${caster.name}は${skill.name}で味方を癒した！`);
                                    let healRatio = 0.3;
                                    if (caster.isLiberatedStripped) {
                                        log(`${caster.name}の解放された心が、癒やしの力を増幅させる！`);
                                        await new Promise(resolve => setTimeout(resolve, 500));
                                        healRatio = 0.5; // 解放状態なら50%回復
                                    }
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        const healAmount = Math.ceil(p.maxHp * healRatio);
                                        await animateStatChange(p, 'hp', healAmount, 'increase');
                                    }
                                    break;
                                }
                            case 'self_heal_and_paralyze':
                                { // メンテナンス
                                    log(`${caster.name}は${skill.name}を開始した！`);
                                    await animateStatChange(caster, 'hp', caster.maxHp, 'increase');
                                    await animateStatChange(caster, 'mp', caster.maxMp, 'increase');
                                    caster.statusEffects.paralysis = {
                                        turns: 2
                                    }; // 1ターン麻痺(次のターンは動けない)
                                    log(`${caster.name}のHPとMPが全回復したが、システムがオーバーヒートし麻痺してしまった！`);
                                    break;
                                }
                            case 'hp_cost_growth':
                                { // バンプアップ
                                    if (caster.heightLocked) {
                                        log(`${caster.name}は${skill.name}を使おうとしたが、体が変化を拒んだ！`);
                                        // HPコストは消費される仕様のままにする
                                        break;
                                    }
                                    let growthAmount = skill.power;
                                    if (caster.height < caster.initialHeight) {
                                        log(`${caster.name}はまず初期身長に戻った！`);
                                        const resetAmount = caster.initialHeight - caster.height;
                                        await animateStatChange(caster, 'height', resetAmount, 'increase');
                                        await new Promise(resolve => setTimeout(resolve, 500)); // ログ表示のための短い待機
                                    }
                                    log(`${caster.name}は${skill.name}で自らのボディを強化！`);
                                    await animateStatChange(caster, 'height', growthAmount, 'increase');
                                    log(`${caster.name}の身長がさらに${growthAmount}cm伸びた！`);
                                    break;
                                }
                            case 'mp_burst_height_scaling':
                                { // オーバーブースト
                                    if (caster.currentMp < skill.cost) {
                                        log("MPが足りない！");
                                        break;
                                    }
                                    const heightBonus = Math.max(0, (caster.height - caster.initialHeight) * 0.1);
                                    const boostSkill = {...skill,
                                        power: skill.power + heightBonus
                                    };
                                    log(`${caster.name}は${skill.name}を放った！`);
                                    const damagePromises = [];
                                    for (const t of target) {
                                        damagePromises.push(dealDamage(t, calculateDamage(caster, t, boostSkill)));
                                    }
                                    await Promise.all(damagePromises);
                                    await animateStatChange(caster, 'mp', -caster.currentMp, 'decrease');
                                    break;
                                }
                            case 'party_buff_and_heal':
                                { // フラワーアレンジ
                                    log(`${caster.name}は${skill.name}で場を和ませた！`);
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        p.buffs.atk_up = 3;
                                        await animateStatChange(p, 'hp', 20, 'increase');
                                    }
                                    log("味方全体の攻撃力が上がり、HPが少し回復した！");
                                    break;
                                }
                            case 'height_transfer':
                                { // ロイヤルティ
                                    await handleRoyaltySkill(caster, target);
                                    break;
                                }
                            case 'party_cure_all':
                                { // ティータイム
                                    await handleTeaTimeSkill(caster);
                                    break;
                                }
                            case 'maid_special_buff':
                                { // マジカルエナジー
                                    await handleMagicalEnergySkill(caster);
                                    break;
                                }
                        }
                    }

                    async function handleItem(caster, target, item, isInternalCall = false) {
                        const itemInfo = itemBlueprints[item.id];
                        log(`${caster.name}は${itemInfo.name}を使った！`);

                        switch (itemInfo.effect) {
                            case 'shrink': // リトルスープの特殊処理
                                if (target && !target.isEnemy && target.heightLocked) {
                                    log(`${target.name}は不思議な力で守られており、スープを飲んでも変化がなかった！`);
                                    return false; // アイテム消費しない
                                }
                                if (target && target.isEnemy) {
                                    // 敵に使った場合
                                    target.buffs = target.buffs || {};
                                    target.buffs.atk_down = 3;
                                    target.buffs.def_down = 3;
                                    flashCard(target, 'yellow');
                                    log(`${target.name}は小さくなって弱々しくなった！攻撃力と防御力が低下！`);
                                } else {
                                    // 味方に使った場合
                                    await animateStatChange(target, 'height', -itemInfo.power, 'decrease');
                                    log(`${target.name}の身長が${itemInfo.power}cm縮んだ！`);
                                }
                                break;
                            case 'heal_percent':
                                if (itemInfo.target === 'party') {
                                    log(`味方全員のHPが回復した！`);
                                    for (const p of gameState.party) {
                                        if (p.currentHp > 0) {
                                            const partyHealAmount = Math.ceil(p.maxHp * itemInfo.power);
                                            await animateStatChange(p, 'hp', partyHealAmount, 'increase');
                                            flashCard(p, 'green');
                                            showDamagePopup(p, partyHealAmount, true);
                                        }
                                    }
                                } else {
                                    const itemHealAmount = Math.ceil(target.maxHp * itemInfo.power);
                                    await animateStatChange(target, 'hp', itemHealAmount, 'increase');
                                    flashCard(target, 'green');
                                    showDamagePopup(target, itemHealAmount, true);
                                    log(`${target.name}のHPが${itemHealAmount}回復した！`);
                                }
                                break;
                            case 'reset_height':
                                if (target.heightLocked) {
                                    log(`${target.name}は不思議な力で守られており、ミルクを飲んでも変化がなかった！`);
                                    return false; // アイテム消費しない
                                }
                                const resetDiff = target.initialHeight - target.height;
                                await animateStatChange(target, 'height', resetDiff, 'increase');
                                flashCard(target, 'yellow');
                                log(`${target.name}の身長が元に戻った！`);
                                break;
                            case 'set_height':
                                if (target.heightLocked) {
                                    log(`${target.name}は不思議な力で守られており、ギフトを受け取っても変化がなかった！`);
                                    return false; // アイテム消費しない
                                }
                                const setDiff = itemInfo.power - target.height;
                                const type = setDiff < 0 ? 'decrease' : 'increase';
                                await animateStatChange(target, 'height', setDiff, type); // Await height animation
                                flashCard(target, 'yellow'); // Flash the card itself
                                log(`${target.name}の身長が${itemInfo.power}cmになった！`);
                                break;
                            case 'damage':
                                {
                                    let baseDamage = itemInfo.power;
                                    let floorBonus = 0;
                                    if (item.id === 'glass_blade') {
                                        floorBonus = gameState.floor * 5;
                                    } else if (item.id === 'crazy_bomb') {
                                        floorBonus = gameState.floor * 3;
                                    }
                                    const finalDamage = baseDamage + floorBonus;

                                    if (itemInfo.target === 'enemies') {
                                        const damagePromisesItem = [];
                                        for (const t of target) {
                                            damagePromisesItem.push(dealDamage(t, finalDamage));
                                        }
                                        log(`敵全体に${finalDamage}のダメージ！`);
                                        await Promise.all(damagePromisesItem);
                                    } else {
                                        await dealDamage(target, finalDamage); // Await damage
                                        log(`${target.name}に${finalDamage}の特大ダメージ！`);
                                    }
                                    break;
                                }
                            case 'restore_mp_full':
                                const mpToRestore = target.maxMp - target.currentMp;
                                await animateStatChange(target, 'mp', mpToRestore, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}のMPが全回復した！`);
                                break;
                            case 'increase_max_hp':
                                target.maxHp += itemInfo.power;
                                await animateStatChange(target, 'hp', itemInfo.power, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}の最大HPが${itemInfo.power}上がった！`);
                                break;
                            case 'increase_max_mp':
                                target.maxMp += itemInfo.power;
                                await animateStatChange(target, 'mp', itemInfo.power, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}の最大MPが${itemInfo.power}上がった！`);
                                break;
                            case 'increase_height_and_initial':
                                if (target.heightLocked) {
                                    log(`${target.name}は不思議な力で守られており、エールを飲んでも変化がなかった！`);
                                    return false; // アイテム消費しない
                                }
                                let growthAmount = itemInfo.power;
                                if (target.height < target.initialHeight) {
                                    // 初期値より低い場合、まず初期値に戻す分の増加量を加える
                                    growthAmount += (target.initialHeight - target.height);
                                }
                                await animateStatChange(target, 'height', growthAmount, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}の体が大きく成長した！(身長+${growthAmount}cm)`);
                                break;
                            case 'revive':
                                if (target.currentHp > 0) {
                                    log(`しかし、${target.name}は戦闘不能ではなかった！`);
                                    return false; // アイテム使用失敗
                                }
                                const reviveHealAmount = Math.ceil(target.maxHp * itemInfo.power);
                                target.currentHp = 0; // HPを0にリセットしてから回復アニメーション
                                await animateStatChange(target, 'hp', reviveHealAmount, 'increase');
                                flashCard(target, 'green');
                                showDamagePopup(target, reviveHealAmount, true);
                                log(`${target.name}は意識を取り戻した！`);
                                break;
                            case 'shrink_party_and_debuff_enemies':
                                let anyShrunk = false;
                                log(`シュリンクアロマの香りが戦場に広がる！`);
                                // 味方全員の身長を縮める
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) {
                                        if (p.heightLocked) {
                                            log(`${p.name}は体の変化を拒んだ！`);
                                            continue;
                                        }
                                        anyShrunk = true;
                                        await animateStatChange(p, 'height', -itemInfo.power, 'decrease');
                                    }
                                }
                                if (anyShrunk) {
                                    for (const p of gameState.party) {
                                        if (p.currentHp > 0 && !p.heightLocked) await animateStatChange(p, 'height', -itemInfo.power, 'decrease');
                                    }
                                }
                                // 敵全員にデバフを付与
                                for (const e of gameState.enemies) {
                                    if (e.currentHp > 0) {
                                        e.statusEffects.stat_down = true;
                                    }
                                }
                                log(`敵が大幅に弱体化した！`);
                                break;
                            case 'lock_height_to_one':
                                if (target.heightLocked) {
                                    log(`${target.name}の体はすでに固定されているため、何も起こらなかった。`);
                                    return false; // アイテム消費しない
                                }
                                await animateStatChange(target, 'height', 1 - target.height, 'decrease');
                                target.heightLocked = true;
                                log(`${target.name}の体が妖精のように小さくなり、その姿で固定された！`);
                                break;
                            case 'increase_height_party':
                                log(`パーティ全員に${itemInfo.name}の効果！`);
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) {
                                        if (p.heightLocked) {
                                            log(`${p.name}は体の変化を拒んだ！`);
                                        } else {
                                            await animateStatChange(p, 'height', itemInfo.power, 'increase');
                                        }
                                    }
                                }
                                log(`全員の身長が${itemInfo.power}cm伸びた！`);
                                break;
                            case 'cure_all_and_restore':
                                await animateStatChange(target, 'hp', target.maxHp, 'increase');
                                await animateStatChange(target, 'mp', target.maxMp, 'increase');
                                target.statusEffects = {}; // 脱衣も治す
                                flashCard(target, 'green');
                                log(`${target.name}は完全に回復した！`);
                                break;
                            case 'lock_height_current':
                                await confirmAndLockHeight(target, target.height);
                                return true; // アイテム消費は確認後
                            case 'increase_height_party_30':
                                log(`パーティ全員に${itemInfo.name}の効果！`);
                                for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                    if (p.heightLocked) log(`${p.name}は体の変化を拒んだ！`);
                                    else await animateStatChange(p, 'height', 30, 'increase');
                                }
                                log(`全員の身長が30cm伸びた！`);
                                break;
                        }
                        // 献身の内部呼び出しではUIを更新しない
                        if (isInternalCall) {
                            return;
                        }
                        updatePartyStatus(); // Refresh all cards after animations
                        updateEnemyStatus(); // Enemy status doesn't have number animation, so it can be updated immediately
                        return true; // アイテム使用成功
                    }

                    function confirmAndLockHeight(target, height) {
                        return new Promise((resolve) => {
                            const modal = document.getElementById('height-lock-confirm-modal');
                            const text = document.getElementById('height-lock-confirm-text');
                            const confirmBtn = document.getElementById('height-lock-confirm-button');
                            const cancelBtn = document.getElementById('height-lock-cancel-button');

                            text.textContent = `${target.name}の身長を${height}cmで固定しますか？この冒険中、この効果は解除できません。`;
                            modal.classList.remove('hidden');

                            confirmBtn.onclick = () => {
                                modal.classList.add('hidden');
                                target.heightLocked = true;
                                animateStatChange(target, 'height', height - target.height, height >= target.height ? 'increase' : 'decrease');
                                log(`${target.name}の身長が${height}cmで固定された！`);
                                resolve(true); // アイテム使用成功
                            };

                            cancelBtn.onclick = () => {
                                modal.classList.add('hidden');
                                log("アイテムの使用をやめた。");
                                resolve(false); // アイテム使用失敗
                            };
                        });
                    }

                    function foundAlchemyEvent() {
                        const recipes = [{
                            name: 'エリクサー',
                            itemId: 'elixir',
                            ingredients: {
                                'potion': 1,
                                'mana_potion': 1,
                                'milk': 1
                            },
                            description: 'HP/MP/状態異常を全回復 (ポーション+マナポーション+ミルク)'
                        }, {
                            name: 'ギガントシロップ',
                            itemId: 'gigant_syrup',
                            ingredients: {
                                'pixie_gift': 1,
                                'fairy_syrup': 1,
                                'gigantes_ale': 1
                            },
                            description: '現在の身長で固定 (ピクシーギフト+フェアリーシロップ+ギガンテスエール)'
                        }, {
                            name: 'オーラスフィア',
                            itemId: 'aura_sphere',
                            ingredients: {
                                'cure_mist': 1,
                                'shrink_aroma': 1,
                                'crazy_bomb': 1
                            },
                            description: '全員の身長+30cm (キュアミスト+シュリンクアロマ+クレイジーボム)'
                        }];

                        const checkIngredients = (ingredients) => {
                            return Object.entries(ingredients).every(([itemId, requiredQty]) => {
                                const itemInInventory = gameState.inventory.find(i => i.id === itemId);
                                return itemInInventory && itemInInventory.quantity >= requiredQty;
                            });
                        };

                        const craftableRecipes = recipes.filter(r => checkIngredients(r.ingredients));

                        if (craftableRecipes.length === 0) {
                            log("調合を試みたが、材料が足りず何も作れなかった…。");
                            return;
                        }

                        alchemyOptions.innerHTML = '';
                        craftableRecipes.forEach(recipe => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg text-left';
                            button.innerHTML = `<strong class="text-lg">${recipe.name}</strong><span class="block text-sm text-purple-100 mt-1">${recipe.description}</span>`;
                            button.onclick = () => {
                                // 材料を消費
                                Object.entries(recipe.ingredients).forEach(([itemId, requiredQty]) => {
                                    const itemInInventory = gameState.inventory.find(i => i.id === itemId);
                                    itemInInventory.quantity -= requiredQty;
                                });
                                // 完成品を追加
                                addItemToInventory(recipe.itemId, 1);
                                log(`調合に成功し、「${recipe.name}」を1個手に入れた！`);
                                flashCard(gameState.party[0], 'yellow');
                                alchemyModal.classList.add('hidden');
                                dungeonCommands.classList.remove('hidden');
                            };
                            alchemyOptions.appendChild(button);
                        });

                        alchemyModal.classList.remove('hidden');
                        dungeonCommands.classList.add('hidden');
                    }

                    alchemyCancelButton.onclick = () => {
                        alchemyModal.classList.add('hidden');
                        log("調合をやめて、探索を続けることにした。");
                        dungeonCommands.classList.remove('hidden');
                    };


                    async function handleTreasureHunterAttack(character, target) {
                        log(`${character.name}は${target.name}からアイテムを盗もうとした！`);

                        if (target.stolen) {
                            log(`しかし、${target.name}からはもう何も盗めない！`);
                            if (Math.random() < 0.5) {
                                target.buffs = target.buffs || {};
                                target.buffs.atk_down = 3;
                                log(`${target.name}の攻撃力が下がった！`);
                            } else {
                                target.buffs = target.buffs || {};
                                target.buffs.def_down = 3;
                                log(`${target.name}の防御力が下がった！`);
                            }
                            const mpHeal = Math.ceil(character.maxMp * 0.15);
                            await animateStatChange(character, 'mp', mpHeal, 'increase');
                            log(`${character.name}はMPを${mpHeal}回復した！`);
                            return;
                        }

                        const successRate = 0.5 + (getEffectiveStats(character).agi - getEffectiveStats(target).agi) * 0.02;
                        if (Math.random() < successRate) {
                            const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].rare && !itemBlueprints[id].special);
                            const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                            addItemToInventory(foundItemId);
                            log(`盗みに成功！「${itemBlueprints[foundItemId].name}」を手に入れた！`);
                            target.stolen = true; // 盗み済みフラグ
                            flashCard(character, 'yellow');
                        } else {
                            log("しかし、盗みは失敗した！");
                            flashCard(character, 'red');
                        }
                    }

                    async function handleTransform(character, skill) {
                        if (skill.type === 'transform_revert') {
                            // 変身解除
                            if (character.originalState) {
                                log(`${character.name}は変身を解き、元の姿に戻った！`);
                                character.role = character.originalState.role;
                                character.skills = character.originalState.skills;
                                character.bgClass = character.originalState.bgClass;
                                // 身長は維持するため、originalState.height には戻さない
                                delete character.originalState;
                                delete character.isTransformed;
                                delete character.thornWhipUses;
                            }
                        } else {
                            // 変身処理
                            const transformType = skill.type.split('_')[1]; // 'succubus', 'fairy', 'alraune'
                            const blueprint = allCharacterBlueprints.find(c => c.name === 'リリィ');
                            const transformData = blueprint.transforms[transformType];

                            if (!transformData) return;

                            // 元の状態を保存
                            character.originalState = {
                                role: character.role,
                                skills: character.skills,
                                bgClass: character.bgClass,
                                height: character.height
                            };

                            log(`${character.name}は${transformData.role}に変身した！`);

                            // ステータス、スキル、見た目を変更
                            character.role = transformData.role;
                            character.skills = transformData.skills;
                            character.bgClass = transformData.bgClass;
                            character.isTransformed = true;

                            // 変身時の特殊効果
                            switch (transformType) {
                                case 'succubus':
                                    await animateStatChange(character, 'height', 30, 'increase');
                                    break;
                                case 'fairy':
                                    await animateStatChange(character, 'height', -30, 'decrease');
                                    break;
                                case 'alraune':
                                    await animateStatChange(character, 'hp', character.maxHp, 'increase');
                                    break;
                            }
                        }
                        updatePartyStatus();
                    }
                    async function handleRoyaltySkill(caster, target) {
                        log(`${caster.name}は${target.name}に${caster.skills.find(s => s.type === 'height_transfer').name}を発動！`);
                        if (target.heightLocked) {
                            log(`しかし、${target.name}の体は不思議な力で守られており、変化しなかった！`);
                            caster.currentMp += 20; // MP消費をキャンセル
                            return;
                        }

                        let totalHeightToTransfer = 0;
                        const otherMembers = gameState.party.filter(p => p !== target && p.currentHp > 0);

                        for (const member of otherMembers) {
                            if (member.heightLocked) {
                                log(`${member.name}の体は変化を拒んだ！`);
                                continue;
                            }
                            const heightToGive = member.height - 1;
                            if (heightToGive > 0) {
                                totalHeightToTransfer += heightToGive;
                                await animateStatChange(member, 'height', -heightToGive, 'decrease');
                            }
                        }

                        if (totalHeightToTransfer > 0) {
                            await animateStatChange(target, 'height', totalHeightToTransfer, 'increase');
                            log(`${target.name}に仲間たちの身長が集約され、他のメンバーは1cmになった！`);
                        } else {
                            log("しかし、誰も身長を分け与えることができなかった…。");
                        }
                    }

                    async function handleTeaTimeSkill(caster) {
                        log(`${caster.name}は優雅に${caster.skills.find(s => s.type === 'party_cure_all').name}の準備をした！`);
                        let curedAny = false;
                        gameState.party.forEach(p => {
                            if (p.currentHp > 0) {
                                const effects = Object.keys(p.statusEffects);
                                if (effects.length > 0) {
                                    curedAny = true;
                                    p.statusEffects = {};
                                    log(`${p.name}の状態異常がすべて治った！`);
                                    flashCard(p, 'green');
                                }
                            }
                        });
                        if (!curedAny) {
                            log("…が、誰も状態異常ではなかったようだ。");
                        }
                    }

                    async function handleMagicalEnergySkill(caster) {
                        log(`${caster.name}は${caster.skills.find(s => s.type === 'maid_special_buff').name}を発動！`);
                        caster.buffs.provoke = 3;
                        caster.buffs.atk_up = 3;
                        caster.buffs.protect = 3;
                        caster.buffs.hp_absorb = true; // 永続
                        caster.buffs.heal_spread = true; // 永続
                        if (caster.height < caster.initialHeight) {
                            await animateStatChange(caster, 'height', caster.initialHeight - caster.height, 'increase');
                        }
                        log(`${caster.name}は不思議な力に包まれ、大幅に強化された！`);
                        flashCard(caster, 'yellow');
                    }


                    async function handleTroubleMakerBox(caster) {
                        log(`${caster.name}は${caster.skills[0].name}を開けた！`);
                        const isChecked = caster.buffs.trouble_check;
                        const successRate = isChecked ? 0.9 : 0.6; // ばっちりチェックで成功率90%
                        if (isChecked) delete caster.buffs.trouble_check;

                        if (Math.random() < successRate) {
                            // 成功

                            // 大あたり抽選 (ばっちりチェック中のみ)
                            if (isChecked && Math.random() < 0.1) { // 10%の確率で大あたり
                                log("箱から眩い光が！これは…大当たりだ！");
                                const isBossBattle = gameState.enemies.some(e => e.isBoss); // ファイター, ソーサラー, ナイト, メディック
                                if (isBossBattle) {
                                    const boss = gameState.enemies.find(e => e.isBoss);
                                    const damage = Math.floor(boss.maxHp * 0.5);
                                    log(`ボスの体に亀裂が走る！`);
                                    await dealDamage(boss, damage);
                                } else {
                                    log("敵が一瞬で塵と化した！");
                                    const damagePromises = [];
                                    for (const enemy of gameState.enemies.filter(e => e.currentHp > 0)) {
                                        damagePromises.push(dealDamage(enemy, enemy.currentHp));
                                    }
                                    await Promise.all(damagePromises);
                                }
                                return; // 大あたりの場合はここで処理終了
                            }

                            // 通常の成功効果
                            const goodEffects = [
                                async() => {
                                    log("箱から光が溢れ、敵全体に大ダメージ！");
                                    const damagePromisesBox = gameState.enemies.filter(e => e.currentHp > 0).map(enemy => dealDamage(enemy, 150 + caster.atk * 2));
                                    await Promise.all(damagePromisesBox);
                                },
                                async() => {
                                    log("箱からお菓子が飛び出し、味方全体が回復した！"); // 回復は1人ずつアニメーション
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.5), 'increase');
                                    }
                                }, {
                                    name: "あたり",
                                    func: () => {
                                        log("箱から虹色のオーラが！味方全体が強化され、傷が癒えていく！");
                                        gameState.party.forEach(p => {
                                            if (p.currentHp > 0) {
                                                p.buffs.atk_up = 3;
                                                p.statusEffects.regeneration = {
                                                    turns: 3
                                                };
                                                flashCard(p, 'yellow');
                                            }
                                        });
                                    }
                                },
                                () => {
                                    log("箱から怪しいガスが！敵全体が弱体化した！");
                                    gameState.enemies.forEach(e => {
                                        if (e.currentHp > 0) e.statusEffects.stat_down = true;
                                    });
                                }
                            ];
                            const chosenGoodEffect = goodEffects[Math.floor(Math.random() * goodEffects.length)];
                            await (typeof chosenGoodEffect === 'function' ? chosenGoodEffect() : chosenGoodEffect.func());
                        } else {
                            // 失敗
                            const badEffects = [{
                                name: "shrink",
                                func: async() => {
                                    log("箱から黒い煙が！味方全体が縮んでしまった！");
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        await animateStatChange(p, 'height', -30, 'decrease');
                                    }
                                }
                            }, {
                                name: "tiny_damage",
                                func: async() => {
                                    const randomEnemy = gameState.enemies.filter(e => e.currentHp > 0)[Math.floor(Math.random() * gameState.enemies.filter(e => e.currentHp > 0).length)];
                                    if (randomEnemy) {
                                        log("箱からかわいい小動物が飛び出して、敵にかみついた！");
                                        await dealDamage(randomEnemy, 1);
                                    } else {
                                        log("箱からかわいい小動物が飛び出したが、何事もなかった。");
                                    }
                                }
                            }, {
                                name: "strip_all",
                                func: () => {
                                    log("箱から妖しい光が！ なんと味方全員が脱衣状態になってしまった！");
                                    gameState.party.forEach(p => { // ファイター, ソーサラー, ナイト, メディック
                                        if (p.currentHp > 0 && p.role !== 'ナイト' && p.role !== 'サムライ' && p.role !== '聖女') {
                                            p.statusEffects.stripped = {
                                                turns: 0
                                            };
                                        }
                                    });
                                }
                            }, ];
                            const chosenEffect = badEffects[Math.floor(Math.random() * badEffects.length)];
                            await chosenEffect.func();
                        }
                    }

                    async function handleTroubleMakerMiracle(caster) {
                        const isChecked = caster.buffs.trouble_check;
                        log(`${caster.name}は${caster.skills.find(s => s.type === 'trouble_maker_miracle').name}を使った！`);
                        if (isChecked) {
                            delete caster.buffs.trouble_check;
                            log("ばっちりチェックの効果で、奇跡は確実に起こる！");
                        }

                        // ばっちりチェック中ではない場合、5%で失敗
                        if (!isChecked && Math.random() < 0.05) {
                            log("…しかし、何も起こらなかった！");
                        } else {
                            log("奇跡の光がパーティを包む！");
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                await animateStatChange(p, 'mp', p.maxMp, 'increase');
                                p.buffs.atk_up = 3;
                                p.buffs.protect = 3;
                                flashCard(p, 'green');
                            }
                            log("味方全体が全回復し、強化された！");
                        }
                    }


                    async function enemyTurn(enemy) {
                        log(`${enemy.name}のターン`);
                        enemy.turnCount = (enemy.turnCount || 0) + 1; // ターン数をカウント

                        // アークリッチの特殊AI (1ターン目に必ず「いたずら」)
                        if (enemy.name === 'アークリッチ' && enemy.turnCount === 1) { // ファイター, ソーサラー, ナイト, メディック
                            const archlichTarget = findTarget(enemy);
                            await inflictStrippedForArchlich(enemy, archlichTarget);
                            endEnemyTurn(enemy); // ターン終了
                            return;
                        }

                        const target = findTarget(enemy);

                        // 星の観測者の特殊AI
                        if (enemy.specialAIType === 'star_observer') {
                            if (enemy.buffs && enemy.buffs.omen) {
                                // 奥義準備中の行動
                                if (enemy.buffs.omen === 1) {
                                    // 最終ターンにブラックホール
                                    await blackholeSkill(enemy, target);
                                } else {
                                    // それ以外の準備ターン
                                    const roll = Math.random();
                                    if (roll < 0.4) { // 40%で全体縮小
                                        log(`${enemy.name}は星屑のシャワーを降らせた！`);
                                        for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                            if (!p.heightLocked) await animateStatChange(p, 'height', -20, 'decrease');
                                        }
                                    } else if (roll < 0.7) { // 30%で単体ステータス吸収
                                        log(`${enemy.name}は${target.name}の才能を盗み見た！`);
                                        const statToSteal = ['atk', 'def', 'agi'][Math.floor(Math.random() * 3)];
                                        target.buffs[`${statToSteal}_down`] = 3;
                                        enemy.buffs[`${statToSteal}_up`] = 3;
                                        log(`${target.name}の${statToSteal === 'atk' ? '攻撃力' : statToSteal === 'def' ? '防御力' : '素早さ'}が下がり、${enemy.name}の能力が上がった！`);
                                    } else { // 30%で通常攻撃
                                        await defaultEnemyAttack(enemy, target);
                                    }
                                }
                            } else {
                                // 1ターン目は必ず「瞬き」
                                await blinkSkill(enemy);
                            }
                            endEnemyTurn(enemy);
                            return;
                        }

                        // 模倣体の特殊AI
                        if (enemy.specialAIType === 'imitation') {
                            // 50%の確率でスキルを使用
                            if (enemy.skills.length > 0 && Math.random() < 0.5) {
                                // 使用させたくないスキルタイプを除外
                                const unusableSkillTypes = ['utility', 'samurai_counter_stance', 'summon_golem', 'guardian_wall'];
                                const usableSkills = enemy.skills.filter(s => !unusableSkillTypes.includes(s.originalType));

                                if (usableSkills.length > 0) {
                                    const originalSkill = usableSkills[Math.floor(Math.random() * usableSkills.length)];
                                    log(`${enemy.name}は「${originalSkill.name}」を模倣した！`);
                                    await new Promise(resolve => setTimeout(resolve, 1000));

                                    // 模倣スキルの効果を簡略化
                                    if (originalSkill.targetType === 'enemy') {
                                        // 単体攻撃スキル
                                        const isMagic = originalSkill.originalType.includes('magic');
                                        const damage = calculateDamage(enemy, target, {
                                            type: isMagic ? 'magic' : 'physical',
                                            power: 2.0
                                        });
                                        await dealDamage(target, damage);
                                        log(`${enemy.name}の強力な一撃！ ${target.name}に${damage}のダメージ！`);
                                    } else if (originalSkill.targetType === 'enemies') {
                                        // 全体攻撃スキル
                                        const isMagic = originalSkill.originalType.includes('magic');
                                        log(`${enemy.name}は全体攻撃を放った！`);
                                        const damagePromises = [];
                                        for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                            const damage = calculateDamage(enemy, p, {
                                                type: isMagic ? 'magic' : 'physical',
                                                power: 1.2
                                            });
                                            damagePromises.push(dealDamage(p, damage));
                                        }
                                        await Promise.all(damagePromises);
                                    } else {
                                        // 自己強化・回復スキル
                                        if (Math.random() < 0.5) {
                                            enemy.buffs.atk_up = 3;
                                            log(`${enemy.name}は自身の攻撃力を上げた！`);
                                        } else {
                                            const healAmount = Math.ceil(enemy.maxHp * 0.2);
                                            await dealDamage(enemy, -healAmount, true);
                                            log(`${enemy.name}は自身のHPを${healAmount}回復した！`);
                                        }
                                    }
                                    endEnemyTurn(enemy);
                                    return;
                                }
                            }
                            // スキルを使わない、または使えるスキルがない場合は通常攻撃
                            await defaultEnemyAttack(enemy, findTarget(enemy));
                            endEnemyTurn(enemy);
                            return; // 模倣体のターンを終了
                        } // ファイター, ソーサラー, ナイト, メディック

                        // ターゲットがゴーレムやウォールの場合、特殊行動はせず通常攻撃
                        const isDefensiveTarget = target.isWall || target === gameState.golem;


                        // 敵のバフ・デバフターン経過処理
                        if (enemy.buffs) {
                            Object.keys(enemy.buffs).forEach(key => {
                                enemy.buffs[key]--;
                                if (enemy.buffs[key] <= 0) {
                                    delete enemy.buffs[key];
                                    let buffName = '';
                                    if (key === 'atk_down') buffName = '攻撃力低下';
                                    else if (key === 'def_down') buffName = '防御力低下';
                                    if (buffName) {
                                        log(`${enemy.name}の${buffName}効果が切れた。`);
                                    }
                                }
                            });
                        }

                        let actionTaken = false;

                        if (enemy.specialAIType === 'phantom_hero') {
                            if (enemy.turnCount === 1) {
                                await chainLockSkill(enemy);
                                actionTaken = true;
                            } else if (enemy.currentHp / enemy.maxHp < 0.5 && !enemy.usedFocus) {
                                await focusSkill(enemy);
                                enemy.usedFocus = true;
                                actionTaken = true;
                            } else if (enemy.currentHp / enemy.maxHp < 0.15 && !enemy.usedHeroicEnd) {
                                await heroicEndSkill(enemy, target);
                                enemy.usedHeroicEnd = true;
                                actionTaken = true;
                            } else if (enemy.specialAIType === 'aqua_dragon' && enemy.turnCount === 1) {
                                // アクアドラゴンの初手行動
                                const skill = enemy.skills.find(s => s.name === 'ミニマムシャワー');
                                if (skill && skill.func) {
                                    await skill.func(enemy);
                                }
                            }
                        } else if (enemy.name === 'インプ' && !enemy.mischiefUsed && !isDefensiveTarget && Math.random() < 0.25) {
                            actionTaken = await inflictStripped(enemy, target);
                        } else if (enemy.name === 'アークリッチ' && enemy.turnCount === 1) {
                            await inflictStrippedForArchlich(enemy, target);
                            actionTaken = true;
                        } else if (enemy.skills && enemy.skills.length > 0 && !isDefensiveTarget && Math.random() < 0.5) {
                            const skill = enemy.skills[Math.floor(Math.random() * enemy.skills.length)];
                            if (skill.name === '状態異常攻撃') {
                                inflictStatusEffect(enemy, target);
                                actionTaken = true;
                            } else if (skill.func) {
                                await skill.func(enemy, target);
                                actionTaken = true;
                            }
                        }

                        // どの特殊行動も実行されなかった場合、通常攻撃を行う
                        if (!actionTaken) {
                            await defaultEnemyAttack(enemy, target);
                        }

                        // 旧ロジックを削除
                        /*
                        ...
                        } else {
                            // 通常攻撃
                            await defaultEnemyAttack(enemy, target);
                        }*/

                        endEnemyTurn(enemy);
                    }

                    async function endEnemyTurn(enemy) {
                        updatePartyStatus(); // Refresh all cards after animations
                        updateEnemyStatus();

                        // ターン終了時の反撃処理
                        if (enemy.counterTarget) {
                            const {
                                counterAttacker,
                                damage, // ファイター, ソーサラー, ナイト, メディック
                                isHpAbsorb
                            } = enemy.counterTarget;
                            await counterAttack(counterAttacker, enemy, damage, isHpAbsorb);
                            delete enemy.counterTarget; // 反撃処理後にクリア
                        }

                        // ターン終了時の毒ダメージ
                        if (enemy.statusEffects && enemy.statusEffects.poison) {
                            const poisonDamage = Math.max(1, Math.ceil(enemy.maxHp * 0.05));
                            log(`${enemy.name}は毒のダメージを受けている！`);
                            await dealDamage(enemy, poisonDamage);
                            updateEnemyStatus();
                        }

                        // ターン終了時の自然治癒
                        if (enemy.statusEffects && enemy.statusEffects.regeneration) {
                            let healAmount = Math.max(1, Math.ceil(enemy.maxHp * 0.08));
                            // 祝福の処理
                            if (character.blessings && character.blessings.hp_regen) {
                                healAmount += Math.max(1, Math.ceil(character.maxHp * 0.05));
                            }
                            if (character.blessings && character.blessings.mp_regen) {
                                const mpHeal = Math.max(1, Math.ceil(character.maxMp * 0.05));
                                animateStatChange(character, 'mp', mpHeal, 'increase');
                            }
                            log(`${enemy.name}の傷が再生していく！`); // 敵の回復ログ
                            await dealDamage(enemy, -healAmount, true);
                            updateEnemyStatus();
                        }

                        setTimeout(() => {
                            gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                            nextTurn();
                        }, 1000);
                    }

                    async function defaultEnemyAttack(enemy, target, power = 1.0) {
                        const damage = calculateDamage(enemy, target);
                        if (damage === 'evaded' && target.role === 'ダンサー' && target.buffs && target.buffs.provoke) {
                            // ダンサーの回避時反撃
                            let counterMessage = `${target.name}は攻撃を華麗にかわし、反撃の体勢に入った！`;
                            let counterPowerMultiplier = 1.0;
                            if (target.isLiberatedStripped) {
                                counterMessage = `${target.name}の解放された肉体が、反撃の威力を増大させる！`;
                                counterPowerMultiplier = 2.0;
                            }
                            log(counterMessage);
                            // ダンサー(target)が敵(enemy)に反撃する
                            const counterDamage = calculateDamage(target, enemy, null, true);
                            enemy.counterTarget = {
                                counterAttacker: target,
                                damage: counterDamage * counterPowerMultiplier
                            };
                        } else if (damage === 'evaded') {
                            log(`${target.name}は攻撃をかわした！`);
                            showDamagePopup(target, '回避');
                            flashCard(target, 'yellow');
                        } else {
                            // サムライ「後の先」の反撃
                            if (target.buffs && target.buffs.go_no_sen) {
                                log(`${target.name}は後の先で反撃！`);
                                enemy.counterTarget = {
                                    counterAttacker: target,
                                    damage: getEffectiveStats(target).atk * 2 // 攻撃力を倍にして反撃
                                };
                            } else if (target.role === 'ナイト' && target.buffs && target.buffs.provoke && Math.random() < 0.5) {
                                // ナイトの被弾時反撃
                                enemy.counterTarget = { // ファイター, ソーサラー, ナイト, メディック
                                    counterAttacker: target,
                                    damage: getEffectiveStats(target).atk
                                };
                            }
                            // 祝福: 反撃
                            if (target.blessings && target.blessings.counter_attack && Math.random() < 0.3) {
                                log(`${target.name}は祝福の力で反撃の構えをとった！`);
                                enemy.counterTarget = {
                                    counterAttacker: target,
                                    damage: getEffectiveStats(target).atk
                                };
                            }
                            // メイドのHP吸収
                            if (target.buffs && target.buffs.hp_absorb) {
                                enemy.counterTarget = {
                                    counterAttacker: target,
                                    damage: getEffectiveStats(target).atk,
                                    isHpAbsorb: true // HP吸収フラグを追加
                                }; // ファイター, ソーサラー, ナイト, メディック
                            }

                            // 通常のダメージ処理
                            // 反撃の祝福
                            if (target.blessings && target.blessings.counter_attack && Math.random() < 0.3) {
                                enemy.counterTarget = {
                                    counterAttacker: target,
                                    damage: getEffectiveStats(target).atk
                                };
                            }
                            await dealDamage(target, damage);
                            if (target.isWall) {
                                log(`${enemy.name}の攻撃！ 防壁に${damage}のダメージ！`);
                            } else {
                                log(`${enemy.name}の攻撃！ ${target.name}に${damage}のダメージ！`);
                            }
                        }

                        // 接頭辞による追加効果
                        if (enemy.name.startsWith('【毒纏い】') && !target.isWall && target !== gameState.golem && Math.random() < 0.2) {
                            log(`${enemy.name}の攻撃から毒が放たれた！`);
                            target.statusEffects.poison = {
                                turns: 3
                            };
                            flashCard(target, 'yellow');
                            log(`${target.name}は毒状態になった！`);
                        }

                        if (enemy.name.startsWith('【痺れる】') && !target.isWall && target !== gameState.golem && Math.random() < 0.2) {
                            log(`${enemy.name}の攻撃から電撃が走った！`);
                            target.statusEffects.paralysis = true;
                            flashCard(target, 'yellow');
                            log(`${target.name}は麻痺してしまった！`);
                        }

                        updatePartyStatus();

                    }

                    async function counterAttack(counterAttacker, originalAttacker, damage, isHpAbsorb = false) {
                        log(`${counterAttacker.name}の反撃！`);
                        const counterDamage = Math.max(1, damage); // 保存しておいたダメージをそのまま使う
                        await dealDamage(originalAttacker, counterDamage);
                        log(`${originalAttacker.name}に${counterDamage}のダメージ！`);

                        // HP吸収効果の処理
                        if (isHpAbsorb) {
                            const absorbAmount = Math.ceil(counterDamage * 0.2);
                            log(`${counterAttacker.name}は反撃から生命力を吸収した！`);
                            await dealDamage(counterAttacker, -absorbAmount, true); // isHealをtrueにしてdealDamageを呼び出す
                        }
                    }

                    async function heroicEndSkill(enemy, target) {
                        log(`${enemy.name}は${enemy.skills[2].name}を放つ！`);
                        const damage = calculateDamage(enemy, target, {
                            power: 3.5
                        }); // 高威力
                        await dealDamage(target, damage);
                        log(`${enemy.name}の${enemy.skills[2].name}！ ${target.name}に${damage}の特大ダメージ！`);
                    }


                    function findTarget(enemy, forCounterDamageCalc = false) {
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);

                        // インプが集中攻撃対象を持っている場合
                        if (enemy.name === 'インプ' && enemy.focusedTargetId !== null) {
                            const focused = gameState.party[enemy.focusedTargetId];
                            if (focused && focused.currentHp > 0) return focused;
                        }

                        // ガーディアンのウォール判定
                        const wallsOnParty = gameState.walls.map((wall, index) => ({...wall,
                            wallIndex: index
                        })).filter(wall => aliveParty.some(p => gameState.party.indexOf(p) === wall.targetId));

                        if (wallsOnParty.length > 0) {
                            // 複数のウォールがある場合、ランダムで1つをターゲットにする
                            const randomWall = wallsOnParty[Math.floor(Math.random() * wallsOnParty.length)];
                            return {...randomWall,
                                isWall: true
                            };
                        }

                        // 「英雄の幻影」の特殊AI
                        if (enemy.specialAIType === 'phantom_hero') {
                            const provokingChar = aliveParty.find(p => p.buffs && (p.buffs.provoke || p.buffs.cover));
                            const golemActive = gameState.golem && gameState.golem.hp > 0;
                            const wallActive = gameState.walls.length > 0;

                            if (provokingChar) {
                                return provokingChar;
                            }
                            if (golemActive) {
                                return gameState.golem;
                            }
                            if (wallActive) {
                                const randomWall = gameState.walls[Math.floor(Math.random() * gameState.walls.length)];
                                return {...randomWall,
                                    isWall: true,
                                    wallIndex: gameState.walls.indexOf(randomWall)
                                };
                            }
                        }

                        // ゴーレムが召喚されていれば最優先でターゲットにする
                        if (gameState.golem && gameState.golem.hp > 0) {
                            return gameState.golem;
                        }

                        // 「かばう」状態のキャラがいれば最優先
                        const coveringMember = aliveParty.find(p => p.buffs && p.buffs.cover);
                        if (coveringMember) {
                            return coveringMember;
                        }

                        updateHate();
                        const totalHate = aliveParty.reduce((sum, char) => sum + char.hate, 0);
                        let random = Math.random() * totalHate;
                        for (const char of aliveParty) {
                            random -= char.hate;
                            if (random <= 0) return char;
                        }
                        return aliveParty[0];
                    }

                    function calculateDamage(attacker, defender, skill = null, isCounter = false) {
                        const attackerStats = getEffectiveStats(attacker);
                        let skillPowerMultiplier = 1.0;
                        let baseAtk;

                        // 魔法攻撃の場合、身長補正を無視し、バフのみを適用した攻撃力を計算
                        if (skill && skill.type && (skill.type === 'magic' || skill.type.includes('magic'))) {
                            baseAtk = attacker.atk; // 素の攻撃力
                            if (attacker.buffs && attacker.buffs.atk_up) {
                                baseAtk *= 1.5; // 攻撃力アップバフは適用
                            }
                            // リーパーの脱衣デバフも適用
                            if (attacker.statusEffects && attacker.statusEffects.stripped && attacker.role === 'リーパー') {
                                baseAtk *= 0.5;
                            }
                        } else if (isCounter) {
                            // ダンサーの反撃ダメージ計算時: 敵の素の攻撃力を参照
                            baseAtk = attacker.atk;
                        } else {
                            // 物理攻撃や通常攻撃の場合は、身長補正を含む攻撃力を使用
                            baseAtk = attackerStats.atk;
                        }

                        // インプが脱衣状態の相手を攻撃する場合、ダメージを減少させる
                        if (attacker.name === 'インプ' && defender.statusEffects && defender.statusEffects.stripped) {
                            baseAtk *= 0.7; // ダメージを30%減少
                        }


                        // 渾身斬りのクリティカル判定
                        if (skill && skill.name === '渾身斬り' && Math.random() < 0.3) {
                            log('会心の一撃！');
                            skillPowerMultiplier = 3; // ダメージ計算用の倍率を変更 // ファイター, ソーサラー, ナイト, メディック
                        }

                        let baseDamage = skill ? baseAtk * ((skill && skill.power) || 1.0) * skillPowerMultiplier : baseAtk;
                        let effectiveDefense = 0;

                        // 防御側の防御力を決定
                        if (defender.isWall) {
                            // ウォールの場合、防御力は0とする
                            effectiveDefense = 0;
                        } else if (defender === gameState.golem) {
                            // ゴーレムの場合、防御力は0とする
                            effectiveDefense = 0;
                        } else if (defender.isEnemy) {
                            // 敵の場合、攻撃タイプに応じて物理防御力か魔法防御力を適用
                            let attackType = 'physical';
                            if (skill && skill.type === 'magic') {
                                attackType = 'magic'; // スキルが魔法なら魔法攻撃
                            } else if (!skill && attacker.buffs && attacker.buffs.atk_up) {
                                // エンチャント(atk_up)中の通常攻撃は魔法攻撃扱い
                                attackType = 'magic';
                            }
                            // 祝福: 巨人殺し
                            if (attacker.blessings && attacker.blessings.giant_slayer && attacker.height < defender.height) {
                                baseDamage *= 1.5;
                            }
                            // 祝福: 巨人の力
                            if (attacker.blessings && attacker.blessings.height_power) {
                                const heightBonus = Math.max(0, (attacker.height - 150) / 150); // 150cmを基準に、150cmごとに100%ボーナス
                                baseDamage *= (1 + heightBonus);
                            }
                            // 新スキル: ヘビースラッシュ
                            if (skill && skill.type === 'heavy_slash') {
                                const heightBonus = Math.max(0, (attacker.height - attacker.initialHeight) * 0.2); // 身長が高いほどボーナス
                                baseDamage += heightBonus;
                            }
                            // 新スキル: チェインスペル
                            if (skill && skill.type === 'chain_spell') {
                                const heightBonus = Math.max(0, (attacker.initialHeight - attacker.height) * 0.3); // 身長が低いほどボーナス
                                baseDamage += heightBonus;
                            }
                            // 新スキル: クラッシュハグ
                            if (skill && skill.type === 'crush_hug') {
                                const heightDifference = attacker.height - defender.height;
                                if (heightDifference > 0) {
                                    const hugBonus = heightDifference * 0.5; // 身長差が大きいほどボーナス
                                    baseDamage += hugBonus;
                                    log(`${attacker.name}は${defender.name}を力強く抱きしめた！`);
                                }
                            }
                            // 祝福: 妖精の加護

                            if (attacker.blessings && attacker.blessings.fairy_grace && attacker.height === 1 && skill) {
                                log(`${attacker.name}の妖精の加護がスキルを強化する！`);
                                baseDamage *= 3;
                            }
                            // 祝福: 絶対零度
                            if (attacker.blessings && attacker.blessings.absolute_zero && Math.random() < 0.1) {
                                defender.statusEffects = defender.statusEffects || {};
                                defender.statusEffects.paralysis = true; // 1ターン麻痺
                                log(`${attacker.name}の一撃が${defender.name}を凍てつかせた！`);
                            }
                            const defenderStats = getEffectiveStats(defender);
                            effectiveDefense = (attackType === 'magic') ? defenderStats.mDef : defenderStats.pDef;

                            // 祝福: 巨躯の地ならし
                            if (attacker.blessings && attacker.blessings.giant_grounding && !skill) { // 通常攻撃時のみ
                                if (attacker.height > defender.height) {
                                    log(`${attacker.name}の巨躯の地ならし！${defender.name}の防御力を無視する！`);
                                    effectiveDefense = 0;
                                }
                            }
                        } else {
                            // 味方の場合、getEffectiveStatsで計算された防御力を使用し、防御状態を考慮
                            const defenderStats = getEffectiveStats(defender);
                            effectiveDefense = defenderStats.def;
                            if (defender.isDefending) {
                                effectiveDefense *= 2;
                            }
                        }

                        // モンクの破砕拳は防御無視
                        if (skill && skill.type === 'def_ignore_physical') {
                            effectiveDefense = 0;
                        }

                        // 溜め攻撃の処理 (物理攻撃のみ)
                        if (attacker.chargeCount > 0 && (!skill || skill.type === 'physical' || skill.type === 'growth_physical' || skill.type === 'hp_cost_physical')) {
                            const chargeMultiplier = 1 + (1.5 * attacker.chargeCount);
                            baseDamage *= chargeMultiplier;
                            attacker.chargeCount = 0;
                        }

                        // ダメージから防御力を減算
                        baseDamage -= effectiveDefense;

                        // 祝福: エレメンタルシールド
                        if (defender.blessings && defender.blessings.elemental_shield) {
                            baseDamage *= 0.75;
                        }
                        // フェアリーのワンダーカーニバル
                        if (skill && skill.name === 'ワンダーカーニバル') {
                            const defenderStats = getEffectiveStats(defender);
                            effectiveDefense = Math.min(defenderStats.pDef, defenderStats.mDef);
                            baseDamage = attackerStats.atk * skill.power; // 攻撃力ベースで計算
                        }

                        // ダンサーの回避判定 (スポットライト効果中)
                        if (defender.buffs && defender.buffs.evade_up) {
                            let evadeRate = 0.7; // 基本回避率70%
                            const heightDiff = defender.initialHeight - defender.height;

                            // 身長が初期値より低い場合、回避率にボーナス
                            if (heightDiff > 0) { // ファイター, ソーサラー, ナイト, メディック
                                // 1cm低くなるごとに0.15%回避率が上昇
                                // ラブステップ中のボーナス
                                if (defender.buffs.evade_up.fromLoveStep) {
                                    evadeRate += 0.1;
                                }

                                const bonusEvadeRate = heightDiff * 0.0015;
                                evadeRate += bonusEvadeRate;
                            }
                            // フェアリー変身中の素早さボーナス
                            if (attacker.role === 'フェアリー') {
                                const heightDiff = attacker.initialHeight - attacker.height;
                                const agiBonus = Math.floor(attacker.agi * (heightDiff / attacker.initialHeight * -1.5));
                                agi += agiBonus; // 通常の2倍のボーナス
                            }
                            // 祝福: 小人の俊敏
                            if (defender.blessings && defender.blessings.low_height_evade) {
                                const heightDiffBonus = Math.max(0, defender.initialHeight - defender.height);
                                evadeRate += (heightDiffBonus * 0.002); // 1cmあたり0.2%回避率上昇
                            }

                            // 回避率の上限を95%に設定
                            const finalEvadeRate = Math.min(0.95, evadeRate);

                            if (Math.random() < finalEvadeRate) {
                                log(`${defender.name}は華麗に攻撃をかわした！`);
                                return 'evaded'; // 回避したことを示す特別な値を返す
                            }
                        }
                        // ダメージに±10%の揺らぎを追加
                        const finalDamage = Math.max(1, Math.ceil(baseDamage * (Math.random() * 0.2 + 0.9)));
                        return finalDamage;
                    }
                    async function dealDamage(target, amount, isHeal = false) {
                        // ターゲットがウォールの場合
                        if (target && target.isWall) {
                            const wall = gameState.walls[target.wallIndex];
                            wall.hp = Math.max(0, wall.hp - amount);
                            log(`防壁が攻撃を受け止めた！ (防壁の残り耐久値: ${wall.hp})`);
                            if (wall && wall.hp <= 0) {
                                flashCard(gameState.party[wall.targetId], 'red');
                                log("防壁は砕け散った！");
                                gameState.walls.splice(target.wallIndex, 1);
                            }
                            return;
                        }
                        if (amount === 0) return; // 回避などでダメージ0の場合は何もしない
                        if (amount === 'evaded') return; // 回避の場合は何もしない
                        if (isHeal) {
                            // 回復の場合
                            if (target && !target.isEnemy) await animateStatChange(target, 'hp', -amount, 'increase');
                            else if (target) target.currentHp = Math.min(target.maxHp, target.currentHp - amount);
                            flashCard(target, 'green');
                            if (target) showDamagePopup(target, Math.abs(amount), true);
                            return;
                        }
                        // ターゲットがゴーレムの場合
                        if (target === gameState.golem) {
                            gameState.golem.hp = Math.max(0, gameState.golem.hp - amount);
                            showDamagePopup(target, amount, false);
                            flashCard(target, 'red');
                            updatePartyStatus();
                            if (gameState.golem.hp <= 0) log('ゴーレムは砕け散った！');
                        } else if (target && !target.isEnemy) { // ターゲットが味方の場合 (敵からの攻撃、自傷など)
                            await animateStatChange(target, 'hp', -amount, 'decrease');
                        } else if (target) { // ターゲットが敵の場合
                            target.currentHp = Math.max(0, target.currentHp - amount);
                            updateEnemyStatus(); // 敵のHPバーを更新
                        }
                        flashCard(target, 'red');
                        if (target) showDamagePopup(target, amount, false);
                        if (target.currentHp <= 0 && target !== gameState.golem) {
                            if (!target.isEnemy && gameState.gameMode === 'enjoy') {
                                log(`${target.name}は倒れた...しかし、不思議な力ですぐに立ち上がった！`);
                                // HPを即座に全回復させる
                                target.currentHp = target.maxHp; // ファイター, ソーサラー, ナイト, メディック
                                flashCard(target, 'green');
                                updatePartyStatus(); // UIを更新 // ファイター, ソーサラー, ナイト, メディック
                            } else if (!target.isEnemy && target.blessings && target.blessings.last_stand) {
                                // 祝福: 不屈の魂
                                target.currentHp = 1;
                                delete target.blessings.last_stand; // 一度だけ発動
                                log(`${target.name}は不屈の魂で踏みとどまった！`);
                                flashCard(target, 'yellow');
                                updatePartyStatus();
                            } else {
                                log(`${target.name}は倒れた...`);
                                if (target.isEnemy) {
                                    const card = document.getElementById(`enemy-card-${gameState.enemies.indexOf(target)}`);
                                    // 祝福: 魂喰らい
                                    const killer = gameState.turnOrder[gameState.currentTurnIndex];
                                    if (killer && !killer.isEnemy && killer.blessings && killer.blessings.kill_heal) {
                                        const healAmount = Math.ceil(killer.maxHp * 0.15);
                                        const mpAmount = Math.ceil(killer.maxMp * 0.15);
                                        animateStatChange(killer, 'hp', healAmount, 'increase');
                                        animateStatChange(killer, 'mp', mpAmount, 'increase');
                                        log(`${killer.name}は倒した敵から魂を吸収し、HPとMPが回復した！`);
                                    }
                                    if (card) card.classList.add('fade-out-down');
                                    setTimeout(() => {
                                        if (card) card.remove();
                                    }, 1000); // アニメーション後に要素を削除
                                }
                            }
                        }
                        // 祝福: 過剰治癒 // ファイター, ソーサラー, ナイト, メディック
                        if (target && !target.isEnemy && target.blessings && target.blessings.over_heal && isHeal && target.currentHp === target.maxHp) {
                            const overHealAmount = (target.currentHp + amount) - target.maxHp;
                            if (target.buffs && target.buffs.heal_spread) {
                                const spreadHeal = Math.ceil(amount / (gameState.party.filter(p => p.currentHp > 0).length - 1));
                                gameState.party.forEach(p => {
                                    if (p !== target && p.currentHp > 0) animateStatChange(p, 'hp', spreadHeal, 'increase');
                                });
                            }
                            if (overHealAmount > 0) {
                                const wallHp = Math.ceil(overHealAmount);
                                gameState.walls.push({
                                    targetId: gameState.party.indexOf(target),
                                    hp: wallHp,
                                    maxHp: wallHp
                                });
                                log(`${target.name}の超過した回復力が、耐久値${wallHp}の防壁に変換された！`);
                            }
                        }
                        // メイドの回復拡散
                        if (target && !target.isEnemy && target.buffs && target.buffs.heal_spread && isHeal) {
                            const aliveAllies = gameState.party.filter(p => p !== target && p.currentHp > 0);
                            if (aliveAllies.length > 0) {
                                const spreadHeal = Math.ceil(amount / aliveAllies.length);
                                log(`${target.name}から癒しの力が拡散し、仲間たちのHPが${spreadHeal}回復した！`);
                                aliveAllies.forEach(p => animateStatChange(p, 'hp', spreadHeal, 'increase'));
                            }
                        }

                    } // ファイター, ソーサラー, ナイト, メディック

                    function triggerLiberationEvent() {
                        liberationModal.classList.remove('hidden');
                        liberationAcceptButton.onclick = () => {
                            liberationModal.classList.add('hidden');
                            log("結晶が砕け散り、空間が歪む…！");
                            // アイテムを1つずつ消費
                            gameState.inventory.find(item => item.id === 'holy_crystal').quantity--;
                            gameState.inventory.find(item => item.id === 'evil_crystal').quantity--;
                            startBattle(true, 'phantom_hero');
                        };
                        liberationDeclineButton.onclick = () => {
                            liberationModal.classList.add('hidden');
                            log("一行は危険を察知し、その場を後にした。");
                        };
                    }

                    async function blinkSkill(enemy) {
                        log(`${enemy.name}は瞬きをした。空間が歪み、奥義の気配が満ちる！`);
                        enemy.buffs.omen = 4; // 自身と次の3ターン、計4ターン持続
                        flashCard(enemy, 'yellow');
                    }

                    async function blackholeSkill(enemy, target) {
                        log(`${enemy.name}は${target.name}にブラックホールを放った！`);
                        const damage = 9999; // 耐えられないダメージ
                        log(`${target.name}は闇に飲み込まれてしまった…！`);
                        await dealDamage(target, damage); // ログ表示の後にダメージ処理
                    }

                    async function finalBossSkill(enemy, target) {
                        const roll = Math.random();
                        if (roll < 0.3) {
                            log(`${enemy.name}は終末の宣告を放った！`);
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                p.statusEffects.stat_down = true;
                                log(`${p.name}は絶望し、全ての能力が低下した！`);
                            }
                        } else if (roll < 0.6) {
                            log(`${enemy.name}は虚無の波動を放った！`);
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                await animateStatChange(p, 'mp', -Math.ceil(p.maxMp * 0.5), 'decrease');
                            }
                        } else {
                            await defaultEnemyAttack(enemy, target);
                        }
                    }

                    function showDamagePopup(target, amount, isHeal = false) {
                        const targetCard = target.isEnemy ?
                            document.getElementById(`enemy-card-${gameState.enemies.indexOf(target)}`) :
                            partyContainer.children[gameState.party.indexOf(target)];
                        if (!targetCard) return;
                        if (target === gameState.golem) {
                            const summonerCard = Array.from(partyContainer.children).find(card => card.querySelector('.golem-card-inner'));
                            if (summonerCard) targetCard = summonerCard.querySelector('.golem-card-inner');
                        }

                        const popup = document.createElement('div');
                        popup.textContent = amount;
                        popup.className = `damage-popup ${isHeal ? 'heal-popup' : ''}`; // 回避ポップアップのスタイル調整
                        if (amount === '回避') {
                            popup.style.color = '#3b82f6'; // 青色
                            popup.style.fontSize = '1.25rem'; // 少し小さく
                        }
                        targetCard.appendChild(popup);
                        setTimeout(() => popup.remove(), 1500);
                    }
                    async function highRiskHighReturnSkill(enemy, target) {
                        log(`${enemy.name}はハイリスク・ハイリターンを発動！`);
                        if (Math.random() < 0.5) {
                            log(`賭けに勝ち、${target.name}に超特大ダメージ！`);
                            const damage = calculateDamage(enemy, target, {
                                power: 4.0
                            });
                            await dealDamage(target, damage);
                        } else {
                            log(`賭けに負け、${enemy.name}は自滅した！`);
                            await dealDamage(enemy, enemy.currentHp);
                        }
                    }

                    function saveShiroTenseiData(character, withPenalty = false) {
                        let dataToSave = {
                            maxHp: character.maxHp,
                            maxMp: character.maxMp,
                            atk: character.atk,
                            def: character.def,
                            agi: character.agi,
                            skills: character.skills,
                            blessings: character.blessings
                        };
                        let modalTitle = "未来への夢";
                        let modalText = "シロは仲間たちとの冒険で得た力を記憶に刻み、満足げに微笑んだ。\n「また、会えるよね…？」\nそう呟くと、彼女の体は光の粒子となって消えていった。\nこの記憶は、次なる転生で彼女を導くだろう。";

                        if (withPenalty) {
                            dataToSave.maxHp = Math.max(1, Math.floor(dataToSave.maxHp * 0.8));
                            dataToSave.maxMp = Math.max(1, Math.floor(dataToSave.maxMp * 0.8));
                            dataToSave.atk = Math.max(1, Math.floor(dataToSave.atk * 0.8));
                            dataToSave.def = Math.max(1, Math.floor(dataToSave.def * 0.8));
                            modalTitle = "途切れた記憶";
                            modalText = "シロは力尽き、その場に崩れ落ちた。\n薄れゆく意識の中、彼女は強く願う。\n「まだ、終わりたくない…」\n\nその願いは、不完全ながらも記憶の欠片となって残り、次なる転生へと引き継がれる。";
                        }

                        localStorage.setItem('shiroTenseiData', JSON.stringify(dataToSave));
                        showModal(modalTitle, modalText);
                        gameState.gameOver = true;
                    }

                    function showTenseiGameOverModal() {
                        const shiro = gameState.party.find(p => p.role === '転生者');
                        if (!shiro) return;

                        generalEventTitle.textContent = "転生の選択";
                        generalEventText.textContent = "シロは力尽きてしまった…\nどうしますか？";
                        generalEventButtons.innerHTML = `
                            <button id="tensei-continue" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">記憶を刻んで転生する<br><span class="text-xs">(ステータスは少し劣化します)</span></button>
                            <button id="tensei-end" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">安らかに眠る</button>
                        `;
                        generalEventModal.classList.remove('hidden');

                        document.getElementById('tensei-continue').onclick = () => {
                            generalEventModal.classList.add('hidden');
                            saveShiroTenseiData(shiro, true);
                        };
                        document.getElementById('tensei-end').onclick = () => {
                            generalEventModal.classList.add('hidden');
                            showModal("ゲームオーバー", "シロの冒険はここで終わった…");
                            gameState.gameOver = true;
                        };
                    }

                    async function endBattle(isVictory) {
                        gameState.inBattle = false;
                        emergencyButton.classList.remove('battle-active'); // 緊急ボタンを無効化

                        // ゴーレムが残っている場合の処理
                        // サイズアップ・ギャンブルのボス戦フラグをリセット
                        if (gameState.nextBattleIsGambleMaster) {
                            gameState.nextBattleIsGambleMaster = false;
                        }

                        if (gameState.golem && gameState.golem.hp > 0) {
                            const summoner = gameState.party.find(p => p.role === 'サモナー' && p.currentHp > 0);
                            if (summoner) {
                                const mpRecovery = Math.ceil(gameState.golem.hp / 5);
                                if (mpRecovery > 0) {
                                    log("ゴーレムは役目を終えて帰還した。");
                                    animateStatChange(summoner, 'mp', mpRecovery, 'increase');
                                    log(`${summoner.name}のMPが${mpRecovery}回復した！`);
                                }
                            }
                            gameState.golem = null;
                        }

                        // 防壁が残っている場合の処理
                        if (gameState.walls.length > 0) {
                            log("戦闘が終わり、残っていた防壁の魔力が少し失われた。");
                            gameState.walls.forEach(wall => {
                                wall.hp = Math.ceil(wall.hp / 2);
                                wall.maxHp = Math.ceil(wall.maxHp / 2); // 最大耐久値も半減
                            });
                            // 耐久値が0になった防壁を削除
                            gameState.walls = gameState.walls.filter(wall => wall.hp > 0);
                        }

                        dungeonCommands.classList.remove('hidden');
                        updateFloorDisplay();
                        battleCommands.classList.add('hidden');
                        // 戦闘終了時に身長を元に戻す処理
                        gameState.party.forEach(p => {
                            if (p.statusEffects.shrunkToOne) delete p.statusEffects.shrunkToOne;
                        });

                        gameState.party.forEach(p => {
                            p.buffs = {};
                            p.isDefending = false;
                            // 脱衣状態のみ持続させる
                            const wasStripped = p.statusEffects.stripped;
                            p.statusEffects = {}; // ファイター, ソーサラー, ナイト, メディック
                            if (wasStripped) p.statusEffects.stripped = wasStripped; // ターン数も引き継ぐ
                        });

                        if (isVictory) {
                            // 「英雄の幻影」撃破ボーナス
                            if (gameState.enemies.some(e => e.name === '英雄の幻影')) {
                                // サイズアップ・ギャンブル！モードの勝利時処理
                                if (gameState.gameMode === 'size_up_gamble') {
                                    log("勝利の報酬として、パーティの体が成長する！");
                                    await new Promise(resolve => setTimeout(resolve, 1500));
                                    for (const char of gameState.party.filter(p => p.currentHp > 0)) {
                                        const growth = Math.floor(Math.random() * 51) + 50; // 50-100
                                        await animateStatChange(char, 'height', growth, 'increase');
                                        log(`${char.name}の身長が${growth}cm伸びた！`);
                                    }
                                    // 目標達成チェック
                                    if (!gameState.sizeUpGambleGoalReached && gameState.party.some(p => p.height >= 1000)) {
                                        gameState.sizeUpGambleGoalReached = true;
                                        log("ついに目標の身長に到達した！次のフロアで何かが起こるだろう…！");
                                    }
                                }
                                log("英雄の幻影を打ち破った！パーティ全員の魂が共鳴し、限界を超えて成長する！"); // ファイター, ソーサラー, ナイト, メディック
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) {
                                        p.maxHp += 5;
                                        p.maxMp += 5;
                                        p.atk += 1;
                                        p.def += 1;
                                        flashCard(p, 'green');
                                    }
                                });
                                updatePartyStatus();
                            }

                            gameState.killCount += gameState.enemies.length; // 倒した敵の数を加算

                            // 新モード「流転の体躯」の処理
                            if (gameState.gameMode === 'unstable_bodies') {
                                log("勝利の余韻に浸る間もなく、パーティの体が不安定に変化する…！");
                                await new Promise(resolve => setTimeout(resolve, 1500)); // メッセージ表示のための待機
                                const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                                if (aliveParty.every(p => p.heightLocked)) {
                                    log("…しかし、全員の体が変化を拒んだ！");
                                    await new Promise(resolve => setTimeout(resolve, 1500)); // ファイター, ソーサラー, ナイト, メディック
                                } // ファイター, ソーサラー, ナイト, メディック
                                for (const char of aliveParty) {
                                    const change = Math.ceil(Math.random() * 101) - 50; // -50 から +50
                                    const type = change >= 0 ? 'increase' : 'decrease';
                                    await animateStatChange(char, 'height', change, type);
                                    log(`${char.name}の身長が${change > 0 ? '+' : ''}${change}cm変化した！`);
                                    await new Promise(resolve => setTimeout(resolve, 500)); // 各キャラのログ表示のための短い待機
                                }
                            }
                        if (gameState.gameMode === 'tensei_rinne') {
                            const shiro = gameState.party.find(p => p.role === '転生者');
                            if (shiro) {
                                const stats = ['maxHp', 'maxMp', 'atk', 'def', 'agi'];
                                const statToUpgrade = stats[Math.floor(Math.random() * stats.length)];
                                let upgradeAmount = 1;
                                let statJp = { 'atk': '攻撃力', 'def': '防御力', 'agi': '素早さ' };
                                if (statToUpgrade === 'maxHp') {
                                    upgradeAmount = 5;
                                    statJp['maxHp'] = '最大HP';
                                } else if (statToUpgrade === 'maxMp') {
                                    upgradeAmount = 3;
                                    statJp['maxMp'] = '最大MP';
                                }
                                shiro[statToUpgrade] += upgradeAmount;
                                log(`シロは戦闘経験から力を吸収し、${statJp[statToUpgrade]}が${upgradeAmount}上昇した！`);
                                flashCard(shiro, 'green');
                            }
                        }
                            if (gameState.gameMode === 'monster_march') {
                                if (gameState.floor === 50) {
                                    showModal("完全踏破", "絶え間ない戦いの果てに、あなたはついにダンジョンの最奥に到達し、元凶を打ち破りました。その行軍は、伝説として語り継がれるでしょう。");
                                    gameState.gameOver = true;
                                    return; // ファイター, ソーサラー, ナイト, メディック
                                }
                                log('敵を倒した！パーティ全員がレベルアップ！');
                                gameState.party.forEach(char => {
                                    if (char.currentHp > 0) levelUpCharacter(char, false); // UIは表示しない
                                });

                                const foundItems = [];
                                const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].battleOnly && !itemBlueprints[id].rare);
                                for (let i = 0; i < 3; i++) {
                                    const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                                    addItemToInventory(foundItemId);
                                    foundItems.push(itemBlueprints[foundItemId].name);
                                }
                                log(`さらに、 ${foundItems.join('、')} を手に入れた！`);
                            } else if (gameState.gameMode === 'endless') {
                                // 無限モードのボス撃破後
                                const isBossFloor = gameState.floor > 0 && gameState.floor % 30 === 0;
                                if (isBossFloor) {
                                    showEndlessCurseModal(); // 呪い選択モーダルを表示
                                } else {
                                    showLevelUpModal(true); // 通常のボーナス選択モーダルを表示
                                }
                            } else if (gameState.gameMode === 'summer_live' && gameState.floor === 30) {
                                log("ビーチステージのボスを撃破！打ち上げの温泉に向けて、冒険は続く！");
                                showLevelUpModal(false); // レベルアップ選択画面へ
                            } else if (gameState.gameMode === 'endgame' && gameState.floor === 1) {
                                showModal("ゲームクリア？", "あなたはダンジョンの入り口で待ち構えていたボスを打ち破りました！…これでよかったのでしょうか？");
                                gameState.gameOver = true;
                            } else if ((gameState.floor === 30 && gameState.gameMode !== 'endless' && gameState.gameMode !== 'monster_march') || (gameState.gameMode === 'endgame_plus' && gameState.floor === 90)) {
                                let title = "ゲームクリア！"; // ファイター, ソーサラー, ナイト, メディック
                                let text = "おめでとう！あなたはダンジョンの最深部に到達し、ボスを打ち破りました！";
                                switch (gameState.gameMode) {
                                    case 'normal':
                                    case 'trial':
                                        text += "\nもしもの物語では、異なる結末があなたを待っているかもしれません。";
                                        break;
                                    case 'endgame_plus':
                                        title = "真の終焉";
                                        text = "終刻の魔王を打ち破り、世界に真の静寂が訪れた。しかし、それは新たな始まりに過ぎないのかもしれない…。\n\nこの偉業を成し遂げた者たちの魂は、星の観測者たちに記憶され、永遠に語り継がれるだろう。";
                                        break;
                                    case 'veterans':
                                        title = "歴戦の証";
                                        text = "歴戦の勇者たちは、その実力を見せつけ、ダンジョンを容易く踏破しました。しかし、彼女たちの本当の戦いは、まだ始まったばかりなのかもしれません。";
                                        break;
                                    case 'dwarves':
                                        title = "小さな英雄譚";
                                        text = "小さな体で、大きな困難を乗り越えた一行。彼女たちの勇気は、どんな巨人よりも雄大でした。";
                                        break;
                                    case 'brawl':
                                        title = "武闘の果てに";
                                        text = "戦い、戦い、そしてまた戦い…。武闘の宴の果てに、彼女たちは最強の称号を手にしました。その拳に宿るは、数多の強敵との記憶。";
                                        break;
                                    case 'solo':
                                        title = "孤独な覇者";
                                        text = `たった一人で、${gameState.party[0].name}はダンジョンを制覇しました。その強さは伝説となり、後世まで語り継がれるでしょう。\n\nこの経験は彼女の魂に刻まれ、「孤高の魂」として今後の冒険で力となります。`;
                                        // ソロクリアしたキャラクターを保存
                                        const soloClearFlags = JSON.parse(localStorage.getItem('sizeDungeonSoloClearFlags') || '{}');
                                        const clearedCharName = gameState.party[0].name;
                                        soloClearFlags[clearedCharName] = true;
                                        localStorage.setItem('sizeDungeonSoloClearFlags', JSON.stringify(soloClearFlags));
                                        break;
                                    case 'saint_march':
                                        title = "聖女の使命";
                                        text = "セレスティアはダンジョンの最深部に巣食う元凶を浄化しました。しかし、世界のどこかで穢れが生まれる限り、彼女の行進は終わりません。";
                                        // 聖女クリアフラグを保存
                                        const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                                        clearFlags.saintMarchCleared = true;
                                        localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(clearFlags));
                                        break;
                                    case 'treasure_map':
                                        title = "秘宝の在り処";
                                        text = "リリィはついにダンジョンの最奥に眠る秘宝を手に入れました。しかし、世界にはまだ見ぬお宝がたくさん眠っています。彼女の冒険は、まだ始まったばかりです。";
                                        // トレジャーハンタークリアフラグを保存
                                        const clearFlagsTreasure = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                                        clearFlagsTreasure.treasureMapCleared = true;
                                        localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(clearFlagsTreasure));
                                        break;
                                    case 'indecent':
                                        title = "恥辱の先の勝利";
                                        text = "数々の羞恥を乗り越え、彼女たちはついにボスを打ち破りました。この冒険のことは、きっと誰にも話せないでしょう…。";
                                        break;
                                    case 'fixed_path':
                                        title = "運命の踏破";
                                        text = "定められた道を乗り越え、一行はついに最深部に到達しました。これは運命だったのか、それとも自ら選び取った未来だったのか…。";
                                        break;
                                    case 'enjoy':
                                        title = "楽しい冒険の終わり";
                                        text = "どんな困難も笑顔で乗り越え、パーティはついにダンジョンを制覇しました！最高の冒険でしたね！";
                                        break;
                                    case 'brawling_belles':
                                        title = "闘争の果てに";
                                        text = "ノエルとフローラは、数々の強敵を打ち破り、ついにダンジョンを踏破しました。彼女たちの絆は、誰にも壊せないでしょう。";
                                        const bellesFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                                        bellesFlags.brawlingBellesCleared = true;
                                        localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(bellesFlags));
                                        break;
                                    case 'size_up_gamble':
                                        title = "ギャンブルの果てに";
                                        text = "ルナとコハルは、常識外れのサイズアップを成し遂げ、ギャンブルに勝利した！二人の挑戦は、伝説として語り継がれるだろう。";
                                        break;
                                    case 'unstable_bodies':
                                        text = "絶え間なく変化する肉体を乗りこなし、あなたは見事ボスを打ち破りました！その精神力は、もはや何物にも揺るがないでしょう。";
                                        break;
                                    case 'random_party':
                                        title = "運命の勝利";
                                        text = "偶然出会った仲間たちと共に、あなたはついにダンジョンを制覇しました。この出会いは運命だったのかもしれません。彼女たちとの絆は、これからも続いていくでしょう。";
                                        break;
                                    case 'secret_night':
                                        title = "ヒミツの夜明け";
                                        const charName = gameState.party[0].name;
                                        if (charName === 'リリカ') {
                                            text = "リリカは、ドキドキの夜の冒険を終えた。誰にも言えないヒミツのステージは、彼女を少しだけ大人にしたのかもしれない。";
                                        } else if (charName === 'ユイ') {
                                            text = "ユイは、恥ずかしくてドキドキの冒険を終えた。このヒミツの経験は、彼女の心に小さな勇気の種を植え付けた。";
                                        } else if (charName === 'ミコ') {
                                            text = "ミコは、モコと一緒に夜の冒険を終えた。いつもと違うダンジョンは、彼女の冒険心をさらに掻き立てたようだ。";
                                        } else if (charName === 'リリィ') {
                                            text = "リリィは、静かな夜のダンジョン探索を終えた。お宝は見つからなかったが、スリリングな一夜は彼女を満足させた。";
                                        } else if (charName === 'フローラ') {
                                            text = "フローラは、背徳感に満ちた夜の冒険を終えた。このヒミツは、彼女の心に甘い棘となって残り続けるだろう。";
                                        } else {
                                            text = "ヒミツの夜は明けた。この冒険のことは、あなたと彼女だけのヒミツだ。";
                                        }
                                        break;
                                }
                                showModal(title, text);
                                gameState.gameOver = true;
                            } else if (gameState.enemies.some(e => e.name === '星の観測者')) {
                                // 星の観測者撃破時の特殊エンディング
                                showModal("観測者の終焉", "星の観測者を打ち破ったあなた達の前に、空間の裂け目が現れる。\n\n「…我を超えし者よ。世界の真の終焉を、見る覚悟があるか…？」\n\nその声と共に、新たな道が開かれた。\n\n（もしもの物語に「終焉の呼び声」が追加されました）");

                                // クリアフラグと実績を保存
                                const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                                clearFlags.endgameCleared = true;
                                localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(clearFlags));

                                const starObserverClearers = JSON.parse(localStorage.getItem('sizeDungeonStarObserverClearers') || '{}');
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) {
                                        starObserverClearers[p.name] = true;
                                    }
                                });
                                localStorage.setItem('sizeDungeonStarObserverClearers', JSON.stringify(starObserverClearers));

                                // デバッグボタンを更新
                                updateDebugButtons();

                                gameState.gameOver = true;
                            } else {
                                showLevelUpModal(false);
                            }
                        } else {
                            if (gameState.gameMode !== 'tensei_rinne' && !(gameState.gameMode === 'endless' && gameState.party.some(p => p.role === '転生者'))) {
                                if (gameState.party.length === 1) {
                                    const characterName = gameState.party[0].name;
                                    showModal("ゲームオーバー", `${characterName}は力尽きてしまった...`);
                                } else {
                                    showModal("ゲームオーバー", "パーティは全滅してしまった...");
                                }
                            }
                            // 転生紀行モードでのゲームオーバー処理
                            if (gameState.gameMode === 'endless' && gameState.party.some(p => p.role === '転生者')) {
                                showTenseiGameOverModal();
                            } else if (gameState.gameMode === 'tensei_rinne') {
                                handleTenseiRinneEnd(false); // isVictory=falseで呼び出し
                            }

                            gameState.gameOver = true;
                        }
                    }

                    function showBlessingModal() {

                        blessingCharSelectList.innerHTML = '';
                        blessingOptionsList.innerHTML = '';
                        blessingCharSelectList.classList.remove('hidden');
                        blessingOptionsList.classList.add('hidden');
                        blessingModalPrompt.textContent = '祝福を授ける仲間を一人選んでください。';

                        gameState.party.forEach((char) => {
                            if (char.currentHp <= 0) return;

                            const card = document.createElement('div');
                            card.className = 'p-4 border rounded-lg cursor-pointer hover:bg-amber-100 hover:shadow-lg transition';
                            card.innerHTML = `
                                <p class="font-bold text-lg text-${char.themeColor}-700">${char.name}</p>
                                <p class="text-sm text-gray-600">${char.role}</p>
                            `;
                            card.onclick = () => presentBlessingChoices(char);
                            blessingCharSelectList.appendChild(card);
                        });

                        blessingModal.classList.remove('hidden');
                    }

                    function presentBlessingChoices(char) {
                        blessingCharSelectList.classList.add('hidden');
                        blessingOptionsList.classList.remove('hidden');
                        blessingModalPrompt.textContent = `${char.name}に授ける祝福を選んでください。`;
                        blessingOptionsList.innerHTML = '';

                        const blessingPool = Object.values(blessings);
                        const available = blessingPool.filter(b => !Object.values(char.blessings).some(owned => owned.name === b.name));
                        const choices = [];
                        while (choices.length < 3 && available.length > 0) {
                            const randomIndex = Math.floor(Math.random() * available.length);
                            choices.push(available.splice(randomIndex, 1)[0]);
                        }

                        choices.forEach(blessing => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-amber-500 hover:bg-amber-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg text-left';
                            button.innerHTML = `<strong class="text-lg">${blessing.name}</strong><span class="block text-sm text-amber-100 mt-1">${blessing.description}</span>`;
                            button.onclick = () => {
                                blessing.effect(char);
                                log(`${char.name}は神々の祝福「${blessing.name}」を授かった！`);
                                blessingModal.classList.add('hidden');
                                dungeonCommands.classList.remove('hidden');
                            };
                            blessingOptionsList.appendChild(button);
                        });
                    }

                    function showModal(title, text) {
                        modalTitle.textContent = title;
                        modalText.textContent = text;
                        modal.classList.remove('hidden');
                    }

                    function showLevelUpModal(isEndless = false) {
                        log('敵を倒した！');
                        enemyContainer.innerHTML = '';
                        dungeonCommands.classList.add('hidden'); // 選択中はコマンドを隠す

                        levelUpPartyList.innerHTML = '';
                        // パーティが1人の場合は選択肢を出さずに即時レベルアップ
                        if (gameState.party.length === 1 && gameState.party[0].currentHp > 0) {
                            // UI表示フラグをtrueにして、レベルアップ処理を呼び出す
                            // isEndlessフラグも正しく渡す
                            levelUpCharacter(gameState.party[0], true, isEndless);
                            return; // ファイター, ソーサラー, ナイト, メディック
                        }


                        gameState.party.forEach((char, index) => {
                            if (char.currentHp <= 0) return; // 戦闘不能のキャラは選択不可

                            const card = document.createElement('div');
                            card.className = 'p-4 border rounded-lg cursor-pointer hover:bg-yellow-100 hover:shadow-lg transition';
                            card.innerHTML = `
                        <p class="font-bold text-lg text-${char.themeColor}-700">${char.name}</p>
                        <p class="text-sm text-gray-600">Lv.${char.level} ${char.role}</p>
                    `;
                            card.onclick = () => {
                                if (isEndless) {
                                    levelUpCharacter(char, true, true);
                                } else {
                                    levelUpCharacter(char);
                                }
                            };
                            levelUpPartyList.appendChild(card);
                        });

                        if (gameState.gameMode === 'summer_live' && gameState.floor === 60) {
                            showModal("ライブ大成功！", "おめでとう！あなたはビーチと温泉でのスペシャルライブを大成功させ、ダンジョンを制覇しました！彼女たちの夏の思い出は、最高の形で幕を閉じました。");
                            // クリアフラグを保存
                            const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                            clearFlags.summerLiveCleared = true;
                            localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(clearFlags));
                            gameState.gameOver = true;
                            return;
                        }
                        levelUpModal.classList.remove('hidden');
                    }

                    function levelUpCharacter(character, showUI = true, isEndless = false) {
                        // applyLevelUpを呼び出してステータスを成長させ、追加成長情報を取得
                        const bonusGrowthInfo = applyLevelUp(character);

                        // HP/MPを全回復
                        character.currentHp = character.maxHp;

                        // 祝福「賭博の魂」の効果
                        if (character.blessings && character.blessings.gambling_soul) {
                            log(`${character.name}は賭博の魂の力で、身長が100cm伸びた！`);
                            animateStatChange(character, 'height', 100, 'increase');
                        }

                        character.currentMp = character.maxMp; // ファイター, ソーサラー, ナイト, メディック

                        // ログメッセージの組み立て
                        let logMessageText = `${character.name}は強くなった！`;
                        if (bonusGrowthInfo) {
                            const statJp = {
                                'maxHp': '最大HP',
                                'maxMp': '最大MP',
                                'atk': '攻撃力',
                                'def': '防御力'
                            };
                            logMessageText += ` さらに、${statJp[bonusGrowthInfo.stat]}が${bonusGrowthInfo.value}上がった！`;
                        }

                        // 新スキル習得
                        if (character.level === 2 && character.unlockableSkill) {
                            logMessageText += `\n新しいスキル「${character.unlockableSkill.name}」を覚えた！`;
                        } else if (character.level === 4 && character.unlockableSkillLv4) {
                            logMessageText = `${character.name}は大きく成長した！ 奥義「${character.unlockableSkillLv4.name}」を習得！`;
                        }
                        log(logMessageText);

                        if (showUI) {
                            levelUpModal.classList.add('hidden');
                            updatePartyStatus();
                            if (isEndless) {
                                showEndlessBonusModal();
                            } else {
                                dungeonCommands.classList.remove('hidden');
                            }
                        }
                    }

                    function showEndlessBonusModal() {
                        endlessBonusButtons.innerHTML = '';
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length === 0) {
                            endBattle(false); // 全滅している場合はゲームオーバー
                            return;
                        }

                        const bonusPool = [{
                            id: 'maxHpUp',
                            text: (target) => `${target.name}の最大HPが永続上昇`,
                            effect: (target) => {
                                target.maxHp += 20;
                                log(`${target.name}の最大HPが20上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'maxMpUp',
                            text: (target) => `${target.name}の最大MPが永続上昇`,
                            effect: (target) => {
                                target.maxMp += 10;
                                log(`${target.name}の最大MPが10上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'atkUp',
                            text: (target) => `${target.name}の攻撃力が永続上昇`,
                            effect: (target) => {
                                target.atk += 3;
                                log(`${target.name}の攻撃力が3上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'defUp',
                            text: (target) => `${target.name}の防御力が永続上昇`,
                            effect: (target) => {
                                target.def += 2;
                                log(`${target.name}の防御力が2上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'cureStrip',
                            text: () => '全員の脱衣状態を治す',
                            effect: () => {
                                gameState.party.forEach(p => delete p.statusEffects.stripped);
                                log('全員が服を着て、元の状態に戻った！');
                            },
                            weight: 15,
                            condition: () => gameState.party.some(p => p.statusEffects.stripped)
                        }, {
                            id: 'allLevelUp',
                            text: () => '全員がさらにレベルアップ',
                            effect: () => {
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) levelUpCharacter(p, false);
                                });
                                log('パーティ全員がさらにレベルアップした！');
                            },
                            weight: 3
                        }, {
                            id: 'getItems',
                            text: () => 'アイテムを5個獲得',
                            effect: () => {
                                const foundItems = [];
                                const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].battleOnly && !itemBlueprints[id].rare && !itemBlueprints[id].special);
                                for (let i = 0; i < 5; i++) {
                                    const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                                    addItemToInventory(foundItemId);
                                    foundItems.push(itemBlueprints[foundItemId].name);
                                }
                                log(`アイテムを5個手に入れた！ (${foundItems.join('、')})`);
                            },
                            weight: 12
                        }, {
                            id: 'getRareItem',
                            text: () => 'レアアイテムを1個獲得',
                            effect: () => {
                                const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                                addItemToInventory(foundItemId);
                                log(`なんと、とても珍しい「${itemBlueprints[foundItemId].name}」を見つけた！`);
                            },
                            weight: 2
                        }, {
                            id: 'becomeCute',
                            text: (target) => `${target.name}がかわいくなる`,
                            effect: async(target) => {
                                log(`突然の光に包まれ、${target.name}は…`);
                                await new Promise(resolve => setTimeout(resolve, 1500));

                                let outcomes = ['shrink', 'strip', 'glow', 'dress', 'full_recover'];
                                // 身長が固定されている場合のみ、「いつもの姿が一番」を候補に追加
                                if (target.heightLocked) {
                                    outcomes.push('reset_height');
                                }

                                const outcome = outcomes[Math.floor(Math.random() * outcomes.length)];

                                switch (outcome) {
                                    case 'full_recover':
                                        await animateStatChange(target, 'hp', target.maxHp, 'increase');
                                        await animateStatChange(target, 'mp', target.maxMp, 'increase');
                                        target.statusEffects = {};
                                        log(`…「かわいいは元気から！」HPとMPが全回復し、状態異常も治った！`);
                                        break;
                                    case 'reset_height':
                                        target.heightLocked = false;
                                        const resetAmount = target.initialHeight - target.height;
                                        await animateStatChange(target, 'height', resetAmount, resetAmount >= 0 ? 'increase' : 'decrease');
                                        log(`…「いつもの姿が一番！」身長の固定が解除され、元の身長に戻った！`);
                                        break;
                                    case 'shrink':
                                        if (target.heightLocked) {
                                            log(`…しかし、${target.name}の体は変化を拒んだ！`);
                                            return;
                                        }
                                        const diff = 1 - target.height;
                                        await animateStatChange(target, 'height', diff, 'decrease');
                                        log(`…なんと、身長が1cmになってしまった！`);
                                        break;
                                    case 'strip':
                                        const immuneRoles = ['ナイト', 'サムライ', '聖女']; // ファイター, ソーサラー, ナイト, メディック
                                        if (immuneRoles.includes(target.role)) {
                                            log(`…しかし、${target.name}は恥じらいを覚えず、何も起こらなかった。`); // ファイター, ソーサラー, ナイト, メディック
                                        } else {
                                            target.statusEffects.stripped = {
                                                turns: 0
                                            };
                                            log(`…なんと、恥ずかしい格好になってしまった！`);
                                        }
                                        break;
                                    case 'glow':
                                        log(`…肌がつやつやになり、いつもより魅力的に見える！(特に効果はない)`);
                                        break;
                                    case 'dress':
                                        if (target.statusEffects.stripped) {
                                            delete target.statusEffects.stripped;
                                            log(`…服がかわいらしいドレスに変化し、脱衣状態が治った！`);
                                        } else {
                                            log(`…服がかわいらしいドレスに変化した！(特に効果はない)`);
                                        }
                                        break;
                                }
                            },
                            weight: 1,
                            needsTarget: true
                        }, {
                            id: 'getBlessing',
                            text: (target) => `${target.name}に神々の祝福を授ける`,
                            effect: (target) => {
                                const blessingPool = Object.values(blessings).filter(b => !b.eventOnly);
                                const available = blessingPool.filter(b => !Object.values(target.blessings).some(owned => owned.name === b.name));

                                if (available.length === 0) {
                                    log(`${target.name}は既に全ての祝福を授かっている！`);
                                    // 代わりにランダムなアイテムを獲得
                                    const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].battleOnly && !itemBlueprints[id].rare && !itemBlueprints[id].special);
                                    const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                                    addItemToInventory(foundItemId);
                                    log(`代わりに「${itemBlueprints[foundItemId].name}」を手に入れた！`);
                                } else {
                                    const chosenBlessing = available[Math.floor(Math.random() * available.length)];
                                    chosenBlessing.effect(target);
                                    log(`${target.name}は神々の祝福「${chosenBlessing.name}」を授かった！`);
                                }
                            },
                            weight: 5,
                            needsTarget: true
                        }, ];

                        let selectedBonuses = []; // ファイター, ソーサラー, ナイト, メディック
                        let availableBonuses = [...bonusPool];

                        while (selectedBonuses.length < 4 && availableBonuses.length > 0) {
                            // 条件を満たすボーナスのみをフィルタリング
                            const filteredBonuses = availableBonuses.filter(b => !b.condition || b.condition());
                            if (filteredBonuses.length === 0) break;

                            // 重み付け抽選
                            const totalWeight = filteredBonuses.reduce((sum, b) => sum + b.weight, 0);
                            let random = Math.random() * totalWeight;
                            let chosenBonus = null;
                            for (const bonus of filteredBonuses) {
                                random -= bonus.weight;
                                if (random <= 0) {
                                    chosenBonus = bonus;
                                    break;
                                }
                            }
                            if (!chosenBonus) chosenBonus = filteredBonuses[filteredBonuses.length - 1];

                            // ターゲットが必要な場合は抽選
                            let target = null;
                            if (chosenBonus.needsTarget) {
                                target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                            }

                            selectedBonuses.push({...chosenBonus,
                                target
                            });

                            // 同じIDのボーナスは再度選ばれないようにする
                            availableBonuses = availableBonuses.filter(b => b.id !== chosenBonus.id);
                        }

                        // 選択肢ボタンを生成
                        selectedBonuses.forEach(bonus => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-4 rounded-lg shadow-lg text-left';

                            let buttonText = bonus.text(bonus.target);
                            let description = '';
                            if (bonus.id === 'becomeCute') description = '（効果は不明）';

                            button.innerHTML = `
                                ${buttonText}
                                <span class="block text-xs text-blue-200">${description}</span>
                            `;

                            button.onclick = () => {
                                endlessBonusModal.classList.add('hidden');
                                bonus.effect(bonus.target);
                                // 選択後、少し待ってからUIを更新し、次のフロアへ
                                setTimeout(() => {
                                    updatePartyStatus();
                                    dungeonCommands.classList.remove('hidden');
                                }, 1000);
                            };
                            endlessBonusButtons.appendChild(button);
                        });

                        dungeonCommands.classList.add('hidden');
                        endlessBonusModal.classList.remove('hidden');
                    }

                    function showEndlessCurseModal() {
                        endlessCurseButtons.innerHTML = '';
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length === 0) {
                            endBattle(false); // 全滅している場合はゲームオーバー
                            return;
                        }

                        // 呪いの選択肢プール
                        const cursePool = [{
                            id: 'hp_half',
                            text: '血の代償',
                            description: '生存者全員の現在HPが半減する。',
                            effect: () => {
                                log("呪いが発動し、全員の生命力が吸い取られた！");
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) { // ファイター, ソーサラー, ナイト, メディック
                                        const damage = Math.ceil(p.currentHp / 2); // ファイター, ソーサラー, ナイト, メディック
                                        animateStatChange(p, 'hp', -damage, 'decrease');
                                    }
                                });
                            },
                            weight: 10
                        }, {
                            id: 'lose_items',
                            text: '忘却の呪い',
                            description: '所持アイテムをランダムに3つ失う。',
                            effect: () => {
                                const lostItems = []; // ファイター, ソーサラー, ナイト, メディック
                                for (let i = 0; i < 3; i++) {
                                    const availableItems = gameState.inventory.filter(item => item.quantity > 0);
                                    if (availableItems.length > 0) {
                                        const itemToLose = availableItems[Math.floor(Math.random() * availableItems.length)];
                                        itemToLose.quantity--;
                                        lostItems.push(itemBlueprints[itemToLose.id].name);
                                    }
                                }
                                if (lostItems.length > 0) {
                                    log(`呪いによって ${lostItems.join('、')} を失ってしまった！`);
                                } else {
                                    log("呪いが発動したが、失うアイテムがなかった。");
                                }
                            },
                            weight: 10,
                            condition: () => gameState.inventory.some(item => item.quantity > 0)
                        }, {
                            id: 'random_height',
                            text: '不安定な肉体',
                            description: '生存者全員の身長が-100cm～+100cmの範囲でランダムに変動する。',
                            effect: async() => {
                                log("呪いがパーティの肉体を蝕む！");
                                for (const p of aliveParty) {
                                    if (p.heightLocked) {
                                        log(`${p.name}は体の変化を拒んだ！`);
                                        continue;
                                    } // ファイター, ソーサラー, ナイト, メディック
                                    const change = Math.ceil(Math.random() * 201) - 100;
                                    await animateStatChange(p, 'height', change, change >= 0 ? 'increase' : 'decrease');
                                    log(`${p.name}の身長が${change > 0 ? '+' : ''}${change}cm変化した！`);
                                }
                            },
                            weight: 8
                        }, {
                            id: 'stat_down_or_lock',
                            text: '個人の犠牲',
                            description: 'ランダムな仲間一人に過酷な運命が降りかかる。',
                            effect: (target) => {
                                if (Math.random() < 0.5) {
                                    target.atk -= 1;
                                    log(`呪いによって${target.name}の魂が少し削られ、攻撃力が永続的に1減少した…。`);
                                } else {
                                    if (target.heightLocked) {
                                        log(`呪いは${target.name}の体を固定しようとしたが、既に固定されていたため何も起こらなかった。`);
                                    } else {
                                        animateStatChange(target, 'height', 1 - target.height, 'decrease');
                                        target.heightLocked = true;
                                        log(`呪いによって${target.name}の体が1cmに固定されてしまった！`);
                                    }
                                }
                            },
                            weight: 7,
                            needsTarget: true
                        }, {
                            id: 'lose_blessing',
                            text: '祝福の喪失',
                            description: 'ランダムな仲間一人の祝福が一つ失われる。',
                            effect: (target) => {
                                const blessings = target.blessings ? Object.keys(target.blessings) : [];
                                if (blessings.length > 0) {
                                    const blessingToLoseKey = blessings[Math.floor(Math.random() * blessings.length)];
                                    const blessingToLoseName = window.blessings[blessingToLoseKey].name;
                                    delete target.blessings[blessingToLoseKey];
                                    log(`呪いによって${target.name}は祝福「${blessingToLoseName}」を失ってしまった…。`);
                                } else {
                                    log(`${target.name}は祝福を授かっていなかったため、呪いの影響を受けなかった。`);
                                }
                            },
                            weight: 7,
                            needsTarget: true,
                            condition: () => gameState.party.some(p => p.blessings && Object.keys(p.blessings).length > 0)
                        }, {
                            id: 'swap_height',
                            text: '天秤の悪戯',
                            description: '最も身長が高いキャラと最も低いキャラの身長が入れ替わる。',
                            effect: async() => {
                                const aliveParty = gameState.party.filter(p => p.currentHp > 0 && !p.heightLocked);
                                if (aliveParty.length < 2) {
                                    log("呪いは発動したが、対象がいなかったため何も起こらなかった。");
                                    return;
                                }
                                aliveParty.sort((a, b) => a.height - b.height);
                                const smallest = aliveParty[0];
                                const tallest = aliveParty[aliveParty.length - 1];

                                if (smallest === tallest) {
                                    log("呪いは発動したが、全員の身長が同じだったため何も起こらなかった。");
                                    return;
                                }

                                const smallestHeight = smallest.height;
                                const tallestHeight = tallest.height;

                                log(`呪いによって、${tallest.name}と${smallest.name}の身長が入れ替わってしまった！`);
                                await animateStatChange(smallest, 'height', tallestHeight - smallest.height, 'increase');
                                await animateStatChange(tallest, 'height', smallestHeight - tallest.height, 'decrease');
                            },
                            weight: 6,
                            condition: () => gameState.party.filter(p => p.currentHp > 0 && !p.heightLocked).length >= 2
                        }, {
                            id: 'imitation_curse',
                            text: '模倣の呪い',
                            description: '次のフロアで、あなたの仲間を模倣した強敵が出現する。',
                            effect: () => {
                                gameState.nextBattleIsImitation = true;
                                log("次の戦いで、言い知れぬ恐怖と対峙することになるだろう…");
                            },
                            weight: 6,
                            // 次のフロアがボスフロアの場合は出現しない
                            condition: () => (gameState.floor + 1) % 30 !== 0
                        }, ]; // ファイター, ソーサラー, ナイト, メディック

                        // 4つの異なる呪いを選択
                        let selectedCurses = [];
                        let availableCurses = [...cursePool];
                        while (selectedCurses.length < 4 && availableCurses.length > 0) {
                            const filtered = availableCurses.filter(c => !c.condition || c.condition());
                            if (filtered.length === 0) break;
                            const index = Math.floor(Math.random() * filtered.length);
                            const curse = filtered[index];
                            // 「なにも起こらない」を追加
                            const allCurses = [...cursePool, {
                                id: 'nothing',
                                text: '空虚な刻',
                                description: '幸運にも、呪いはあなたを素通りしていった。',
                                effect: () => {
                                    log("呪いの気配が霧散し、何も起こらなかった。");
                                },
                                weight: 5
                            }];
                            if (curse.needsTarget) curse.target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                            selectedCurses.push(curse);
                            availableCurses.splice(availableCurses.findIndex(c => c.id === curse.id), 1);
                        }

                        // 選択肢ボタンを生成
                        selectedCurses.forEach(curse => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-purple-700 hover:bg-purple-800 text-white font-bold py-4 px-4 rounded-lg shadow-lg text-left';
                            const targetName = curse.target ? ` (${curse.target.name})` : '';
                            button.innerHTML = `
                                <strong class="text-lg">${curse.text}${targetName}</strong>
                                <span class="block text-sm text-purple-200 mt-1">${curse.description}</span>
                            `;
                            button.onclick = async() => {
                                endlessCurseModal.classList.add('hidden');
                                await curse.effect(curse.target);
                                setTimeout(() => {
                                    updatePartyStatus();
                                    dungeonCommands.classList.remove('hidden');
                                }, 1000);
                            };
                            endlessCurseButtons.appendChild(button);
                        });

                        dungeonCommands.classList.add('hidden');
                        endlessCurseModal.classList.remove('hidden');
                    }

                    function flashCard(target, type) {
                        const card = target.isEnemy ?
                            document.getElementById(`enemy-card-${gameState.enemies.indexOf(target)}`) :
                            document.getElementById(`party-card-${gameState.party.indexOf(target)}`);

                        if (card) {
                            const className = `flash-${type}`;
                            card.classList.add(className);
                            // 敵のカードの場合、z-indexを一時的に上げてフラッシュが手前に表示されるようにする
                            if (target.isEnemy) {
                                card.style.zIndex = '10';
                            }
                            setTimeout(() => {
                                card.classList.remove(className); // ファイター, ソーサラー, ナイト, メディック
                                if (target.isEnemy) {
                                    card.style.zIndex = 'auto';
                                }
                            }, 500); // アニメーション時間と合わせる
                        }
                    }

                    // Renamed and extended flashStat to handle both visual flash and number animation
                    async function animateStatChange(target, statName, changeAmount, type, source = 'player') {
                        if (target.isEnemy) return; // 敵のステータスは表示されていないので何もしない
                        // 身長固定フラグをチェック
                        if (statName === 'height' && target.heightLocked) {
                            // ログは呼び出し元で出すのでここでは不要
                            return;
                        }

                        const card = document.getElementById(`party-card-${gameState.party.indexOf(target)}`);
                        if (!card) return;

                        const statElement = card.querySelector(`.stat-${statName}`);
                        if (!statElement) return;

                        const statSpan = statElement.querySelector('.font-semibold');
                        if (!statSpan) {
                            // If there's no specific number span (e.g., for 'atk' if it were displayed)
                            // Just do the background flash and return
                            const className = `stat-flash-${type}`;
                            statElement.classList.add(className);
                            setTimeout(() => statElement.classList.remove(className), 800);
                            return;
                        }

                        const duration = 500; // Animation duration for number change
                        const flashDuration = 800; // Animation duration for background flash

                        // Apply background flash // ファイター, ソーサラー, ナイト, メディック
                        const flashClassName = `stat-flash-${type}`;
                        statElement.classList.add(flashClassName);
                        setTimeout(() => statElement.classList.remove(flashClassName), flashDuration);

                        // Get current displayed value (before gameState update)
                        if (!statSpan) return animationPromise; // statSpanがない場合はアニメーションをスキップ
                        let startValue;
                        if (statName === 'height') startValue = parseInt(statSpan.textContent.replace('cm', ''));
                        else startValue = parseInt(statSpan.textContent);

                        // Update the actual game state value
                        if (statName === 'hp') target.currentHp += changeAmount;
                        else if (statName === 'mp') target.currentMp += changeAmount;
                        else if (statName === 'height' && target.blessings && target.blessings.size_master && source === 'enemy') {
                            const buffAmount = Math.ceil(Math.abs(changeAmount) / 10);
                            target.buffs.atk_up = (target.buffs.atk_up || 0) + buffAmount;
                            target.buffs.protect = (target.buffs.protect || 0) + buffAmount;
                            target.buffs.agi_up = (target.buffs.agi_up || 0) + buffAmount;
                            log(`${target.name}は変幻自在の力で一時的に強化された！`);
                        } else if (statName === 'height') {
                            let newHeight = target.height + changeAmount;

                            // 「小人族の戦い」モードでの身長上限チェック
                            if (gameState.gameMode === 'dwarves' && newHeight > 10) {
                                if (target.height < 10) {
                                    log(`${target.name}はこれ以上大きくはなれないようだ！`);
                                }
                                changeAmount = 10 - target.height; // 10cmまでの変化量に修正
                                newHeight = 10;
                            }
                            // 「リトルパニック！」モードでの身長上限チェック
                            if (gameState.gameMode === 'little_panic' && ['ソーサラー', 'ドクター', 'トラブルメーカー'].includes(target.role)) {
                                if (newHeight > target.initialHeight) {
                                    changeAmount = target.initialHeight - target.height;
                                    newHeight = target.initialHeight;
                                }
                            }
                            if (newHeight > 2000) {
                                if (target.height < 2000) {
                                    // 上限に達した瞬間にメッセージを表示
                                    const showSpecialMessage = async() => {
                                        log(`${target.name}は成長の限界に達した！これ以上大きくはなれない！`);
                                        await new Promise(resolve => setTimeout(resolve, 1500));
                                        const charConvos = conversations[target.name];
                                        const maxLines = charConvos ? charConvos.grown_max : null;
                                        if (maxLines && maxLines.length > 0) {
                                            log(`${target.name}「${maxLines[Math.floor(Math.random() * maxLines.length)]}」`);
                                        }
                                    };
                                    showSpecialMessage();
                                }
                                changeAmount = 2000 - target.height; // 実際に変化する量に修正
                                target.height = 2000; // 上限値に設定
                            } else {
                                target.height += changeAmount;
                            }
                        }
                        const heightLimit = gameState.gameMode === 'endgame_plus' ? 1000 : 2000;
                        // Clamp values to min/max
                        target.currentHp = Math.min(target.maxHp, Math.max(0, target.currentHp));
                        target.currentMp = Math.min(target.maxMp, Math.max(0, target.currentMp));
                        target.height = Math.min(heightLimit, Math.max(1, Math.ceil(target.height))); // 整数にして1cmと上限値でクランプ

                        const endValue = (statName === 'hp') ? target.currentHp :
                            (statName === 'mp') ? target.currentMp :
                            (statName === 'height') ? target.height : startValue; // Fallback

                        const startTime = performance.now();
                        let resolveAnimation; // アニメーション完了を通知するためのPromise
                        const animationPromise = new Promise(resolve => {
                            resolveAnimation = resolve;
                        });

                        function updateNumber(currentTime) {
                            const elapsedTime = currentTime - startTime;
                            const progress = Math.min(1, elapsedTime / duration);
                            const currentValue = Math.ceil(startValue + (endValue - startValue) * progress);

                            // Update the displayed number and bar // ファイター, ソーサラー, ナイト, メディック
                            if (statName === 'hp') {
                                statSpan.textContent = currentValue;
                                const hpBarInner = card.querySelector('.hp-bar-inner');
                                if (hpBarInner) hpBarInner.style.width = `${Math.max(0, currentValue / target.maxHp * 100)}%`;
                            } else if (statName === 'mp') {
                                statSpan.textContent = currentValue;
                                const mpBarInner = card.querySelector('.mp-bar-inner');
                                if (mpBarInner) mpBarInner.style.width = `${Math.max(0, currentValue / target.maxMp * 100)}%`;
                            } else if (statName === 'height') {
                                statSpan.textContent = `${currentValue}cm`;
                                const heightDiffElement = card.querySelector('.stat-height');
                                if (heightDiffElement) {
                                    const diff = currentValue - target.initialHeight;
                                    heightDiffElement.innerHTML = `身長: <span class="font-semibold">${currentValue}cm</span> (${diff >= 0 ? '+' : ''}${diff})`;
                                }
                            }

                            if (progress < 1) {
                                requestAnimationFrame(updateNumber);
                            } else {
                                // Ensure final value is set after animation // ファイター, ソーサラー, ナイト, メディック
                                if (statName === 'hp') {
                                    statSpan.textContent = endValue;
                                    const hpBarInner = card.querySelector('.hp-bar-inner');
                                    if (hpBarInner) hpBarInner.style.width = `${Math.max(0, endValue / target.maxHp * 100)}%`;
                                } else if (statName === 'mp') {
                                    statSpan.textContent = endValue;
                                    const mpBarInner = card.querySelector('.mp-bar-inner');
                                    if (mpBarInner) mpBarInner.style.width = `${Math.max(0, endValue / target.maxMp * 100)}%`;
                                } else if (statName === 'height') {
                                    statSpan.textContent = `${endValue}cm`;
                                    const heightDiffElement = card.querySelector('.stat-height');
                                    if (heightDiffElement) {
                                        const diff = endValue - target.initialHeight;
                                        heightDiffElement.innerHTML = `身長: <span class="font-semibold">${endValue}cm</span> (${diff >= 0 ? '+' : ''}${diff})`;
                                    }
                                }
                                resolveAnimation();
                            }
                        }
                        requestAnimationFrame(updateNumber);
                        return animationPromise;
                    }

                    function getStatusAndBuffsHtml(target) { // ファイター, ソーサラー, ナイト, メディック
                        let html = '<div class="mt-3 pt-3 border-t border-gray-300 space-y-1">';
                        let hasEffect = false;

                        const effectMap = {
                            // buffs
                            'atk_up': {
                                name: '攻撃力アップ', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-red-600'
                            },
                            'tension_up': {
                                name: 'テンションアップ',
                                color: 'text-orange-500'
                            },

                            'protect': {
                                name: '防御力アップ', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-blue-600'
                            },
                            'agi_up': {
                                name: '素早さアップ', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-green-600'
                            },
                            'provoke': {
                                name: '挑発', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-orange-600'
                            },
                            'cover': {
                                name: 'かばう',
                                color: 'text-amber-600'
                            },
                            'evade_up': {
                                name: '回避アップ',
                                color: 'text-cyan-600'
                            },
                            'guardian_high': {
                                name: 'ガーディアンズハイ',
                                color: 'text-stone-600'
                            },
                            'trouble_check': {
                                name: 'ばっちりチェック',
                                color: 'text-rose-600'
                            },
                            // statusEffects (good)
                            'regeneration': {
                                name: 'HP自動回復', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-green-700'
                            },
                            // statusEffects (bad)
                            'poison': {
                                name: '毒', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-purple-600'
                            },
                            'paralysis': {
                                name: '麻痺',
                                color: 'text-yellow-600'
                            },
                            'slow': {
                                name: '鈍化',
                                color: 'text-gray-600'
                            },
                            'stripped': {
                                name: '脱衣', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-pink-600'
                            },
                            'stat_down': {
                                name: '能力低下',
                                color: 'text-gray-600'
                            },
                        };

                        const allEffects = {...target.buffs,
                            ...target.statusEffects
                        };

                        for (const key in allEffects) {
                            if (effectMap[key]) {
                                hasEffect = true;
                                const effect = effectMap[key];
                                const turns = (typeof allEffects[key] === 'object' && allEffects[key].turns !== undefined) ? allEffects[key].turns : (typeof allEffects[key] === 'number' && allEffects[key] > 0 ? allEffects[key] : null);
                                html += `<p class="${effect.color} font-semibold">${effect.name} ${turns !== null ? `(残り ${turns} ターン)` : ''}</p>`;
                            }
                    }

                if (!hasEffect) return ''; // 効果がなければ何も返さない
                return html + '</div>';
            }

            function showScanResult(target) {
                const scanModalTitle = document.getElementById('scan-modal-title');
                const scanModalContent = document.getElementById('scan-modal-content');
                const scanModalTextContainer = document.getElementById('scan-modal-text-content');
                const scanModalImageContainer = document.getElementById('scan-modal-image-container');
                scanModalContent.innerHTML = ''; // コンテンツをクリア
                scanModalImageContainer.innerHTML = ''; // 画像コンテナもクリア

                if (target.isEnemy) {
                    scanModalTitle.textContent = `${target.name} の調査結果`;

                    let weakness = '物理・魔法ともに同程度有効。';
                    if (target.pDef < target.mDef * 0.8) {
                        weakness = '<strong class="text-red-600">物理攻撃が有効。</strong> 魔法攻撃は効きにくい。';
                    } else if (target.mDef < target.pDef * 0.8) {
                        weakness = '<strong class="text-blue-600">魔法攻撃が有効。</strong> 物理攻撃は効きにくい。';
                    }

                    let skillInfo = '特別なスキルは使用しない。';
                    if (target.skills && target.skills.length > 0) {
                        skillInfo = '使用スキル: ' + target.skills.map(s => s.name).join('、');
                    }

                    scanModalContent.innerHTML = `
                        <p>HP: ${target.currentHp} / ${target.maxHp}</p>
                        <p>弱点: ${weakness}</p>
                        <p>${skillInfo}</p> 
                        ${getStatusAndBuffsHtml(target)}
                    `;
                    // 敵の場合は立ち絵を隠し、テキストエリアを全幅にする
                    scanModalImageContainer.classList.add('hidden');
                    scanModalTextContainer.classList.remove('md:w-1/2');
                    scanModalTextContainer.classList.add('w-full');

                } else { // 味方の場合
                    scanModalTitle.textContent = `${target.name} の情報`;
                    // 変身状態を考慮してブループリントを一度だけ取得する
                    const blueprint = allCharacterBlueprints.find(c => c.name === (target.isTransformed ? 'リリィ' : target.name));
                    let skillHtml = target.skills.map(skill => {
                        // スキルが存在しない、または説明がない場合は空文字を返す
                        if (!skill || !skill.description) return '';
                        return `<div class="p-2 bg-gray-100 rounded-md">
                                   <p class="font-bold">${skill.name} <span class="text-sm font-normal text-gray-600">(${skill.type && skill.type.includes('hp_cost') ? 'HP' : 'MP'}:${skill.cost})</span></p>
                                   <p class="text-sm">${skill.description}</p>
                               </div>`;
                    }).join('');

                    let blessingHtml = '';
                    if (target.blessings && Object.keys(target.blessings).length > 0) {
                        blessingHtml += '<div class="mt-3 pt-3 border-t border-gray-300 space-y-1">';
                        blessingHtml += '<p class="font-bold text-amber-700">授かった祝福</p>';
                        Object.keys(target.blessings).forEach(blessingKey => {
                            const blessingInfo = blessings[blessingKey];
                            if (blessingInfo) {
                                blessingHtml += `<div class="p-2 bg-amber-50 rounded-md"><p class="font-semibold text-amber-800">${blessingInfo.name}</p><p class="text-sm text-amber-700">${blessingInfo.description}</p></div>`;
                            }
                        });
                        blessingHtml += '</div>';
                    }

                    // 先天性能力の表示
                    const innateCriticalRoles = ['ファイター', 'ナイト', 'サムライ', 'ガーディアン', 'トラブルメーカー', 'アンドロイド'];
                    const innateMpRecoveryRoles = ['ソーサラー', 'メディック', 'モンク', 'ギャンブラー', 'サモナー', 'アルケミスト', 'ダンサー', 'ネクロマンサー', 'ドクター'];

                    let innateHtml = '';
                    if (innateCriticalRoles.includes(target.role)) {
                        innateHtml += `<div class="p-2 bg-gray-100 rounded-md"><p class="font-semibold text-gray-800">先天性：クリティカル</p><p class="text-sm text-gray-700">通常攻撃時、確率で会心の一撃になる。</p></div>`;
                    }
                    if (innateMpRecoveryRoles.includes(target.role)) {
                        innateHtml += `<div class="p-2 bg-gray-100 rounded-md"><p class="font-semibold text-gray-800">先天性：MP回復</p><p class="text-sm text-gray-700">通常攻撃時、自身のMPが少し回復する。</p></div>`;
                    }

                    if (innateHtml) {
                        // 祝福欄が既にあればその中に追加、なければ新しく作る
                        if (blessingHtml) {
                            // 閉じタグの直前に挿入
                            blessingHtml = blessingHtml.slice(0, -6) + innateHtml + '</div>';
                        } else {
                            blessingHtml = '<div class="mt-3 pt-3 border-t border-gray-300 space-y-1">' +
                                '<p class="font-bold text-amber-700">授かった祝福</p>' + innateHtml + '</div>';
                        }
                    }

                    scanModalContent.innerHTML = `
                        <p class="italic">"${blueprint.description}"</p>
                        <div class="space-y-2 mt-2">${skillHtml}</div>
                        ${getStatusAndBuffsHtml(target)}
                        ${blessingHtml}
                    `;
                    // 味方の場合は立ち絵を表示し、テキストエリアを半分の幅にする
                    scanModalImageContainer.classList.remove('hidden');
                    scanModalTextContainer.classList.remove('w-full');
                    scanModalTextContainer.classList.add('md:w-1/2');

                    // 立ち絵の表示
                    const imgDiv = document.createElement('div');
                    const bgClass = target.bgClass || blueprint.bgClass;
                    imgDiv.className = `absolute inset-0 bg-no-repeat ${bgClass}`;
                    imgDiv.style.backgroundSize = 'contain';
                    imgDiv.style.backgroundPosition = 'center';
                    scanModalImageContainer.appendChild(imgDiv);
                }

                scanModal.classList.remove('hidden');
                pendingAction = null; // アクションをクリア
                document.querySelectorAll('.enemy-card, .character-card').forEach(c => c.classList.remove('targeted'));
            }

            function showAmountChoiceModal(title, text, choices, callback) {
                amountChoiceTitle.textContent = title;
                amountChoiceText.textContent = text;
                amountChoiceButtons.innerHTML = '';

                choices.forEach(choice => {
                    const button = document.createElement('button');
                    button.className = 'action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg';
                    button.textContent = choice.text;
                    button.onclick = () => {
                        amountChoiceModal.classList.add('hidden');
                        callback(choice.value);
                    };
                    amountChoiceButtons.appendChild(button);
                });

                amountChoiceModal.classList.remove('hidden');
            }

            function cancelScanMode() {
                // 探索中の「調べる」モードをキャンセルする
                if (!gameState.inBattle) {
                    log('探索を続けます。');
                    dungeonCommands.classList.remove('hidden');
                    updatePartyStatus(); // クリックイベントとカードのスタイルを元に戻す
                }
            }

            function showScanTargetSelection() {
                log('誰を調べますか？');
                dungeonCommands.classList.add('hidden'); // コマンドを隠す
                gameState.party.forEach((char, index) => {
                    const card = document.getElementById(`party-card-${index}`);
                    if (card) {
                        card.classList.add('targeted');
                        // 探索中のクリックイベントを一時的に上書き
                        card.onclick = () => {
                            showScanResult(char);
                        };
                    }
                });
            }

            function showItemModal(character = null) {
                itemList.innerHTML = '';
                const availableItems = gameState.inventory.filter(item => item.quantity > 0);

                if (availableItems.length === 0) {
                    itemList.innerHTML = '<p class="text-gray-500">使えるアイテムがありません。</p>';
                } else {
                    availableItems.forEach(item => {
                        const itemInfo = itemBlueprints[item.id];
                        let canUse = gameState.inBattle || !itemInfo.battleOnly;

                        // 復活アイテムは戦闘中で、かつ戦闘不能の味方がいる場合のみ使用可能
                        if (itemInfo.effect === 'revive') {
                            const hasFallenAlly = gameState.party.some(p => p.currentHp <= 0);
                            canUse = gameState.inBattle && hasFallenAlly;
                        }

                        const itemDiv = document.createElement('div');
                        let itemClasses = 'p-2 border-b flex justify-between items-center';
                        if (!canUse) {
                            itemClasses += ' opacity-50';
                        }
                        itemDiv.className = itemClasses;

                        itemDiv.innerHTML = `
                            <div>
                                <p class="font-bold">${itemInfo.name} (x${item.quantity})</p>
                                <p class="text-sm text-gray-600">${itemInfo.description}</p>
                            </div>
                            <button 
                                class="use-item-btn action-button text-white text-sm py-1 px-3 rounded ${canUse ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-400 cursor-not-allowed'}"
                                ${!canUse ? 'disabled' : ''}
                            >つかう</button>
                        `;
                        itemDiv.querySelector('.use-item-btn').onclick = () => {
                            useItem(character, item);
                        };
                        itemList.appendChild(itemDiv);
                    });
                }
                itemModal.classList.remove('hidden');
            }

            function useItem(character, item) {
                itemModal.classList.add('hidden');
                const itemInfo = itemBlueprints[item.id];

                if (!gameState.inBattle && itemInfo.battleOnly) {
                    log("そのアイテムはバトル中にしか使えません。");
                    return;
                }

                if (gameState.inBattle) {
                    playerAction(character, {
                        type: 'item',
                        item: item
                    });
                } else {
                    // 探索中のアイテム使用
                    pendingAction = {
                        character: getRandomPartyMember(),
                        action: {
                            type: 'item',
                            item: item
                        },
                        target: null // ターゲットは後で選択
                    };
                    if (itemInfo.target === 'ally' || itemInfo.target === 'any') {
                        log('誰に使いますか？');
                        // 復活アイテムの場合、戦闘不能の味方をターゲット可能にする
                        if (itemInfo.effect === 'revive') {
                            gameState.party.forEach((char, index) => {
                                // 戦闘不能のキャラのみ光らせる
                                if (char.currentHp <= 0) {
                                    document.getElementById(`party-card-${index}`).classList.add('targeted');
                                }
                            });
                            return; // ここで処理を中断し、ユーザーの選択を待つ
                        }
                        gameState.party.forEach((char, index) => {
                            if (char.currentHp > 0) document.getElementById(`party-card-${index}`).classList.add('targeted');
                        });
                    } else if (itemInfo.target === 'party') {
                        // 全体対象や対象不要のアイテム
                        handleItem(pendingAction.character, gameState.party, pendingAction.action.item);
                    } else {
                        // 全体対象や対象不要のアイテム
                        executePlayerAction();
                    }
                }
            }

            function startGame(mode = 'normal', selectedMembers = null, fromSave = false) {
                gameState.gameMode = mode;
                let backgroundSet = false;

                // 顕現：転生輪廻モードのパーティ決定ロジック
                if (mode === 'tensei_rinne' && !selectedMembers) {
                    const shiroData = localStorage.getItem('shiroTenseiData');
                    if (!shiroData) {
                        alert("転生データが見つかりません。先に「転生紀行」モードをプレイしてください。");
                        return; // ゲーム開始を中止
                    }
                    let characterPool = allCharacterBlueprints.filter(c => c.role !== '転生者' && c.role !== '聖女').map(c => c.name);
                    for (let i = characterPool.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [characterPool[i], characterPool[j]] = [characterPool[j], characterPool[i]];
                    }
                    selectedMembers = ['シロ', ...characterPool.slice(0, 3)];
                }

                // 新しいモード「運命の出会い」の処理

                if (mode === 'random_party') {
                    const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                    let characterPool = allCharacterBlueprints.map(c => c.name);

                    // 聖女の行進をクリアしていない場合、聖女を抽選対象から除外
                    if (!clearFlags.saintMarchCleared) {
                        characterPool = characterPool.filter(name => name !== 'セレスティア');
                    }

                    // Fisher-Yates shuffleで配列をシャッフル
                    for (let i = characterPool.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [characterPool[i], characterPool[j]] = [characterPool[j], characterPool[i]];
                    }

                    selectedMembers = characterPool.slice(0, 4); // シャッフルされたリストから先頭4人を選ぶ
                }

                if (mode === 'treasure_map') {
                    selectedMembers = ['リリィ'];
                }
                if (mode === 'brawling_belles') {
                    selectedMembers = ['ノエル', 'フローラ'];
                }
                // 転生者モード
                if (mode === 'tensei_kikou') {
                    selectedMembers = ['シロ'];
                    // 転生紀行モードの背景を設定
                        gameState.dungeonBackground = FANTASY_FOREST_BG;
                        dungeonView.style.backgroundImage = gameState.dungeonBackground;
                        backgroundSet = true; // 他の背景設定を上書きしないようにフラグを立てる

                    gameState.gameMode = 'endless'; // 無限モードのルールを適用

                    // 転生紀行の記憶引き継ぎイベント (UI要素定義後に移動)
                    const shiroData = localStorage.getItem('shiroTenseiData');
                    if (shiroData && !fromSave) {
                        generalEventTitle.textContent = "過去の記憶";
                        generalEventText.textContent = "シロの脳裏に、過去の自分の記憶が流れ込んでくる…\nこの記憶を呼び覚ましますか？";
                        generalEventButtons.innerHTML = `
                            <button id="inherit-yes" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">はい</button>
                            <button id="inherit-no" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">いいえ</button>
                        `;
                        generalEventModal.classList.remove('hidden');

                        document.getElementById('inherit-yes').onclick = () => applyShiroTenseiData(JSON.parse(shiroData));
                        document.getElementById('inherit-no').onclick = () => {
                            localStorage.removeItem('shiroTenseiData');
                            generalEventModal.classList.add('hidden');
                            log("シロは過去の記憶を振り払い、新たな一歩を踏み出した。");
                        };
                    }
                }
                if (mode === 'size_up_gamble') {
                    selectedMembers = ['ルナ', 'コハル'];
                }


                // メンバー選択が必要なモードで、まだメンバーが選ばれていない場合 (聖女の行進は除く)
                const toggleSelectTeam = document.getElementById('toggle-select-team');
                const fixedPartyModes = ['normal', 'saint_march', 'treasure_map', 'summer_live', 'random_party', 'little_panic', 'brawling_belles', 'tensei_rinne'];
                const teamSelectionRequired = toggleSelectTeam.checked && !fixedPartyModes.includes(mode);

                if ((mode === 'solo' || mode === 'indecent' || mode === 'secret_night' || teamSelectionRequired) && !selectedMembers) {
                    whatIfModal.classList.add('hidden');
                    showSelectTeamModal(mode); // モードを引き継いで選択画面へ
                    return;
                }

                // パーティ表示をクリア
                partyContainer.innerHTML = '';

                titleScreen.classList.add('hidden');
                whatIfModal.classList.add('hidden');
                selectTeamModal.classList.add('hidden');
                dungeonView.classList.remove('hidden');
                hud.classList.remove('hidden');
                commandContainer.classList.remove('hidden');

                if (mode === 'saint_march') {
                    selectedMembers = ['セレスティア'];
                }

                // サマータイム・スペシャルライブ！モードの初期設定
                if (mode === 'summer_live') {
                    selectedMembers = ['リリカ', 'ユイ', 'ミコ', 'リリィ'];
                } else if (mode === 'little_panic') {
                    selectedMembers = ['ヒカリ', 'ベアトリス', 'コハル', 'オリビア'];
                }

                initGame(selectedMembers, fromSave);

                // initGame の後にモード別の特殊設定を適用
                if (!fromSave) {
                    if (mode === 'tensei_rinne') {
                        const shiroData = localStorage.getItem('shiroTenseiData');
                        if (shiroData) {
                            applyShiroTenseiData(JSON.parse(shiroData));
                            // 他のメンバーをLv10にする
                            gameState.party.forEach(char => {
                                if (char.role !== '転生者') {
                                    applyLevelUp(char, 9);
                                    // HP/MPを全快
                                    char.currentHp = char.maxHp;
                                    char.currentMp = char.maxMp;
                                }
                            });
                            log("シロは過去の記憶と共に顕現し、仲間たちはその力に呼応して成長した！");
                        }
                    }



                    if (mode === 'little_panic') {
                        gameState.party.forEach(char => {
                            switch (char.role) {
                                case 'シスター':
                                    // レベル10に設定
                                    applyLevelUp(char, 9);
                                    // スキル変更
                                    char.skills = char.skills.map(skill => {
                                        if (skill.name === 'ホーリーライト') {
                                            return littlePanicSkills.holySphere;
                                        }
                                        if (skill.name === '祈りの円環') {
                                            return littlePanicSkills.heavensJudgment;
                                        }
                                        return skill;
                                    });
                                    // 立ち絵変更
                                    char.bgClass = 'bg-char-olivia-a';
                                    break;
                                case 'ソーサラー': // ドクターからアルケミストに変更
                                case 'アルケミスト':
                                case 'トラブルメーカー':
                                    // 身長と初期身長を-30
                                    char.height -= 30;
                                    char.initialHeight -= 30;
                                    // 立ち絵変更
                                    if (char.role === 'ソーサラー') char.bgClass = 'bg-char-hikari-a';
                                    if (char.role === 'アルケミスト') char.bgClass = 'bg-char-beatrice-a';
                                    if (char.role === 'トラブルメーカー') char.bgClass = 'bg-char-koharu-a';
                                    break;
                            }
                        });
                        log("幼くなった仲間を守るため、シスターが本気を出す！");
                    }
                    if (mode === 'summer_live') {
                        backgroundSet = true;
                        gameState.dungeonBackground = SUMMER_BEACH_BG;
                        // 開始レベルを2にする
                        gameState.party.forEach(char => {
                            applyLevelUp(char, 1); // Lv1 -> Lv2
                            // レベルアップ後にHP/MPを全快させる
                            char.currentHp = char.maxHp;
                            char.currentMp = char.maxMp;
                        });

                        // 立ち絵を水着に変更
                        gameState.party.forEach(char => {
                            if (char.name === 'リリカ') char.bgClass = 'bg-char-ririka-a';
                            if (char.name === 'ユイ') char.bgClass = 'bg-char-yui-a';
                            if (char.name === 'ミコ') char.bgClass = 'bg-char-miko-a';
                        });

                        // リリィをフェアリー化＆スキル変更
                        const lily = gameState.party.find(p => p.name === 'リリィ');
                        if (lily) {
                            const blueprint = allCharacterBlueprints.find(c => c.name === 'リリィ');
                            const transformData = blueprint.transforms['fairy'];
                            lily.originalState = { role: lily.role, skills: lily.skills, bgClass: lily.bgClass, height: lily.height };
                            // 開始時の身長を30cmにする
                            lily.height = 30;
                            lily.role = transformData.role;
                            lily.skills = transformData.skills.map(s => {
                                if (s.type === 'transform_revert') {
                                    return { name: 'ビーチエール', cost: 10, type: 'cure_strip_party', targetType: 'party', description: '味方全員の脱衣状態を解除する。' };
                                }
                                return s;
                            });
                            lily.bgClass = 'bg-char-lily-fairy-a'; // 水着フェアリー
                            lily.isTransformed = true;
                        }

                        // ユイのスキル変更
                        const yui = gameState.party.find(p => p.name === 'ユイ');
                        if (yui) {
                            const devotionIndex = yui.skills.findIndex(s => s.name === '献身');
                            if (devotionIndex !== -1) {
                                yui.skills[devotionIndex] = { name: 'パッションハート', cost: 15, type: 'party_heal', targetType: 'party', description: '味方全体のHPを30%回復する。' };
                            }
                        }
                    }
                }
                // 通常モードの背景設定
                if (!backgroundSet) {
                    gameState.dungeonBackground = DEFAULT_DUNGEON_BG;
                }
                dungeonView.style.backgroundImage = gameState.dungeonBackground;

                setupDungeonUI();
                dungeonCommands.classList.remove('hidden');
                battleCommands.classList.add('hidden');
                enemyContainer.innerHTML = '';
                updatePartyStatus();
            }



            nextFloorButton.addEventListener('click', () => {
                if (!gameState.inBattle && !gameState.gameOver) advanceFloor();
            });
            talkButton.addEventListener('click', () => {
                cancelScanMode(); // 会話する前に調べるモードを終了
                generateConversation();
            });
            modalButton.addEventListener('click', () => {
                returnToTitle();
            });
            itemModalClose.addEventListener('click', () => {
                itemModal.classList.add('hidden');
                document.querySelectorAll('.character-card').forEach(c => c.classList.remove('targeted'));
            });
            loadButton.addEventListener('click', () => {
                const savedData = localStorage.getItem('sizeDungeonSaveData');
                if (savedData) {
                    try {
                        const loadedState = JSON.parse(savedData);
                        // セーブデータをgameStateに復元
                        gameState = loadedState;
                        // ゲーム画面を直接セットアップ
                        // 背景画像を復元
                        dungeonView.style.backgroundImage = gameState.dungeonBackground || DEFAULT_DUNGEON_BG;
                        titleScreen.classList.add('hidden');
                        dungeonView.classList.remove('hidden');
                        hud.classList.remove('hidden');
                        commandContainer.classList.remove('hidden');
                        setupDungeonUI();
                        updatePartyStatus();
                        log("セーブデータをロードしました。");
                    } catch (e) {
                        console.error("セーブデータの読み込みに失敗しました:", e);
                        alert("セーブデータの形式が正しくありません。");
                    }
                }
            });
            startButton.addEventListener('click', () => startGame('normal'));
            ruleButton.addEventListener('click', () => ruleModal.classList.remove('hidden'));
            ruleModalClose.addEventListener('click', () => ruleModal.classList.add('hidden'));
            whatIfButton.addEventListener('click', () => whatIfModal.classList.remove('hidden'));
            whatIfModalClose.addEventListener('click', () => whatIfModal.classList.add('hidden'));
            selectTeamBackButton.addEventListener('click', () => {
                // 選択状態をリセット
                pendingAction = null;
                selectTeamModal.classList.add('hidden');
                whatIfModal.classList.remove('hidden');
            });

            // 「もしもの物語」のタブ切り替え処理
            const whatIfTabs = document.querySelectorAll('.what-if-tab');
            const whatIfContents = document.querySelectorAll('.what-if-content');

            whatIfTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // すべてのタブとコンテンツを非アクティブ/非表示にする
                    whatIfTabs.forEach(t => t.classList.remove('active-tab'));
                    whatIfContents.forEach(c => c.classList.add('hidden'));

                    // クリックされたタブと対応するコンテンツをアクティブ/表示にする
                    tab.classList.add('active-tab');
                    const tabName = tab.dataset.tab;
                    document.getElementById(`what-if-content-${tabName}`).classList.remove('hidden');
                });
            });

            // 各モード選択ボタンにイベントリスナーを設定
            document.querySelectorAll('.what-if-content button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const mode = e.currentTarget.dataset.mode;
                    // startGameを呼び出す。メンバー選択が必要なら中で処理される
                    startGame(mode);
                    whatIfModal.classList.add('hidden');
                });
            });
            // リトルパニックモードのスキル定義
            const littlePanicSkills = {
                holySphere: {
                    name: 'ホーリースフィア', // ファイター, ソーサラー, ナイト, メディック
                    cost: 30,
                    power: 3.5,
                    type: 'magic',
                    targetType: 'enemies',
                    description: '敵全体に高威力の聖なる魔法ダメージを与える。'
                },
                heavensJudgment: {
                    name: '天の裁き',
                    cost: 50,
                    power: 999,
                    type: 'magic',
                    targetType: 'enemy',
                    description: '敵ひとりをほぼ確実に倒す魔法攻撃。低確率で味方ひとりが大ダメージを受ける。'
                }
            };

            // 天の裁きの副作用処理
            async function handleHeavensJudgmentSideEffect(caster) {
                if (Math.random() < 0.15) { // 15%の確率で副作用
                    const aliveAllies = gameState.party.filter(p => p.currentHp > 0 && p !== caster);
                    if (aliveAllies.length > 0) {
                        const victim = aliveAllies[Math.floor(Math.random() * aliveAllies.length)];
                        const damage = Math.ceil(victim.currentHp * 0.7);
                        log(`天罰が下り、${victim.name}が巻き添えを食らった！`);
                        await dealDamage(victim, damage);
                        return true;
                    }
                }
                return false;
            }




            scanModalClose.addEventListener('click', () => {
                scanModal.classList.add('hidden');
                // 「調べる」をキャンセルした場合、元のキャラクターのターンに戻す
                if (gameState.inBattle && !pendingAction) {
                    playerTurn(gameState.turnOrder[gameState.currentTurnIndex]);
                } else if (!gameState.inBattle) {
                    // 探索中の場合は調べるモードをキャンセルするだけ
                    cancelScanMode();
                }
            });

            menuButton.addEventListener('click', () => {
                if (!gameState.inBattle) { // 戦闘中でなければメニューを開ける
                    menuModal.classList.remove('hidden');
                } else {
                    log("戦闘中はメニューを開けません。");
                }
            });
            menuModalClose.addEventListener('click', () => menuModal.classList.add('hidden'));
            saveButton.addEventListener('click', () => {
                try {
                    localStorage.setItem('sizeDungeonSaveData', JSON.stringify(gameState));
                    log("ゲームの状態をセーブしました。");
                    menuModal.classList.add('hidden');
                    checkSaveData(); // セーブ後に「つづきから」ボタンの状態を更新
                } catch (e) {
                    console.error("セーブに失敗しました:", e);
                    log("セーブに失敗しました。ブラウザのストレージ容量が不足している可能性があります。");
                }
            });
            menuReturnTitleButton.addEventListener('click', () => {
                menuModal.classList.add('hidden');
                returnToTitle();
            });

            emergencyButton.addEventListener('click', () => {
                if (!gameState.inBattle) return; // 戦闘中のみ有効

                log("【緊急処理】現在のターンを強制的にスキップします。");

                // 保留中のアクションをクリア
                pendingAction = null;
                document.querySelectorAll('.enemy-card, .character-card').forEach(c => c.classList.remove('targeted'));

                // コマンドUIをリセット
                actionButtons.innerHTML = '';
                commandMessage.textContent = '';

                // ターンを進める
                gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                nextTurn();
            });

            function showSelectTeamModal(mode) {
                teamSelectionList.innerHTML = '';
                let selectedNames = [];
                const isSolo = mode === 'solo';
                const isIndecent = mode === 'indecent';
                const isTrial = mode === 'trial' || mode === 'enjoy' || mode === 'uninhibited_souls';
                const isSecretNight = mode === 'secret_night';

                // モードに応じてプロンプトと選択上限を変更 (enjoy, uninhibited_souls も trial と同じ扱い)
                if (isSolo) {
                    selectionPrompt.textContent = '共に冒険する仲間を1人選んでください。';
                } else if (isIndecent) {
                    selectionPrompt.textContent = '共に冒険する仲間を2～4人選んでください。(ナイト、サムライは選択不可)';
                } else if (isTrial) {
                    selectionPrompt.textContent = '共に冒険する仲間を2～4人選んでください。(このモードはチーム選択が可能です)';
                } else if (isSecretNight) {
                    selectionPrompt.textContent = 'ヒミツの夜を過ごす仲間を1人選んでください。';
                } else {
                    selectionPrompt.textContent = '共に冒険する仲間を2～4人選んでください。';
                }

                // 表示するキャラクターリストを準備
                const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                let availableBlueprints = allCharacterBlueprints.filter(char => {
                    if (char.role === '聖女' && !clearFlags.saintMarchCleared) return false;
                    if (char.role === 'トレジャーハンター' && !clearFlags.treasureMapCleared) return false;
                    if (char.role === 'アンドロイド' && !clearFlags.brawlingBellesCleared) return false;
                    if (isSecretNight) {
                        const secretNightChars = ['リリカ', 'ユイ', 'ミコ', 'リリィ', 'フローラ'];
                        return secretNightChars.includes(char.name);
                    }
                    // 転生紀行モード以外では転生者を選択不可にする
                    if (mode !== 'tensei_kikou' && char.role === '転生者') {
                        // ただし、転生紀行モード自体はチーム選択画面を通らないので、このチェックは他モード用
                        return false;
                    }
                    if (char.role === 'メイド' && !clearFlags.brawlingBellesCleared) return false;
                    return true; // ファイター, ソーサラー, ナイト, メディック
                }); // ファイター, ソーサラー, ナイト, メディック
                
                // 終焉の呼び声モードの参加資格チェック
                const soloClearFlags = JSON.parse(localStorage.getItem('sizeDungeonSoloClearFlags') || '{}');
                const starObserverClearers = JSON.parse(localStorage.getItem('sizeDungeonStarObserverClearers') || '{}');
                const isEndgamePlus = mode === 'endgame_plus';

                availableBlueprints.forEach(char => {
                    if (isIndecent && (char.role === 'ナイト' || char.role === 'サムライ' || char.role === '聖女')) {
                        return; // 痴態騒ぎモードではナイト、サムライ、聖女をスキップ
                    }
                    // 終焉の呼び声モードの参加資格チェック
                    if (isEndgamePlus && !soloClearFlags[char.name] && !starObserverClearers[char.name]) {
                        return; // 資格がなければスキップ
                    }


                    const specialRoles = ['聖女', 'トレジャーハンター', 'アンドロイド', 'メイド'];
                    const isSpecialChar = specialRoles.includes(char.role);

                    const card = document.createElement('div');
                    let cardClasses = 'p-4 border-2 border-gray-200 rounded-lg cursor-pointer hover:bg-gray-100 transition';

                    // 特別なキャラクターの背景色を少し変える
                    if (isSpecialChar) {
                        // TailwindのJITコンパイラが動的にクラスを生成できるよう、完全なクラス名を記述します。
                        if (char.themeColor === 'yellow') cardClasses += ' bg-gradient-to-br from-yellow-50 to-yellow-100';
                        else if (char.themeColor === 'lime') cardClasses += ' bg-gradient-to-br from-lime-50 to-lime-100';
                        else if (char.themeColor === 'rose') cardClasses += ' bg-gradient-to-br from-rose-50 to-rose-100';
                        else if (char.themeColor === 'emerald') cardClasses += ' bg-gradient-to-br from-emerald-50 to-emerald-100';
                    }
                    card.className = cardClasses;
                    card.dataset.name = char.name;
                    card.innerHTML = `
                        <p class="font-bold text-lg text-${char.themeColor}-700">${char.name}</p>
                        <p class="text-sm text-gray-600">${char.role}</p>
                    `;
                    card.addEventListener('click', () => {
                        if (selectedNames.includes(char.name)) {
                            selectedNames = selectedNames.filter(name => name !== char.name);
                            card.classList.remove('border-indigo-500', 'bg-indigo-50');
                        } else if ((isSolo || isSecretNight) && selectedNames.length < 1) {
                            selectedNames.push(char.name);
                            card.classList.add('border-indigo-500', 'bg-indigo-50');
                        } else if (!isSolo && !isSecretNight && selectedNames.length < 4) {
                            selectedNames.push(char.name);
                            card.classList.add('border-indigo-500', 'bg-indigo-50');
                        }
                        updateSelectionUI();
                    });
                    teamSelectionList.appendChild(card);
                });

                function updateSelectionUI() {
                    let isValid;
                    if (isSolo || isSecretNight) { // 1人選択モード
                        selectionCounter.textContent = `${selectedNames.length} / 1 人選択中`;
                        isValid = selectedNames.length === 1;
                    } else { // 2〜4人選択モード
                        selectionCounter.textContent = `${selectedNames.length} 人選択中`;
                        isValid = selectedNames.length >= 2 && selectedNames.length <= 4;
                    }
                    startSelectionButton.disabled = !isValid;
                    startSelectionButton.classList.toggle('opacity-50', !isValid);
                    startSelectionButton.classList.toggle('cursor-not-allowed', !isValid);
                }

                startSelectionButton.onclick = () => {
                    const count = selectedNames.length;
                    const validSolo = isSolo && count === 1; // soloモードは1人
                    const validSecretNight = isSecretNight && count === 1; // secret_nightモードは1人
                    const validTrial = isTrial && count >= 2 && count <= 4; // trial, enjoy, uninhibited_soulsモードは2-4人
                    const validIndecent = isIndecent && count >= 2 && count <= 4; // indecentモードは2-4人
                    // 上記以外のモード（endgame_plusなど）でチーム選択が有効な場合
                    const validTeam = !isSolo && !isSecretNight && !isIndecent && !isTrial && count >= 2 && count <= 4;


                    if (validSolo || validSecretNight || validIndecent || validTrial || validTeam) startGame(mode, selectedNames);
                };

                selectTeamModal.classList.remove('hidden');
            }

            randomSelectButton.addEventListener('click', () => {
                const teamListContainer = document.getElementById('team-selection-list');
                const allCharacterCards = Array.from(teamListContainer.children);
                const availableCharacters = allCharacterCards.map(card => card.dataset.name);

                // Fisher-Yates shuffle algorithm
                for (let i = availableCharacters.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availableCharacters[i], availableCharacters[j]] = [availableCharacters[j], availableCharacters[i]];
                }

                const isSolo = gameState.gameMode === 'solo';
                const selectionCount = isSolo ? 1 : 4;
                const randomSelection = availableCharacters.slice(0, selectionCount);

                // Simulate clicks on the character cards
                allCharacterCards.forEach(card => {
                    const shouldBeSelected = randomSelection.includes(card.dataset.name);
                    const isCurrentlySelected = card.classList.contains('border-indigo-500');
                    if (shouldBeSelected !== isCurrentlySelected) card.click();
                });
            });

            function returnToTitle() {
                modal.classList.add('hidden');
                titleScreen.classList.remove('hidden');
                dungeonView.classList.add('hidden');
                hud.classList.add('hidden');
                commandContainer.classList.add('hidden');
                // 背景をデフォルトに戻す
                dungeonView.style.backgroundImage = DEFAULT_DUNGEON_BG;
                checkSaveData(); // タイトルに戻るたびにセーブデータの有無をチェック
            }

            // 顕現：転生輪廻モードのクリア/ゲームオーバー処理
            function handleTenseiRinneEnd(isVictory) {
                const shiro = gameState.party.find(p => p.role === '転生者');
                if (!shiro) {
                    // シロがいない場合は通常のゲームオーバー
                    showModal("ゲームオーバー", "パーティは全滅してしまった...");
                    gameState.gameOver = true;
                    return;
                }

                saveShiroTenseiData(shiro, false); // ペナルティなしで保存

                if (isVictory && gameState.floor === 30) {
                    showModal("踏破成功", "あなたは仲間と共に30階のボスを打ち破った。\nシロの力はさらに強まり、その記憶は次なる輪廻へと引き継がれる…。");
                    gameState.gameOver = true;
                } else if (isVictory) {
                    // 30階未満での勝利
                    showLevelUpModal(false);
                } else {
                    // 敗北時の処理
                    showModal("輪廻の終わり", "力尽きたが、シロの魂は不滅だ。この経験を糧に、彼女は再び転生するだろう。");
                    gameState.gameOver = true;
                }
            }


            // --- デバッグ用クリアフラグ操作 ---
            const debugSaintButton = document.getElementById('debug-saint-button');
            const debugTreasureButton = document.getElementById('debug-treasure-button');
            const debugSummerButton = document.getElementById('debug-summer-button');
            const debugBellesButton = document.getElementById('debug-belles-button');
            const debugEndgameButton = document.createElement('button'); // 終焉モード用

            // ボタンの表示状態を更新する関数
            function updateDebugButtons() {
                const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');

                // 終焉の呼び声ボタンの表示制御
                const shiroData = localStorage.getItem('shiroTenseiData');
                if (shiroData) tenseiRinneButton.classList.remove('hidden');
                else tenseiRinneButton.classList.add('hidden');

                if (clearFlags.endgameCleared) endgamePlusButton.classList.remove('hidden');
                else endgamePlusButton.classList.add('hidden');

                // 聖女
                if (clearFlags.saintMarchCleared) {
                    debugSaintButton.textContent = '聖女クリア済';
                    debugSaintButton.className = 'text-white p-1 rounded bg-green-600 hover:bg-green-700';
                } else {
                    debugSaintButton.textContent = '聖女未クリア';
                    debugSaintButton.className = 'text-white p-1 rounded bg-red-600 hover:bg-red-700';
                }

                // 秘宝
                if (clearFlags.treasureMapCleared) {
                    debugTreasureButton.textContent = '秘宝クリア済';
                    debugTreasureButton.className = 'text-white p-1 rounded bg-green-600 hover:bg-green-700';
                } else {
                    debugTreasureButton.textContent = '秘宝未クリア';
                    debugTreasureButton.className = 'text-white p-1 rounded bg-red-600 hover:bg-red-700';
                }

                // サマー
                if (clearFlags.summerLiveCleared) {
                    debugSummerButton.textContent = 'サマークリア済';
                    debugSummerButton.className = 'text-white p-1 rounded bg-green-600 hover:bg-green-700';
                } else {
                    debugSummerButton.textContent = 'サマー未クリア';
                    debugSummerButton.className = 'text-white p-1 rounded bg-red-600 hover:bg-red-700';
                }

                // 闘争令嬢
                if (clearFlags.brawlingBellesCleared) {
                    debugBellesButton.textContent = '令嬢クリア済';
                    debugBellesButton.className = 'text-white p-1 rounded bg-green-600 hover:bg-green-700';
                } else {
                    debugBellesButton.textContent = '令嬢未クリア';
                    debugBellesButton.className = 'text-white p-1 rounded bg-red-600 hover:bg-red-700';
                }

                // 終焉
                if (clearFlags.endgameCleared) {
                    debugEndgameButton.textContent = '終焉クリア済';
                    debugEndgameButton.className = 'text-white p-1 rounded bg-green-600 hover:bg-green-700';
                } else {
                    debugEndgameButton.textContent = '終焉未クリア';
                    debugEndgameButton.className = 'text-white p-1 rounded bg-red-600 hover:bg-red-700';
                }
            }

            // クリアフラグをトグルする関数
            function toggleClearFlag(flagName) {
                const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                const isClearing = !clearFlags[flagName]; // これからクリア済みにするかどうか
                clearFlags[flagName] = isClearing;
                localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(clearFlags));

                // 「終焉の呼び声」のデバッグ操作時に、参加資格も同時に操作する
                if (flagName === 'endgameCleared') {
                    if (isClearing) { // 終焉をクリア済みにする場合
                        const soloClearFlags = {};
                        allCharacterBlueprints.forEach(char => {
                            soloClearFlags[char.name] = true;
                        });
                        localStorage.setItem('sizeDungeonSoloClearFlags', JSON.stringify(soloClearFlags));
                    } else { // 未クリアに戻す場合
                        localStorage.removeItem('sizeDungeonSoloClearFlags');
                    }
                }

                updateDebugButtons();
            }

            // デバッグボタンのイベントリスナーを設定する関数
            function setupDebugControls() {
                debugEndgameButton.id = 'debug-endgame-button';
                document.getElementById('debug-controls').appendChild(debugEndgameButton);
                debugSaintButton.addEventListener('click', () => toggleClearFlag('saintMarchCleared'));
                debugTreasureButton.addEventListener('click', () => toggleClearFlag('treasureMapCleared'));
                debugSummerButton.addEventListener('click', () => toggleClearFlag('summerLiveCleared'));
                debugBellesButton.addEventListener('click', () => toggleClearFlag('brawlingBellesCleared'));
                debugEndgameButton.addEventListener('click', () => toggleClearFlag('endgameCleared'));
            }

            logContainer.addEventListener('mouseleave', () => {
                logTooltip.classList.add('hidden');
            });

            // ツールチップ自体にマウスが入った時も表示を維持
            logTooltip.addEventListener('mouseenter', () => {
                logTooltip.classList.remove('hidden');
            });
            logTooltip.addEventListener('mouseleave', () => {
                logTooltip.classList.add('hidden');
            });

            // ログ履歴表示のイベントリスナー
            logContainer.addEventListener('mouseenter', () => {
                if (logHistory.length > 0) {
                    const recentLogs = logHistory.slice(-5).reverse(); // 最新5件を新しい順に取得
                    logTooltip.innerHTML = recentLogs.map((log, index) =>
                        `<p class="${index === 0 ? 'font-bold' : 'text-gray-300'}">${log}</p>`
                    ).join('');
                    logTooltip.classList.remove('hidden');
                }
            });

            // --- 初期化処理 ---
            // セーブデータの有無をチェックし、「つづきから」ボタンの表示を制御
            function checkSaveData() {
                if (localStorage.getItem('sizeDungeonSaveData')) { // ファイター, ソーサラー, ナイト, メディック
                    loadButton.classList.remove('hidden');
                } else {
                    loadButton.classList.add('hidden');
                }
            }

            checkSaveData(); // セーブデータチェックを実行
            setupDebugControls(); // デバッグ関連のセットアップを実行
            updateDebugButtons(); // デバッグボタンの初期表示を更新
            // 1階の会話再生後に祝福を付与する処理
            const originalPlayConversation = window.playConversation;
            window.playConversation = async function(conversation) {
                await originalPlayConversation(conversation);
                if (gameState.gameMode === 'size_up_gamble' && gameState.floor === 1) {
                    applySizeUpGambleBlessing();
                }
            };
        }); // DOMContentLoadedの閉じ括弧
    </script>
    <script>
        // 新しいモード用の関数をこちらに分離
        async function triggerSizeUpGambleGoalEvent() {
            dungeonCommands.classList.add('hidden');
            log("？？？「見事だ、挑戦者よ！そのサイズ、まさに天を突くようだ！」");
            await new Promise(resolve => setTimeout(resolve, 2500));
            log("？？？「だが、本当のギャンブルはここからだ。次の戦いで、お前たちの運命を決めさせてもらう…！」");
            await new Promise(resolve => setTimeout(resolve, 2500));
            log("（次の戦闘で、とてつもなく強大な気配が待ち受けている…！）");
            gameState.nextBattleIsGambleMaster = true;
            dungeonCommands.classList.remove('hidden');
        }

        async function triggerSizeUpGambleGameOverEvent() {
            dungeonCommands.classList.add('hidden');
            log("ルナ「…ちょっと、これはマズいんじゃない？」");
            await new Promise(resolve => setTimeout(resolve, 2500));
            log("コハル「ふぇぇ…！二人とも、アリさんみたいになっちゃいました…！」");
            await new Promise(resolve => setTimeout(resolve, 2500));
            log("？？？「おやおや、賭けに負けて全てを失ってしまったようだね」");
            await new Promise(resolve => setTimeout(resolve, 2500));
            log("？？？「残念だが、君たちの冒険はここでおしまいだ」");
            await new Promise(resolve => setTimeout(resolve, 2500));

            showModal("ゲームオーバー", "賭けに負け、全てを失った二人は、ダンジョンの塵と消えた…。");
            gameState.gameOver = true;
        }
    </script>
</body>

</html>