<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>しゅりんく・だんじょん・がーるず</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            touch-action: manipulation;
        }
        
        .hud-gradient {
            background-image: linear-gradient(to top, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.8));
        }
        
        .log-gradient {
            background-image: linear-gradient(to bottom, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.8));
        }
        
        .action-button {
            transition: all 0.2s ease-in-out;
        }
        
        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        .action-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .hp-bar-inner,
        .mp-bar-inner {
            transition: width 0.5s ease-in-out;
        }
        
        .character-card {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            min-height: 140px;
            /* 少し高さを増やして見栄えを調整 */
            position: relative;
            overflow: hidden;
            /* 疑似要素をはみ出させない */
            background-image: linear-gradient(to bottom, #fffbeb, #fef3c7);
            /* 羊皮紙のような背景 */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1), 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            /* 内側に影を追加して立体感を出す */
            display: flex;
            align-items: flex-end;
            /* 子要素を下揃えにする */
        }
        
        .character-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: var(--char-bg-image);
            /* 画像URL */
            background-color: white;
            background-size: var(--char-bg-size, cover);
            /* サイズ (JSで変更) */
            background-position: var(--char-bg-position, center bottom);
            /* 位置 (JSで変更) */
            background-repeat: no-repeat;
            opacity: 0.6;
            /* 背景画像の透明度を調整 */
            z-index: 0;
            transition: background-size 0.5s ease-in-out, background-position 0.5s ease-in-out;
        }
        
        .character-card.targeted {
            border-color: #3b82f6;
        }
        
        .character-stats {
            position: relative;
            /* 疑似要素より手前に表示 */
            z-index: 1;
            padding: 0.25rem;
            border-radius: 0.25rem;
            /* 文字の視認性確保のためにテキストシャドウを追加 */
            text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.7), -1px -1px 3px rgba(255, 255, 255, 0.7), 1px -1px 3px rgba(255, 255, 255, 0.7), -1px 1px 3px rgba(255, 255, 255, 0.7);
        }
        
        .targeted {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.8);
            /* 敵選択時のスタイル */
            border-color: #ef4444;
        }
        
        .enemy-card {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        
        .damage-popup {
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: red;
            text-shadow: 1px 1px 2px white;
            animation: floatUp 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }
        
        .heal-popup {
            color: #22c55e;
        }
        
        @keyframes floatUp {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -150%) scale(1.5);
                opacity: 0;
            }
        }
        
        .flash-red {
            animation: flash-red 0.5s ease-out;
        }
        
        .flash-green {
            animation: flash-green 0.5s ease-out;
        }
        
        .flash-yellow {
            animation: flash-yellow 0.5s ease-out;
        }
        
        @keyframes flash-red {
            0%,
            100% {
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(255, 59, 59, 0.8);
                transform: scale(1.05);
            }
        }
        
        @keyframes flash-green {
            0%,
            100% {
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(34, 197, 94, 0.8);
                transform: scale(1.05);
            }
        }
        
        @keyframes flash-yellow {
            0%,
            100% {
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(253, 224, 71, 0.9);
                transform: scale(1.05);
            }
        }
        
        .enemy-card.flash-red {
            animation: flash-red-enemy 0.5s ease-out;
        }
        
        .enemy-card.flash-green {
            animation: flash-green-enemy 0.5s ease-out;
        }
        
        .enemy-card.flash-yellow {
            animation: flash-yellow-enemy 0.5s ease-out;
        }
        
        @keyframes flash-red-enemy {
            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(255, 59, 59, 0.8);
                transform: scale(1.05);
            }
        }
        
        @keyframes flash-green-enemy {
            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(34, 197, 94, 0.8);
                transform: scale(1.05);
            }
        }
        
        @keyframes flash-yellow-enemy {
            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(253, 224, 71, 0.9);
                transform: scale(1.05);
            }
        }
        
        .stat-flash-increase {
            animation: flash-stat-green 0.8s ease-out;
            border-radius: 0.25rem;
        }
        
        .stat-flash-decrease {
            animation: flash-stat-red 0.8s ease-out;
            border-radius: 0.25rem;
        }
        
        @keyframes flash-stat-green {
            0%,
            100% {
                background-color: transparent;
            }
            50% {
                background-color: rgba(34, 197, 94, 0.5);
            }
        }
        
        @keyframes flash-stat-red {
            0%,
            100% {
                background-color: transparent;
            }
            50% {
                background-color: rgba(239, 68, 68, 0.5);
            }
        }
        
        .status-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-left: 4px;
        }
        
        .fade-out-down {
            animation: fade-out-down 1s ease-out forwards;
        }
        
        @keyframes fade-out-down {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(20px);
            }
        }
        /* ゴーレムと防壁のオーバーレイ表示 */
        
        .golem-status-container,
        .wall-status-container {
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            z-index: 2;
            /* character-stats(z-index:1)より手前に表示 */
            pointer-events: none;
            /* 下の要素をクリックできるように */
        }
        
        .golem-card-inner,
        .wall-card-inner {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 2px 4px;
            border-radius: 4px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        /* キャラクター背景画像 */
        
        .bg-char-akari {
            --char-bg-image: url('sgd_1.png');
        }
        
        .bg-char-hikari {
            --char-bg-image: url('sgd_2.png');
        }
        
        .bg-char-shizuka {
            --char-bg-image: url('sgd_3.png');
        }
        
        .bg-char-yui {
            --char-bg-image: url('sgd_4.png');
        }
        
        .bg-char-beatrice {
            --char-bg-image: url('sgd_5.png');
        }
        
        .bg-char-ririka {
            --char-bg-image: url('sgd_6.png');
        }
        
        .bg-char-sakuya {
            --char-bg-image: url('sgd_7.png');
        }
        
        .bg-char-shaomei {
            --char-bg-image: url('sgd_8.png');
        }
        
        .bg-char-eriza {
            --char-bg-image: url('sgd_9.png');
        }
        
        .bg-char-runa {
            --char-bg-image: url('sgd_10.png');
        }
        
        .bg-char-chloe {
            --char-bg-image: url('sgd_11.png');
        }
        
        .bg-char-miko {
            --char-bg-image: url('sgd_12.png');
        }
        
        .bg-char-renka {
            --char-bg-image: url('sgd_13.png');
        }
        
        .bg-char-iori {
            --char-bg-image: url('sgd_14.png');
        }
        
        .bg-char-koharu {
            --char-bg-image: url('sgd_15.png');
        }
        
        .bg-char-olivia {
            --char-bg-image: url('sgd_16.png');
        }
        
        .bg-char-celestia {
            --char-bg-image: url('sgd_17.png');
        }
        /* リトルパニック用 */
        
        .bg-char-hikari-a {
            --char-bg-image: url('sgd_2a.png');
        }
        
        .bg-char-beatrice-a {
            --char-bg-image: url('sgd_5a.png');
        }
        
        .bg-char-koharu-a {
            --char-bg-image: url('sgd_15a.png');
        }
        
        .bg-char-olivia-a {
            --char-bg-image: url('sgd_16a.png');
        }
        /* トレジャーハンター用 */
        
        .bg-char-lily {
            --char-bg-image: url('sgd_18.png');
        }
        
        .bg-char-lily-succubus {
            --char-bg-image: url('sgd_18-1.png');
        }
        
        .bg-char-lily-fairy {
            --char-bg-image: url('sgd_18-2.png');
        }
        
        .bg-char-lily-alraune {
            --char-bg-image: url('sgd_18-3.png');
        }
        /* 闘争令嬢用 */
        
        .bg-char-noel {
            --char-bg-image: url('sgd_19.png');
        }
        
        .bg-char-flora {
            --char-bg-image: url('sgd_20.png');
        }
        /* 闘争令嬢プライベート衣装用 */
        
        .bg-char-noel-a {
            --char-bg-image: url('sgd_19a.png');
        }
        
        .bg-char-flora-a {
            --char-bg-image: url('sgd_20a.png');
        }
        /* サマータイム・スペシャルライブ用 */
        
        .bg-char-ririka-a {
            --char-bg-image: url('sgd_6a.png');
        }
        
        .bg-char-yui-a {
            --char-bg-image: url('sgd_4a.png');
        }
        
        .bg-char-miko-a {
            --char-bg-image: url('sgd_12a.png');
        }
        
        .bg-char-lily-fairy-a {
            --char-bg-image: url('sgd_18-2a.png');
        }
        
        .bg-char-ririka-b {
            --char-bg-image: url('sgd_6b.png');
        }
        
        .bg-char-yui-b {
            --char-bg-image: url('sgd_4b.png');
        }
        
        .bg-char-miko-b {
            --char-bg-image: url('sgd_12b.png');
        }
        
        .bg-char-lily-b {
            --char-bg-image: url('sgd_18b.png');
        }
        /* サマータイム・スペシャルライブ衣装（リリィ変身後） */
        
        .bg-char-lily-a {
            --char-bg-image: url('sgd_18a.png');
        }
        
        .bg-char-lily-succubus-a {
            --char-bg-image: url('sgd_18-1a.png');
        }
        
        .bg-char-lily-alraune-a {
            --char-bg-image: url('sgd_18-3a.png');
        }
        
        .bg-char-lily-succubus-b {
            --char-bg-image: url('sgd_18-1b.png');
        }
        
        .bg-char-lily-fairy-b {
            --char-bg-image: url('sgd_18-2b.png');
        }
        
        .bg-char-lily-alraune-b {
            --char-bg-image: url('sgd_18-3b.png');
        }
        /* 緊急ボタンの表示制御 */
        
        #emergency-button {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: translateY(-10px);
        }
        /* 戦闘中にメニューエリアをホバーした時 */
        
        #menu-area:hover #emergency-button.battle-active {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }
        /* ログ履歴ツールチップ */
        
        #log-tooltip {
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
            transform: translateY(10px);
            opacity: 0;
            pointer-events: none;
        }
        
        #log-container:hover+#log-tooltip {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }
        /* もしもの物語モーダルのタブスタイル */
        
        .what-if-tab {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            color: #6b7280;
            /* gray-500 */
            transition: all 0.2s ease-in-out;
        }
        
        .what-if-tab:hover {
            color: #111827;
            /* gray-900 */
        }
        
        .what-if-tab.active-tab {
            color: #3b82f6;
            /* blue-500 */
            border-bottom-color: #3b82f6;
            /* blue-500 */
        }
    </style>
</head>

<body class="bg-green-100 flex items-center justify-center min-h-screen">
    <div id="game-container" class="w-full max-w-4xl mx-auto bg-green-200 rounded-2xl shadow-2xl overflow-hidden relative aspect-[4/3] sm:aspect-[16/9] flex flex-col">
        <!-- タイトル画面 -->
        <div id="title-screen" class="absolute inset-0 bg-cover bg-center flex flex-col items-center justify-center z-20 p-8" style="background-image: url('https://image.pollinations.ai/prompt/fantasy%20rpg%20dungeon,%20dark,%20mysterious,%20glowing%20runes,%20stone%20columns,%20roots,%20moss,%20pathway,%20digital%20painting');">
            <div class="bg-black/60 p-8 rounded-xl text-center shadow-lg">
                <h1 class="text-4xl sm:text-5xl font-bold text-white mb-8" style="text-shadow: 2px 2px 4px #000;">しゅりんく・だんじょん・がーるず</h1>
                <div class="flex flex-col sm:flex-row gap-4 justify-center">
                    <button id="load-button" class="action-button bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg hidden">つづきから</button>
                    <button id="start-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg">はじめから</button>
                    <button id="what-if-button" class="action-button bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg">もしもの物語</button>
                    <button id="rule-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg">ルール説明</button>
                </div>
            </div>
            <div id="debug-controls" class="absolute bottom-4 right-4 bg-black/50 p-2 rounded-lg flex flex-col gap-2 text-xs">
                <button id="debug-saint-button" class="text-white p-1 rounded"></button>
                <button id="debug-treasure-button" class="text-white p-1 rounded"></button>
                <button id="debug-summer-button" class="text-white p-1 rounded"></button>
                <button id="debug-belles-button" class="text-white p-1 rounded"></button>
            </div>
        </div>

        <!-- ゲーム画面 -->
        <div id="dungeon-view" class="hidden flex-grow bg-cover bg-center relative flex flex-col justify-between p-4" style="background-image: url('https://image.pollinations.ai/prompt/fantasy%20rpg%20dungeon,%20dark,%20mysterious,%20glowing%20runes,%20stone%20columns,%20roots,%20moss,%20pathway,%20digital%20painting');">
            <p id="floor-display" class="hidden absolute top-4 left-4 text-white font-bold text-lg" style="text-shadow: 1px 1px 3px #000;"></p>
            <div id="menu-area" class="absolute top-4 right-4 z-30 flex flex-col items-end gap-2">
                <button id="menu-button" class="action-button bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-lg shadow-lg">メニュー</button>
                <button id="emergency-button" class="action-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg" title="戦闘が止まった時に押してください">緊急</button>
            </div>
            <div id="log-container" class="w-full max-w-2xl mx-auto rounded-lg p-2 text-center log-gradient shadow-md">
                <p id="log-message" class="text-gray-800 font-bold text-sm md:text-base"></p>
            </div>
            <div id="enemy-container" class="flex justify-center items-end gap-4 h-1/2"></div>
        </div>

        <!-- ログ履歴ツールチップ -->
        <div id="log-tooltip" class="hidden absolute bottom-24 left-1/2 -translate-x-1/2 w-full max-w-2xl bg-black/80 text-white text-sm rounded-lg p-4 shadow-lg z-40">
            <!-- ログ履歴がここに挿入される -->
        </div>

        <div id="hud" class="hidden w-full p-2 sm:p-4 hud-gradient shadow-inner">
            <div id="party-container" class="flex flex-wrap justify-center gap-2 sm:gap-4"></div>
        </div>

        <div id="command-container" class="hidden bg-gray-800/80 p-4 text-white flex justify-center items-center">
            <div id="dungeon-commands" class="flex gap-4">
                <button id="next-floor-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">次のフロアへ</button>
            </div>
            <div id="battle-commands" class="hidden w-full">
                <p id="command-message" class="text-center font-bold mb-2"></p>
                <div id="action-buttons" class="grid grid-cols-2 sm:grid-cols-4 gap-2"></div>
            </div>
        </div>

        <div id="modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-sm w-full">
                <h2 id="modal-title" class="text-3xl font-bold mb-4"></h2>
                <p id="modal-text" class="mb-6"></p>
                <button id="modal-button" class="action-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">タイトルに戻る</button>
            </div>
        </div>

        <!-- 願い星イベントモーダル -->
        <div id="wishing-star-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 id="wishing-star-modal-title" class="text-3xl font-bold mb-2 text-center text-cyan-600">願い星</h2>
                <p id="wishing-star-modal-prompt" class="mb-6 text-center">願い事をする仲間を一人選んでください。</p>
                <div id="wishing-star-char-select" class="grid grid-cols-2 sm:grid-cols-4 gap-4"></div>
                <div id="wishing-star-options" class="hidden grid grid-cols-1 md:grid-cols-2 gap-4"></div>
            </div>
        </div>

        <!-- 調合イベントモーダル -->
        <div id="alchemy-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 class="text-3xl font-bold mb-2 text-center text-purple-600">調合</h2>
                <p class="mb-6 text-center">手持ちのアイテムを組み合わせて、新たなアイテムを作り出せそうだ。<br>何を作りますか？</p>
                <div id="alchemy-options" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <!-- 調合選択肢がここに挿入される -->
                </div>
                <div class="text-center">
                    <button id="alchemy-cancel-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">やめる</button>
                </div>
            </div>
        </div>

        <!-- 身長固定確認モーダル -->
        <div id="height-lock-confirm-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <p id="height-lock-confirm-text" class="mb-6"></p>
                <button id="height-lock-confirm-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg mr-4">はい</button>
                <button id="height-lock-cancel-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">いいえ</button>
            </div>
        </div>

        <div id="item-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-40 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-md w-full">
                <h2 class="text-2xl font-bold mb-4">アイテム</h2>
                <div id="item-list" class="max-h-64 overflow-y-auto mb-4"></div><button id="item-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">閉じる</button></div>
        </div>

        <div id="level-up-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 class="text-3xl font-bold mb-4 text-center">勝利！</h2>
                <p class="mb-6 text-center">強化するキャラクターを一人選んでください。</p>
                <div id="level-up-party-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4"></div>
            </div>
        </div>

        <div id="rule-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-lg w-full">
                <h2 class="text-2xl font-bold mb-4">ルール説明</h2>
                <div class="space-y-2 text-gray-700 max-h-96 overflow-y-auto pr-2">
                    <p class="font-bold">目的:</p>
                    <p>ダンジョンの最深部(30階)にいるボスを倒すとゲームクリアです。</p>
                    <p class="font-bold">探索:</p>
                    <p>「次のフロアへ」進むと、敵との戦闘やランダムなイベントが発生します。「会話する」で仲間との会話を楽しめます。</p>
                    <p class="font-bold">戦闘:</p>
                    <p>素早さの順に行動します。戦闘に勝利すると、仲間を一人強化できます。</p>
                    <p class="font-bold">身長システム:</p>
                    <p>身長が変わるとステータスが変動します。高くなると攻撃力・防御力が上がり、低くなると素早さが上がります。敵からの狙われやすさ(ヘイト)も身長に影響されます。</p>
                </div>
                <div class="text-right mt-4">
                    <button id="rule-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">閉じる</button></div>
            </div>
        </div>

        <div id="select-team-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-2xl w-full relative">
                <h2 class="text-2xl font-bold mb-2">選抜チーム</h2>
                <button id="random-select-button" class="absolute top-6 right-6 action-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg text-sm">ランダム選択</button>
                <p id="selection-prompt" class="mb-4 text-gray-600">共に冒険する仲間を2～4人選んでください。</p>
                <div id="team-selection-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6 max-h-72 overflow-y-auto pr-2">
                    <!-- キャラクター選択肢がここに挿入されます -->
                </div>
                <div class="flex justify-between items-center">
                    <button id="select-team-back-button" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">戻る</button>
                    <div>
                        <span id="selection-counter" class="text-gray-600 mr-4">0 人選択中</span>
                        <button id="start-selection-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg opacity-50 cursor-not-allowed" disabled>冒険を始める</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="what-if-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-lg w-full">
                <h2 class="text-2xl font-bold mb-4">もしもの物語</h2>
                <p class="mb-2 text-gray-600">特別な設定で冒険を始めます。どの物語を体験しますか？</p>
                <div class="mb-2 p-2 bg-blue-50 border border-blue-200 rounded-lg flex items-center justify-between">
                    <label for="toggle-select-team" class="font-bold text-blue-700 cursor-pointer">好きな仲間で冒険する</label>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="toggle-select-team" id="toggle-select-team" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" />
                        <label for="toggle-select-team" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <!-- タブコンテナ -->
                <div id="what-if-tabs" class="flex border-b mb-4">
                    <button class="what-if-tab active-tab" data-tab="basic">基本</button>
                    <button class="what-if-tab" data-tab="challenge">挑戦</button>
                    <button class="what-if-tab" data-tab="story">物語</button>
                    <button class="what-if-tab" data-tab="endgame">終焉</button>
                </div>

                <!-- コンテンツコンテナ -->
                <div id="what-if-contents" class="max-h-60 overflow-y-auto pr-2">
                    <!-- 基本タブ -->
                    <div id="what-if-content-basic" class="what-if-content space-y-3">
                        <button data-mode="enjoy" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-sky-700">エンジョイ</strong><span class="block text-sm text-gray-600">味方が戦闘不能になっても、即座にHPが全回復する。ゲームオーバーにならずに最後まで遊べる。</span></button>
                        <button data-mode="trial" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-blue-700">腕試し</strong><span class="block text-sm text-gray-600">通常ルールで冒険を開始する。</span></button>
                        <button data-mode="random_party" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-teal-700">運命の出会い</strong><span class="block text-sm text-gray-600">共に冒険する仲間がランダムに4人選ばれる。誰と出会うかは運命次第。</span></button>
                    </div>
                    <!-- 挑戦タブ -->
                    <div id="what-if-content-challenge" class="what-if-content space-y-3 hidden">
                        <button data-mode="indecent" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-pink-700">痴態騒ぎ</strong><span class="block text-sm text-gray-600">全員が脱衣状態で開始。服は手に入らず、恥ずかしさに慣れることもない。ナイトとサムライは参加不可。</span></button>
                        <button data-mode="dwarves" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-green-700">小人族の戦い</strong><span class="block text-sm text-gray-600">全員の身長が10cmの状態で冒険を開始する。</span></button>
                        <button data-mode="unstable_bodies" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-cyan-700">流転の体躯</strong><span class="block text-sm text-gray-600">戦闘に勝利するたび、生存者全員の身長が-50cm～+50cmの範囲でランダムに変動する。</span></button>
                        <button data-mode="veterans" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-purple-700">歴戦の勇者たち</strong><span class="block text-sm text-gray-600">全員レベル4の状態で冒険を開始する。</span></button>
                        <button data-mode="solo" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-yellow-700">孤独な闘い</strong><span class="block text-sm text-gray-600">好きな仲間を一人選び、強化された状態で冒険に出る。</span></button>
                        <button data-mode="brawl" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-red-700">武闘の宴</strong><span class="block text-sm text-gray-600">2フロアごとに必ず戦闘が発生する。</span></button>
                        <button data-mode="monster_march" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-red-800">魔物の行軍</strong><span class="block text-sm text-gray-600">全てのフロアで戦闘が発生する。勝利する度にレベルアップし、アイテムを獲得する。50階踏破を目指せ。</span></button>
                        <button data-mode="endless" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-slate-700">無限への挑戦</strong><span class="block text-sm text-gray-600">全滅するまでダンジョンを進み続ける。30階ごとにボスが出現し、倒すと試練が訪れる。</span></button>
                        <button data-mode="uninhibited_souls" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-orange-700">奔放な魂</strong><span class="block text-sm text-gray-600">探索中、コマンドで味方を「脱衣」させたり、身長を自由に操作したりできる。</span></button>
                        <button data-mode="peaceful_dungeon" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-lime-700">平和？なダンジョン</strong><span class="block text-sm text-gray-600">全員の身長が初期身長で固定され、変動しない。</span></button>
                    </div>
                    <!-- 物語タブ -->
                    <div id="what-if-content-story" class="what-if-content space-y-3 hidden">
                        <button data-mode="saint_march" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-yellow-500">聖女の行進</strong><span class="block text-sm text-gray-600">特別なジョブ「聖女」ひとりで30階の踏破を目指す。彼女はターン開始時にHPとMPが回復し、脱衣を無効化する。</span></button>
                        <button data-mode="treasure_map" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-lime-700">秘宝の地図</strong><span class="block text-sm text-gray-600">特別なジョブ「トレジャーハンター」ひとりで30階の踏破を目指す。彼女は魔物に変身する能力を持つ。</span></button>
                        <button data-mode="little_panic" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-yellow-600">リトルパニック！</strong><span class="block text-sm text-gray-600">ソーサラー、アルケミスト、トラブルメーカーが幼い姿に！彼女たちを守るため、シスターが本気を出す。</span></button>
                        <button data-mode="brawling_belles" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-rose-500">闘争令嬢</strong><span class="block text-sm text-gray-600">特別なジョブ「アンドロイド」と「メイド」の2人で30階の踏破を目指す。クリアすると選抜チームに2人が追加される。</span></button>
                        <button data-mode="summer_live" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-sky-500">サマータイム・スペシャルライブ！</strong><span class="block text-sm text-gray-600">リリカ、ユイ、ミコ、リリィの4人で、ビーチと温泉を巡る特別な冒険に出る。60階踏破を目指せ。</span></button>
                        <button data-mode="secret_night" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-indigo-700">ヒミツの夜</strong><span class="block text-sm text-gray-600">リリカ、ユイ、ミコ、リリィ、フローラの誰かひとりで、静まったダンジョンを裸で歩く。物語重視のモード。</span></button>
                    </div>
                    <!-- 終焉タブ -->
                    <div id="what-if-content-endgame" class="what-if-content space-y-3 hidden">
                        <button id="endgame-plus-button" data-mode="endgame_plus" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition hidden"><strong class="text-red-900">終焉の呼び声</strong><span class="block text-sm text-gray-600">超高難易度モード。選ばれし者のみが挑戦できる。90階に潜む「終刻の魔王」を討伐せよ。</span></button>
                        <button data-mode="endgame" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-gray-700">おわりから</strong><span class="block text-sm text-gray-600">1フロア目に最終ボスが登場する。</span></button>
                    </div>
                </div>
                <div class="text-right mt-6">
                    <button id="what-if-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">戻る</button></div>
            </div>
        </div>

        <div id="challenge-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-sm w-full">
                <h2 class="text-3xl font-bold mb-4">怪しげな祭壇</h2>
                <p class="mb-6">祭壇に何かを捧げますか？<br>幸運が舞い込むか、災いが降りかかるかは分かりません…</p>
                <button id="challenge-accept-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg mr-4">捧げる</button>
                <button id="challenge-decline-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">立ち去る</button>
            </div>
        </div>

        <div id="event-choice-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 class="text-2xl font-bold mb-4">道が二手に分かれている…</h2>
                <p class="mb-6">どちらの道へ進みますか？</p>
                <div id="event-choice-buttons" class="flex flex-col gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <div id="scan-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 shadow-2xl max-w-3xl w-full flex gap-6">
                <div id="scan-modal-image-container" class="hidden w-1/2 relative rounded-lg overflow-hidden">
                    <!-- 立ち絵がここに挿入されます -->
                </div>
                <div id="scan-modal-text-content" class="w-full md:w-1/2">
                    <h2 id="scan-modal-title" class="text-2xl font-bold mb-4">調査結果</h2>
                    <div id="scan-modal-content" class="space-y-3 text-gray-700 max-h-96 overflow-y-auto pr-2">
                        <!-- 調査結果がここに挿入されます -->
                    </div>
                    <style>
                        /* スキャンモーダルの立ち絵表示用 */
                        
                        #scan-modal-image-container>div {
                            background-image: var(--char-bg-image);
                        }
                    </style>
                    <div class="text-right mt-4">
                        <button id="scan-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">閉じる</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 聖女イベントモーダル -->
        <div id="celestia-event-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 id="celestia-event-title" class="text-2xl font-bold mb-4"></h2>
                <p id="celestia-event-text" class="mb-6 whitespace-pre-wrap"></p>
                <div id="celestia-event-buttons" class="flex justify-center gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <!-- 無限モードボーナス選択モーダル -->
        <div id="endless-bonus-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-2xl w-full">
                <h2 class="text-2xl font-bold mb-2">勝利ボーナス！</h2>
                <p class="mb-6">生存者全員がレベルアップした！<br>さらに、以下のボーナスから一つを選択してください。</p>
                <div id="endless-bonus-buttons" class="grid grid-cols-2 gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <!-- 無限モード呪い選択モーダル -->
        <div id="endless-curse-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-2xl w-full">
                <h2 class="text-2xl font-bold mb-2 text-red-700">試練の刻</h2>
                <p class="mb-6">ボスを打ち破った代償として、避けられぬ呪いを一つ選ばなければならない。</p>
                <div id="endless-curse-buttons" class="grid grid-cols-2 gap-4">
                    <!-- 呪いボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <!-- 解放イベントモーダル -->
        <div id="liberation-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 class="text-3xl font-bold mb-4">解放の刻</h2>
                <p class="mb-6">聖結晶と邪結晶が共鳴し、強大な魔力の気配が空間を歪ませている。<br>結晶を捧げ、古の英雄の幻影に挑戦しますか？</p>
                <button id="liberation-accept-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg mr-4">挑戦する</button>
                <button id="liberation-decline-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">立ち去る</button>
            </div>
        </div>


        <!-- 怪しい装置イベントモーダル -->
        <div id="device-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 class="text-2xl font-bold mb-4">怪しい装置</h2>
                <p class="mb-6">研究室のような部屋で、人が二人入れる奇妙な装置を見つけた。<br>装置にはいくつかのボタンが付いている…。</p>
                <div id="device-buttons" class="grid grid-cols-1 gap-4">
                    <div class="p-3 border rounded-lg">
                        <button id="device-red-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg w-full">赤いボタン</button>
                        <p class="text-sm text-gray-600 mt-2">一人目が二人目の身長を吸収し、二人目を1cmにする。</p>
                    </div>
                    <div class="p-3 border rounded-lg">
                        <button id="device-blue-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg w-full">青いボタン</button>
                        <p class="text-sm text-gray-600 mt-2">二人の身長を平均化する。</p>
                    </div>
                    <div id="device-green-button-container" class="hidden p-3 border rounded-lg">
                        <button id="device-green-button" class="action-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg w-full">緑のボタン</button>
                        <p class="text-sm text-gray-600 mt-2">味方ひとりの身長を100cm伸ばす。</p>
                    </div>
                    <div id="device-white-button-container" class="hidden p-3 border rounded-lg">
                        <button id="device-white-button" class="action-button bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-6 rounded-lg shadow-lg w-full">白いボタン</button>
                        <p class="text-sm text-gray-600 mt-2">味方ひとりの能力を永続的に強化する。</p>
                    </div>
                    <button id="device-ignore-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg mt-2">無視する</button>
                </div>
            </div>
        </div>

        <!-- 2人選択モーダル -->
        <div id="two-member-select-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 id="two-member-select-title" class="text-2xl font-bold mb-4 text-center">対象を2人選んでください</h2>
                <div id="two-member-select-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6"></div>
                <div class="text-center"><button id="two-member-select-confirm" class="action-button bg-gray-400 text-white font-bold py-2 px-6 rounded-lg shadow-lg opacity-50 cursor-not-allowed" disabled>決定</button></div>
            </div>
        </div>

        <!-- 迷いの石像イベントモーダル -->
        <div id="statue-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 class="text-2xl font-bold mb-4">迷いの石像</h2>
                <p class="mb-6">怪しいオーラを放つ石像がある。<br>触れると何かが起こりそうだ…。</p>
                <div id="statue-buttons" class="flex justify-center gap-4">
                    <button id="statue-touch-button" class="action-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg">触れる</button>
                    <button id="statue-leave-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">立ち去る</button>
                </div>
            </div>
        </div>

        <!-- 1人選択モーダル -->
        <div id="one-member-select-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 id="one-member-select-title" class="text-2xl font-bold mb-4 text-center">対象を1人選んでください</h2>
                <div id="one-member-select-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4"></div>
            </div>
        </div>

        <!-- 数値選択モーダル -->
        <div id="amount-choice-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 id="amount-choice-title" class="text-2xl font-bold mb-4">量を選択</h2>
                <p id="amount-choice-text" class="mb-6">どのくらい変化させますか？</p>
                <div id="amount-choice-buttons" class="flex justify-center gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <!-- 神々の試練モーダル -->
        <div id="blessing-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 id="blessing-modal-title" class="text-3xl font-bold mb-2 text-center text-amber-600">神々の祝福</h2>
                <p id="blessing-modal-prompt" class="mb-6 text-center">祝福を授ける仲間を一人選んでください。</p>
                <div id="blessing-char-select-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4"></div>
                <div id="blessing-options-list" class="hidden grid grid-cols-1 md:grid-cols-3 gap-4"></div>
            </div>
        </div>
        <div id="menu-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-xs w-full">
                <h2 class="text-2xl font-bold mb-6">メニュー</h2>
                <div class="flex flex-col gap-4">
                    <button id="save-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">セーブ</button>
                    <button id="menu-return-title-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">タイトルに戻る</button>
                    <button id="menu-modal-close" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg mt-4">閉じる</button>
                </div>
            </div>
        </div>
    </div>
    <style>
        /* トグルスイッチのスタイル */
        
        .toggle-checkbox:checked {
            right: 0;
            border-color: #4f46e5;
            /* indigo-600 */
        }
        
        .toggle-checkbox:checked+.toggle-label {
            background-color: #4f46e5;
            /* indigo-600 */
        }
    </style>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
                    const gameContainer = document.getElementById('game-container');
                    const logMessage = document.getElementById('log-message');
                    const partyContainer = document.getElementById('party-container');
                    const enemyContainer = document.getElementById('enemy-container');
                    const logContainer = document.getElementById('log-container');
                    const dungeonCommands = document.getElementById('dungeon-commands');
                    const dungeonView = document.getElementById('dungeon-view');
                    const hud = document.getElementById('hud');
                    const commandContainer = document.getElementById('command-container');
                    const battleCommands = document.getElementById('battle-commands');
                    const commandMessage = document.getElementById('command-message');
                    const actionButtons = document.getElementById('action-buttons');
                    const nextFloorButton = document.getElementById('next-floor-button');
                    const talkButton = document.createElement('button'); // 会話ボタンを生成
                    const modal = document.getElementById('modal');
                    const modalTitle = document.getElementById('modal-title');
                    const modalText = document.getElementById('modal-text');
                    const modalButton = document.getElementById('modal-button');
                    const itemModal = document.getElementById('item-modal');
                    const itemList = document.getElementById('item-list');
                    const itemModalClose = document.getElementById('item-modal-close');
                    const levelUpModal = document.getElementById('level-up-modal');
                    const levelUpPartyList = document.getElementById('level-up-party-list');
                    const titleScreen = document.getElementById('title-screen');
                    const startButton = document.getElementById('start-button');
                    const loadButton = document.getElementById('load-button');
                    const ruleButton = document.getElementById('rule-button');
                    const ruleModal = document.getElementById('rule-modal');
                    const ruleModalClose = document.getElementById('rule-modal-close');
                    const whatIfButton = document.getElementById('what-if-button');
                    const whatIfModal = document.getElementById('what-if-modal');
                    const whatIfModalClose = document.getElementById('what-if-modal-close');
                    const selectTeamModal = document.getElementById('select-team-modal');
                    const endgamePlusButton = document.getElementById('endgame-plus-button');
                    const teamSelectionList = document.getElementById('team-selection-list');
                    const selectionCounter = document.getElementById('selection-counter');
                    const selectionPrompt = document.getElementById('selection-prompt');
                    const startSelectionButton = document.getElementById('start-selection-button');
                    const selectTeamBackButton = document.getElementById('select-team-back-button');
                    const randomSelectButton = document.getElementById('random-select-button');
                    const floorDisplay = document.getElementById('floor-display');
                    const scanModal = document.getElementById('scan-modal');
                    const scanModalClose = document.getElementById('scan-modal-close');
                    const menuButton = document.getElementById('menu-button');
                    const menuModal = document.getElementById('menu-modal');
                    const saveButton = document.getElementById('save-button');
                    const menuReturnTitleButton = document.getElementById('menu-return-title-button');
                    const menuModalClose = document.getElementById('menu-modal-close');

                    const emergencyButton = document.getElementById('emergency-button');
                    const challengeModal = document.getElementById('challenge-modal');
                    const challengeAcceptButton = document.getElementById('challenge-accept-button');
                    const challengeDeclineButton = document.getElementById('challenge-decline-button');

                    const eventChoiceModal = document.getElementById('event-choice-modal');
                    const eventChoiceButtons = document.getElementById('event-choice-buttons');

                    const celestiaEventModal = document.getElementById('celestia-event-modal');
                    const celestiaEventTitle = document.getElementById('celestia-event-title');
                    const celestiaEventText = document.getElementById('celestia-event-text');
                    const celestiaEventButtons = document.getElementById('celestia-event-buttons');

                    const endlessBonusModal = document.getElementById('endless-bonus-modal');
                    const endlessBonusButtons = document.getElementById('endless-bonus-buttons');

                    const endlessCurseModal = document.getElementById('endless-curse-modal');
                    const endlessCurseButtons = document.getElementById('endless-curse-buttons');

                    // 解放イベント用
                    const liberationModal = document.getElementById('liberation-modal');
                    const liberationAcceptButton = document.getElementById('liberation-accept-button');
                    const liberationDeclineButton = document.getElementById('liberation-decline-button');

                    // 怪しい装置イベント用
                    const deviceModal = document.getElementById('device-modal');
                    const deviceRedButton = document.getElementById('device-red-button');
                    const deviceBlueButton = document.getElementById('device-blue-button');
                    const deviceIgnoreButton = document.getElementById('device-ignore-button');
                    const deviceGreenButtonContainer = document.getElementById('device-green-button-container');
                    const deviceGreenButton = document.getElementById('device-green-button');
                    const deviceWhiteButtonContainer = document.getElementById('device-white-button-container');
                    const deviceWhiteButton = document.getElementById('device-white-button');
                    const twoMemberSelectModal = document.getElementById('two-member-select-modal');
                    const twoMemberSelectList = document.getElementById('two-member-select-list');
                    const twoMemberSelectConfirm = document.getElementById('two-member-select-confirm');

                    // 迷いの石像イベント用
                    const statueModal = document.getElementById('statue-modal');
                    const statueTouchButton = document.getElementById('statue-touch-button');
                    const statueLeaveButton = document.getElementById('statue-leave-button');
                    const oneMemberSelectModal = document.getElementById('one-member-select-modal');
                    const oneMemberSelectList = document.getElementById('one-member-select-list');

                    // 奔放な魂モード用
                    const amountChoiceModal = document.getElementById('amount-choice-modal');
                    const amountChoiceTitle = document.getElementById('amount-choice-title');
                    const amountChoiceText = document.getElementById('amount-choice-text');
                    const amountChoiceButtons = document.getElementById('amount-choice-buttons');

                    // 神々の試練モーダル
                    const blessingModal = document.getElementById('blessing-modal');
                    const blessingModalTitle = document.getElementById('blessing-modal-title');
                    const blessingModalPrompt = document.getElementById('blessing-modal-prompt');
                    const blessingCharSelectList = document.getElementById('blessing-char-select-list');
                    const blessingOptionsList = document.getElementById('blessing-options-list');

                    // 願い星イベントモーダル
                    const wishingStarModal = document.getElementById('wishing-star-modal');
                    const wishingStarModalPrompt = document.getElementById('wishing-star-modal-prompt');
                    const wishingStarCharSelect = document.getElementById('wishing-star-char-select');
                    const wishingStarOptions = document.getElementById('wishing-star-options');

                    // 調合イベントモーダル
                    const alchemyModal = document.getElementById('alchemy-modal');
                    const alchemyOptions = document.getElementById('alchemy-options');
                    const alchemyCancelButton = document.getElementById('alchemy-cancel-button');
                    const heightLockConfirmModal = document.getElementById('height-lock-confirm-modal');


                    // ログ履歴ツールチップ
                    const logTooltip = document.getElementById('log-tooltip');

                    // 背景画像のURLを定数化
                    const DEFAULT_DUNGEON_BG = "url('https://image.pollinations.ai/prompt/fantasy%20rpg%20dungeon,%20dark,%20mysterious,%20glowing%20runes,%20stone%20columns,%20roots,%20moss,%20pathway,%20digital%20painting')";
                    const SUMMER_BEACH_BG = "url('https://image.pollinations.ai/prompt/beautiful%20anime%20style%20beach,%20sparkling%20ocean,%20white%20sand,%20blue%20sky,%20summer,%20palm%20trees,%20digital%20painting')";
                    const SUMMER_ONSEN_BG = "url('https://image.pollinations.ai/prompt/Japanese%20open-air%20onsen,%20steam%20rising%20from%20the%20water,%20bamboo%20fences,%20stone%20lanterns,%20night,%20starry%20sky,%20anime%20style,%20digital%20painting')";

                    let gameState = {
                        floor: 0,
                        party: [],
                        enemies: [],
                        turnOrder: [],
                        currentTurnIndex: 0,
                        inBattle: false,
                        gameOver: false,
                        inventory: [],
                        golem: null, // ファイター, ソーサラー, ナイト, メディック
                        foundEquipment: [],
                        killCount: 0, // ネクロマンサー用
                        walls: [], // ガーディアン用 
                        gameMode: 'normal', // normal, veterans, dwarves, brawl, solo, endgame, endless, indecent, enjoy, saint_march, fixed_path, uninhibited_souls, random_party, divine_trial, treasure_map, secret_night
                        triggeredSpecialConvos: [],
                        dungeonBackground: DEFAULT_DUNGEON_BG, // 背景画像をgameStateで管理
                        bellesPrivateCostumeEventTriggered: false, // 闘争令嬢プライベート衣装イベント用フラグ
                        summerBeachAllLiberatedTriggered: false, // サマーライブビーチ全員解放イベント用フラグ
                        summerOnsenAllLiberatedTriggered: false, // サマーライブ温泉全員解放イベント用フラグ
                        bellesReviveEventTriggered: false, // 闘争令嬢復活イベント用フラグ
                        wishingStarNoClothes: false, // 願い星イベントで服発見を無効化するフラグ
                        greatHoleEventTriggered: false, // 「大穴になあれ」イベント発生フラグ
                        greatHoleEventFloor: 0, // 「大穴になあれ」発生階層
                        wishPrayEventTriggered: false, // 「願い/祈りの少女」イベント発生フラグ
                        nextBattleIsImitation: false, // 模倣の呪いフラグ
                        drunkenMonsterEventTriggered: false, // 「酒豪の怪物」イベント発生フラグ
                        mazeOfShadeEventTriggered: false, // 「木陰の迷宮」イベント発生フラグ
                    };

                    const allCharacterBlueprints = [{
                            name: 'アカリ',
                            role: 'ファイター',
                            hp: 100,
                            mp: 20,
                            atk: 44,
                            def: 10,
                            agi: 12,
                            height: 165,
                            description: '元気で前向きなパーティのムードメーカー。考えるより先に体が動くタイプで、巨大な剣を軽々と振り回す。',
                            skills: [{ // グロウスラッシュ
                                name: 'グロウスラッシュ',
                                cost: 8,
                                power: 1.2,
                                type: 'growth_physical',
                                targetType: 'enemy',
                                description: '敵一体に物理ダメージを与える。使うたびに威力が永続的に上昇する。'
                            }, {
                                name: 'なぎ払い',
                                cost: 12,
                                power: 1.0,
                                type: 'physical',
                                targetType: 'enemies',
                                description: '敵全体に物理ダメージを与える。'
                            }],
                            unlockableSkill: {
                                name: '渾身斬り',
                                cost: 6,
                                power: 1.5,
                                type: 'physical',
                                targetType: 'enemy',
                                description: '敵一体に物理ダメージを与える。30%の確率で会心の一撃になる。'
                            },
                            unlockableSkillLv4: {
                                name: '乱舞',
                                cost: 20,
                                type: 'multi_hit_physical',
                                targetType: 'random_enemies',
                                description: '敵にランダムで4～6回の物理ダメージを与える。'
                            },
                            bgClass: 'bg-char-akari',
                            themeColor: 'red',
                        }, {
                            name: 'ヒカリ',
                            role: 'ソーサラー',
                            hp: 80,
                            mp: 50,
                            atk: 16,
                            def: 8,
                            agi: 15,
                            height: 145,
                            description: '無口で冷静な魔術の探求者。古代の知識に精通しており、強力な攻撃魔法を操る。アカリの突進を諌めることもしばしば。',
                            skills: [{
                                name: 'ファイア',
                                cost: 8,
                                power: 3.5,
                                type: 'magic',
                                targetType: 'enemy',
                                description: '敵一体に炎の魔法ダメージを与える。'
                            }, {
                                name: 'エンチャント',
                                cost: 8,
                                type: 'buff',
                                targetType: 'ally',
                                effect: 'atk_up',
                                description: '味方一体の攻撃力を一時的に上昇させる。'
                            }],
                            unlockableSkill: {
                                name: 'ストーム',
                                cost: 16,
                                power: 1.8,
                                type: 'magic',
                                targetType: 'enemies',
                                description: '敵全体に嵐の魔法ダメージを与える。'
                            },
                            unlockableSkillLv4: {
                                name: 'マジックバースト',
                                cost: 0, // MPを全て消費
                                type: 'mp_burst_magic',
                                targetType: 'enemy',
                                description: '残りMPを全て消費し、敵一体に超特大の魔法ダメージを与える。'
                            },
                            bgClass: 'bg-char-hikari',
                            themeColor: 'purple',
                        }, {
                            name: 'シズカ',
                            role: 'ナイト',
                            hp: 120,
                            mp: 10,
                            atk: 30,
                            def: 20,
                            agi: 8,
                            height: 175,
                            description: 'パーティの頼れる姉御役。巨大な盾であらゆる攻撃から仲間を守る。その守りは鉄壁と名高い。',
                            skills: [{
                                name: '挑発',
                                cost: 3,
                                type: 'utility',
                                targetType: 'self',
                                description: '敵の注意を自分に引きつけ、狙われやすくなる。'
                            }, { // チャージ
                                name: 'チャージ',
                                cost: 0,
                                type: 'charge',
                                targetType: 'self',
                                description: '次の物理攻撃の威力を溜める。重ねがけで効果が上昇する。'
                            }],
                            unlockableSkill: {
                                name: 'かばう',
                                cost: 8,
                                type: 'buff',
                                targetType: 'self',
                                description: '次のターンまで、味方への単体攻撃を代わりに受ける。'
                            },
                            unlockableSkillLv4: {
                                name: '堅守の構え',
                                cost: 5,
                                type: 'self_buff_special',
                                targetType: 'self',
                                effects: ['provoke', 'regeneration'],
                                description: '敵の注意を引きつけつつ、3ターンの間HPが自動回復する。'
                            },
                            bgClass: 'bg-char-shizuka',
                            themeColor: 'amber',
                        }, {
                            name: 'ユイ',
                            role: 'メディック',
                            hp: 90,
                            mp: 40,
                            atk: 20,
                            def: 9,
                            agi: 10,
                            height: 120,
                            description: '心優しく、誰かのために尽くすことを厭わない少女。パーティの回復役として、その身を挺して仲間を癒す。',
                            skills: [{
                                name: 'ヒール',
                                cost: 10,
                                power: 50,
                                type: 'heal',
                                targetType: 'ally',
                                description: '味方一体のHPを回復する。'
                            }, {
                                name: 'プロテクト',
                                cost: 8,
                                type: 'buff',
                                targetType: 'ally',
                                effect: 'protect',
                                description: '味方一体の防御力を一時的に上昇させる。'
                            }],
                            unlockableSkill: {
                                name: '献身',
                                cost: 0, // MPコストなし
                                type: 'special_heal',
                                targetType: 'party',
                                description: '自身の身長を20cm消費して、味方全体のHPを30%回復する。'
                            },
                            unlockableSkillLv4: {
                                name: 'サンクチュアリ',
                                cost: 40,
                                type: 'party_restore_growth',
                                targetType: 'party',
                                growth: 5,
                                description: '味方全体のHPを全回復し、状態異常を治し、身長を5cm伸ばす聖域を作り出す。'
                            },
                            bgClass: 'bg-char-yui',
                            themeColor: 'green',
                        }, {
                            name: 'ベアトリス',
                            role: 'アルケミスト',
                            hp: 85,
                            mp: 60,
                            atk: 18,
                            def: 9,
                            agi: 13,
                            height: 170,
                            description: '知的好奇心が旺盛な錬金術師。ダンジョンの謎や敵の生態に強い興味を示す。様々な薬品を合成して戦う。',
                            skills: [{
                                name: 'アシッドボルト',
                                cost: 4,
                                power: 2.8,
                                type: 'magic',
                                targetType: 'enemy',
                                description: '敵一体に酸の魔法ダメージを与える。'
                            }, {
                                name: 'マジッククラフト',
                                cost: 10,
                                type: 'alchemist_craft',
                                targetType: 'self',
                                description: '戦闘中にダメージアイテムを作成する。ガラスブレードかクレイジーボムを1～2個獲得する。'
                            }],
                            unlockableSkill: {
                                name: 'ポイズンミスト',
                                cost: 15,
                                type: 'status_magic',
                                targetType: 'enemies',
                                effect: 'poison',
                                description: '敵全体を毒状態にする。'
                            },
                            unlockableSkillLv4: {
                                name: 'アルケミックフレア',
                                cost: 18,
                                power: 6.0,
                                type: 'magic',
                                targetType: 'enemy',
                                description: '敵一体に錬金術の爆発で大ダメージを与える。'
                            },
                            bgClass: 'bg-char-beatrice',
                            themeColor: 'indigo',
                        }, {
                            name: 'リリカ',
                            role: 'ダンサー',
                            hp: 95,
                            mp: 35,
                            atk: 25,
                            def: 8,
                            agi: 18,
                            height: 131,
                            description: '歌と踊りで仲間を鼓舞するアイドル。どんな状況でもステージに変え、ファンサービスを忘れない。素早い動きで敵を翻弄する。',
                            skills: [{
                                name: 'スポットライト',
                                cost: 10,
                                type: 'evade_provoke',
                                targetType: 'self',
                                description: '敵の注目を集めつつ、自身の回避率を大幅に上げる。'
                            }, {
                                name: 'ラブステップ',
                                cost: 12,
                                type: 'dancer_buff_pair',
                                targetType: 'ally',
                                effects: ['agi_up', 'evade_up'],
                                description: '味方一人と自分の素早さと回避率を上げる。このスキルによる回避アップ中は、挑発時の回避率にボーナスが付く。'
                            }],
                            unlockableSkill: {
                                name: 'キューティチアー',
                                cost: 20,
                                type: 'dancer_party_buff_height',
                                targetType: 'party',
                                effect: 'atk_up',
                                description: '味方全体の攻撃力を一時的に上昇させる。自身の身長が低いほど効果が上がり、10cm以下で最大3倍になる。'
                            },
                            unlockableSkillLv4: {
                                name: 'センターオブステージ',
                                cost: 30,
                                type: 'dancer_tension_up',
                                targetType: 'party',
                                description: '味方全体をテンションアップ状態にする。戦闘終了まで基本攻撃力が+10されるが、ターン開始時にHPが少し減少する。'
                            },
                            bgClass: 'bg-char-ririka',
                            themeColor: 'pink',
                        }, {
                            name: 'サクヤ',
                            role: 'サムライ',
                            hp: 110,
                            mp: 0,
                            atk: 50,
                            def: 12,
                            agi: 14,
                            height: 168,
                            description: '己の剣の道を極めんとする求道者。口数は少ないが、その一太刀は岩をも断つ。HPを代償に強力な技を放つ。',
                            skills: [{
                                name: '居合',
                                cost: 15, // HP cost
                                power: 2.5,
                                type: 'hp_cost_physical',
                                targetType: 'enemy',
                                description: '自身のHPを15消費し、敵一体に強力な物理ダメージを与える。'
                            }, {
                                name: '後の先',
                                cost: 5, // HP cost
                                type: 'samurai_counter_stance',
                                targetType: 'self',
                                description: '1ターン挑発状態になる。攻撃を受けた際、自身の攻撃力を倍にして反撃する。'
                            }],
                            unlockableSkill: {
                                name: '明鏡止水',
                                cost: 0,
                                type: 'self_buff_samurai',
                                targetType: 'self',
                                description: '精神を集中させ、自身の攻撃力を一時的に上昇させる。'
                            },
                            unlockableSkillLv4: {
                                name: '無明の一閃',
                                cost: 40, // HP cost
                                power: 5.0,
                                type: 'hp_cost_physical',
                                targetType: 'enemy',
                                description: '自身のHPを大きく消費し、敵一体に絶大な物理ダメージを与える。'
                            },
                            bgClass: 'bg-char-sakuya',
                            themeColor: 'cyan',
                        }, {
                            name: 'シャオメイ',
                            role: 'モンク',
                            hp: 105,
                            mp: 25,
                            atk: 48,
                            def: 14,
                            agi: 11,
                            height: 152,
                            description: '明朗快活な拳法家。強敵と戦うことと食べることが大好き。その小さな体からは想像もつかないほどのパワーを秘めている。',
                            skills: [{
                                name: '正拳突き',
                                cost: 8,
                                power: 1.6,
                                type: 'physical',
                                targetType: 'enemy',
                                description: '敵一体に物理ダメージを与える。'
                            }, {
                                name: '癒しの掌',
                                cost: 15,
                                power: 40,
                                type: 'heal',
                                targetType: 'ally',
                                description: '気功で味方一体のHPを回復する。'
                            }],
                            unlockableSkill: {
                                name: '気功波',
                                cost: 18,
                                power: 1.2,
                                type: 'physical',
                                targetType: 'enemies',
                                description: '敵全体に気の力で物理ダメージを与える。'
                            },
                            unlockableSkillLv4: {
                                name: '破砕拳',
                                cost: 22,
                                power: 2.0,
                                type: 'def_ignore_physical',
                                targetType: 'enemy',
                                description: '敵の防御力を無視して物理ダメージを与える。'
                            },
                            bgClass: 'bg-char-shaomei',
                            themeColor: 'orange',
                        }, {
                            name: 'エリザ',
                            role: 'ドクター',
                            hp: 95,
                            mp: 55,
                            atk: 22,
                            def: 12,
                            agi: 16,
                            height: 128,
                            description: '自信家で研究熱心な女医。あらゆるものを研究対象と見なし、自作の薬品で戦況をコントロールする。豊満な体格を誇りに思っている。',
                            skills: [{
                                name: '成長促進剤',
                                cost: 15,
                                power: 30, // 30cm
                                type: 'growth_ally',
                                targetType: 'ally',
                                description: '味方一体の身長を30cm伸ばす薬を投与する。'
                            }, {
                                name: '衰弱ガス',
                                cost: 18,
                                type: 'doctor_debuff',
                                targetType: 'enemy',
                                description: '敵一体を毒にし、攻撃力と防御力を低下させる。'
                            }],
                            unlockableSkill: {
                                name: '縮小薬',
                                cost: 15,
                                power: 30, // 30cm
                                type: 'shrink_ally',
                                targetType: 'ally',
                                description: '味方一体の身長を30cm縮める薬を投与する。'
                            },
                            unlockableSkillLv4: {
                                name: 'パンデミック',
                                cost: 35,
                                type: 'status_ailment_multi',
                                effects: ['poison', 'paralysis', 'slow'],
                                targetType: 'enemies',
                                description: '敵全体に毒、麻痺、鈍化のいずれかの状態異常を引き起こすウイルスを散布する。'
                            },
                            bgClass: 'bg-char-eriza',
                            themeColor: 'teal',
                        }, {
                            name: 'ルナ',
                            role: 'ギャンブラー',
                            hp: 85,
                            mp: 45,
                            atk: 25,
                            def: 8,
                            agi: 17,
                            height: 145,
                            description: 'スリルと勝負をこよなく愛する生粋のギャンブラー。戦いすらも賭けの対象と捉え、運に身を任せたトリッキーなスキルで戦う。',
                            skills: [{
                                name: 'ダーツショット',
                                cost: 10,
                                type: 'gambling_damage',
                                targetType: 'enemy',
                                description: '敵一体にダーツを投げる。命中率やダメージは運次第で大きく変動する。'
                            }, {
                                name: 'ラッキースター',
                                cost: 15,
                                type: 'gambling_support',
                                targetType: 'ally',
                                description: '味方一体に幸運の星を祈る。HP回復、MP回復、攻撃力UP、防御力UP、状態異常回復の中からランダムで3つの良い効果が発生する。'

                            }],
                            unlockableSkill: {
                                name: 'オールイン',
                                cost: 20,
                                type: 'gambling_all_in',
                                targetType: 'enemies',
                                description: '全てを賭ける大勝負。敵全体に大ダメージを与えるか、味方全体を回復するか、何も起こらないか、あるいは自分がダメージを受けるか。'
                            },
                            unlockableSkillLv4: {
                                name: 'ジャックポット',
                                cost: 40,
                                type: 'gambling_jackpot',
                                targetType: 'party',
                                description: '奇跡を信じて全てを賭ける。低確率で味方全体が全回復＆強化されるが、ほとんどの場合は何も起こらない。'
                            },
                            bgClass: 'bg-char-runa',
                            themeColor: 'fuchsia',
                        }, {
                            name: 'クロエ',
                            role: 'リーパー',
                            hp: 80,
                            mp: 60,
                            atk: 15,
                            def: 7,
                            agi: 16,
                            height: 110,
                            description: 'ぶかぶかのローブで顔を隠した寡黙な少女。魂を狩る大鎌を携え、敵の命を摘み取る。自身の身長が低いほど力を発揮する。',
                            skills: [{
                                name: '魂狩り',
                                cost: 25,
                                power: 0.5, // 失敗時のダメージ倍率
                                type: 'reaper_instant_death',
                                targetType: 'enemy',
                                description: '敵一体の魂を狩る。低確率で即死させる。ボスには大ダメージを与える。失敗しても少しダメージを与える。'
                            }, {
                                name: '影の一撃',
                                cost: 12,
                                power: 1.5,
                                type: 'reaper_height_scaling',
                                targetType: 'enemy',
                                description: '影に潜んで敵一体を攻撃する。自身の身長が初期値より低いほど威力が増す。'
                            }],
                            unlockableSkill: {
                                name: '魂の交換',
                                cost: 20,
                                type: 'reaper_soul_exchange',
                                targetType: 'ally',
                                description: '自身の現在HPの半分を捧げ、味方一体のHPとMPを大きく回復する。'
                            },
                            unlockableSkillLv4: {
                                name: '冥府の鎌',
                                cost: 40,
                                power: 1.2,
                                type: 'reaper_height_scaling_multi',
                                targetType: 'enemies',
                                description: '敵全体に冥府の鎌を振るう。自身の身長が初期値より低いほど威力が増す。'
                            },
                            bgClass: 'bg-char-chloe',
                            themeColor: 'slate',
                        }, {
                            name: 'ミコ',
                            role: 'サモナー',
                            hp: 85,
                            mp: 65,
                            atk: 15,
                            def: 9,
                            agi: 14,
                            height: 121,
                            description: 'モンスターと心を通わせる人懐っこい少女。いつも一緒の相棒「モコ」と共に、様々な精霊やゴーレムを召喚して戦う。',
                            skills: [{
                                name: 'プチサラマンダー',
                                cost: 12,
                                power: 3.8,
                                type: 'magic',
                                targetType: 'enemy',
                                description: '炎の精霊を召喚し、敵一体に魔法ダメージを与える。'
                            }, {
                                name: 'ゴーレム召喚',
                                cost: 20,
                                power: 0.7, // 自身の最大HPに対するゴーレムのHP割合
                                type: 'summon_golem',
                                targetType: 'self',
                                description: '自身の最大HPの50%のHPを持つゴーレムを召喚し、パーティの盾とする。'
                            }],
                            unlockableSkill: {
                                name: 'プチウンディーネ',
                                cost: 22,
                                power: 2.0,
                                type: 'magic',
                                targetType: 'enemies',
                                description: '水の精霊を召喚し、敵全体に魔法ダメージを与える。'
                            },
                            unlockableSkillLv4: {
                                name: 'ガーディアンゴーレム',
                                cost: 40,
                                power: 1.2, // 自身の最大HPに対するゴーレムのHP割合
                                type: 'summon_golem',
                                targetType: 'self',
                                description: '自身の最大HPと同じHPを持つ、より強力なゴーレムを召喚する。'
                            },
                            bgClass: 'bg-char-miko',
                            themeColor: 'lime',
                        }, {
                            name: 'レンカ',
                            role: 'ネクロマンサー',
                            hp: 90,
                            mp: 70,
                            atk: 18,
                            def: 8,
                            agi: 15,
                            height: 157,
                            description: '死者の魂と対話する、ちょっと怪しい雰囲気のお姉さん。冒険で倒した魂を力に変える。通常攻撃でMPが回復する。',
                            skills: [{
                                name: 'ソウルアブソーブ',
                                cost: 15,
                                power: 3.0,
                                type: 'necro_magic',
                                targetType: 'enemy',
                                description: '敵一体に魂を吸収する魔法ダメージを与える。倒したモンスター数で威力が上がる。'
                            }, {
                                name: 'ドレインソウル',
                                cost: 3,
                                power: 1.5,
                                type: 'mp_drain',
                                targetType: 'enemy',
                                description: '敵一体に魔法ダメージを与え、与えたダメージに応じてMPを吸収する。'
                            }],
                            unlockableSkill: {
                                name: 'コープスエクスプロージョン',
                                cost: 25,
                                power: 1.5,
                                type: 'necro_magic',
                                targetType: 'enemies',
                                description: '敵全体に魂を爆発させる魔法ダメージを与える。これまでに倒したモンスターの数に応じて威力が上がる。'
                            },
                            unlockableSkillLv4: {
                                name: 'リザレクション',
                                cost: 60,
                                type: 'revive_full',
                                targetType: 'ally',
                                description: '戦闘不能の味方一人をHP100%の状態で復活させる禁断の蘇生術。'
                            },
                            bgClass: 'bg-char-renka',
                            themeColor: 'gray',
                        }, {
                            name: 'イオリ',
                            role: 'ガーディアン',
                            hp: 125,
                            mp: 20,
                            atk: 35,
                            def: 18,
                            agi: 9,
                            height: 118,
                            description: '小柄で可憐な見た目だが、実はパーティの先輩。縮小病で成長が止まっている。仲間を護ることに全てを懸ける。通常攻撃は確率でクリティカルになる。',
                            skills: [{
                                name: 'ウォール',
                                cost: 10,
                                power: 0.6, // 自身の最大HPに対する耐久値の割合
                                type: 'guardian_wall',
                                targetType: 'ally',
                                description: '味方一人に、自身の最大HPの60%の耐久値を持つ防壁を生成する。'
                            }, {
                                name: 'タイタンスタンプ',
                                cost: 12,
                                type: 'guardian_stomp',
                                targetType: 'enemy',
                                description: '防壁がある場合はそれを消費して大ダメージ、ない場合は自身の身長に応じたダメージを与える。'
                            }],
                            unlockableSkill: {
                                name: 'ガーディアンズハイ',
                                cost: 15,
                                type: 'self_buff_guardian',
                                targetType: 'self',
                                description: '3ターンの間、自身の防御力を上げ、次に使用する「ウォール」の耐久値を1.5倍にする。'
                            },
                            unlockableSkillLv4: {
                                name: 'キャッスルウォール',
                                cost: 25,
                                power: 0.4, // 自身の最大HPに対する耐久値の割合
                                type: 'guardian_wall_party',
                                targetType: 'party',
                                description: '味方全体に、自身の最大HPの40%の耐久値を持つ防壁を生成する。'
                            },
                            bgClass: 'bg-char-iori',
                            themeColor: 'stone',
                        }, {
                            name: 'コハル',
                            role: 'トラブルメーカー',
                            hp: 95,
                            mp: 40,
                            atk: 28,
                            def: 10,
                            agi: 14,
                            height: 128,
                            description: 'いつも元気で、ちょっとおっちょこちょいな少女。彼女の行動は、時に奇跡を、時に大惨事を引き起こす。通常攻撃は確率でクリティカルになる。',
                            skills: [{
                                name: 'ハプニングボックス',
                                cost: 20,
                                type: 'trouble_maker_box',
                                targetType: 'all', // 敵味方全体
                                description: '何が起こるかわからない箱を開ける。敵全体に大ダメージか、味方全体が強化されるか、あるいは味方全体が縮んでしまうか…。'
                            }, {
                                name: 'びっくりクラッカー',
                                cost: 5,
                                power: 1.5,
                                type: 'trouble_maker_debuff',
                                targetType: 'enemy',
                                description: '敵一体に物理ダメージを与え、たまに攻撃力か防御力を下げる。'
                            }],
                            unlockableSkill: {
                                name: 'ばっちりチェック',
                                cost: 4,
                                type: 'self_buff_trouble',
                                targetType: 'self',
                                description: '次の「ハプニングボックス」か「ミラクルギフト」の成功率を大幅に上げる。'
                            },
                            unlockableSkillLv4: {
                                name: 'ミラクルギフト',
                                cost: 40,
                                type: 'trouble_maker_miracle',
                                targetType: 'party',
                                description: '味方全体に奇跡の贈り物を届ける。HPとMPが全回復し、3ターン攻撃力と防御力が上昇する。ごく稀に失敗する。'
                            },
                            bgClass: 'bg-char-koharu',
                            themeColor: 'rose',
                        }, {
                            name: 'オリビア',
                            role: 'シスター',
                            hp: 100,
                            mp: 50,
                            atk: 20,
                            def: 13,
                            agi: 12,
                            height: 149,
                            description: '聖堂に仕える、篤い信仰心を持つ女性。慈愛に満ちた祈りで、仲間の傷を癒し続ける。',
                            skills: [{
                                name: 'リジェネ',
                                cost: 12,
                                type: 'regeneration_ally',
                                targetType: 'ally',
                                description: '味方一人に、3ターンの間HPが自動で回復する祝福を与える。'
                            }, { // ファイター, ソーサラー, ナイト, メディック
                                name: 'ファーストエイド',
                                cost: 8,
                                power: 60,
                                type: 'heal',
                                targetType: 'ally',
                                description: '味方一人のHPを少し回復する。' // ファイター, ソーサラー, ナイト, メディック
                            }],
                            unlockableSkill: {
                                name: 'ホーリーライト',
                                cost: 20,
                                power: 120,
                                type: 'heal',
                                targetType: 'ally',
                                description: '味方一人のHPを大きく回復する。' // ファイター, ソーサラー, ナイト, メディック
                            },
                            unlockableSkillLv4: {
                                name: '祈りの円環',
                                cost: 30,
                                type: 'regeneration_party',
                                targetType: 'party',
                                description: '味方全体にHP継続回復と、1ターン後にMPが大きく回復する祝福を与える。'
                            },
                            bgClass: 'bg-char-olivia',
                            themeColor: 'sky',
                        }, {
                            name: 'セレスティア',
                            role: '聖女',
                            hp: 110,
                            mp: 60,
                            atk: 45,
                            def: 15,
                            agi: 16,
                            height: 140,
                            description: '神の祝福を受けし聖なる乙女。その身に宿す聖なる力で、たった一人で穢れたダンジョンを浄化する使命を帯びている。',
                            skills: [{
                                name: 'ホーリーエッジ',
                                cost: 10,
                                power: 1.9,
                                type: 'physical',
                                targetType: 'enemy',
                                description: '聖なる力を刃に乗せ、敵一体に物理ダメージを与える。'
                            }, {
                                name: 'セイクリッドウォール',
                                cost: 10,
                                type: 'saint_wall',
                                targetType: 'self',
                                effect: 'protect',
                                description: '聖なる障壁で身を守り、自身の防御力を一時的に上昇させる。'
                            }],
                            unlockableSkill: {
                                name: 'ジャッジメント',
                                cost: 25,
                                power: 1.5,
                                type: 'magic',
                                targetType: 'enemies',
                                description: '天からの光で、敵全体に聖なる魔法ダメージを与える。'
                            },
                            unlockableSkillLv4: {
                                name: 'ディバインライト',
                                cost: 30,
                                power: 0.3, // 30%
                                type: 'divine_light',
                                targetType: 'enemy',
                                description: '敵ひとりに、その敵の最大HPの30%にあたる固定ダメージを与える。'
                            },
                            bgClass: 'bg-char-celestia',
                            themeColor: 'yellow',
                        }, {
                            name: 'リリィ',
                            role: 'トレジャーハンター',
                            hp: 100,
                            mp: 80,
                            atk: 25,
                            def: 12,
                            agi: 18,
                            height: 120,
                            description: '様々なダンジョンの宝物を漁ってきた、小柄で可愛らしい見た目とは裏腹に経験が豊富。周囲への気配りができて、優しく元気な少女。過去にダンジョンで魔力を取り込み、一時的に魔物の姿に変身できる能力を持つ。',
                            skills: [{
                                name: 'ジュエルショット',
                                cost: 10,
                                type: 'treasure_hunter_attack',
                                targetType: 'enemy',
                                description: '敵単体にダメージを与え、自身の攻撃力が上がるかMPが大きく回復する。'
                            }, {
                                name: 'サキュバスモード',
                                cost: 0,
                                type: 'transform_succubus',
                                targetType: 'self',
                                description: 'MPが尽きるまでサキュバスに変身する。変身時、身長が30cm伸びる。'
                            }, {
                                name: 'フェアリーモード',
                                cost: 0,
                                type: 'transform_fairy',
                                targetType: 'self',
                                description: 'MPが尽きるまでフェアリーに変身する。変身時、身長が30cm縮む。'
                            }, {
                                name: 'アルラウネモード',
                                cost: 0,
                                type: 'transform_alraune',
                                targetType: 'self',
                                description: 'MPが尽きるまでアルラウネに変身する。変身時、HPが全回復する。'
                            }],
                            bgClass: 'bg-char-lily',
                            themeColor: 'lime',
                            // 変身後の情報
                            transforms: {
                                succubus: {
                                    role: 'サキュバス',
                                    bgClass: 'bg-char-lily-succubus',
                                    skills: [{
                                        name: '変身解除',
                                        cost: 0,
                                        type: 'transform_revert',
                                        targetType: 'self',
                                        description: 'トレジャーハンターの姿に戻る。'
                                    }, {
                                        name: 'チャーム',
                                        cost: 0,
                                        type: 'status_ailment_multi',
                                        effects: ['paralysis'],
                                        targetType: 'enemies',
                                        description: '敵全体を高確率で麻痺させる。'
                                    }, {
                                        name: 'ハートドレイン',
                                        cost: 0,
                                        power: 2.5,
                                        type: 'drain_physical',
                                        targetType: 'enemy',
                                        description: '敵単体に大ダメージを与え、HPを吸収する。'
                                    }, {
                                        name: 'ボディドロップ',
                                        cost: 0,
                                        power: 4.0,
                                        type: 'height_power_physical',
                                        targetType: 'enemy',
                                        description: '敵単体に超特大ダメージ。身長が高いほど威力が上がる。'
                                    }, ]
                                },
                                fairy: {
                                    role: 'フェアリー',
                                    bgClass: 'bg-char-lily-fairy',
                                    skills: [{
                                        name: '変身解除',
                                        cost: 0,
                                        type: 'transform_revert',
                                        targetType: 'self',
                                        description: 'トレジャーハンターの姿に戻る。'
                                    }, {
                                        name: 'クイックブロー',
                                        cost: 0,
                                        power: 1.8,
                                        type: 'physical',
                                        targetType: 'enemy',
                                        description: '敵単体に物理攻撃し、防御力を低下させる。身長が低いほど威力ボーナス。'
                                    }, {
                                        name: 'マジックアロー',
                                        cost: 0,
                                        power: 3.0,
                                        type: 'magic',
                                        targetType: 'enemy',
                                        description: '敵単体に魔法攻撃し、攻撃力を低下させる。身長が低いほど威力ボーナス。'
                                    }, {
                                        name: 'ワンダーカーニバル',
                                        cost: 0,
                                        power: 2.0,
                                        type: 'special_magic',
                                        targetType: 'enemies',
                                        description: '敵全体に高威力攻撃。身長が低いほど威力ボーナス。敵の低い方の防御でダメージ計算。'
                                    }, ]
                                },
                                alraune: {
                                    role: 'アルラウネ',
                                    bgClass: 'bg-char-lily-alraune',
                                    skills: [{
                                        name: '変身解除',
                                        cost: 0,
                                        type: 'transform_revert',
                                        targetType: 'self',
                                        description: 'トレジャーハンターの姿に戻る。'
                                    }, {
                                        name: 'シードショット',
                                        cost: 0,
                                        power: 3.5,
                                        type: 'magic',
                                        targetType: 'enemy',
                                        description: '敵単体に高威力魔法攻撃し、自身の攻撃力を上げる。'
                                    }, {
                                        name: 'グロウヒール',
                                        cost: 0,
                                        type: 'special_heal_alraune',
                                        targetType: 'ally',
                                        description: '味方単体のHPを全回復し、防御力を上げる。自身に使うとポーションも獲得。'
                                    }, {
                                        name: 'ソーンウィップ',
                                        cost: 0,
                                        power: 2.2,
                                        type: 'special_magic',
                                        targetType: 'enemies',
                                        description: '敵全体に超高威力魔法攻撃。使用回数で威力が爆発的に増加する。'
                                    }, ]
                                }
                            }
                        }, {
                            name: 'ノエル',
                            role: 'アンドロイド',
                            hp: 130,
                            mp: 20,
                            atk: 52,
                            def: 18,
                            agi: 10,
                            height: 170,
                            description: 'おしとやかなお嬢様のように見えるが、その正体は怪力のアンドロイド。斧を使った物理攻撃に特化している。',
                            skills: [{
                                name: 'スマッシュ',
                                cost: 20, // HP cost
                                power: 2.8,
                                type: 'hp_cost_physical',
                                targetType: 'enemy',
                                description: 'HPを20消費し、敵単体に斧による強力な一撃を見舞う。'
                            }, {
                                name: 'メンテナンス',
                                cost: 0,
                                type: 'self_heal_and_paralyze',
                                targetType: 'self',
                                description: '自身のHPを全回復するが、1ターン麻痺状態になる。'
                            }],
                            unlockableSkill: {
                                name: 'バンプアップ',
                                cost: 50, // HP cost
                                power: 100, // growth amount
                                type: 'hp_cost_growth',
                                targetType: 'self',
                                description: 'HPを大きく消費し、自身の身長を爆発的に伸ばす。'
                            },
                            unlockableSkillLv4: {
                                name: 'オーバーブースト',
                                cost: 10, // MP cost
                                power: 2.0,
                                type: 'mp_burst_height_scaling',
                                targetType: 'enemies',
                                description: '敵全体に大ダメージを与える。身長が高いほど威力に特大ボーナス。MPを全て消費する。'
                            },
                            bgClass: 'bg-char-noel',
                            themeColor: 'rose',
                        }, {
                            name: 'フローラ',
                            role: 'メイド',
                            hp: 110,
                            mp: 50,
                            atk: 60, // 基本攻撃力が高い
                            def: 12,
                            agi: 15,
                            height: 80,
                            description: 'お花好きの小人族のメイド。非力そうな外見に反して拳から繰り出される力は圧倒的。',
                            skills: [{
                                name: 'フラワーアレンジ',
                                cost: 15,
                                type: 'party_buff_and_heal',
                                targetType: 'party',
                                description: '味方全体の攻撃力を上げ、HPを少量回復する。'
                            }, {
                                name: 'ロイヤルティ',
                                cost: 20,
                                type: 'height_transfer',
                                targetType: 'ally',
                                description: '味方ひとりに、それ以外の味方全員の身長を移動させる。'
                            }],
                            unlockableSkill: {
                                name: 'ティータイム',
                                cost: 10,
                                type: 'party_cure_all',
                                targetType: 'party',
                                description: '味方全体の毒、麻痺、鈍化、脱衣を解除する。'
                            },
                            unlockableSkillLv4: {
                                name: 'マジカルエナジー',
                                cost: 30,
                                type: 'maid_special_buff',
                                targetType: 'self',
                                description: '自身に複数の強化効果を付与し、身長が初期値より低い場合は元に戻す。'
                            },
                            bgClass: 'bg-char-flora',
                            themeColor: 'emerald',
                        },

                    ];

                    const characterBlueprints = allCharacterBlueprints.slice(0, 4); // 初期パーティ

                    const itemBlueprints = {
                        'potion': {
                            name: 'ポーション',
                            description: '味方ひとりのHPを最大値の50%回復する。',
                            target: 'ally',
                            effect: 'heal_percent',
                            power: 0.5,
                            battleOnly: false
                        },
                        'cure_mist': {
                            name: 'キュアミスト',
                            description: '味方全員のHPを最大値の30%回復する。',
                            target: 'party',
                            effect: 'heal_percent',
                            power: 0.3,
                            battleOnly: false
                        },
                        'milk': {
                            name: 'ミルク',
                            description: '味方ひとりの身長を初期値に戻す。',
                            target: 'ally',
                            effect: 'reset_height',
                            battleOnly: false
                        },
                        'little_soup': {
                            name: 'リトルスープ',
                            description: '味方ひとりの身長を30cm縮める。戦闘中に敵に使うと、その攻撃力と防御力をしばらく低下させる。',
                            target: 'any',
                            effect: 'shrink',
                            power: 30,
                            battleOnly: false
                        },
                        'pixie_gift': {
                            name: 'ピクシーギフト',
                            description: '味方ひとりの身長を10cmにする。',
                            target: 'ally',
                            effect: 'set_height',
                            power: 10,
                            battleOnly: false
                        },
                        'glass_blade': {
                            name: 'ガラスブレード',
                            description: '敵ひとりに200の固定ダメージを与える。',
                            target: 'enemy',
                            effect: 'damage',
                            power: 200,
                            battleOnly: true
                        },
                        'crazy_bomb': {
                            name: 'クレイジーボム',
                            description: '敵全員に100の固定ダメージを与える。',
                            target: 'enemies',
                            effect: 'damage',
                            power: 100,
                            battleOnly: true
                        },
                        'mana_potion': {
                            name: 'マナポーション',
                            description: '味方ひとりのMPを全回復させる。',
                            target: 'ally',
                            effect: 'restore_mp_full',
                            battleOnly: false
                        },
                        'heart_element': {
                            name: 'ハートエレメント',
                            description: '味方ひとりの最大HPを20永続的に上昇させる。',
                            target: 'ally',
                            effect: 'increase_max_hp',
                            power: 20,
                            battleOnly: false,
                            rare: true
                        },
                        'mana_element': {
                            name: 'マナエレメント',
                            description: '味方ひとりの最大MPを10永続的に上昇させる。',
                            target: 'ally',
                            effect: 'increase_max_mp',
                            power: 10,
                            battleOnly: false,
                            rare: true
                        },
                        'gigantes_ale': {
                            name: 'ギガンテスエール',
                            description: '味方ひとりの身長を100cm伸ばす。身長が初期値より低い場合は、初期値に戻してから伸ばす。',
                            target: 'ally',
                            effect: 'increase_height_and_initial',
                            power: 100,
                            battleOnly: false,
                            rare: true
                        },
                        'revive_herb': {
                            name: 'リバイブハーブ',
                            description: '戦闘不能の味方ひとりをHP50%で復活させる。',
                            target: 'ally',
                            effect: 'revive',
                            power: 0.5,
                            battleOnly: true
                        },
                        'shrink_aroma': {
                            name: 'シュリンクアロマ',
                            description: '味方全員の身長が-20cmされ、戦闘終了まで敵全員の攻撃力と防御力を大幅に下げる。',
                            target: 'party', // 実質的には全体効果
                            effect: 'shrink_party_and_debuff_enemies',
                            power: 20, // 身長減少量
                            battleOnly: true
                        },
                        'fairy_syrup': {
                            name: 'フェアリーシロップ',
                            description: '味方ひとりの身長を1cmにし、その冒険中、身長が1cmで固定される。',
                            target: 'ally',
                            effect: 'lock_height_to_one',
                            battleOnly: false,
                            rare: true
                        },
                        'holy_crystal': {
                            name: '聖結晶',
                            description: '味方全員のHPを全回復する。',
                            target: 'party',
                            effect: 'heal_percent',
                            power: 1.0,
                            battleOnly: false,
                            special: true // 通常のイベントでは入手不可
                        },
                        'evil_crystal': {
                            name: '邪結晶',
                            description: '敵全員に250の固定ダメージを与える。',
                            target: 'enemies',
                            effect: 'damage',
                            power: 250,
                            battleOnly: true,
                            special: true // 通常のイベントでは入手不可
                        },
                        'kanpai_juice': {
                            name: 'カンパイジュース',
                            description: '味方全員の身長を50cm伸ばす。夏の思い出が詰まっている。',
                            target: 'party',
                            effect: 'increase_height_party',
                            power: 50,
                            battleOnly: false,
                            special: true // 通常のイベントでは入手不可
                        },
                        'elixir': {
                            name: 'エリクサー',
                            description: '味方ひとりのHP、MP、状態異常を完全に回復する。',
                            target: 'ally',
                            effect: 'cure_all_and_restore',
                            battleOnly: false,
                            special: true // 調合専用
                        },
                        'gigant_syrup': {
                            name: 'ギガントシロップ',
                            description: '味方ひとりの身長を、現在の身長で固定する。',
                            target: 'ally',
                            effect: 'lock_height_current',
                            battleOnly: false,
                            special: true // 調合専用
                        },
                        'aura_sphere': {
                            name: 'オーラスフィア',
                            description: '味方全員の身長を30cm伸ばす。',
                            target: 'party',
                            effect: 'increase_height_party_30',
                            battleOnly: false,
                            special: true // 調合専用
                        },
                    };

                    const equipmentBlueprints = {
                        'short_sword': {
                            name: 'ショートソード',
                            targetRole: 'ファイター',
                            stat: 'atk',
                            value: 3,
                            description: 'アカリの攻撃力が3上がった！'
                        },
                        'headgear': {
                            name: 'ヘッドギア',
                            targetRole: 'ファイター',
                            stat: 'maxMp',
                            value: 10,
                            description: 'アカリの最大MPが10上がった！'
                        },
                        'mana_rod': {
                            name: 'マナロッド',
                            targetRole: 'ソーサラー',
                            stat: 'maxMp',
                            value: 15,
                            description: 'ヒカリの最大MPが15上がった！'
                        },
                        'claymore': {
                            name: 'クレイモア',
                            targetRole: 'ナイト',
                            stat: 'atk',
                            value: 5,
                            description: 'シズカの攻撃力が5上がった！'
                        },
                        'tower_shield': {
                            name: 'タワーシールド',
                            targetRole: 'ナイト',
                            stat: 'maxHp',
                            value: 20,
                            description: 'シズカの最大HPが20上がった！'
                        },
                        'talisman': {
                            name: 'タリスマン',
                            targetRole: 'メディック',
                            stat: 'maxMp',
                            value: 20,
                            description: 'ユイの最大MPが20上がった！'
                        },
                        'alchemist_goggles': {
                            name: '錬金術師のゴーグル',
                            targetRole: 'アルケミスト',
                            stat: 'maxMp',
                            value: 15,
                            description: 'ベアトリスの最大MPが15上がった！'
                        },
                        'dance_shoes': {
                            name: 'ダンスシューズ',
                            targetRole: 'ダンサー',
                            stat: 'agi',
                            value: 5,
                            description: 'リリカの素早さが5上がった！'
                        },
                        'katana_oil': {
                            name: '名刀油',
                            targetRole: 'サムライ',
                            stat: 'atk',
                            value: 5,
                            description: 'サクヤの攻撃力が5上がった！'
                        },
                        'iron_gauntlets': {
                            name: '鉄甲',
                            targetRole: 'モンク',
                            stat: 'atk',
                            value: 4,
                            description: 'シャオメイの攻撃力が4上がった！'
                        },
                        'medical_kit': {
                            name: '医療キット',
                            targetRole: 'ドクター',
                            stat: 'maxMp',
                            value: 20,
                            description: 'エリザの最大MPが20上がった！'
                        },
                        'loaded_dice': {
                            name: 'イカサマダイス',
                            targetRole: 'ギャンブラー',
                            stat: 'agi',
                            value: 4,
                            description: 'ルナの素早さが4上がった！'
                        },
                        'shadow_cloak': {
                            name: '影隠しのローブ',
                            targetRole: 'リーパー',
                            stat: 'agi',
                            value: 3,
                            description: 'クロエの素早さが3上がった！'
                        },
                        'summoners_bell': {
                            name: '召喚士の鈴',
                            targetRole: 'サモナー',
                            stat: 'maxMp',
                            value: 25,
                            description: 'ミコの最大MPが25上がった！'
                        },
                        'reinforced_flask': {
                            name: '強化フラスコ',
                            targetRole: 'アルケミスト',
                            stat: 'atk',
                            value: 5,
                            description: 'ベアトリスの攻撃力が5上がった！'
                        },
                        'samurai_armor': {
                            name: '侍の鎧',
                            targetRole: 'サムライ',
                            stat: 'maxHp',
                            value: 15,
                            description: 'サクヤの最大HPが15上がった！'
                        },
                        'noel_axe_parts': {
                            name: '斧の強化パーツ',
                            targetRole: 'アンドロイド',
                            stat: 'atk',
                            value: 5,
                            description: 'ノエルの攻撃力が5上がった！'
                        },
                        'noel_self_repair': {
                            name: '自己修復ユニット',
                            targetRole: 'アンドロイド',
                            stat: 'maxHp',
                            value: 20,
                            description: 'ノエルの最大HPが20上がった！'
                        },
                        'flora_knuckles': {
                            name: '刺繍入りのナックル',
                            targetRole: 'メイド',
                            stat: 'atk',
                            value: 6,
                            description: 'フローラの攻撃力が6上がった！'
                        },

                    };

                    function getRemainingEquipment() {
                        const allEquipmentIds = Object.keys(equipmentBlueprints);
                        return allEquipmentIds.filter(id => !gameState.foundEquipment.includes(id));
                    }

                    function addItemToInventory(itemId, quantity = 1) {
                        const existingItem = gameState.inventory.find(item => item.id === itemId);
                        if (existingItem) existingItem.quantity += quantity;
                        else gameState.inventory.push({
                            id: itemId,
                            quantity
                        });
                    }
                    const conversations = {
                        // アカリ (アタッカー): 元気はつらつ、とてもポジティブ。
                        'アカリ': {
                            default: ["よーっし、この調子でどんどん行こう！", "次の敵はどんなやつかな？わくわくする！", "みんな、疲れてない？私はまだまだいけるよ！", "このダンジョン、結構広いね！探検しがいがある！", "お腹すいたなー！終わったら美味しいもの食べに行こう！", "ヒカリ、足元大丈夫？暗いから気をつけてね！", "シズカがいると安心感が違うよね！", "ユイ、いつも回復ありがとう！頼りにしてるよ！", "なんだかちょっとひんやりするね。", "ここ、ちょっと不気味な感じ…でも私が吹き飛ばしてあげる！"],
                            lowHp: ["ちょっとかすり傷が…。でも、これくらい平気！", "うぅ、ちょっと油断したかな。でも、まだまだ戦える！", "いたたた…。やるじゃない！でも、負けないから！", "大丈夫、大丈夫！ちょっと転んだだけだって！", "ヒールサンキュー！これでまた暴れられる！"],
                            allyLowHp: ["{name}、大丈夫！？無理しないでね！", "{name}、危なかったね。私がもっと頑張らないと！", "{name}、下がってて！ここは私がやる！", "ユイ！{name}の回復お願い！", "よくも{name}を！許さないんだから！"],
                            shrunk: ["あれ、なんだか視界が低い…？でも、すばしっこくなったかも！", "ちっちゃくなっても、元気は100倍だから！", "わ、石ころが岩みたいに見える！", "このサイズ、敵に見つかりにくいかも？チャンス！", "みんなー！ここにいるよー！踏まないでね！"],
                            stripped: ["きゃっ！な、何するのよー！恥ずかしいじゃない！", "こ、こんな格好じゃ戦えないよぉ…！でも、やるしかない！", "だ、だめ！見ないで！…って、敵は見てくるかぁ！", "寒くはないけど…！心が寒い！"],
                            allyShrunk: ["{name}、なんだか小さくて可愛いね！でも、ちゃんとついてきてよ！", "わ、{name}が豆粒みたいだ！踏んづけないように気をつけなきゃ！", "{name}、私の後ろにいれば安全だよ！", "そんなに小さいと、敵も気づかないんじゃない？", "大丈夫？ちゃんとご飯食べてる？"],
                            shrunk_100: ["わ、なんだかテーブルの上がすごく高く見える！", "ドアノブに手が届かないかも…ジャンプ！"],
                            shrunk_70: ["シズカの腰くらいまでしかないや！えへへ、面白い！", "ユイと身長同じくらいかな？"],
                            shrunk_50: ["うわー！みんなの膝くらいしかない！子供に戻ったみたい！", "攻撃が当たるか心配になってきた…！"],
                            shrunk_30: ["ユイちゃんの足元だ！見失わないでねー！", "もう妖精さんサイズだね！飛べそう！"],
                            shrunk_10: ["もうみんなの靴くらいの大きさしかないよ！アリさんとお話できちゃうかも！", "誰か、ポケットに入れてー！"],
                            shrunk_1: ["もう指先くらいの大きさしかないよ！誰か、私を拾ってー！"],
                            allyShrunk_100: ["{name}、小さくなっても私が守るからね！", "あれ、{name}、いつもより目線が下だね！"],
                            grown: ["わーい！大きくなった！これならどんな敵も一撃だ！", "なんだか見晴らしがいいなー！", "シズカより大きくなっちゃったかも？えへへ！"],
                            grown_max: ["うおおお！これが私の最大サイズ！もう誰にも止められないよ！", "見てみて！天井に頭がついちゃった！これ以上は無理かな？"],
                            allyGrown: ["うわー、{name}が大きい！見上げちゃうね！", "{name}、天井に頭をぶつけないように気をつけてね！"],
                            stripped_pair: ["え、{name}も！？なんだかお揃いみたいで、ちょっと楽しいかも！", "こうなったら、どっちが大胆になれるか勝負だね！", "二人してこの格好じゃ、敵も呆れるんじゃない？", "恥ずかしいけど、{name}と一緒なら乗り越えられる気がする！", "風邪ひかないように、くっついていようか！", "シズカに見られたら、二人して怒られちゃうかな…？"],
                            stripped_shrunk: ["えぇ！？小さくなっちゃった上に、この格好！？もう、どうしたらいいのー！", "恥ずかしいけど、小さくなったから隠れやすいかも…？いや、やっぱり恥ずかしい！", "こんなに小さいのに、服がないなんて…！敵に見つかったらどうしよう！", "誰か、私を隠してー！小さすぎて、余計に目立っちゃうよ！"],
                            solo_stripped_tiny: ["こんなに小さくて、服もないなんて…！岩陰に隠れていよう…。", "（こそこそ…）誰にも見つかりませんように…！", "（しくしく…）もう、お嫁にいけないよぉ…。", "（じっ…）敵が通り過ぎるまで、息を潜めていよう…。", "このサイズなら、葉っぱ一枚で隠れるかな…？"],
                            fairy_shrunk: ["妖精さんみたいでしょ！えへへ、なんだか楽しいな！", "このサイズなら、どんな隙間でも探検できちゃう！冒険の始まりだ！", "見てみて！指先サイズのアカリだよ！最強に可愛い！"],
                            dollhouse_explore_giant: ["うわー！巨人のお家だ！探検、探検！", "何かお宝、隠されてないかな？わくわくする！", "おじゃましまーす！おっきくてすごいお家だね！"],
                            liberated: ["ふっふーん！見てみて、これが本当の私！", "もう何も隠すものなんてない！かかってきなさい！", "なんだか、すっごく身軽で、どこまでも飛んでいけそう！"],
                            cracked_rock_tiny: ["わーい、隙間がいっぱい！お宝探しだー！", "こんな小さな体でも、役に立てるんだから！見ててね！", "よーし、一番乗りで何か見つけてくる！"],
                            dollhouse_explore: ["わーい、ミニチュアのお家だ！探検、探検！", "何かお宝、隠されてないかな？わくわくする！", "おじゃましまーす！ちっちゃくて可愛いお家だね！"],
                            cracked_rock_break: ["うおおお！この岩、私が粉々にしてやるー！", "邪魔だよー！えいっ！", "これで道が開けたね！"],
                            allyNew: ["{name}、よろしくね！私がしっかり守ってあげる！", "新しい仲間だ！{name}、一緒に頑張ろうね！"],
                            allyStripped_shrunk: ["{name}、小さくなった上にその格好！？私が守ってあげるからね！", "わわわ、{name}！小さくて可愛いけど、その格好は…！", "敵の趣味、悪すぎ！{name}をこんな目に遭わせるなんて！"],
                            allyStripped: ["{name}、大丈夫！？とりあえず私のマント使って！", "わわわ、{name}！目のやり場に困るよ！", "敵の趣味、悪すぎ！絶対許さない！", "ヒカリ、どこ見てるの！"],
                            allyShrunk_70: ["{name}、そのサイズ感、なんだか懐かしい感じがするね！", "ちっちゃい{name}も可愛い！"],
                            allyShrunk_50: ["{name}、半分くらいになっちゃった！？大丈夫？", "わっ、そこにいたの！？気づかなかった！"],
                            shame_pillory: ["いやぁっ！は、離して…！こんな格好で、みんなに見られちゃう…！", "やめて、やめてよぉ！こんなの、絶対おかしいよぉ！", "（ぷるぷる…）もう、お嫁にいけない…！"],
                            allyShrunk_30: ["{name}、ポケットに入れて運んであげようか？", "風邪ひかないようにね！"],
                            shrunk_pair: ["{name}も小さくなっちゃったんだね！なんだかお揃いで楽しいね！", "二人いれば怖くない！ちびっこ探検隊、出発だ！", "こうなったら、どっちがもっと小さくなれるか競争しちゃう？なんちゃって！", "二人で敵の足元を狙えば、最強コンビかも！", "見失わないように、手、繋いでいこうか！"],
                            pair_ベアトリス: ["ベアトリス、その薬、飲むとどうなるの？ちょっと興味ある！", "なんか難しいこと考えてるの？私が代わりに敵、殴ってこようか？"],
                            pair_リリカ: ["リリカちゃんのダンス、見てると元気出る！私も踊っちゃおうかな！", "リリカちゃん、今度一緒に歌おうよ！"],
                            high_mouse_hole_giant: ["うおおお！ボクの肩に乗って、お宝ゲットだー！", "よーっし、この高さなら任せて！しっかり掴まってな！"],
                            high_mouse_hole_tiny: ["任せて！一番乗りでお宝見つけてくるから！", "わーい、高い高い！行ってきまーす！"],
                            high_mouse_hole_all_tiny: ["うーん、みんなで肩車しても全然届かないね…。", "ジャンプしてもダメだー！悔しい！", "鳥さんでも呼んでこれないかなぁ…。", "あそこにお宝があるかもしれないのに…！"],
                            pair_サクヤ: ["サクヤちゃん、その刀すごいね！私のも負けてないよ！", "たまには笑ってよー！ね？"],
                            pair_シャオメイ: ["シャオメイちゃん、勝負だ！どっちが多く倒せるか競争しよう！", "お腹すいたねー！終わったら肉まん食べに行こう！"],
                            pair_エリザ: ["エリザさん、その注射、痛くない…？", "大きくなる薬、もっとちょうだい！"],
                            pair_ルナ: ["ルナちゃん、ギャンブルってよくわからないけど、楽しそうだね！", "私に賭けてみてよ！絶対勝つから！"],
                            pair_クロエ: ["クロエちゃん、静かだね。でも、強いのは知ってるよ！", "その大鎌、重くない？私が持ってあげようか？"],
                            pair_ミコ: ["ミコちゃん、そのモコって子、ふわふわだね！触ってもいい？", "ゴーレムくん、かっこいいね！私とどっちが強いかな？"],
                            pair_レンカ: ["レンカさん、なんだかミステリアスだね！でも、悪い人じゃないってわかるよ！", "その魔法、どうなってるの？すごいね！"],
                            pair_イオリ: ["イオリ先輩！小さくてもすっごく頼りになります！", "私が先輩を守りますからね！任せてください！"],
                            pair_コハル: ["コハルちゃん、見てて飽きないなー！次はなにが起こるか楽しみ！", "失敗しても私がフォローするから、思いっきりやっていいよ！"],
                            pair_オリビア: ["オリビアさん、いつもありがとう！その祈り、すっごく温かいです！", "私も、オリビアさんみたいに誰かを癒せるようになりたいな！"],
                            pair_レンカ: ["レンカさん、なんだかミステリアスだね！でも、悪い人じゃないってわかるよ！", "その魔法、どうなってるの？すごいね！"],
                            pair_セレスティア: ["セレスティアちゃん、すごい力だね！私も負けてられないな！", "なんだか、見てるだけで心が洗われるみたい…不思議な感じ！"],
                            pair_イオリ: ["イオリ先輩！小さくてもすっごく頼りになります！", "私が先輩を守りますからね！任せてください！"],
                            pair_コハル: ["コハルちゃん、見てて飽きないなー！次はなにが起こるか楽しみ！", "失敗しても私がフォローするから、思いっきりやっていいよ！"],
                            pair_オリビア: ["オリビアさん、いつもありがとう！その祈り、すっごく温かいです！", "私も、オリビアさんみたいに誰かを癒せるようになりたいな！"],
                        },
                        // ヒカリ (魔法使い): 無口で慎重派。
                        'ヒカリ': { // ソーサラー
                            default: ["…順調。", "…先の気配を探る。", "…静か。油断は禁物。", "…この通路、魔力の流れが少し違う。", "…アカリ、あまり先行するな。", "…シズカ、後方は頼む。", "…ユイ、MPは足りているか？", "…壁の模様…古代の魔法文字か？", "…空気が澱んでいる。注意。", "…もう少し、慎重に進むべき。"],
                            lowHp: ["…少し、魔力が乱れてる。", "…問題ない。集中する。", "…かすっただけ。", "…呼吸を整えれば、まだやれる。", "…回復に感謝。"],
                            allyLowHp: ["{name}…回復を。", "…{name}、下がって。", "…シズカ、{name}のカバーを。", "…ユイ、急いで。", "…敵の狙いは{name}か。"],
                            shrunk: ["…これでは、歩幅が…。", "…魔力の制御に、影響は無い。", "…体が軽い。エーテルの流れが速い。", "…詠唱の声が、小さくなる。", "…このサイズなら、敵の死角に入りやすい。"],
                            stripped: ["…不愉快。", "…ローブで隠す。…これでは動きにくい。", "…見てくれるな。", "…集中を削がれる。", "…風魔法で、体を隠せないか…"],
                            allyShrunk: ["…{name}、そこにいたのか。", "…小さい。敵に見つかりにくい利点も。", "…アカリ、{name}を踏むな。", "…気配が希薄になった。暗殺者向き。 ", "…守るべき対象が、小さくなった。"],
                            shrunk_100: ["…視界が低い。腰をかがめないと本が取れない。", "…魔導書が重い。"],
                            shrunk_70: ["…大人の膝ほどの高さ。魔導書の文字が少し読みづらい。", "…走る速度が落ちる。"],
                            shrunk_50: ["…世界のすべてが大きく見える。", "…私のファイアボールの方が大きい。"],
                            shrunk_30: ["…草むらが、森のようだ。", "…これでは、ネズミと間違われる。"],
                            shrunk_10: ["…指先ほどの大きさ。だが、魔力は私と共にある。", "…風で飛ばされそうだ。"],
                            shrunk_1: ["…塵芥のようだ。だが、魔力は消えぬ。"],
                            allyShrunk_100: ["…{name}、足元に注意して。", "…{name}、私の後ろを歩け。"],
                            grown: ["…体が大きいと、魔力の流れが少し鈍る。", "…天井が近い。頭上に注意。", "…この体格なら、魔導書で殴っても強そうだ。"],
                            grown_max: ["…これが、力の頂点。…これ以上は、ない。", "…魔力の器が、限界に達した。"],
                            allyGrown: ["…{name}、大きい。威圧感がある。", "…{name}、その体で、狭い通路は通れるのか？"],
                            allyNew: ["…{name}か。よろしく。足を引っ張るなよ。", "…新しい仲間。{name}、君の実力を見せてもらう。"],
                            stripped_shrunk: ["…体が縮み、さらにこの状態。…魔力集中が困難だ。", "…この状況で、敵に遭遇すれば…最悪だ。", "…この小ささで、この格好。…隠れる場所を探す。", "…恥辱。だが、この状況を乗り越えねば。"],
                            solo_stripped_tiny: ["…この小ささで、この格好。…屈辱だ。", "…物陰に隠れる。気配を消せば、見つかることはない。", "…早く、この状況を脱したい。", "…（魔導書を盾のようにして、体を隠している）"],
                            dollhouse_explore_giant: ["…この家、巨大だ。調査の価値がある。", "…微弱な魔力の残滓を感じる。何かあるな。", "…侵入する。巨人族の生活痕跡か。"],
                            liberated: ["…これが、真理に近い姿。", "…魔力の流れを、肌で直接感じる。悪くない。", "…無駄な装飾は、思考の妨げになる。"],
                            cracked_rock_tiny: ["…この隙間なら、内部構造を調査できる。", "…岩の内部に、微弱な魔力の流れを感じる。何かあるかもしれない。", "…行ってくる。"],
                            dollhouse_explore: ["…この家、精巧な作りだ。調査の価値がある。", "…微弱な魔力の残滓を感じる。何かあるな。", "…侵入する。何者かの生活痕跡か。"],
                            cracked_rock_break: ["…魔力で、内部から破壊する。", "…道を開ける。", "…邪魔。"],
                            fairy_shrunk: ["…世界の解像度が上がったようだ。全てが鮮明に見える。", "…魔力の流れが、いつもより肌で感じられる。悪くない。", "…この体、エーテルの循環が最適化されている。"],
                            allyStripped_shrunk: ["…{name}、小さくなった上にその格好か。…気の毒に。", "…{name}、私のローブの影に隠れるといい。", "…敵の悪趣味な攻撃。速やかに排除する。"],
                            stripped_pair: ["…{name}もか。…不愉快だ。互いに、視線を避けるべきだ。", "…この状況、魔力集中に影響が出る。", "…二人でいれば、敵も呆れるか。…いや、逆か。", "…アカリ、{name}を見るな。…いや、私もか。", "…この恥辱、忘れない。"],
                            allyStripped: ["…{name}、私のローブを。…いや、サイズが合わないか。", "…敵の悪趣味な攻撃。速やかに排除する。", "…アカリ、{name}を見るな。"],
                            shame_pillory: ["…っ！離せ。…この、不愉快な…！", "…屈辱だ。…だが、ここで精神を乱されては、敵の思う壺。", "（目を固く閉じ、屈辱に耐えている）"],
                            allyShrunk_70: ["…{name}、その姿でも、油断はするな。", "…アカリ、{name}をからかうな。"],
                            allyShrunk_50: ["…{name}、気配がさらに薄くなった。隠密には向いている。", "…シズカ、{name}が見えない。"],
                            allyShrunk_30: ["…{name}、私のローブの影に隠れるといい。", "…ユイ、{name}を鞄に入れるか検討を。"],
                            shrunk_pair: ["…{name}もか。互いに、見失わないようにしよう。", "…二人分の気配が消えた。奇襲には最適。", "…この状況、笑えてきた。", "…{name}、段差だ。手を貸す。", "…二人でいれば、ただの小さい存在ではない。"],
                            pair_アカリ: ["…アカリ、また突っ走って。少しは落ち着け。", "…アカリ、背中は任せた。"],
                            pair_シズカ: ["…シズカ、頼りにしてる。援護は任せて。", "…その盾、私の魔法でも壊せないかも。"],
                            high_mouse_hole_giant: ["…肩を貸す。落ちるなよ。", "…この高さなら届く。中を頼む。"],
                            high_mouse_hole_tiny: ["…了解。内部の構造を調査する。", "…行ってくる。すぐに戻る。"],
                            high_mouse_hole_all_tiny: ["…届かない。物理的に不可能。", "…全員で塔になっても、高さが足りない。", "…飛行魔法があれば。…ない。", "…諦めるのが、合理的。"],
                            pair_ユイ: ["…ユイ、MPは大丈夫？無理はするな。", "…いつもありがとう。助かる。"],
                            pair_ベアトリス: ["…ベアトリス、その探究心、嫌いじゃない。", "…錬金術と魔術、根源は同じかもしれない。"],
                            pair_リリカ: ["…リリカ、騒がしい。だが、士気が上がるのは確か。", "…その歌、魔力に影響を与える。面白い。"],
                            pair_サクヤ: ["…サクヤ、その太刀筋…無駄がない。", "…サクヤ、気配を消すのが上手い。静かなのは、嫌いじゃない。", "…剣禅一如、か。魔道にも通じるものがある。"],
                            pair_シャオメイ: ["…シャオメイ、単純。だが、それが強さか。", "…腹が減った、しか言わない。"],
                            pair_エリザ: ["…エリザ、あなたの薬、興味深い。だが、私は被検体にはならない。", "…科学と魔法、どちらが真理か。…愚問。"],
                            pair_ルナ: ["…ルナ、運命はサイコロでは決まらない。", "…そのギャンブル、確率論で解析できる。"],
                            pair_クロエ: ["…クロエ、あなたも静か。…魂、見えるの？", "…その鎌、どこで手に入れた？"],
                            pair_ミコ: ["…ミコ、その召喚術、系統が違う。興味深い。", "…モコ、という生き物。解析したい。"],
                            pair_レンカ: ["…レンカ、死霊術か。…禁忌の領域。だが、力は本物。", "…その魂、どこから呼んでいる？"],
                            pair_イオリ: ["…イオリ、先輩か。その守り、確か。", "…小さくても、その存在感は大きい。"],
                            pair_コハル: ["…コハル、予測不能。それが一番厄介。", "…次は何が起こるか、見ておく。"],
                            pair_オリビア: ["…オリビア、その祈り、純粋な魔力。…聖属性か。", "…回復魔法、専門外だが、参考になる。"],
                            pair_レンカ: ["…レンカ、死霊術か。…禁忌の領域。だが、力は本物。", "…その魂、どこから呼んでいる？"],
                            pair_セレスティア: ["…その力、聖なるものか。魔力とは異なる、純粋なエネルギー。", "…あなたの存在そのものが、この地の穢れを払っている。"],
                            pair_イオリ: ["…イオリ、先輩か。その守り、確か。", "…小さくても、その存在感は大きい。"],
                            pair_コハル: ["…コハル、予測不能。それが一番厄介。", "…次は何が起こるか、見ておく。"],
                            pair_オリビア: ["…オリビア、その祈り、純粋な魔力。…聖属性か。", "…回復魔法、専門外だが、参考になる。"],
                        },
                        // シズカ (タンク): 姉御肌、とても頼れる。
                        'シズカ': { // ナイト
                            default: ["みんな、いい調子だね。このまま気を引き締めていこうか。", "何かあったらすぐに言いな。あたしが前に出るからさ。", "ふぅ、一休みも大事だよ。焦らず行こう。", "アカリ、あんまりはしゃいでると転ぶよ。", "ヒカリ、何か気になるものでもあったのかい？", "ユイ、いつもありがとうね。無理するんじゃないよ。", "この階は静かだね。嵐の前の静けさ、ってやつじゃなきゃいいけど。", "よし、次の角を曲がるよ。準備はいいね？", "全員、あたしの後ろから離れるんじゃないよ。", "敵の気配はないね。今のうちに体制を整えよう。"],
                            lowHp: ["ちっ、今の攻撃はちょっと効いたね…。でも、まだまだ！", "これしきでへこたれるあたしじゃないよ。", "はは、上等じゃないか。もっときな！", "大丈夫、大丈夫。みんなはあたしが守るからさ。", "ユイ、すまないね。回復助かるよ。"],
                            allyLowHp: ["{name}、大丈夫かい？あたしの後ろに隠れな！", "{name}、無理は禁物だよ。しっかり守ってやるからさ。", "アカリ！{name}から敵を引き剥がすよ！", "ヒカリ、援護を頼む！", "ユイ、{name}を頼んだよ！"],
                            shrunk: ["おっと、こりゃ小さくなっちまったね。守れる範囲が狭くなるのは困るね。", "体が小さくても、気合でどうにでもなるさ！", "盾が体より大きいじゃないか。これはこれで要塞だね。", "敵の攻撃が当たらなくなるかもね。それはそれで儲けもんさ。", "みんな、あたしを見失うんじゃないよ！", "盾を構えるのに、いつもより力が必要だね。"],
                            // シズカは脱衣状態にならない
                            allyShrunk: ["{name}、あんまり小さいと見失っちまうよ。側にいな。", "あらあら、{name}が可愛くなっちゃって。でも、油断するんじゃないよ。", "よしな、{name}。あんたはあたしの足元にいれば安全さ。", "ヒカリ、{name}がどこにいるか分かるかい？", "アカリ、{name}で遊ぶんじゃないよ。"],
                            shrunk_100: ["おっと、盾が壁みたいに感じるね。", "いつもより低い位置から敵を見上げるのは、新鮮だね。"],
                            shrunk_70: ["あたしの盾の上半分くらいしか見えないじゃないか。これじゃあ敵になめられちまうかな？", "アカリと目線が同じくらいかね。"],
                            shrunk_50: ["アカリの膝くらいまでしか無いじゃないか…。だが、守りの魂は小さくならないよ！", "これじゃあ、盾を構えるのがやっとだね。"],
                            shrunk_30: ["さすがにこれは、守りにくいねぇ。敵の足元を狙うしかないか。", "ゴブリンより小さいじゃないか…。"],
                            shrunk_10: ["こりゃ驚いた。もう盾の裏に住めそうだね。", "誰かあたしを拾っておくれ。"],
                            shrunk_1: ["…もう、盾の取っ手の一部になった気分だよ。"],
                            allyShrunk_100: ["{name}、小さくなってもあたしが壁になってやるさ。", "おっと、{name}。そこにいたのかい。"],
                            grown: ["はは、こりゃいい！巨人になった気分だね！", "これならどんな攻撃も受け止めてやれるさ！", "天井が低いねぇ。頭をぶつけないようにしないと。"],
                            grown_max: ["はは、ついに天井に頭がついちまったね。これ以上は無理か。", "この体格なら、竜だって止められそうだ！"],
                            allyGrown: ["おぉ、{name}、見上げるほど大きくなったじゃないか！頼もしいね！", "{name}、あんまり大きいと敵に見つかりやすいから気をつけな。"],
                            allyNew: ["お、新しい仲間かい。{name}、よろしくな。あたしがしっかり守ってやるよ。", "ようこそ、{name}。歓迎するよ。"],
                            // シズカは脱衣状態にならないため、stripped_shrunkも発生しない
                            allyLiberated: ["おやおや、{name}。随分と開放的じゃないか。風邪ひくんじゃないよ。", "{name}、その格好…何か吹っ切れたのかい？まあ、あんたがいいならあたしは何も言わないけどね。", "はは、大胆だねぇ。敵もびっくりして逃げ出すんじゃないか？"],
                            dollhouse_explore_giant: ["はは、こりゃまたでっかい家だねぇ。誰か住んでるのかい？", "よし、ちょっと失礼して中を拝見させてもらうよ。", "こんな大きな家にも、暮らしがあるのかねぇ。"],
                            cracked_rock_tiny: ["はは、こんな小さな体でも役に立つとはね。見てくるよ。", "よし、この隙間ならあたしでも通れる。任せときな。", "お宝でも隠されてないか、ちょっと探してくるよ。"],
                            // シズカは脱衣状態にならないため、stripped_pairは発生しない
                            dollhouse_explore: ["はは、こりゃまた可愛らしい家だねぇ。誰か住んでるのかい？", "よし、ちょっと失礼して中を拝見させてもらうよ。", "こんな小さな家にも、暮らしがあるのかねぇ。"],
                            cracked_rock_break: ["はっはっは！あたしのでかさをなめてもらっちゃ困るよ！", "どきな！こんな岩、盾の一撃で十分さ！", "ふんっ！…よし、道が開いたね。"],
                            fairy_shrunk: ["はは、豆粒みたいになっちまったが、守る心は変わらないよ。", "このサイズなら、敵の懐に飛び込むのも容易いね。", "盾が家みたいだ。雨風はしのげるな。"],
                            allyStripped: ["おやおや、{name}。大胆な格好じゃないか。風邪ひくんじゃないよ。", "敵の奴、くだらない真似をしやがる。さっさと叩き潰してやるからな！", "アカリ、{name}から目を離しな。"],
                            allyShrunk_70: ["{name}、そのサイズじゃ一歩が大きいだろう。無理するなよ。", "可愛いねぇ。頭を撫でてやりたいよ。"],
                            allyShrunk_50: ["{name}、あたしの足元にいれば安全だよ。踏んじまわないようにしないとね。", "半分か…。ちゃんと守ってやらないとね。"],
                            high_mouse_hole_giant: ["よし、あたしの肩に乗りな。しっかり支えててやるからさ。", "はは、こうでもしないと届かないかね。さあ、行きな！"],
                            high_mouse_hole_tiny: ["はは、こりゃいい眺めだね。じゃ、ちょっと見てくるよ。", "了解。中の様子を探ってくる。任せときな。"],
                            high_mouse_hole_all_tiny: ["はは、こりゃ参ったね。全員豆粒じゃ、どうしようもないか。", "誰か一人、鳥にでも運んでもらうかい？冗談だよ。", "まあ、仕方ない。諦めて次に行こうか。"],
                            allyShrunk_30: ["{name}、どこだい？ああ、そこにいたのか。", "ユイ、あんたの鞄に入れてやったらどうだい？"],
                            shrunk_pair: ["おや、{name}もかい。こりゃ、ちびっこコンビで敵を油断させるかね。", "二人してこの様かい。笑っちまうね。", "こうなったら、どっちがうまく隠れられるか勝負といくかい？", "あんたが囮で、あたしが仕留める。どうだい、この作戦？", "よし、手でも繋いでおくかね。はぐれないようにさ。"],
                            pair_アカリ: ["アカリ、あんまり前に出過ぎるんじゃないよ。あたしが壁になってやるからさ。", "よしよし、いい子だ。"],
                            pair_ヒカリ: ["ヒカリ、あんたの魔法は頼りになるね。後衛は任せたよ。", "たまにはあたしにも頼りな。"],
                            pair_ユイ: ["ユイ、いつもありがとうね。あんたがいるから、安心して前に出られるよ。", "無理するんじゃないよ。"],
                            pair_ベアトリス: ["ベアトリス、あんたの薬はよく効くねぇ。でも、変な薬はあたしに使うんじゃないよ。", "研究もいいが、ほどほどにな。"],
                            pair_リリカ: ["リリカ、あんたの踊りは見てて楽しいね。士気が上がるよ。", "ステージはあたしが守ってやるから、思いっきりやりな。"],
                            pair_サクヤ: ["サクヤ、あんたの剣の腕は確かだね。背中を預けられるよ。", "たまには肩の力抜きな。"],
                            pair_シャオメイ: ["シャオメイ、あんたの拳は見てて飽きないねぇ。", "腹が減ったのかい？終わったら美味い店に連れてってやるよ。", "あんまり無茶するんじゃないよ。あたしが前に出るからさ。"],
                            pair_エリザ: ["エリザ、あんたも大概物好きだねぇ。でも、その腕は確かだ。", "あたしを実験台にするのはやめときな。"],
                            pair_ルナ: ["ルナ、博打もいいが、命まで賭けるんじゃないよ。", "あんたの度胸は買ってやるよ。"],
                            pair_クロエ: ["クロエ、大丈夫かい？あたしの後ろにいな。", "あんまり暗い顔してると、幸せが逃げちまうよ。"],
                            pair_ミコ: ["ミコ、その召喚獣は頼りになるね。あたしの盾とどっちが硬いかね？", "モコとかいうの、可愛いじゃないか。"],
                            pair_レンカ: ["レンカ、あんたの魔法は気味が悪いねぇ。でも、頼りにしてるよ。", "死人相手とは、感心しないね。"],
                            pair_イオリ: ["イオリ、あんたが先輩だったのかい。頼りにしてるよ、先輩。", "その小さな体で、よく頑張るねぇ。感心だよ。"],
                            pair_コハル: ["コハル、あんたは見ててハラハラするねぇ。でも、面白いからいいか。", "何かあったらあたしがなんとかしてやるから、好きにやりな。"],
                            pair_オリビア: ["オリビア、あんたの祈りは心に染みるね。ありがとうよ。", "無理するんじゃないよ。あんたも大事な仲間だからね。"],
                            pair_レンカ: ["レンカ、あんたの魔法は気味が悪いねぇ。でも、頼りにしてるよ。", "死人相手とは、感心しないね。"],
                            pair_セレスティア: ["セレスティア、あんたは一人で背負いすぎだよ。あたしたちもいるんだからさ。", "その小さな体で、よく頑張るねぇ。感心だよ。"],
                            pair_イオリ: ["イオリ、あんたが先輩だったのかい。頼りにしてるよ、先輩。", "その小さな体で、よく頑張るねぇ。感心だよ。"],
                            pair_コハル: ["コハル、あんたは見ててハラハラするねぇ。でも、面白いからいいか。", "何かあったらあたしがなんとかしてやるから、好きにやりな。"],
                            pair_オリビア: ["オリビア、あんたの祈りは心に染みるね。ありがとうよ。", "無理するんじゃないよ。あんたも大事な仲間だからね。"],
                        },
                        // ユイ (メディック): 世話焼き、みんなの妹。
                        'ユイ': { // メディック
                            default: ["皆さん、ケガはありませんか？いつでも言ってくださいね！", "なんだか、ドキドキしますね…。でも、みんなと一緒なら大丈夫！", "次の階には何があるんでしょうか…？", "アカリさん、元気ですね！私も見習わないと！", "ヒカリさん、何か見つけましたか？", "シズカさん、いつも頼りになります…！", "回復薬、まだありますから安心してくださいね。", "少し休憩しますか？お茶とか淹れましょうか？", "わ、今の音なんでしょう…！？", "お腹すきましたね…。あとでみんなでお菓子パーティしませんか？"],
                            lowHp: ["ひゃっ…！今の、危なかったです…。", "だ、大丈夫です！まだ、ヒールできますから！", "うぅ…ちょっと目が回ります…。", "ご、ごめんなさい！私がもっとしっかりしないと…！", "回復ありがとうございます…！助かりました！"],
                            allyLowHp: ["{name}さん、大変！すぐに治しますから、じっとしててください！", "きゃー！{name}さん、血が！私がなんとかしないと…！", "{name}さん、下がってください！危ないです！", "シズカさん！{name}さんをお願いします！", "そんな…！{name}さんを傷つけるなんて、ひどいです！"],
                            shrunk: ["えぇ！？体が縮んじゃいました…！これじゃ、みんなに追いつけないかも…。", "うぅ、服がぶかぶかです…。歩きにくい…", "なんだか、世界がとっても大きく見えます…！", "このままじゃ、回復魔法をかけるのも一苦労です…。", "アカリさん、待ってくださいー！歩くのが速いですー！"],
                            stripped: ["ひゃああっ！？い、いやです！こんな格好、恥ずかしいですぅ…！", "うぅ…だれかハンカチを…！", "も、もうお嫁にいけません…！", "こんな格好じゃ、回復に集中できません…！", "リリカさんなら、こんな時でも堂々としてるんでしょうか…？"],
                            allyShrunk: ["わ、{name}さん、小さくなっちゃって…。ケガしてませんか？", "{name}さん、どこですかー？あ、そんなところに！", "{name}さん、ちゃんとご飯は食べてますか？心配です…。", "シズカさん、{name}さんが見えません！", "ヒカリさん、{name}さんが迷子にならないように見ててあげてください！"],
                            shrunk_100: ["小学生みたいになっちゃいました…。", "なんだか、アカリさんの妹になった気分です。"],
                            shrunk_70: ["これじゃ、高いところの薬草が取れません…。誰か、手伝ってください…。", "ヒカリさんのローブに隠れられちゃいますね。"],
                            shrunk_50: ["半分に…。シズカさんの膝くらいしかありません…。どうしましょう…。", "わたしの回復魔法、届くでしょうか…。"],
                            shrunk_30: ["お、お人形さんみたいです…。このままじゃ戦えません…！", "シズカさんのブーツより小さいです…！"],
                            shrunk_10: ["ふぇぇ…もう、歩くのが大変ですぅ…。誰か、カバンに入れてください…！", "アリさんとお友達になれそうです…。"],
                            shrunk_1: ["ふぇぇ…もう涙の粒のほうが大きいですぅ…！"],
                            allyShrunk_100: ["{name}さん、小さくなっても私がちゃんとヒールしますからね！", "わ、{name}さん、いつもと雰囲気が違いますね！"],
                            grown: ["わわっ、大きくなっちゃいました！なんだか、シズカさんみたいです…！", "これなら、高いところの薬草も簡単に取れますね！", "天井に頭が…！気をつけないと…！"],
                            grown_max: ["わわっ！もう、これ以上は大きくなれないみたいです…！", "なんだか、雲の上にいるみたいです…！"],
                            allyGrown: ["わぁ、{name}さん、とっても大きいですね！見上げちゃいます！", "{name}さん、そんなに大きいと、服が破けちゃいませんか？"],
                            allyNew: ["新しいお仲間ですね！{name}さん、よろしくお願いします！", "わぁ、{name}さん！これから一緒に頑張りましょうね！"],
                            stripped_shrunk: ["ひゃああっ！小さくなった上に、こんな格好だなんて…！もう、泣いちゃいそうですぅ…！", "だ、誰か、私を隠してください…！小さすぎて、余計に目立っちゃいます…！", "こんなに小さいのに、服がないなんて…！敵に見つかったらどうしましょう…！", "恥ずかしいですぅ…！でも、回復はちゃんとしますから…！"],
                            solo_stripped_tiny: ["ふぇぇ…こんなに小さくて、お洋服もないなんて…！石の後ろに隠れてます…。", "（きゅるん…）誰か、助けてください…。", "（ふるふる…）寒くて、恥ずかしいですぅ…。", "もう、涙で前が見えません…。", "（ぽつん…）"],
                            dollhouse_explore_giant: ["わぁ、巨人さんのお家みたいです！とっても大きい！", "おじゃまします！何か困っていることはありませんか？", "綺麗なお家…！私もこんなお家に住んでみたいです！…って、大きすぎますね！"],
                            cracked_rock_tiny: ["は、はいっ！行ってきます！何か見つかるかもしれません！", "こんな私でも、みんなの役に立てるなら…！", "わわっ、狭いですけど…頑張ります！"],
                            dollhouse_explore: ["わぁ、お人形さんのお家みたいです！とっても可愛い！", "おじゃまします！何か困っていることはありませんか？", "綺麗なお家…！私もこんなお家に住んでみたいです！"],
                            liberated: ["は、はいぃ…！こ、これが、私の覚悟です！", "も、もう何も怖くありません！みんなを、守るためなら…！", "なんだか、心がすーっとして…祈りが、もっと深くなった気がします…！"],
                            cracked_rock_break: ["わわっ！こんなに大きくなっちゃったんですから、これくらい！", "えいっ！…わー！壊れちゃいました！", "みなさんのために、頑張ります！"],
                            fairy_shrunk: ["妖精さんになっちゃいました！なんだか、飛べそうな気がします！", "小さくても、ヒールはちゃんと届きますからね！安心してください！", "わあ、お花畑にいるみたいです！綺麗…！"],
                            allyStripped_shrunk: ["きゃっ！{name}さん、小さくなった上にその格好ですか！？私が守りますから！", "{name}さん、大丈夫ですか！？小さくて可愛いけど、その格好は…！", "シズカさん、早く敵を倒してください！{name}さんがかわいそうです！"],
                            stripped_pair: ["ひゃああっ！{name}さんもですか！？もう、どうしましょう…！", "二人でいると、恥ずかしさも倍増ですぅ…！", "こんな格好じゃ、回復に集中できません…！", "だ、誰か、私たちに服を…！", "せめて、お互い見ないようにしましょう…！"],
                            allyStripped: ["きゃっ！{name}さん、大丈夫ですか！？これを…私のハンカチですけど…！", "{name}さんになんてことを！私がすぐに治しますから！", "シズカさん、早く敵を倒してください！"],
                            shame_pillory: ["ひゃああっ！い、いやです！離してください！", "ふぇぇ…こんなの、あんまりですぅ…！", "（涙目でぷるぷると震えている）"],
                            allyShrunk_70: ["{name}さん、なんだか可愛らしいですけど…転ばないでくださいね？", "私が手を引いてあげます！"],
                            allyShrunk_50: ["{name}さん、半分に…。私が守ってあげないと！", "そんなに小さいと、敵に見つからないかもしれませんね！"],
                            allyShrunk_30: ["{name}さん、私のカバンに入りますか？その方が安全かも…。", "寒くないですか？私のハンカチをどうぞ！"],
                            shrunk_pair: ["{name}さんもですか！？ふぇぇ…二人で一緒に頑張りましょうね…！", "二人とも小さくなっちゃって…どうしましょう…。", "でも、なんだか秘密基地みたいで、ちょっとだけ楽しいです…！", "手、繋いでいきましょう！はぐれたら大変ですから！", "{name}さん、怖くないですか？私がそばにいますからね！"],
                            pair_アカリ: ["アカリさん、あんまり無茶しないでくださいね！ケガしたら私が治しますから！", "元気で、見てて楽しいです！"],
                            pair_ヒカリ: ["ヒカリさん、大丈夫ですか？疲れたらいつでも言ってくださいね。", "その本、面白そうですね！"],
                            high_mouse_hole_giant: ["わわっ、私で大丈夫でしょうか…？えいっ！しっかり掴まってくださいね！", "こ、こんな高いところ…！私がしっかり支えますから！"],
                            high_mouse_hole_tiny: ["は、はいっ！行ってきます！皆さんのために、頑張らないと…！", "わ、高いです…！でも、お宝のためなら！"],
                            high_mouse_hole_all_tiny: ["ふぇぇ…あんなに高いところ、どうやっても届きません…。", "みんなで頑張っても、全然足りませんね…。", "せめて、背が伸びるお薬があれば…。", "（しくしく…）ごめんなさい、私じゃお役に立てなくて…"],
                            pair_シズカ: ["シズカさん、いつも守ってくれてありがとうございます！私も頑張ります！", "シズカさんがいると、とっても安心です！"],
                            pair_ベアトリス: ["ベアトリスさん、そのお薬、なんですか？回復薬ですか？", "研究、頑張ってください！"],
                            pair_リリカ: ["リリカさんのステージ、いつも見てます！とってもキラキラしてます！", "わわ、リリカさん！私、ファンなんです！サインください！", "リリカさんのダンス、どうしてあんなに綺麗なんですか？"],
                            pair_サクヤ: ["サクヤさん、なんだか怖そうですけど、きっと優しい人ですよね！", "ケガしたら、我慢しないで言ってくださいね！"],
                            pair_シャオメイ: ["シャオメイさん、いつも元気ですね！お腹がすいたら、私のお菓子をどうぞ！", "その拳、とっても強そうです！"],
                            pair_エリザ: ["エリザさん、その注射器、ちょっと怖いです…。", "でも、人を助けるお医者さんなんですよね！すごいです！"],
                            pair_ルナ: ["ルナさん、ギャンブルはほどほどに…。心配です…。", "でも、楽しそうなのはいいことですね！"],
                            pair_クロエ: ["クロエちゃん、大丈夫？寒くないですか？私のマント、使いますか？", "一人でいないで、こっちに来てください！"],
                            pair_ミコ: ["ミコちゃん、モコちゃん、とっても可愛いですね！なでなでしてもいいですか？", "召喚術って、すごいんですね！"],
                            pair_レンカ: ["レンカさん、その魔法、ちょっと怖いですけど…味方だと頼もしいです！", "何かあったら、私がヒールしますからね！"],
                            pair_イオリ: ["イオリ先輩、小さくてもとっても頼りになります！尊敬します！", "先輩のこと、私がしっかりお守りしますね！"],
                            pair_コハル: ["コハルちゃん、大丈夫ですか！？転んだりしてませんか？", "見ててハラハラしますけど…なんだか楽しいです！"],
                            pair_オリビア: ["オリビアさん、その祈り、とっても温かいです。私もそんな風になりたいです。", "疲れたら、いつでも言ってくださいね。私がヒールしますから！"],
                            // サマータイム・スペシャルライブ！
                            beach_liberation_prompt: ["この太陽、なんだか私を元気にしてくれます…！もっと、この光を全身で感じたいです…！"],
                            beach_liberation_stop: ["は、はいっ！わ、私、ちょっと大胆になりすぎてました…！"],
                            onsen_liberation_prompt: ["この温泉、とっても気持ちいいです…。なんだか、悩み事も全部溶けていっちゃいそうで…ふふっ。"],
                            onsen_liberation_stop: ["わわっ！す、すみません！私、ちょっとのぼせちゃったみたいです…！"],

                            summer_beach: [
                                "わぁ、海、綺麗ですね…！みんなとはしゃげて、とっても楽しいです！",
                                "日差しが強いので、皆さん熱中症には気をつけてくださいね！",
                                "リリカさんのライブ、素敵でした…！私も、もっと皆さんのお役に立てるように頑張らないと！",
                                "リリィさん、砂のお城作り、上手ですね！私も手伝います！"
                            ],
                            summer_onsen: ["温泉…気持ちいいです…。なんだか、眠くなってきちゃいました…。", "このタオル、ちゃんと巻けてますか…？ちょっと心配です…。", "温泉まんじゅう、美味しいです！皆さん、どうぞ！", "ミコちゃん、温泉で泳いじゃだめですよー！"],
                            onsen_towel_trouble: ["ひゃああっ！？い、いやです！こんな格好、恥ずかしいですぅ…！見ないでください！"],
                            pair_レンカ: ["レンカさん、その魔法、ちょっと怖いですけど…味方だと頼もしいです！", "何かあったら、私がヒールしますからね！"],
                            pair_セレスティア: ["セレスティアさん、なんだかとても温かい光を感じます…。", "疲れたらいつでも言ってくださいね。私、ヒールしますから！"],
                            pair_イオリ: ["イオリ先輩、小さくてもとっても頼りになります！尊敬します！", "先輩のこと、私がしっかりお守りしますね！"],
                            pair_コハル: ["コハルちゃん、大丈夫ですか！？転んだりしてませんか？", "見ててハラハラしますけど…なんだか楽しいです！"],
                            pair_オリビア: ["オリビアさん、その祈り、とっても温かいです。私もそんな風になりたいです。", "疲れたら、いつでも言ってくださいね。私がヒールしますから！"],
                            // 特別衣装時のセリフ
                            summer_beach_costume: ["この水着、どうですか？えへへ、ちょっと恥ずかしいですけど、動きやすいです！", "なんだか、海に来たみたいでわくわくしますね！", "この格好だと、ヒールする時にちょっと気合が入ります！"],
                            summer_beach_costume_lowHp: ["ひゃっ…！水着だと、ちょっとした傷も目立ちますね…。", "だ、大丈夫です！これくらいなら、まだヒールできますから！"],
                            summer_beach_costume_shrunk: ["わわっ、水着のまま小さくなっちゃいました…！なんだか、お人形さんみたいです…！", "この格好で小さいと、波にさらわれちゃいそうですぅ…！"],
                            summer_beach_costume_stripped: ["ひゃあああっ！？水着まで取られちゃうなんて…！もう、何もありません…！", "ふぇぇ…！だ、誰かタオルを…！うぅ、恥ずかしいですぅ…！"],
                            summer_beach_costume_grown: ["わわっ、水着のまま大きくなっちゃいました！なんだか、モデルさんみたいで恥ずかしいです…！", "この格好で大きいと、なんだかすごく目立ちますね…！"],

                            summer_onsen_costume: ["この格好、温泉みたいで落ち着きますね…。いつでもお背中、流しますよ！", "ふふっ、なんだかみんなで温泉旅行に来たみたいで楽しいです！", "タオル一枚だと、ちょっと動きにくいですけど…頑張ります！"],
                            summer_onsen_costume_lowHp: ["きゃっ…！タオルがはだけちゃいそうです…！", "だ、大丈夫です！これくらい、平気ですから…！"],
                            summer_onsen_costume_shrunk: ["わわっ、タオルのまま小さくなっちゃいました…！これじゃあ、タオルに埋もれちゃいますぅ…！", "この格好で小さいと、湯船で溺れちゃいそうです…！"],
                            summer_onsen_costume_stripped: ["ひゃあああっ！？タオルまで取られちゃうなんて…！もう、隠すものが何も…！", "ふぇぇ…！み、見ないでくださいぃ…！うぅ…！"],
                            summer_onsen_costume_grown: ["わわっ、タオルのまま大きくなっちゃいました！なんだか、お相撲さんみたいです…！", "この格好で大きいと、タオルがはだけちゃいそうで、すごく心配です…！"],
                            liberated_beach: ["太陽の光が、私のすべてを照らしてくれます…！なんだか、女神様になったみたいです…！", "この格好なら、もっとたくさんの人を癒せる気がします！えへへ！"],
                            liberated_onsen: ["温泉の湯気が、私を優しく包んでくれます…。もう、何も恥ずかしくなんてありません…。", "このまま、自然と一つになりたいです…。ふふっ。"],
                        },
                        summer_all_tiny_play: [{
                            chars: ['リリカ', 'ユイ'],
                            lines: ["ユイちゃん、ちっちゃいね。リリカの指の上で踊れちゃいそう。", "リリカさんこそ、お人形さんみたいで可愛いです。"]
                        }, {
                            chars: ['ミコ', 'リリィ'],
                            lines: ["リリィちゃん、アリさんとおんなじサイズだね！", "ミコちゃんもね。二人でいれば、敵にも見つからないかも！"]
                        }],
                        summer_all_grown_play: [{
                            chars: ['リリカ', 'ユイ'],
                            lines: ["ユイちゃん、おっきいね！なんだか、頼もしいな…。", "リリカさんこそ、モデルさんみたいで素敵です…！"]
                        }, {
                            chars: ['ミコ', 'リリィ'],
                            lines: ["リリィちゃん、巨人さんみたい！かっこいい！", "ミコちゃんもね！二人でなら、どんな敵も倒せそうだ！"]
                        }, {
                            chars: ['リリカ', 'リリィ'],
                            lines: ["リリィちゃん、見下ろされるのって、なんだかドキドキしちゃうね…", "ふふっ、リリカちゃんも可愛いよ。もっと大きくしてあげようか？"]
                        }, {
                            chars: ['ユイ', 'ミコ'],
                            lines: ["ミコちゃん、大きくて、なんだか安心します…。", "ユイちゃんもだよ！ぎゅーってしたくなっちゃう！"]
                        }],
                        // サマータイム・スペシャルライブ！専用掛け合い
                        summer_beach_pair: [{
                            chars: ['リリカ', 'ユイ'],
                            lines: ["見てみて、ユイちゃん！この貝殻、すっごく綺麗！", "本当ですね、リリカさん！まるで宝石みたいです！"]
                        }, {
                            chars: ['ミコ', 'リリィ'],
                            lines: ["リリィちゃん、見て！砂でモコ作ったんだ！", "わー、上手だね！じゃあ私は、その隣におっきなゴーレムくんを作ろっかな！"]
                        }, {
                            chars: ['リリカ', 'ミコ'],
                            lines: ["ミコちゃん、あそこのかき氷屋さん、どっちが早く着くか競争だよ！", "わーい！負けないぞー！モコ、応援しててね！"]
                        }, {
                            chars: ['ユイ', 'リリィ'],
                            lines: ["リリィさん、日差しが強いので、これを…。日焼け止めです。", "ありがとう、ユイちゃん！気が利くね！一緒に塗ろっか！"]
                        }, {
                            chars: ['リリカ', 'リリィ'],
                            lines: ["ねえねえリリィちゃん、あっちの岩場、探検してみない？お宝があるかも！", "いいね！冒険の予感！よーし、どっちが先に見つけるか勝負だ！"]
                        }, {
                            chars: ['ユイ', 'ミコ'],
                            lines: ["ミコちゃん、あまり遠くへ行くと危ないですよ。波にさらわれたら大変です。", "はーい！大丈夫だよ、ユイちゃん！モコがちゃんと見ててくれるもん！"]
                        }, {
                            chars: ['リリカ', 'ユイ'],
                            lines: ["砂のお城、どっちが大きいの作れるか勝負だよ、ユイちゃん！", "ふふ、望むところです！私のお城には、教会も作りますから！"]
                        }, {
                            chars: ['ミコ', 'リリィ'],
                            lines: ["リリィちゃん、見て！ヒトデさんがいたよ！お星さまみたい！", "本当だ、かわいいね！でも、ちゃんとお海に帰してあげようね。"]
                        }, ],
                        summer_onsen_pair: [{
                            chars: ['リリカ', 'ユイ'],
                            lines: ["やっぱりライブの後は温泉だよねー！極楽、極楽！", "ふふ、リリカさん、おじさんみたいですよ。でも、気持ちいいですね。"]
                        }, {
                            chars: ['ミコ', 'リリィ'],
                            lines: ["わーい、広いお風呂！リリィちゃん、向こうまで競争だよ！", "こらこら、ミコちゃん。温泉では静かに入るんだよ。…まあ、私もちょっとだけなら…。"]
                        }, {
                            chars: ['リリカ', 'ミコ'],
                            lines: ["ミコちゃん、見て！お空にお星さまがいっぱいだよ！", "本当だー！キラキラしてて、お砂糖みたいだね！"]
                        }, {
                            chars: ['ユイ', 'リリィ'],
                            lines: ["リリィさん、少しのぼせてしまったかもしれません…。少し休みますね。", "大丈夫？無理しないで。はい、お水。ゆっくり飲んでね。"]
                        }, {
                            chars: ['リリカ', 'リリィ'],
                            lines: ["ふぅ～、極楽極楽…。ねえリリィちゃん、今度みんなで温泉旅行もいいね！", "さんせーい！美味しいものいっぱい食べて、また温泉入って…最高だね！"]
                        }, {
                            chars: ['ユイ', 'ミコ'],
                            lines: ["ミコちゃん、お背中流しましょうか？", "ほんと！？ありがとう、ユイちゃん！じゃあミコも、ユイちゃんの背中ごしごししてあげる！"]
                        }, ],
                        summer_beach_stripped_pair: [{
                            chars: ['リリカ', 'ユイ'],
                            lines: ["きゃっ！ユイちゃんも！？こ、これは…真夏のセクシーハプニングって感じ！？", "ふぇぇ…！リリカさんまで…！もう、恥ずかしくて砂に埋まりたいですぅ…！"]
                        }, {
                            chars: ['ミコ', 'リリィ'],
                            lines: ["わわっ！リリィちゃんも水着が…！", "ミコちゃんこそ！…まあ、こうなったらビーチのマーメイドってことで、どう？"]
                        }, {
                            chars: ['リリカ', 'ミコ'],
                            lines: ["ミコちゃんも大胆だねー！もう、二人でアイドルユニット組んじゃう？", "ええっ！？恥ずかしいけど…モコが見てるから、頑張る…！"]
                        }, {
                            chars: ['ユイ', 'リリィ'],
                            lines: ["リリィさんまで…！もう、どうしたら…！", "大丈夫だって、ユイちゃん。誰も見てない、見てない！…たぶん。"]
                        }, ],
                        summer_onsen_stripped_pair: [{
                            chars: ['リリカ', 'ユイ'],
                            lines: ["きゃっ！ユイちゃんも！？こ、これは…禁断のセクシーデュエットって感じ！？", "ふぇぇ…！リリカさんまで…！もう、恥ずかしくてお湯に沈んじゃいそうですぅ…！"]
                        }, {
                            chars: ['ミコ', 'リリィ'],
                            lines: ["わわっ！リリィちゃんもタオルが…！", "ミコちゃんこそ！…まあ、こうなったら温泉の女神様ってことで、どう？"]
                        }, {
                            chars: ['リリカ', 'リリィ'],
                            lines: ["リリィちゃんもやっちゃったんだ！ふふ、私たち、気が合うね！", "もー、リリカちゃんは楽しそうだね！…まあ、私もだけど！"]
                        }, {
                            chars: ['ユイ', 'ミコ'],
                            lines: ["ミコちゃんまで…！だ、だめです！ちゃんと隠さないと…！", "ユイちゃん、顔まっかだよ？温泉のせいかな？"]
                        }, ],
                        summer_beach_liberated_pair: [{
                            chars: ['リリカ', 'ユイ'],
                            lines: ["ユイちゃん、見てみて！もう何も怖くないよ！これぞ真のアイドルの姿！", "は、はいぃ…！リリカさんがそう言うなら…！私も、覚悟を決めます！"]
                        }, {
                            chars: ['ミコ', 'リリィ'],
                            lines: ["リリィちゃん！ミコね、なんだか無敵な気分だよ！", "ふふ、わかるよミコちゃん！私たち、太陽と友達になったみたいだね！"]
                        }, {
                            chars: ['リリカ', 'ミコ'],
                            lines: ["ミコちゃん、このままステージに立っちゃう！？伝説の始まりだよ！", "うん！モコも賛成してる！伝説のライブ、やっちゃおう！"]
                        }, {
                            chars: ['ユイ', 'リリィ'],
                            lines: ["リリィさん…！もう、怖いものなんてありませんね！", "その意気だよ、ユイちゃん！私たち、生まれ変わったんだ！"]
                        }, ],
                        summer_onsen_liberated_pair: [{
                            chars: ['リリカ', 'ユイ'],
                            lines: ["ふふーん、ユイちゃん。もうタオルなんて野暮なもの、いらないよね？", "リリカさん…！もう、どこまで大胆なんですか…！でも、なんだかスッキリしますね！"]
                        }, {
                            chars: ['ミコ', 'リリィ'],
                            lines: ["リリィちゃん、お空の星が全部見えるよ！すっごく綺麗！", "本当だね、ミコちゃん。心も体も、ぜーんぶ解き放たれたみたい。"]
                        }, {
                            chars: ['リリカ', 'リリィ'],
                            lines: ["このまま月光浴びてたら、女神様になっちゃうかも！", "いいね！月の女神リリカと星の女神リリィって感じ？最強じゃん！"]
                        }, ],
                        summer_beach_all_liberated: [{
                            chars: ['リリカ', 'ユイ', 'ミコ', 'リリィ'],
                            lines: ["みんなー！見て！私たち、ビーチの女神になっちゃった！", "め、女神様ですか！？そ、そんな、大げさですよぉ…！", "わーい！女神様ごっこだ！ミコは風の女神！", "じゃあ私は大地の女神かな？ふふ、なんだか楽しくなってきたね！"]
                        }, {
                            chars: ['リリィ', 'ミコ', 'ユイ', 'リリカ'],
                            lines: ["もう何も隠すものなんてないね！これぞ究極の開放感！", "うん！鳥さんになった気分だよ！", "は、恥ずかしいですけど…でも、なんだか清々しいです！", "でしょー！これが本当の私たち！さあ、伝説の始まりだよ！"]
                        }, ],
                        summer_onsen_all_liberated: [{
                            chars: ['リリカ', 'ユイ', 'ミコ', 'リリィ'],
                            lines: ["見て、みんな！私たち、温泉の妖精さんだよ！", "ふぇぇ…妖精さんですか…？なんだか、恥ずかしいような、でも…！", "ミコは湯気の妖精！ふわふわだよー！", "いいね！じゃあ私は岩の妖精！…って、それじゃ可愛くないか！あはは！"]
                        }, {
                            chars: ['ユイ', 'リリィ', 'ミコ', 'リリカ'],
                            lines: ["皆さん…もう、何も言うことはありません…。", "ふふ、ユイちゃんが一番楽しんでるんじゃない？", "ミコね、今ならお魚さんとお話しできる気がする！", "わかるー！私たち、自然と一体になったんだよ！"]
                        }, ],
                        summer_beach_party: [{
                            chars: ['リリカ', 'ユイ', 'ミコ', 'リリィ'],
                            lines: ["みんなー！ビーチライブ、最高に盛り上がったね！", "はい！お客さんの笑顔、キラキラしてました！", "ミコもね、モコと一緒にいっぱい応援したんだよ！", "うん、最高のステージだったね！この後の打ち上げも楽しみ！"]
                        }, {
                            chars: ['リリィ', 'ミコ', 'ユイ', 'リリカ'],
                            lines: ["見てみて、すっごく大きなスイカ！みんなでスイカ割りしようよ！", "わーい！ミコ、一番に割るー！", "ふふ、ミコちゃん、棒はそっちじゃありませんよ。", "もー！ユイちゃんが一番上手だったりして！"]
                        }, {
                            chars: ['ミコ', 'リリカ', 'ユイ', 'リリィ'],
                            lines: ["見て！あのおっきな雲、ソフトクリームみたい！", "ほんとだ！あっちのはクジラさんみたいだね！", "ふふ、皆さん、想像力が豊かですね。", "平和だねぇ。こういう時間も、冒険の醍醐味だよね。"]
                        }, ],
                        summer_onsen_party: [{
                            chars: ['リリカ', 'ユイ', 'ミコ', 'リリィ'],
                            lines: ["温泉、最高ー！ライブの疲れが全部吹っ飛ぶね！", "本当ですね…。お肌もつるつるになる気がします。", "ミコ、もうちょっとで泳いじゃうところだったよ！危ない、危ない！", "ふふ、みんなでのぼせないように気をつけないとね。"]
                        }, {
                            chars: ['ユイ', 'リリィ', 'リリカ', 'ミコ'],
                            lines: ["温泉まんじゅう、買ってきました。皆さんでいただきましょう。", "わーい、ありがとうユイちゃん！美味しそう！", "温泉の後に食べるおまんじゅうは格別だよねー！", "モコにもちょうだい！…って、ミコが言ってるよ！"]
                        }, {
                            chars: ['リリィ', 'ユイ', 'リリカ', 'ミコ'],
                            lines: ["ねえ、みんなで恋バナとかしない？こういう時の定番でしょ！", "こ、恋バナですか！？そ、そんな、私には…！", "いいねー！じゃあまずリリィちゃんから！", "えーっ！？ミコからがいい！"]
                        }, ],
                        // ベアトリス (アルケミスト): 知的、大人、丁寧語。
                        'ベアトリス': {
                            default: ["ふむ、このダンジョンの構造、興味深いですね。", "皆さん、消耗品は足りていますか？私のほうでいくつか合成できますが。", "この空気の淀み…錬金術の素材になりそうな気配がしますわ。", "アカリさん、あまり突っ走ると危険ですよ。", "ヒカリさん、その魔導書、少し見せてもらっても？", "シズカさん、その大盾、素晴らしいですね。どんな金属で？", "ユイさん、いつも助かりますわ。ありがとう。", "リリカさん、その舞、戦場を和ませますわね。", "サクヤさん、その剣筋、見事ですわ。", "シャオメイさん、その拳、岩をも砕きそうですね。"],
                            lowHp: ["あら…少し計算が狂いましたわね。", "大丈夫です。まだ研究の途中ですから。", "この程度の傷、ポーションでどうにでもなりますわ。"],
                            allyLowHp: ["{name}さん、ご無理なさらず。私が援護しますわ。", "どなたか、{name}さんの回復を。"],
                            shrunk: ["あらあら、小さくなってしまいましたわ。実験動物の気持ちが少しわかりますわね。", "このサイズですと、試薬の調合が難しいですわね。", "フラスコを運ぶのも一苦労ですわ。"],
                            shrunk_100: ["あら、視界が随分と低くなりましたわね。実験台のフラスコを見上げるようですわ。"],
                            shrunk_70: ["この身長ですと、本棚の高い場所にある文献に手が届きませんわね。"],
                            shrunk_50: ["半分ですか。なるほど、世界のスケール感が全く違って見えますわね。興味深い。"],
                            shrunk_30: ["ここまで小さいと、錬金術の釜をかき混ぜるのも一苦労ですわ。"],
                            shrunk_10: ["ふふ、まるで小人のようですわね。敵から見れば、ただの虫けらにしか見えないかもしれませんわ。"],
                            shrunk_1: ["…フラスコの中の微生物と、同じ視点になりましたわ。これは新発見ですわね。"],
                            stripped: ["…これは、非科学的な現象ですわね。", "…合理的ではありませんわ。早く服を見つけませんと。", "…見てはいけませんわよ。"],
                            allyShrunk: ["{name}さん、可愛らしいサイズになりましたわね。", "あら、{name}さん。そこにいらっしゃいましたの。"],
                            grown: ["ふふ、大きくなりましたわ。これで高い場所の素材も採集できますわね。", "見晴らしが良くて、戦況の分析がしやすいですわ。"],
                            grown_max: ["あらあら、ついに限界値ですか。素晴らしいデータが取れましたわ。", "これ以上の成長は、現在の科学では説明できませんわね。"],
                            allyGrown: ["あら、{name}さん。大きくなられて。頼もしいですわね。", "{name}さん、その巨体、敵の的になりやすいのでご注意を。"],
                            allyNew: ["新しい仲間…{name}さん、ですわね。あなたの能力、見せていただきましょう。"],
                            stripped_shrunk: ["…これは、想定外の事態ですわ。小さくて、服もないなんて。", "…隠れる場所を探しませんと。このままでは実験どころではありませんわ。"],
                            solo_stripped_tiny: ["あらあら…これは、非常に非合理的な状況ですわね。", "（フラスコの後ろに隠れて、体を丸めている）", "この状況、錬金術でどうにかならないかしら…？", "…誰か来たら、ネズミのふりをしましょうか。"],
                            dollhouse_explore_giant: ["ふむ、この家の建材、興味深いですわね。分析の価値がありそうですわ。", "失礼しますわよ。何か珍しい素材はないかしら…？", "このサイズ感…ドールハウスの設計にも応用できそうですわね。"],
                            cracked_rock_tiny: ["ふむ、この亀裂…内部の鉱石サンプルを採取する好機ですわ。", "このサイズなら、岩の内部構造を直接観察できますわね。行ってまいります。", "何か珍しい鉱物が隠されているかもしれませんわ。"],
                            liberated: ["ふふ、これぞ機能美の極致ですわ。無駄な装飾を排した、完璧なフォルム…。", "私の知性も、肉体も、全てを白日の下に晒しましょう。さあ、観察なさい。", "この方が、薬品の調合もスムーズですわ。合理的です。"],
                            dollhouse_explore: ["ふむ、この家の建材、興味深いですわね。分析の価値がありそうですわ。", "失礼しますわよ。何か珍しい素材はないかしら…？", "このサイズ感…ドールハウスの設計にも応用できそうですわね。"],
                            cracked_rock_break: ["この岩の組成なら…この薬品で脆くなるはずですわ。ほら。", "ふふ、力だけが全てではありませんのよ。", "錬金術にかかれば、このような障害、無いに等しいですわ。"],
                            fairy_shrunk: ["ふふ、この視点、新しい発見がありそうですわ。", "世界の構成要素を、よりミクロな視点で観察できる…素晴らしいですわ！", "この体、空気抵抗が最小限ですわね。移動が効率的です。"],
                            allyStripped_shrunk: ["あらあら、{name}さん。それは大変なことになりましたわね。", "私が何か羽織るものを作って差し上げますわ。少しお待ちになって。"],
                            stripped_pair: ["{name}さんもですの？…これは、非常に気まずい状況ですわね。", "お互い、見なかったことにしましょう。ええ、それが合理的ですわ。"],
                            allyStripped: ["{name}さん、大丈夫ですの？私のコートをお使いになりますか？", "…敵の悪趣味には、付き合いきれませんわね。"],
                            high_mouse_hole_giant: ["ふふ、私の肩をお貸ししますわ。さあ、どうぞ。", "この高さですと、肩車が最も合理的な手段ですわね。"],
                            high_mouse_hole_tiny: ["これは興味深い構造ですわね。内部を調査してまいります。", "失礼しますわ。何か面白いサンプルが見つかると良いのですが。"],
                            high_mouse_hole_all_tiny: ["あらあら、これは物理的に不可能ですわね。", "全員で縦に並んでも、この高さには届きませんわ。計算するまでもありません。", "飛行能力を持つ個体がいないのが悔やまれますわね。", "諦めましょう。時間の無駄ですわ。"],
                            shame_pillory: ["あらあら…これは、非科学的な拘束ですわね。", "…この粘液、サンプルとして採取しておきたいくらいですわ。", "（冷静に状況を分析しようとしているが、顔が少し赤い）"],
                            shrunk_pair: ["ふふ、{name}さんも小さいですのね。なんだか、小動物のようで可愛らしいですわ。", "二人でいれば、敵の死角を突くのも容易いですわね。"],
                            pair_アカリ: ["アカリさん、その剣、錬金術で強化できそうですわね。", "あなたのそのエネルギー、どこから湧いてくるのですか？興味深いですわ。", "あまり無鉄砲な行動は感心しませんわよ。もう少し、合理的に。"],
                            pair_ヒカリ: ["ヒカリさん、その魔術、私の錬金術とは異なる体系ですわね。議論の価値がありそうですわ。", "静かな方ですのね。研究に集中できそうで、好感が持てますわ。"],
                            pair_シズカ: ["シズカさん、その盾、素晴らしい硬度ですわね。どんな合金ですの？", "あなたの守りがあれば、安心して研究に打ち込めますわ。"],
                            pair_ユイ: ["ユイさん、いつもありがとう。あなたの回復魔法、非科学的ですが効果は絶大ですわね。", "その優しさ、貴重なサンプルですわ。"],
                            pair_リリカ: ["リリカさん、その舞、人々の精神に作用する…興味深いですわ。", "あなたの発するエネルギー、測定してみたいですわね。"],
                            pair_サクヤ: ["サクヤさん、その剣技、物理法則を超越していますわね。素晴らしい。", "その精神集中、解明したいものですわ。"],
                            pair_シャオメイ: ["シャオメイさん、そのパワーの源は、その食欲ですの？", "あなたの身体能力、研究対象として非常に魅力的ですわ。"],
                            pair_エリザ: ["エリザさん、医学と錬金術、通じるものがありますわね。今度、ぜひ議論を。", "あなたの薬、成分を分析させていただけませんこと？"],
                            pair_ルナ: ["ルナさん、その運、確率論で説明できますの？", "ギャンブルは非合理的ですが…そのスリル、少しだけ理解できますわ。"],
                            pair_クロエ: ["クロエさん、その鎌、魂を刈る…？非科学的ですが、非常に興味深いですわ。", "あなた自身も、研究対象として魅力的ですわね。"],
                            pair_ミコ: ["ミコさん、その召喚術、異次元の生物を呼び出しているのですの？", "そのモコという生物、サンプルを少しいただけませんこと？"],
                            pair_レンカ: ["レンカさん、死霊術…生命の理を冒涜する行為。ですが、その力、認めざるを得ませんわ。", "その魂、どこからエネルギーを得ているのですの？"],
                            pair_イオリ: ["イオリさん、先輩でしたのね。その守り、錬金術の防壁とは違う原理のようですわ。", "その病、研究すれば治療法が見つかるかもしれませんわ。"],
                            pair_コハル: ["コハルさん、あなたの行動は、因果律を無視しているようですわね。観測対象として最適ですわ。", "次は何が起こるのか…楽しみですわ。"],
                            pair_オリビア: ["オリビアさん、その祈り、高エネルギー反応を観測しましたわ。素晴らしい。", "聖なる力…科学で解明できるかしら。"],
                            pair_レンカ: ["レンカさん、死霊術…生命の理を冒涜する行為。ですが、その力、認めざるを得ませんわ。", "その魂、どこからエネルギーを得ているのですの？"],
                            pair_セレスティア: ["聖女…その聖なる力の源、非常に興味深いですわ。少し調査させていただけませんこと？", "あなたのその力、科学では説明できない現象ですわね。素晴らしい研究対象ですわ。"],
                            pair_イオリ: ["イオリさん、先輩でしたのね。その守り、錬金術の防壁とは違う原理のようですわ。", "その病、研究すれば治療法が見つかるかもしれませんわ。"],
                            pair_コハル: ["コハルさん、あなたの行動は、因果律を無視しているようですわね。観測対象として最適ですわ。", "次は何が起こるのか…楽しみですわ。"],
                            pair_オリビア: ["オリビアさん、その祈り、高エネルギー反応を観測しましたわ。素晴らしい。", "聖なる力…科学で解明できるかしら。"],
                        },
                        // リリカ (ダンサー): 明るい、アイドル、ファンサービス精神旺盛。
                        'リリカ': {
                            default: ["みんなー！リリカのステージ、始まるよー！", "このダンジョンも、リリカのステージにしちゃえばいいんだ！", "みんなの応援がリリカの力になるから、よろしくね！", "アカリちゃん、元気いっぱいだね！リリカも負けないよ！", "ヒカリちゃん、クールだね！そういうのもファンの心を掴むんだよね！", "シズカさん、頼りになります！リリカの最高のSPさんですね！", "ユイちゃん、いつもありがとう！リリカの専属ヒーラーさんだね！", "ベアトリスさん、知的で素敵！リリカに新しい衣装のデザイン、お願いしちゃおうかな？", "サクヤちゃん、その真剣な眼差し、キュンとしちゃう！", "シャオメイちゃん、ちっちゃくて可愛いのにパワフル！ギャップ萌えってやつだね！"],
                            lowHp: ["きゃっ！ちょっとステージから足を踏み外しちゃった！", "大丈夫！これくらいじゃ、リリカのパフォーマンスは止まらないよ！", "今の攻撃、ちょっと痛かったかも…。でも、笑顔は絶やさないよ！"],
                            allyLowHp: ["{name}ちゃん、大丈夫！？無理しないで、リリカがヘイトを集めるから！", "みんな！{name}ちゃんがピンチだよ！応援してあげて！"],
                            shrunk: ["あれれ？リリカ、ちっちゃくなっちゃった！ミニリリカも可愛いって言ってくれるかな？", "このサイズなら、妖精さんの役もできちゃうかも！", "マイクを持つのが大変！でも、歌声は変わらないよ！"],
                            shrunk_100: ["ステージがすっごく大きく見える！でも、リリカのパフォーマンスは小さくならないよ！"],
                            shrunk_70: ["この身長なら、新しいダンスの振り付けも思いついちゃうかも！ちびっこステップ！"],
                            shrunk_50: ["ミニリリカだよー！みんな、ちゃんと見えてるー？"],
                            shrunk_30: ["マイクスタンドが高すぎるよぉ！誰か、リリカ専用のミニマイク持ってきてー！"],
                            shrunk_10: ["もう、みんなの靴の上で踊れちゃいそう！ポケットに入れてくれたら、そこでライブしちゃうよ！"],
                            shrunk_1: ["リリカ、ステージから落っこちたら見つからないかも！みんな、絶対キャッチしてね！"],
                            stripped: ["きゃー！みんなのエッチ！見ちゃダメだよー！", "こ、こんな姿、ファンのみんなには見せられないよぉ…！", "でも…これも新しいコンセプトってことにすれば…アリかも？"],
                            allyShrunk: ["わー、{name}ちゃんがミニサイズに！可愛いー！", "{name}ちゃん、リリカのポケットに入っちゃう？"],
                            grown: ["わーい！大きくなったよ！これならステージがもっと映えるね！", "みんなー！大きくなったリリカも、ちゃーんと見ててね！"],
                            grown_max: ["見てみてー！リリカ、こんなにおっきくなっちゃった！もう、これ以上は無理みたい！", "これがリリカの最大級のパフォーマンスだよ！"],
                            allyGrown: ["わぁ、{name}ちゃん、おっきーい！見上げちゃうね！", "{name}ちゃん、そのままだと天井で頭ぶつけちゃうよ！気をつけて！"],
                            allyNew: ["新しいファン…じゃなくて、仲間だね！{name}ちゃん、よろしくね！リリカが最高のステージを見せてあげる！"],
                            stripped_shrunk: ["ひゃあ！ちっちゃい上にこの格好は、さすがにマズいよぉ！", "こ、これじゃあ、ただの恥ずかしい子だよぉ…！早く服を見つけなきゃ！"],
                            solo_stripped_tiny: ["ひゃーん！こんな姿、誰にも見せられないよぉ！", "（きのこの傘の下に隠れて、膝を抱えている）", "リリカのアイドル生命、終わっちゃうかも…！", "でも…これも新しいキャラ付けってことにすれば…！ううん、無理！"],
                            dollhouse_explore_giant: ["きゃー！巨人さんのお家！？リリカの新しいステージにぴったりじゃない？", "おじゃましまーす！ここでゲリラライブしちゃうよー！", "見てみて！このお家、リリカのドールハウスみたい！…って、大きすぎ！"],
                            cracked_rock_tiny: ["きゃー！秘密の通路みたい！リリカが探検してきちゃうよ！", "この隙間の向こうに、キラキラのお宝がある予感！", "ミニミニ探検隊、出動！みんな、応援しててね！"],
                            liberated: ["みんなー！見てー！これがリリカの最終形態だよ！", "もう何も隠さない！リリカの全部、受け止めて！", "ふふん、これぞ究極のファンサービスってね！"],
                            dollhouse_explore: ["きゃー！可愛いお家！リリカの新しいステージにぴったりじゃない？", "おじゃましまーす！ここでゲリラライブしちゃうよー！", "見てみて！このお家、リリカのドールハウスみたい！"],
                            cracked_rock_break: ["みんなー！リリカのパワフルなステージ、見ててね！せーのっ！", "こんな岩、リリカの情熱で溶かしちゃう！", "これでリリカのステージが広くなったね！"],
                            fairy_shrunk: ["ミニミニリリカだよー！みんな、ちゃんと見ててね！", "このサイズなら、マスコットとしてデビューできちゃうかも！", "ポケットに入れてくれたら、そこでスペシャルライブしちゃうよ！"],
                            allyStripped_shrunk: ["{name}ちゃん、大丈夫！？リリカのステージ衣装、貸してあげる！ちょっと小さいかもだけど！", "なんてことするの！{name}ちゃんに！絶対許さないんだから！"],
                            stripped_pair: ["え、{name}ちゃんも！？こ、これは…禁断のデュエットって感じ！？", "二人でこうしてたら、逆に芸術っぽく見えないかな？…見えないかぁ。"],
                            allyStripped: ["{name}ちゃん、大変！リリカのタオル、使って！", "もう！敵のセンス、サイテー！リリカがステージから退場させてあげる！"],
                            high_mouse_hole_giant: ["はーい、リリカのスペシャルリフトだよー！最高の景色、楽しんでってね！", "リリカがおっきくしてあげる！しっかり掴まっててね、未来のスター！"],
                            high_mouse_hole_tiny: ["きゃー、高い！まるでステージのセットみたい！お宝、見つけてくるから応援しててね！", "任せて！リリカがキラキラのお宝、ゲットしてきちゃうから！"],
                            high_mouse_hole_all_tiny: ["うー、あんな高いところ、全然届かないよぉ！", "みんなでジャンプしてもダメだね…。悔しい！", "リリカの歌声で、お宝をこっちに呼び寄せられないかな？", "あきらめないで！きっと何か方法があるはず！…ないかなぁ。"],
                            shame_pillory: ["きゃー！何これ！こんなの、ステージの演出にないよぉ！", "だ、だめ！こんな姿、ファンのみんなには見せられない…！", "（ぷるぷる…）でも、これも新しいコンセプトってことにすれば…アリかも…？"],
                            shrunk_pair: ["{name}ちゃんも小さいんだね！二人で『ちびっこアイドルユニット』結成しちゃう？", "二人でいれば怖くないね！手、繋いでいこ！"],
                            pair_アカリ: ["アカリちゃん、元気いっぱいだね！リリカも負けてられないな！", "その剣、ステージの小道具にどうかな？キラキラしてて映えそう！"],
                            pair_ヒカリ: ["ヒカリちゃん、クールビューティーだね！そういうのもファンの心を掴むんだよ！", "たまには笑ってよー！ね？"],
                            pair_シズカ: ["シズカさん、頼りになります！リリカの最高のSPさんですね！", "シズカさんがいれば、どんなステージでも安心だよ！"],
                            pair_ユイ: ["ユイちゃん、いつも応援ありがとう！リリカの一番のファンだね！", "サイン？もちろんいいよ！どこに書こうかな？", "ユイちゃんがいると、リリカ、安心してステージに立てるんだ！"],
                            pair_ベアトリス: ["ベアトリスさん、知的で素敵！リリカに新しい衣装のデザイン、お願いしちゃおうかな？", "その薬、飲むとキラキラになれる薬？"],
                            pair_サクヤ: ["サクヤちゃん、その真剣な眼差し、キュンとしちゃう！リリカのファンにならない？", "その刀、マイクみたいに持って歌ってみない？"],
                            pair_シャオメイ: ["シャオメイちゃん、ちっちゃくて可愛いのにパワフル！ギャップ萌えってやつだね！", "今度一緒にダンスの練習しない？"],
                            pair_エリザ: ["エリザさん、スタイル抜群だね！リリカも負けてられないな！", "その注射、美容注射だったりする？"],
                            pair_ルナ: ["ルナちゃん、勝負好きだね！じゃあ、どっちがファンを多く集められるか勝負しよ！", "リリカのライブ、賭けの対象にしてみる？絶対勝つよ！"],
                            pair_クロエ: ["クロエちゃん、ミステリアスで可愛い！新しいアイドルのコンセプトにどうかな？", "もっと声聞かせてよー！"],
                            pair_ミコ: ["ミコちゃんも可愛いね！モコちゃんと一緒にユニット組まない？", "召喚するとき、決めポーズとか考えようよ！"],
                            pair_レンカ: ["レンカさん、大人っぽくてセクシーだね！リリカも見習わなきゃ！", "その魔法、ステージ演出に使えそう！"],
                            pair_イオリ: ["イオリ先輩！小さくても頼りになるなんて、ギャップが素敵です！", "先輩のことも、リリカが応援しちゃいます！"],
                            pair_コハル: ["コハルちゃん、見ててハラハラするけど、そこがまた可愛い！", "失敗しても、リリカがアンコールで盛り上げるから大丈夫だよ！"],
                            pair_オリビア: ["オリビアちゃん、その清楚な感じ、王道アイドルって感じだね！", "その祈りのポーズ、リリカも今度取り入れてみようかな！"],
                            // サマータイム・スペシャルライブ！
                            beach_liberation_prompt: ["ふふっ、このビーチの熱気、リリカを大胆にさせちゃうみたい！ねえ、もっとアツくならない？"],
                            beach_liberation_stop: ["えー、つまんないの。まあ、ファンの言うことなら聞いてあげよっかな！"],
                            onsen_liberation_prompt: ["この温泉、最高に気持ちいい！なんだか、心も体もぜーんぶ解き放ちたくなっちゃうなー！"],
                            onsen_liberation_stop: ["ちぇっ、せっかくのチャンスなのに。まあ、また今度ね！"],

                            summer_beach: [
                                "見てみて、この水着！リリカのために作られたみたいでしょ！",
                                "ビーチでのライブなんて最高！みんな、盛り上がってるー？",
                                "砂浜でダンスの練習！これもトレーニングだよね！",
                                "ユイちゃん、日焼け止めちゃんと塗った？リリカが塗ってあげようか？"
                            ],
                            onsen_towel_trouble: ["きゃー！ちょっと、タオルが…！で、でも、これもファンサービスってことで許して！"],
                            summer_onsen: ["温泉、気持ちい～！ライブの疲れが吹飛ぶね！", "このタオル、ちょっと危なくない！？でも、これもファンサービスってことで！", "温泉といえば卓球だよね！負けないよー！", "ミコちゃん、温泉でゴーレム召喚したらお湯が溢れちゃうよ！"],
                            giant_among_tinies: ["みんな、ちっちゃくて可愛い！リリカがおっきく守ってあげるね！", "ミニミニ軍団を引き連れる巨大アイドル、リリカだよー！みんな、ちゃんとついてきてね！"],
                            pair_レンカ: ["レンカさん、大人っぽくてセクシーだね！リリカも見習わなきゃ！", "その魔法、ステージ演出に使えそう！"],
                            pair_セレスティア: ["セレスティアちゃん、ミステリアスで素敵！新しいアイドルのコンセプトになりそう！", "リリカの歌で、セレスティアちゃんを応援しちゃうからね！"],
                            pair_イオリ: ["イオリ先輩！小さくても頼りになるなんて、ギャップが素敵です！", "先輩のことも、リリカが応援しちゃいます！"],
                            pair_コハル: ["コハルちゃん、見ててハラハラするけど、そこがまた可愛い！", "失敗しても、リリカがアンコールで盛り上げるから大丈夫だよ！"],
                            pair_オリビア: ["オリビアちゃん、その清楚な感じ、王道アイドルって感じだね！", "その祈りのポーズ、リリカも今度取り入れてみようかな！"],
                            // 特別衣装時のセリフ
                            summer_beach_costume: ["この水着、どう？似合ってる？ダンジョンの中でも、リリカはいつでもアイドルだからね！", "ビーチ気分でテンション上がっちゃう！このままライブ始めちゃおうかな！", "水着だと、ダンスもいつもよりキレッキレになっちゃうかも！"],
                            summer_beach_costume_lowHp: ["きゃっ！ちょっとはしゃぎすぎちゃった！でも、これくらいじゃリリカのステージは終わらないよ！", "水着だと、ちょっとした傷も目立っちゃうな…。でも、ファンのみんなには笑顔を見せないと！"],
                            summer_beach_costume_shrunk: ["あれれ？水着のままちっちゃくなっちゃった！ミニミニアイドル・リリカだよ！", "このサイズなら、砂のお城に住めちゃうかも！"],
                            summer_beach_costume_stripped: ["きゃー！水着まで取られちゃうなんて！これはさすがに放送事故だよぉ！", "こ、これじゃあ、ただの恥ずかしい子だよぉ…！でも、これも新しいコンセプトってことにすれば…アリかも？"],
                            summer_beach_costume_grown: ["わーい、水着のままおっきくなったよ！これなら、ステージのどこからでもリリカのこと、見えるでしょ？", "この格好で大きいと、なんだかセクシーダイナマイトって感じ！？"],

                            summer_onsen_costume: ["タオル一枚でのステージなんて、斬新じゃない？リリカ、いつでも新しいことに挑戦しちゃうよ！", "この格好、なんだかドキドキしちゃうね！でも、これもファンサービスってことで！", "温泉気分で、しっとりしたバラードでも歌っちゃおうかな。"],
                            summer_onsen_costume_lowHp: ["きゃっ！のぼせちゃったかも…。でも、リリカのステージはまだまだ続くよ！", "タオルがはだけそうで、ちょっとヒヤヒヤする！でも、それがまたスリリングでいいよね！"],
                            summer_onsen_costume_shrunk: ["あれれ？タオルのままちっちゃくなっちゃった！これじゃあ、タオルに埋もれちゃうよぉ！", "ミニミニ温泉アイドルだよ！みんな、ちゃんと見えてるー？"],
                            summer_onsen_costume_stripped: ["きゃー！タオルまで取られちゃうなんて！これはもう、R-18指定だよぉ！", "こ、これじゃあ、ファンのみんなに合わせる顔がないよぉ…！"],
                            summer_onsen_costume_grown: ["わーい、タオルのままおっきくなったよ！これなら、どんな温泉も貸し切り状態だね！", "この格好で大きいと、なんだかセクシーすぎて、みんながのぼせちゃうかも！"],
                            liberated_beach: ["見てみて！太陽の光を浴びて、リリカ、キラキラでしょ！", "ビーチの視線は、リリカが独り占めしちゃうんだから！"],
                            liberated_onsen: ["ふふっ、温泉の湯気で、もっとセクシーに見えちゃうかも？", "このまま温泉の女神様になっちゃおうかな！"],
                        },
                        // サクヤ (サムライ): 寡黙、求道的、武士。
                        'サクヤ': {
                            default: ["…道は、まだ遠い。", "…一歩一歩、踏みしめて進むのみ。", "…油断大敵。常に、刃は心と共に。", "アカリ、その勢い、悪くない。だが、隙が多い。", "ヒカリ、魔道もまた、一つの道。興味深い。", "シズカ、その守り、まさに鉄壁。見事。", "ユイ、癒しの力、感謝する。", "ベアトリス、知もまた力。侮れない。", "リリカ、その舞、心を惑わす。…だが、悪くない。", "シャオメイ、その拳、純粋な破壊の力。"],
                            lowHp: ["…不覚。まだ、修行が足りぬ。", "…この程度の傷、誉れと思えばこそ。", "…まだ、立てる。"],
                            allyLowHp: ["…{name}、下がれ。ここは拙者が。", "…{name}を狙うか。愚かな。"],
                            shrunk: ["…体が縮もうと、我が斬撃の鋭さは変わらぬ。", "…小さき体、間合いを詰めるには好都合。", "…柄を握る手に、いつもと違う感触が。"],
                            shrunk_100: ["…刀の柄を握る感覚は変わらぬ。だが、鞘が地面を擦る。"],
                            shrunk_70: ["…間合いが、遠い。踏み込みを深くする必要がある。"],
                            shrunk_50: ["…半身か。敵の懐に潜り込むには、むしろ好都合。"],
                            shrunk_30: ["…敵の足首を狙う。それもまた、一興。"],
                            shrunk_10: ["…もはや、刃と一体。我が身、弾丸となりて敵を討つ。"],
                            shrunk_1: ["…刀の柄頭の飾りに、なれそうだ。"],
                            // サクヤは脱衣状態にならない
                            allyShrunk: ["…{name}、小さくなったな。見失わぬよう、気をつけよ。", "…その身でも、戦う覚悟はあるか、{name}。"],
                            grown: ["…体が大きい。大太刀を振るうには、丁度良い。", "…見晴らしが良い。敵の位置、把握しやすし。"],
                            grown_max: ["…これ以上は、我が器を超えている。…だが、悪くない。", "…天に、手が届きそうだ。"],
                            allyGrown: ["…{name}、巨人か。頼もしい。", "…{name}、その巨体、狭い場所では足手まといにならぬよう。"],
                            allyNew: ["…{name}と申すか。拙者はサクヤ。…腕、見せてもらうぞ。", "…新たな仲間。互いに、背中は預けられるか。"],
                            allyLiberated: ["…{name}、破廉恥な。…だが、その覚悟、悪くない。", "…無防備すぎる。敵に隙を見せるな。", "…その姿、何か意味があるのか。…まあ、よかろう。"],
                            // サクヤは脱衣状態にならない
                            cracked_rock_tiny: ["…この隙間、拙者ならば通れる。…見てくる。", "…岩の内部に、気配は無いか。確かめてくる。", "…任されよ。"],
                            dollhouse_explore_giant: ["…巨大な家。…だが、造りはしっかりしている。侮れぬ。", "…失礼する。中に、何者かの気配は…ないか。", "…静寂。茶でも一服点てたいものだ。"],
                            allyStripped: ["…{name}、破廉恥な。…これを。拙者の羽織でよければ。", "…敵の所業、武士の風上にも置けぬ。斬る。"],
                            dollhouse_explore: ["…小さな家。…だが、造りはしっかりしている。侮れぬ。", "…失礼する。中に、何者かの気配は…ないか。", "…静寂。茶でも一服点てたいものだ。"],
                            cracked_rock_break: ["…ふんっ！岩斬るも、人斬るも、同じこと。", "…道を開く。ただ、それだけのこと。", "…無心の境地にて、一閃。"],
                            high_mouse_hole_giant: ["…肩を貸す。行け。", "…拙者が足場となろう。務め、果たしてまいれ。"],
                            high_mouse_hole_tiny: ["…承知。中の様子、探ってくる。", "…任されよ。必ずや、何かを見つけてくる。"],
                            high_mouse_hole_all_tiny: ["…届かぬ。詮方なし。", "…全員で組体操でもするか？…冗談だ。", "…心頭滅却すれば、壁もまた道なり。…ならぬか。", "…無念。"],
                            fairy_shrunk: ["…我が身、刃と一体となれり。この小ささ、むしろ好都合。", "…敵の足元、がら空き。好機。", "…心の大きさは、体の大きさにはよらぬ。"],
                            shrunk_pair: ["…{name}もか。二人して、豆粒のようだな。", "…この状況、むしろ好機。二人で奇襲をかけるぞ。"],
                            pair_アカリ: ["アカリ、その勢い、悪くない。だが、隙だらけだ。", "…少しは落ち着け。"],
                            pair_ヒカリ: ["ヒカリ、その魔道…興味深い。静寂の中に、確かな力を感じる。", "…ヒカリ、お主の魔法は静かだが、強力だな。", "…互いに、多くは語らぬ。だが、それが良い。"],
                            pair_シズカ: ["シズカ、その守り、見事。背中は任せた。", "…頼りにしている。"],
                            pair_ユイ: ["ユイ、感謝する。その癒し、なければ拙者の道は絶えていた。", "…無理はするな。"],
                            pair_ベアトリス: ["ベアトリス、その知識、剣の道にも通じるか。", "…その薬、拙者には不要。"],
                            pair_リリカ: ["リリカ、その舞、心を乱す。…だが、悪くはない。", "…騒がしい。"],
                            pair_シャオメイ: ["シャオメイ、その拳、純粋な力。好ましい。", "…手合わせ願いたい。"],
                            pair_エリザ: ["エリザ、その視線、値踏みするような目は好かぬ。", "…拙者の体に、興味を持つな。"],
                            pair_ルナ: ["ルナ、勝負は運否天賦にあらず。鍛錬の先にあるもの。", "…そのサイコロ、拙者には斬れぬか。"],
                            pair_クロエ: ["クロエ、その鎌、死の匂いがする。…拙者と同じか。", "…多くを語るな。それで良い。"],
                            pair_ミコ: ["ミコ、その獣、侮れぬ気配。…面白い。", "…召喚術、か。拙者の剣とは、相容れぬ道。"],
                            pair_レンカ: ["レンカ、死者を操るか。…外道の術。だが、力は認めよう。", "…その魂、成仏させてやるのが武士の情けか。"],
                            pair_イオリ: ["イオリ、先輩か。その守り、見事。", "…その体で、よくぞ。感服する。"],
                            pair_コハル: ["コハル、お主の周りは、常に騒がしいな。", "…予測できぬ動き。…厄介だ。"],
                            pair_オリビア: ["オリビア、その祈り、邪念がない。…故に、強い。", "…感謝する。"],
                            pair_レンカ: ["レンカ、死者を操るか。…外道の術。だが、力は認めよう。", "…その魂、成仏させてやるのが武士の情けか。"],
                            pair_セレスティア: ["…その身に宿す光、迷いがない。見事なものだ。", "…その使命、拙者の剣で助太刀いたす。"],
                            pair_イオリ: ["イオリ、先輩か。その守り、見事。", "…その体で、よくぞ。感服する。"],
                            pair_コハル: ["コハル、お主の周りは、常に騒がしいな。", "…予測できぬ動き。…厄介だ。"],
                            pair_オリビア: ["オリビア、その祈り、邪念がない。…故に、強い。", "…感謝する。"],
                        },
                        // シャオメイ (モンク): 豪快、元気、食いしん坊。
                        'シャオメイ': {
                            default: ["うおー！もっと強いヤツはいないのかー！", "腹が減っては戦はできぬ、だ！終わったら肉まん食うぞ！", "オラ、わくわくしてきたぞ！", "アカリ！どっちが先に敵を倒すか競争な！", "ヒカリ！魔法ってのは便利だな！オラにはよくわからんが！", "シズカ！その盾、カッチカチだな！オラの拳でも壊せるか！？", "ユイ！回復サンキューな！これでまた暴れられる！", "ベアトリス！なんか強くなる薬、作ってくれよ！", "リリカ！お前の踊り、見てると腹が減るな！", "サクヤ！その刀、スッパスパ切れそうだな！"],
                            lowHp: ["いってぇ！今の、ちょっと効いたぞ！", "ちっ、やるじゃねえか！だが、オラはまだやれる！", "腹が減ってきた…。力が…"],
                            allyLowHp: ["{name}！大丈夫か！オラがそいつをぶっ飛ばしてやる！", "おい、{name}から離れろ！"],
                            shrunk: ["お？体が軽くなったぞ！もっと速く動けるんじゃねえか？", "ちっちぇー！これじゃあ、拳が当たらねえかもしれねえ！"],
                            shrunk_100: ["お、なんだか地面が近いな！低い姿勢からの攻撃も悪くねえ！"],
                            shrunk_70: ["ゴブリンと同じくらいの目線か？面白え！"],
                            shrunk_50: ["半分になっちまった！だが、拳の重さは変わらねえぞ！"],
                            shrunk_30: ["スライムみてえになっちまったな！でも、すばしっこくていいぞ！"],
                            shrunk_10: ["うおっ、豆粒みてえだ！でも、気合は一人前だ！"],
                            shrunk_1: ["肉まんの欠片くらいしかねえぞ！でも、腹は減る！"],
                            stripped: ["うおっ！？なんだこりゃ！動きやすくていいじゃねえか！", "はっはっは！身軽になったぜ！これで本気が出せる！", "…って、ちょっとスースーするな。", "シズカの姉御に見られたら、なんか言われるかな？"],
                            allyShrunk: ["{name}、ちっちぇくなったな！オラの肩にでも乗ってくか？", "おい、{name}！そこにいたのか！踏んじまうところだったぞ！"],
                            grown: ["でっかくなったぞー！これならどんなヤツでも一撃だ！", "うおー！見晴らしがいいな！敵はどこだー！"],
                            grown_max: ["うおおお！オラの力がカンストしたみてえだ！", "これ以上でかくなったら、ダンジョンが壊れちまうな！"],
                            allyGrown: ["うお、{name}がでっかくなった！頼もしいじゃねえか！", "{name}、天井に頭ぶつけんなよ！"],
                            allyNew: ["お！新しいの！オラはシャオメイだ！よろしくな！", "{name}か！強えのか？"],
                            stripped_shrunk: ["うおっ！？ちっちぇーし、服もねえ！これはさすがにマズいんじゃねえか？", "隠れるとこ探さねえと！風邪ひく！"],
                            solo_stripped_tiny: ["うおっ！？ちっちぇーし、服もねえ！これはさすがに…！", "（岩陰で体育座りしている）…腹、冷えるな…。", "誰か来たら、石ころのフリでもすっか…。", "は、腹減った…"],
                            dollhouse_explore_giant: ["お、でっけー家だな！中に美味いもんはあるか！？", "おーい！誰かいるかー！いねえなら入るぞー！", "なんだか巨人族の村みてえで、わくわくすっぞ！"],
                            cracked_rock_tiny: ["おう！この隙間ならオラでも通れるな！行ってくらあ！", "中に美味いもんでも隠されてねえかな？", "任せとけ！腹が減ってても、宝探しはできる！"],
                            liberated: ["はっはっは！動きやすくて最高だぜ！", "これぞ、肉体言語ってやつよ！", "邪魔な服がねえから、拳がもっと速く出せる気がするぜ！"],
                            dollhouse_explore: ["お、ちっちぇー家だな！中に食いもんはあるか！？", "おーい！誰かいるかー！いねえなら入るぞー！", "なんだか秘密基地みてえで、わくわくすっぞ！"],
                            cracked_rock_break: ["うおおお！オラの拳、岩をも砕く！見てろよ！", "邪魔だ、どけぇ！", "腹が減ってちゃ、岩も壊せねえからな！…ふんっ！"],
                            fairy_shrunk: ["うおー！ちっちぇー！でも、拳の重さは変わんねえぞ！", "このサイズ、速すぎて敵には見えねえんじゃねえか！？", "腹は減るな！"],
                            allyStripped_shrunk: ["{name}！ちっちぇー上にその格好はヤベえだろ！オラの服、貸してやるよ！", "てめえ！{name}に何しやがった！ぶっ飛ばす！"],
                            high_mouse_hole_all_tiny: ["うーん、全然届かねえな！腹立つ！", "腹が減ってて力が出ねえ！…いや、関係ねえか！", "誰か、オラを投げてくれねえか？", "ちくしょう！諦めるしかねえのか！"],
                            stripped_pair: ["お、{name}もか！二人して身軽になったな！動きやすくていいじゃねえか！", "はっはっは！こうなったら、どっちが先に敵を倒すか勝負だ！"],
                            high_mouse_hole_giant: ["うおー！オラの肩は頑丈だぞ！しっかり掴まってろ！", "よっしゃ、任せとけ！このまま天井まで届かせてやろうか！"],
                            high_mouse_hole_tiny: ["おう！行ってくるぜ！中に美味いもんでもあるといいな！", "ははっ、高いな！宝探しは得意なんだ、任せとけ！"],
                            allyStripped: ["{name}、大胆だな！風邪ひくなよ！", "敵のヤツ、くだらねえことしやがる！オラが拳で分からせてやる！"],
                            shrunk_pair: ["{name}もか！二人して豆粒だな！だが、二人いればなんとかなるだろ！", "よし、連携技だ！オラが下から、お前が上からだ！"],
                            pair_シズカ: ["シズカの姉御がいると安心するな！背中は任せたぜ！", "姉御！腹減った！肉まん食いてえ！", "その盾、やっぱカッチカチだな！オラの拳とどっちが硬いか勝負だ！"],
                            pair_レンカ: ["レンカ！お前の魔法、よくわかんねえけどスゲーな！", "死んだヤツと話せんのか？すげー！"],
                            pair_イオリ: ["イオリの姉ちゃん、ちっちぇーのにスゲーな！オラも負けてらんねえ！", "オラが守ってやっからな！"],
                            pair_コハル: ["コハル！お前、見てて飽きねえな！次はなにするんだ？", "失敗したって気にすんな！腹が減るだけだ！"],
                            pair_オリビア: ["オリビア！お前の祈り、なんだか腹の底からあったかくなるな！", "腹減ったらオラに言えよ！"],
                            pair_セレスティア: ["おー！なんかキラキラしてて強そうだな！オラと勝負だ！", "腹減らねえのか？不思議なヤツだな！"],
                        },
                        // エリザ (ドクター): 自信家、研究熱心、尊大。
                        'エリザ': {
                            default: ["ふふ、このダンジョン、私の研究意欲をそそりますわね。", "皆さん、検体…いえ、体調は万全ですこと？", "敵の生態、実に興味深い。サンプルを持ち帰りたいくらいですわ。", "アカリさん、その有り余る元気、どこから来るのか解析してみたいですわね。", "ヒカリさん、魔法と科学…どちらが優れているか、ここで証明しましょう。", "シズカさん、その頑丈さ、私の新薬の被験体として最適ですわ。", "ユイさん、あなたの回復魔法、非科学的ですが…効果は認めましょう。", "ベアトリスさん、錬金術と医学、通じるものがありそうですわね。今度、議論しませんこと？", "リリカさん、その舞、人々の精神にどう作用するのか…観察対象として実に興味深いですわ。", "サクヤさん、その精神集中…医学的にも解明したい現象ですわ。", "シャオメイさん、その単純な思考回路、羨ましいですわね。"],
                            lowHp: ["あら…？計算外のダメージですわ。検体が優秀だったようですわね。", "ふふ、少しは楽しませてくれますわね。ですが、ここまでですわ。", "この程度の傷、私の薬があればすぐに…！"],
                            allyLowHp: ["あらあら、{name}さん。私の助けが必要なようですわね。", "下がっていなさい、{name}さん。貴重なサンプルが壊れてしまいますわ。"],
                            shrunk: ["あら、この身長…子供の頃を思い出しますわね。ふふ、悪くありませんわ。", "視線が低いと、新しい発見があるものですわ。", "この体で、どうやって効率よく検体を処理するか…思考実験もまた一興ですわ。"],
                            shrunk_100: ["ふふ、このサイズ感、懐かしいですわね。"],
                            shrunk_70: ["ユイさんと同じくらいの目線ですわね。"],
                            shrunk_50: ["あらあら、世界の解像度が変わりましたわ。面白いデータが取れそうですわ。"],
                            shrunk_30: ["ここまで小さいと、フラスコを運ぶのも一苦労ですわね。"],
                            shrunk_10: ["ふふ、ネズミの気持ちがわかりますわ。これで敵を欺きましょう。"],
                            shrunk_1: ["…微生物との対話も、夢ではないかもしれませんわね。"],
                            stripped: ["…なんですの、この非科学的な現象は！", "私の完璧なボディバランスが…！許せませんわ！", "見てはいけませんわよ！…まあ、見惚れるのは仕方ありませんが。"],
                            allyShrunk: ["あら、{name}さん。可愛らしいサイズになりましたわね。臨床実験に最適ですわ。", "{name}さん、そこにいらっしゃいましたの。踏んでしまうところでしたわ。"],
                            grown: ["素晴らしい！このパワー！私の処方は完璧ですわ！", "見下ろす景色は最高ですわね！さあ、ひれ伏しなさい！"],
                            grown_max: ["ふふ、ついに限界値ですわね。私の研究の、素晴らしい成果ですわ！", "これ以上の巨大化は、未知の領域…ふふ、そそりますわね！"],
                            allyGrown: ["あら、{name}さん。私の処方が効いたようですわね。素晴らしい検体ですわ。", "{name}さん、大きくなりましたわね。データ、取らせていただきますわ。"],
                            allyNew: ["私がエリザですわ。あなた、私の研究の役に立ちそうですわね。期待していますわよ。", "新しい仲間ですの？ふふ、せいぜい私の足手まといにならないようになさい。"],
                            stripped_shrunk: ["小さくて、この格好…！これは、私の経歴の汚点ですわ…！", "…隠れますわよ。ええ、合理的な判断ですわ。"],
                            solo_stripped_tiny: ["（こんな屈辱…！ありえませんわ…！）", "（物陰でうずくまっている）…早くこの状況を打開する薬を開発しませんと…。", "（誰か来たら、新種のキノコのフリをしますわ…）"],
                            dollhouse_explore_giant: ["あら、巨人用の家ですの？私の研究室の拡張の参考にさせていただきますわ。", "失礼。内部構造を調査させていただきますわよ。", "このサイズなら、巨大な検体の解剖も可能ですわね。"],
                            cracked_rock_tiny: ["あら、この亀裂、興味深いですわね。内部の地層を調査する絶好の機会ですわ。", "このサイズなら、岩の内部を傷つけずにサンプルを採取できますわね。", "行ってまいりますわ。貴重なデータが手に入るかもしれません。"],
                            liberated: ["ふふ、これぞ究極の機能美。私の完璧な肉体を、存分に観察なさい。", "この方が動きやすいですし、体温調節も容易ですわ。実に合理的。", "さあ、私の研究の成果、その目に焼き付けなさい！"],
                            dollhouse_explore: ["あら、ドールハウスですの？私の研究室の模型作りの参考にさせていただきますわ。", "失礼。内部構造を調査させていただきますわよ。", "このサイズなら、人体の縮小モデルとしても有用ですわね。"],
                            cracked_rock_break: ["ふふ、私の特製薬を使えば、こんな岩、豆腐のようになりますわ。", "邪魔ですわね。さっさと片付けてしまいましょう。", "私の知性の前には、このような障害、無意味ですわ。"],
                            fairy_shrunk: ["素晴らしい！このサイズなら、人体の未知なる領域を探求できますわ！", "ふふ、私の知性がこの小さな体に凝縮されているのですわ。", "検体との距離が近い。観察にはもってこいですわね。"],
                            allyStripped_shrunk: ["あらあら、{name}さん。それは惨めな姿ですわね。私がすぐに服薬…いえ、服を作って差し上げますわ。", "敵の悪趣味な攻撃…サンプルとして解析する価値もありませんわね。"],
                            high_mouse_hole_all_tiny: ["あら、これは物理的に不可能ですわね。", "全員で肩車をしても、計算上、全く届きませんわ。", "飛行薬の材料があれば…残念ですわ。", "諦めましょう。非合理的な試みは時間の無駄ですわ。"],
                            stripped_pair: ["{name}さんもですの？…ふふ、二人でいれば羞恥も和らぐ、というデータが取れそうですわね。", "こうなったら、どちらが堂々としていられるか、勝負ですわよ。"],
                            allyStripped: ["{name}さん、風邪をひきますわよ。私の白衣をお使いなさい。", "敵の非科学的な攻撃…私が根絶して差し上げますわ。"],
                            high_mouse_hole_giant: ["ふふ、私の肩は安定していますわよ。さあ、どうぞ。", "これが最も効率的な手段ですわね。中の調査、お願いしますわ。"],
                            high_mouse_hole_tiny: ["あら、面白い構造ですわね。調査の価値がありそうですわ。", "行ってまいりますわ。貴重なサンプルが見つかるかもしれませんし。"],
                            shame_pillory: ["なんですの、この粘着質なものは！私の体に！", "離しなさい！この無礼者！私の完璧なボディを汚すなんて…！", "（屈辱に顔を歪ませているが、どこか興奮しているようにも見える）"],
                            shrunk_pair: ["あら、{name}さんも小さいですのね。ふふ、二人でいれば敵も油断するでしょう。好都合ですわ。", "ミニミニ探検隊、ですわね。私の指揮に従いなさい。"],
                            pair_アカリ: ["アカリさん、その有り余る元気、どこから来るのか解析してみたいですわね。", "あなたの単純な思考回路、羨ましいですわ。"],
                            pair_ヒカリ: ["ヒカリさん、魔法と科学…どちらが優れているか、ここで証明しましょう。", "あなたの魔術、興味深い研究対象ですわ。"],
                            pair_シズカ: ["シズカさん、その頑丈さ、私の新薬の被験体として最適ですわ。", "ふふ、冗談ですわよ。"],
                            pair_ユイ: ["ユイさん、あなたの回復魔法、非科学的ですが…効果は認めましょう。", "もっと効率的な治療法を、私が編み出して差し上げますわ。"],
                            pair_ベアトリス: ["ベアトリスさん、あなたの錬金術、実に興味深いですわ。今度、共同研究などいかがですこと？", "そのフラスコの中身…少し味見させてもらっても？", "科学と錬金術、どちらが真理に近いか…ここで決着をつけましょう。"],
                            pair_リリカ: ["リリカさん、その舞、人々の精神にどう作用するのか…観察対象として実に興味深いですわ。", "あなたのその豊満な肉体…素晴らしい検体ですわ。"],
                            pair_サクヤ: ["サクヤさん、その精神集中…医学的にも解明したい現象ですわ。", "あなたの身体能力、データとして収集させてくださいな。"],
                            pair_シャオメイ: ["シャオメイさん、その単純な思考回路、羨ましいですわね。", "あなたのその食欲、代謝機能がどうなっているのか…解剖してみたいですわ。"],
                            pair_ルナ: ["ルナさん、運などという不確定要素に身を委ねるなんて、非合理的ですわ。", "ですが、そのスリルを求める心理、研究の価値はありますわね。"],
                            pair_クロエ: ["クロエさん、あなたのその低い体温、恒温動物として異常ですわ。実に興味深い。", "魂…？ふふ、非科学的ですわね。ですが、面白い。"],
                            pair_ミコ: ["ミコさん、その生物とのコミュニケーション、どうやっているのですの？", "そのモコという生物、解剖させていただけませんこと？"],
                            pair_レンカ: ["レンカさん、死体蘇生…生命倫理に反しますわ。ですが、その技術、喉から手が出るほど欲しいですわね。", "その魂、捕獲して研究してみたいですわ。"],
                            pair_イオリ: ["イオリさん、その縮小病、私の研究対象として完璧ですわ。", "安心なさい。私が必ず、あなたの病を解明して差し上げますわ。"],
                            pair_コハル: ["コハルさん、あなたの引き起こす現象、確率論を無視していますわ。最高の研究対象ですわ！", "さあ、もっと面白いことを起こしてごらんなさい！"],
                            pair_オリビア: ["オリビアさん、その祈り、プラシーボ効果以上のものを感じますわ。", "その聖なる力とやら、科学で再現してみせますわ。"],
                            pair_レンカ: ["レンカさん、死体蘇生…生命倫理に反しますわ。ですが、その技術、喉から手が出るほど欲しいですわね。", "その魂、捕獲して研究してみたいですわ。"],
                            pair_セレスティア: ["聖女…ふふ、神の代行者ですって？実に非科学的ですわ。ですが、その力、解析する価値はありますわね。", "あなたのその体、私の研究対象として完璧ですわ。隅々まで調べさせてくださいな。"],
                            pair_イオリ: ["イオリさん、その縮小病、私の研究対象として完璧ですわ。", "安心なさい。私が必ず、あなたの病を解明して差し上げますわ。"],
                            pair_コハル: ["コハルさん、あなたの引き起こす現象、確率論を無視していますわ。最高の研究対象ですわ！", "さあ、もっと面白いことを起こしてごらんなさい！"],
                            pair_オリビア: ["オリビアさん、その祈り、プラシーボ効果以上のものを感じますわ。", "その聖なる力とやら、科学で再現してみせますわ。"],
                        },
                        // ルナ (ギャンブラー): スリル好き、自信家、気まぐれ。
                        'ルナ': {
                            default: ["さーて、次の勝負は丁か半か？", "退屈させないでよね！スリルのある冒険にしましょう！", "人生はギャンブルよ。このダンジョンも、私のステージってわけ。", "アカリ、その勢い、嫌いじゃないわ。賭けてみる価値、あるかもね。", "ヒカリ、あなたって読めないわね。ポーカーフェイスってやつ？", "シズカ、その安定感はつまらないけど…まあ、保険としてはアリかしら。", "ユイ、あなたの回復は確実すぎてドキドキしないわね。", "ベアトリス、あなたの錬金術、成功率はどのくらい？興味あるわ。", "リリカ、あなたのステージ、私も混ぜてくれない？もっと盛り上げてあげるわよ。", "サクヤ、その真剣な顔…崩してみたいわね。", "シャオメイ、単純でわかりやすいわね。賭けの対象としては一番かも。", "エリザ、あなたの薬、副作用の確率も教えてくれる？それが大事なのよ。"],
                            lowHp: ["ふふ、ちょっとスリリングになってきたじゃない！", "ここで引いたらギャンブラーの名が廃るわ！", "チップが減ってきたけど…まだまだ勝負はこれからよ！"],
                            allyLowHp: ["あらら、{name}がピンチね。ここは大きく賭けるチャンスかしら？", "{name}、大丈夫？私の幸運、分けてあげるわ。"],
                            shrunk: ["ちっちゃくなっちゃった。ふふ、これならイカサマし放題ね！", "このサイズ、カードの裏に隠れられそう。", "視点が低いと、相手の足元が見えて面白いわね。"],
                            shrunk_100: ["あら、テーブルを見上げるなんて新鮮ね。"],
                            shrunk_70: ["ヒカリと同じくらいの目線ね。勝負しましょうか？"],
                            shrunk_50: ["世界の何もかもが大きいわ。面白い！"],
                            shrunk_30: ["コインの山に隠れられそうね。"],
                            shrunk_10: ["サイコロみたいになっちゃった。誰か、私を振ってみる？"],
                            shrunk_1: ["カードの絵柄より小さいかも。ふふっ。"],
                            stripped: ["きゃっ！…ふふ、面白いじゃない。この状況、逆手にとってやるわ。", "サービスタイムってとこかしら？観覧料は高いわよ？", "こんな格好で勝ったら、伝説になっちゃうかも！"],
                            allyShrunk: ["あら、{name}がミニチュアサイズに。可愛いじゃない。私のペットにしてあげようかしら。", "{name}、そこにいたの。チップと間違えて拾っちゃうところだったわ。"],
                            grown: ["大きくなったわ！これでハッタリも効くってものね！", "見下ろす気分、最高！みんな、私の前にひれ伏しなさい！"],
                            grown_max: ["ふふ、ついに天井知らずの私にも限界が来たってわけね。", "これ以上はベットできないわ。最高のショーだったでしょ？"],
                            allyGrown: ["あら、{name}が大きくなったのね。頼もしいじゃない。賭けの対象としては悪くないわ。", "{name}、その巨体、ブラフには最適ね。"],
                            allyNew: ["私がルナよ。あなた、ツイてる？私と一緒に、最高のギャンブルをしましょう。", "新しい仲間ね。あなたに賭ける価値があるか、見極めさせてもらうわ。"],
                            stripped_shrunk: ["小さくて、この格好…！これは、さすがに計算外だわ…！", "…隠れるわよ。ええ、次のゲームのための戦略的撤退よ。"],
                            solo_stripped_tiny: ["（こんな屈辱…ありえないわ…！次の勝負で絶対に取り返してやる…！）", "（コインの影でうずくまっている）…ツイてない。流れが悪いわね…。", "（誰か来たら、新種のキノコのフリでもしてやろうかしら…）"],
                            dollhouse_explore_giant: ["ふふ、面白いじゃない。この家には大きなお宝が眠ってる…そんな予感がするわ。", "オールインよ！きっと何かいいものが見つかるはず！", "失礼するわね。家探しは得意なのよ。"],
                            cracked_rock_tiny: ["ふふ、この隙間の先に大当たりがある…そんな予感がするわ。", "ハイリスク・ハイリターンね。面白そうじゃない、行ってくるわ。", "私に賭けてみなさい。きっとお宝を見つけてきてあげる。"],
                            liberated: ["ふふ、面白いじゃない。全部見せた方が、勝負は盛り上がるってものよ。", "さあ、私のすべてを賭けるわ。あなたも、覚悟はいい？", "この方が、カードを隠す場所がなくて、フェアでいいでしょ？"],
                            dollhouse_explore: ["ふふ、面白いじゃない。この家にはお宝が眠ってる…そんな予感がするわ。", "オールインよ！きっと何かいいものが見つかるはず！", "失礼するわね。家探しは得意なのよ。"],
                            cracked_rock_break: ["この岩を壊せるかどうかに、私の運命、賭けてみるわ！", "ふふ、ツイてるわね。ちょうどいいところにヒビが入ってるじゃない。", "邪魔よ。どきなさい。"],
                            fairy_shrunk: ["ふふ、面白いじゃない。このサイズ、誰も私を警戒しないわ。最高のブラフね。", "サイコロの目で世界を見てるみたい。悪くないわ。", "カードの裏に隠れられるなんて、イカサマし放題じゃない！"],
                            allyStripped_shrunk: ["あらあら、{name}。それは無様ね。でも、そこからの大逆転劇、期待してるわよ。", "敵の趣味、最悪ね。美しくないわ。"],
                            stripped_pair: ["{name}も？ふふ、面白いじゃない。二人で『ノーペア』ってとこかしら。", "こうなったら、どっちが先に服を手に入れるか、勝負しましょうか。"],
                            allyStripped: ["{name}、大胆ね。でも、風邪ひいたら元も子もないわよ。私のストール、貸してあげる。", "敵のやり方、スマートじゃないわね。私がきっちりお灸を据えてあげる。"],
                            high_mouse_hole_giant: ["さあ、私の肩に乗りなさい。最高の特等席よ。", "ふふ、私を踏み台にするなんて、いい度胸じゃない。"],
                            high_mouse_hole_tiny: ["ふふ、面白そうじゃない。お宝に賭けてみるのも悪くないわね。", "行ってくるわ。大当たりを引いてきてあげる。"],
                            high_mouse_hole_all_tiny: ["あらら、これは完全に詰みね。賭けにすらならないわ。", "全員でジャンプして、一番高く飛べた人が勝ちってゲームでもする？", "ツイてないわね。諦めて次に行きましょう。", "この状況を打開できる確率…0%ね。"],
                            shame_pillory: ["…ふふ、面白いじゃない。こんなの、初めての経験だわ。", "もっと、強く…！なんてね。早く離してくれないかしら。", "（恍惚とした表情で、ガラスに映る自分の姿を見ている）"],
                            shrunk_pair: ["あら、{name}も小さいのね。二人でなら、どんなイカサマも見破られないかも。", "ミニミニギャンブラーズの結成ね。私の指示に従いなさい。"],
                            pair_アカリ: ["アカリ、その勢い、嫌いじゃないわ。賭けてみる価値、あるかもね。", "単純でわかりやすいわね。"],
                            pair_ヒカリ: ["ヒカリ、あなたって読めないわね。ポーカーフェイスってやつ？勝負しましょうか。", "その魔法、成功率は何パーセント？"],
                            pair_シズカ: ["シズカ、その安定感はつまらないけど…まあ、保険としてはアリかしら。", "あなたの鉄壁、私の運で突破できるかしら？"],
                            pair_ユイ: ["ユイ、あなたの回復は確実すぎてドキドキしないわね。", "たまには、失敗してみたらどう？スリリングでいいじゃない。"],
                            pair_ベアトリス: ["ベアトリス、あなたの錬金術、成功率はどのくらい？興味あるわ。", "その薬、どんな副作用があるのかしら？そこに賭けるのも面白そうね。"],
                            pair_リリカ: ["リリカ、あなたのステージ、賭けの対象としては最高ね。観客がどれだけ熱狂するか、賭けてみない？", "あなたのダンス、見てる人を惹きつけるわ。その才能、ギャンブルにも活かせるんじゃない？"],
                            pair_サクヤ: ["サクヤ、その真剣な顔…崩してみたいわね。", "あなたの斬撃、私が避けられるかに賭けてみない？"],
                            pair_シャオメイ: ["シャオメイ、単純でわかりやすいわね。賭けの対象としては一番かも。", "あなたと私、どっちが先に腹を空かせるか、賭ける？"],
                            pair_エリザ: ["エリザ、あなたの薬、副作用の確率も教えてくれる？それが大事なのよ。", "あなたの自信、いつまで続くかしら？ふふっ。"],
                            pair_クロエ: ["クロエ、あなたもミステリアスね。何を考えてるか、当ててみせようかしら。", "魂を狩る…？ふふ、面白そうじゃない。"],
                            pair_ミコ: ["ミコ、その召喚、成功する確率は？", "そのモコって子、私に懐くか懐かないか、賭けてみない？"],
                            pair_レンカ: ["レンカ、死者を操るなんて、ハイリスク・ハイリターンね。嫌いじゃないわ。", "その魔法、失敗したらどうなるの？面白そうじゃない。"],
                            pair_イオリ: ["イオリ先輩、ね。その守り、いつまで続くかしら？", "小さくても、賭けの対象としては面白いわ。"],
                            pair_コハル: ["コハル、あなたこそ最高のギャンブルね！次に何が起こるか、全く読めないわ！", "あなたに全部賭けてみるのも、面白そうね！"],
                            pair_オリビア: ["オリビア、祈りだけで勝てるなんて思ってないでしょうね？", "神様と私、どっちがツイてるか勝負しましょうか。"],
                            pair_レンカ: ["レンカ、死者を操るなんて、ハイリスク・ハイリターンね。嫌いじゃないわ。", "その魔法、失敗したらどうなるの？面白そうじゃない。"],
                            pair_セレスティア: ["聖女様、ね。あなたに賭けても、スリルはなさそうね。だって、絶対に勝つんでしょう？", "あなたのその力、イカサマじゃないんでしょうね？"],
                            pair_イオリ: ["イオリ先輩、ね。その守り、いつまで続くかしら？", "小さくても、賭けの対象としては面白いわ。"],
                            pair_コハル: ["コハル、あなたこそ最高のギャンブルね！次に何が起こるか、全く読めないわ！", "あなたに全部賭けてみるのも、面白そうね！"],
                            pair_オリビア: ["オリビア、祈りだけで勝てるなんて思ってないでしょうね？", "神様と私、どっちがツイてるか勝負しましょうか。"],
                        },
                        // クロエ (リーパー): 寡黙、ミステリアス、達観している。
                        'クロエ': {
                            default: ["…静か。…魂の、囁きが聞こえる。", "…ここは、終わりが近い場所の匂いがする。", "…みんな、死なないでね。…まだ、その時じゃないから。", "アカリ…その光、眩しい。", "ヒカリ…魔法は、魂の形を変える力。", "シズカ…その盾は、多くの魂を守ってきたのね。", "ユイ…あなたの祈り、届いてるよ。", "ベアトリス…真理の探求、その先に何を見るの？", "リリカ…あなたの歌、魂を揺さぶる。", "サクヤ…あなたの剣、魂を断つ覚悟が見える。", "シャオメイ…その拳、純粋な魂の輝き。", "エリザ…命の探求、面白い。", "ルナ…運命の糸、見えるの？"],
                            lowHp: ["…少し、境界が近くなった。", "…まだ、逝けない。", "…この痛み、生きている証。"],
                            allyLowHp: ["…{name}、危ない。…こっちに来て。", "{name}の魂の灯が、揺れてる。"],
                            shrunk: ["…小さくなった。…影に、もっと近づける。", "…地面が近い。…死んだ魂の声が、よく聞こえる。", "…この姿なら、誰にも気づかれずに、魂を狩れる。"],
                            shrunk_100: ["…ユイさんと同じくらい…。", "…ローブが、もっとぶかぶか。"],
                            shrunk_70: ["…世界の境界が、曖昧になる。"],
                            shrunk_50: ["…半分。…存在が、希薄になる感じ。", "…影と、一体になれそう。"],
                            shrunk_30: ["…草の葉が、鎌みたいに見える。"],
                            shrunk_10: ["…蝶々みたい。…魂を運ぶ、蝶々。"],
                            shrunk_1: ["…もう、いないのと同じ。…でも、いる。"],
                            stripped: ["…これは、だめ。", "…魂が、裸にされたみたいで、寒い。", "…フードで、隠す。"],
                            allyShrunk: ["…{name}、小さくなったね。…可愛い。", "{name}、そこにいたの。…気づかなかった。"],
                            grown: ["…大きくなった。…天に、手が届きそう。", "…見下ろすのは、慣れない。"],
                            grown_max: ["…これ以上は、魂の器が持たない。", "…世界の境界が、見える。"],
                            allyGrown: ["…{name}、大きい。…守護者みたい。", "{name}、その力、魂を傷つけないでね。"],
                            allyNew: ["…クロエ。…あなたの魂、見せて。", "…よろしく。…あなたの最期、私が見届けてあげる。"],
                            stripped_shrunk: ["…小さくて、服もない。…これは、一番、死に近い。", "…隠れる。…誰にも、見つからないように。"],
                            solo_stripped_tiny: ["（…もう、消えてしまいたい…）", "（…影の中で、じっとしている）", "（…誰か来たら、石になる…）"],
                            dollhouse_explore_giant: ["…大きな、魂の器。…誰が、住んでいたの？", "…おじゃまします。…静かね。…好き。", "…何か、残された想いは、ない？"],
                            cracked_rock_tiny: ["…この隙間、向こう側と繋がってる。…死者の魂が、呼んでるかも。", "…静かに入って、見てくる。", "…何か、落ちてる。…拾ってくる。"],
                            liberated: ["…服なんて、生者のためのもの。…私には、不要。", "…魂の形が、一番わかりやすい。…これでいい。", "…風が、肌を撫でる。…死者の囁きみたい。"],
                            dollhouse_explore: ["…小さな、魂の器。…誰が、住んでいたの？", "…おじゃまします。…静かね。…好き。", "…何か、残された想いは、ない？"],
                            cracked_rock_break: ["…この岩にも、魂はある。…でも、今は邪魔。", "…道を開けて。…お願い。", "…鎌で、少しずつ。"],
                            fairy_shrunk: ["…影と、一体になれる。…心地いい。", "…魂の囁きが、もっと近くで聞こえる。", "…この姿なら、誰にも気づかれずに、魂を狩れる。"],
                            allyStripped_shrunk: ["…{name}、かわいそう。…私のローブ、貸してあげる。", "…ひどいこと、するね。…あの敵の魂、私がもらう。"],
                            stripped_pair: ["…{name}も。…二人とも、魂が丸見え。", "…こうしてると、少しだけ、温かいかも。"],
                            allyStripped: ["…{name}、風邪ひくよ。…これ、使って。", "…許さない。"],
                            high_mouse_hole_giant: ["…私の肩、使って。…静かにね。", "…この高さなら、届く。…お願い。"],
                            high_mouse_hole_tiny: ["…行ってくる。…中に、何かいるかも。", "…静かに。…中の魂の声を、聞いてくる。"],
                            high_mouse_hole_all_tiny: ["…届かない。…仕方ない。", "…みんなで、お祈りする？…届かないかな。", "…諦める。…静かで、いい。", "…（じっと穴を見上げている）"],
                            shame_pillory: ["…これは、罰…？", "…魂が、見られてる。…寒い。", "（ただ静かに、目を閉じている）"],
                            shrunk_pair: ["…{name}も、小さいね。…二人で、影になろう。", "…二人なら、見つからない。"],
                            pair_アカリ: ["アカリ…その光、眩しい。…魂が、燃えてるみたい。", "…元気、だね。"],
                            pair_ヒカリ: ["…ヒカリ。…あなたの魔法、静かで好き。", "…魔道と、魂の道。…似てる。"],
                            pair_シズカ: ["シズカ…その盾は、多くの魂を守ってきたのね。", "…あなたの後ろ、温かい。"],
                            pair_ユイ: ["ユイ…あなたの祈り、届いてるよ。…優しい魂。", "…ありがとう。"],
                            pair_ベアトリス: ["ベアトリス…真理の探求、その先に何を見るの？", "…あなたの魂、知りたがり。"],
                            pair_リリカ: ["リリカ…あなたの歌、魂を揺さぶる。", "…賑やか。"],
                            pair_サクヤ: ["サクヤ…あなたの剣、魂を断つ覚悟が見える。", "…私と、同じ匂い。"],
                            pair_シャオメイ: ["シャオメイ…その拳、純粋な魂の輝き。", "…お腹、すいたの？"],
                            pair_エリザ: ["エリザ…命の探求、面白い。…でも、やりすぎはだめ。", "…あなたの魂、傲慢。"],
                            pair_ルナ: ["ルナ…運命の糸、見えるの？…私には、魂の終わりが見える。", "…あなたの魂、いつも揺れてる。"],
                            pair_ミコ: ["ミコ…その子たち、魂があるの？…話してみたい。", "…優しい魂。"],
                            pair_レンカ: ["レンカ…死者の魂を弄ぶのは、よくない。", "…でも、あなたの魂は、寂しそう。"],
                            pair_イオリ: ["イオリ…先輩。…その魂、古い。…でも、強い。", "…守る、ね。…わかる。"],
                            pair_コハル: ["コハル…あなたの周り、魂が騒がしい。", "…何が起こるか、わからない。…面白い。"],
                            pair_オリビア: ["オリビア…あなたの魂、光ってる。…綺麗。", "…その祈り、死者の魂も、癒されるかも。"],
                            pair_レンカ: ["レンカ…死者の魂を弄ぶのは、よくない。", "…でも、あなたの魂は、寂しそう。"],
                            pair_セレスティア: ["…あなたの魂、光そのもの。…眩しい。", "…たくさんの魂が、あなたに救いを求めてる。…聞こえる。"],
                            pair_イオリ: ["イオリ…先輩。…その魂、古い。…でも、強い。", "…守る、ね。…わかる。"],
                            pair_コハル: ["コハル…あなたの周り、魂が騒がしい。", "…何が起こるか、わからない。…面白い。"],
                            pair_オリビア: ["オリビア…あなたの魂、光ってる。…綺麗。", "…その祈り、死者の魂も、癒されるかも。"],
                        },
                        // ミコ (サモナー): 人懐っこい、天然、モンスター好き。
                        'ミコ': {
                            default: ["モコ、元気？…うん、ミコも元気だよ！", "このダンジョン、面白いモンスターいるかな？お友達になりたいな！", "みんな、疲れてない？モコが応援してるって！", "アカリちゃん、すごいね！モコもああなりたいって！", "ヒカリちゃん、その本、難しいの？モコが読んであげようか？", "シズカさん、かっこいい！ゴーレムくんもああなりたいって！", "ユイちゃん、いつもありがとう！モコも喜んでるよ！", "ベアトリスさん、その薬、モンスターは飲める？", "リリカちゃん、可愛い！モコと一緒に踊ってほしいな！", "サクヤさん、その刀、キラキラだね！モコが舐めてもいい？", "シャオメイちゃん、お腹すいたの？モコのおやつ、半分あげる！", "エリザさん、モコを調べてもいいよ！でも、痛くしないでね？", "ルナさん、ギャンブルってなあに？モコとできる？", "クロエちゃん、静かだね。モコとお話しよ？"],
                            lowHp: ["うぅ…ちょっと痛いかも…。モコ、大丈夫だよ！", "まだ平気！みんなを守らないと！", "モコ、ミコのこと心配してくれてるの？ありがとう。"],
                            allyLowHp: ["{name}ちゃん、大丈夫！？ゴーレムくん、{name}ちゃんを守って！", "モコがね、{name}ちゃんのこと心配してるよ。"],
                            shrunk: ["わ、ちっちゃくなっちゃった！モコと同じ目線だ！", "これなら、モンスターの子供と間違えられちゃうかも！", "モコ、ミコの頭の上に乗れるよ！"],
                            shrunk_100: ["ユイちゃんと同じくらいかな？えへへ。"],
                            shrunk_70: ["モコよりちょっと大きいかな？"],
                            shrunk_50: ["モコと一緒にお散歩してるみたい！"],
                            shrunk_30: ["草むらがジャングルみたい！探検だー！"],
                            shrunk_10: ["モコ、ミコのこと見失わないでね！"],
                            shrunk_1: ["モコのお鼻の先っぽくらいになっちゃった！"],
                            stripped: ["ひゃっ！？だ、だめだよぉ…！モコ、見ないで！", "こ、こんな格好、召喚の儀式に集中できないよ…！", "ゴーレムくん、ミコのこと隠して！"],
                            allyShrunk: ["わー、{name}ちゃん、ちっちゃくて可愛い！モコのお友達みたい！", "{name}ちゃん、そこにいたの！気づかなかった！"],
                            grown: ["おっきくなった！これなら大きいモンスターともお話しできるかも！", "ゴーレムくんと同じくらい大きいかな？"],
                            grown_max: ["わー！もうこれ以上おっきくなれないみたい！モコ、見てるー？", "ゴーレムくんよりおっきくなっちゃった！"],
                            allyGrown: ["わー、{name}ちゃん、おっきい！ゴーレムくんみたい！", "{name}ちゃん、天井、気をつけてね！"],
                            allyNew: ["はじめまして！ミコだよ！こっちは相棒のモコ！{name}ちゃん、よろしくね！", "新しいお友達だ！{name}ちゃん、モンスター好き？"],
                            stripped_shrunk: ["ちっちゃくて、服もないなんて…！モコ、ミコのこと隠してー！", "これじゃあ、ただの迷子の子だよぉ…！"],
                            solo_stripped_tiny: ["（しくしく…）モコ、どうしよう…。", "（葉っぱの裏に隠れて、モコを抱きしめている）", "もう、おうちに帰りたいよぉ…"],
                            dollhouse_explore_giant: ["わーい！巨人さんのお家だ！モコのお家みたい！おじゃまします！", "おっきいモンスターさん、いませんかー？", "モコ、見て！ベッドもテーブルもみんなおっきいね！"],
                            cracked_rock_tiny: ["わーい！秘密のトンネルだ！モコ、行ってくるね！", "中に、ちっちゃいモンスターさん、いないかな？お友達になりたいな！", "お宝、見つけてくるね！"],
                            liberated: ["わーい！なんだか、ミコもモンスターになった気分！", "この方が、モコともっと仲良くなれる気がする！", "見てみて！ミコ、元気いっぱいだよ！"],
                            dollhouse_explore: ["わーい！モコのお家みたい！おじゃまします！", "ちいさいモンスターさん、いませんかー？", "モコ、見て！ベッドもテーブルもみんなちっちゃいね！"],
                            cracked_rock_break: ["ゴーレムくん、お願い！この岩、壊して！", "モコ、危ないから下がっててね！せーのっ！", "サラマンダーくん、この岩、燃やしちゃえ！"],
                            fairy_shrunk: ["わーい！モコと同じ目線だ！お話しやすいね！", "このサイズなら、小さいモンスターさんとお友達になれるかも！", "モコの背中に乗って冒険だー！"],
                            allyStripped_shrunk: ["{name}ちゃん、大丈夫！？モコが温めてあげるって！", "ひどいことする敵さんだね！ゴーレ-ムくん、やっつけて！"],
                            stripped_pair: ["{name}ちゃんもなの！？二人でいれば、恥ずかしくない…かな？ううん、恥ずかしい！", "モコ、どっちも見ちゃだめだよ！"],
                            allyStripped: ["{name}ちゃん、風邪ひいちゃう！ミコのマント、使って！", "敵さん、意地悪だね！サラマンダーくん、お仕置きして！"],
                            high_mouse_hole_giant: ["うん！ミコがおっきくしてあげる！モコも応援してるよ！", "ゴーレムくんみたいに、どっしり構えてるから大丈夫だよ！"],
                            high_mouse_hole_tiny: ["わーい、高いね！モコ、行ってくるね！", "中にモンスターさん、いるかな？お友達になれるといいな！"],
                            high_mouse_hole_all_tiny: ["うーん、全然届かないね…。モコ、どうしよう？", "みんなで肩車しても、全然だめだね…。", "モコを投げても、届かないかなぁ…。", "諦めるしかないのかなぁ…。"],
                            shame_pillory: ["いやー！なにこれ、ネバネバするよぉ！モコ、助けてー！", "だ、だめ！こんな格好、ゴーレムくんに見られちゃう！", "（うるうるした目で助けを求めている）"],
                            shrunk_pair: ["{name}ちゃんも小さいんだね！二人でモコに乗って探検しようよ！", "ちびっこ探検隊だね！"],
                            pair_ユイ: ["ユイちゃん、いつもありがとう！モコもね、ユイちゃんのこと大好きなんだって！", "ユイちゃんのお菓子、美味しいね！モコにも少しちょうだい！"],
                            pair_レンカ: ["レンカさん、死んじゃったモンスターともお話しできるの？すごい！", "モコがね、レンカさんのこと、ちょっと怖いけど気になるって！"],
                            pair_イオリ: ["イオリ先輩、ちっちゃくてもかっこいいね！ゴーレムくんもそう言ってる！", "先輩！ミコとモコが守るからね！"],
                            pair_コハル: ["コハルちゃん、次はなにするの？モコがわくわくしてるよ！", "失敗しても、モコがなぐさめてくれるから大丈夫だよ！"],
                            pair_セレスティア: ["わー！セレスティアさん、キラキラしてる！モコがね、すりすりしたいって！", "セレスティアさん、モンスターとお話しできる？"],
                            // サマータイム・スペシャルライブ！
                            beach_liberation_prompt: ["太陽さん、あったかいね！モコもミコも、もっと元気いっぱいになりたいな！"],
                            beach_liberation_stop: ["そっかぁ。じゃあ、また今度にしよっかな！"],
                            onsen_liberation_prompt: ["このお湯、あったかくてお母さんみたい！なんだか、甘えたくなっちゃうなー。"],
                            onsen_liberation_stop: ["うん、わかった！じゃあ、もうちょっとだけこのままでいよっと！"],

                            // サマータイム・スペシャルライブ！
                            summer_beach: [
                                "見てみて、モコ！ヤドカリさんだよ！お友達になれるかな？",
                                "この砂、ゴーレムくんの材料にいいかも！…なんてね！",
                                "リリカちゃんの歌、モコもノリノリだよ！",
                                "海の水ってしょっぱいんだね！モコ、びっくりしてる！"
                            ],
                            summer_onsen: ["わーい、温泉だ！モコ、泳いでもいい？…え、だめなの？", "このお湯、なんだか体に良さそう！ゴーレムくんも元気になったりして！", "ユイちゃん、おまんじゅうありがとう！モコと半分こするね！", "リリィちゃん、背中流してあげようか？モコが！"],
                            onsen_towel_trouble: ["わわっ！タオルが取れちゃった！モコ、隠してー！"],
                            pair_オリビア: ["オリビアさん、優しい匂いがするね！モコがすりすりしたがってる！", "その祈り、モンスターにも効くのかな？"],
                            // 特別衣装時のセリフ
                            summer_beach_costume: ["わーい、水着だ！海に来たみたいで楽しいね！モコも嬉しそう！", "この格好だと、召喚獣たちもなんだか楽しそうにしてる気がする！", "砂浜でゴーレムくん作ったら、砂のゴーレムくんになるのかな？"],
                            summer_beach_costume_lowHp: ["うぅ…転んで膝すりむいちゃった…。砂がしみるよぉ…。", "モコ、大丈夫だよ！ミコはまだ戦えるから！"],
                            summer_beach_costume_shrunk: ["わわっ、水着のままちっちゃくなっちゃった！ヤドカリさんとおんなじサイズだ！", "モコ、ミコのこと見失わないでねー！"],
                            summer_beach_costume_stripped: ["ひゃっ！？水着取られちゃった！だめだよぉ、モコ、見ちゃだめ！", "うぅ…こんな格好、召喚の儀式に集中できないよ…！"],
                            summer_beach_costume_grown: ["わー！水着のままおっきくなった！これなら、どんなモンスターよりも大きいかも！", "モコ、見て見て！ミコ、おっきいよー！"],

                            summer_onsen_costume: ["この格好、温泉みたいでぽかぽかするね！モコも気持ちよさそう！", "タオル一枚だと、召喚の時にちょっと動きにくいかも…？", "みんなで温泉卓球したいなー！"],
                            summer_onsen_costume_lowHp: ["わわっ、のぼせちゃったかも…。ちょっとふらふらする…。", "タオルがはだけそうだよぉ…！"],
                            summer_onsen_costume_shrunk: ["わわっ、タオルのままちっちゃくなっちゃった！おちょこのお風呂に入れそうだね！", "モコ、ミコのこと、タオルと間違えて持って行かないでね！"],
                            summer_onsen_costume_stripped: ["ひゃっ！？タオル取られちゃった！だめだよぉ、ゴーレムくん、隠してー！", "うぅ…こんな格好、恥ずかしいよぉ…！"],
                            summer_onsen_costume_grown: ["わー！タオルのままおっきくなった！これなら、露天風呂も小さく見えるかも！", "モコ、見て！ミコ、おっきいよー！タオル、足りるかな？"],
                            liberated_beach: ["太陽さんとお友達になったみたい！ミコ、無敵だよ！", "この格好なら、お魚さんたちも仲間だって思ってくれるかな？"],
                            liberated_onsen: ["温泉の神様と、お話しできちゃうかも！", "モコもミコも、ぽっかぽかだよー！"],
                        },
                        // レンカ (ネクロマンサー): ミステリアス、お姉さん、死者と対話。
                        'レンカ': {
                            default: ["ふふ、魂たちが囁いているわ…この先に強い気配があるって。", "あら、元気な魂ね。死んだら私のコレクションにしてあげる。", "静かね…死者の安らぎを邪魔する者は誰かしら？", "このダンジョン、魂の吹き溜まりになっているみたい。居心地がいいわ。", "アカリちゃん、その生命力…眩しいわね。", "ヒカリちゃん、魔術と死霊術、根は同じかもね。", "シズカさん、その盾、何体の魂を守ってきたのかしら。", "ユイちゃん、あなたの癒しは生者だけのもの？", "あら、新しい魂の気配…よろしくね、迷える子羊さん。"],
                            lowHp: ["…少し、死が近くなったかしら。悪くないわ。", "ふふ、この痛み…生きているって実感するわね。", "大丈夫よ。魂の一つや二つ、くれてやるもの。"],
                            allyLowHp: ["{name}、無理はよしなさい。死んだら私が蘇らせてあげるから。", "あらあら、{name}の魂の灯が弱まっているわ。"],
                            shrunk: ["小さくなるなんて…ふふ、面白いわね。魂の重さは変わらないのに。", "このサイズなら、魂たちの囁きがもっと近くで聞こえるかしら。", "あら、服がぶかぶか。まるで幽霊みたいね。"],
                            shrunk_100: ["子供の頃に戻ったみたい。…もっとも、私の子供時代はこんなに明るくなかったけれど。"],
                            shrunk_70: ["ユイちゃんと同じくらいの目線ね。可愛いわ。"],
                            shrunk_50: ["世界のすべてが大きく見える。魂の視点って、こんな感じなのかしら。"],
                            shrunk_30: ["墓石の影に隠れるには、ちょうどいいサイズね。"],
                            shrunk_10: ["ふふ、まるで魂そのものになった気分だわ。"],
                            shrunk_1: ["…もう、誰の目にも映らない。死者と同じね。"],
                            stripped: ["あら…大胆なことしてくれるじゃない。魂まで裸にされた気分よ。", "…見てるんでしょう？いいわ、存分に見なさい。ただし、代償は高くつくわよ。", "ふふ、この格好で死霊術を唱えるのも、一興かしら。"],
                            allyShrunk: ["あら、{name}が小さくなっているわ。可愛いわね、小動物みたい。", "{name}、そこにいたの。魂の気配で気づいたわ。"],
                            grown: ["大きくなったわね。これなら、より多くの魂を従えられそう。", "見下ろす景色も、悪くないわ。"],
                            grown_max: ["ふふ、これ以上は魂の器が持たないわね。最高の状態よ。", "これ以上の成長は、死の領域を侵すことになるわ。"],
                            allyGrown: ["まあ、{name}が大きくなってる。頼もしいわね。", "{name}、その体、魂を宿すにはちょうどいい器かも。"],
                            allyNew: ["新しい魂…{name}、よろしくね。あなたの最期、私が見届けてあげる。", "ふふ、可愛い子。仲良くしましょうね。"],
                            stripped_shrunk: ["小さくて、服もないなんて…これは、さすがに想定外ね。", "…隠れましょうか。死者のように、気配を消して。"],
                            solo_stripped_tiny: ["（…これは、屈辱ね。あの敵の魂、必ず私のものにする…）", "（物陰で膝を抱えている）…寒い。死者の温もりが恋しいわ。", "（誰か来たら、ただの石ころのフリでもしましょうか…）"],
                            dollhouse_explore_giant: ["あら、大きな家。死者の魂はいないようね。…残念。", "ふふ、おじゃましますわ。何か面白いもの、残ってないかしら。", "この家、私のコレクションに加えるのも悪くないわね。"],
                            cracked_rock_tiny: ["あら、この隙間…死者の魂が隠したお宝があるかもしれないわね。", "ふふ、行ってくるわ。何か面白いものが見つかるかもしれないもの。", "このサイズなら、誰にも気づかれずに調査できるわね。"],
                            liberated: ["ふふ、これぞ死者に最も近い姿。魂が、喜んでいるわ。", "この方が、魂たちとの対話がしやすいのよ。", "私のすべて、死者たちに捧げましょう。"],
                            dollhouse_explore: ["あら、可愛いお家。死者の魂はいないようね。…残念。", "ふふ、おじゃましますわ。何か面白いもの、残ってないかしら。", "この家、私のコレクションに加えるのも悪くないわね。"],
                            cracked_rock_break: ["ふふ、こんな岩、私のアンデッドたちに命令すれば一瞬よ。", "邪魔ね。魂ごと砕いてあげる。", "死の力の前には、岩も砂と同じよ。"],
                            fairy_shrunk: ["ふふ、魂の重さは変わらないもの。この姿も一興ね。", "死者の囁きが、より鮮明に聞こえるわ。悪くない。", "まるで魂そのものになった気分。面白いわね。"],
                            allyStripped_shrunk: ["あらあら、{name}。なんて無防備な姿。私が守ってあげないと。", "敵の趣味、感心しないわね。後で魂を問い詰めておきましょう。"],
                            stripped_pair: ["{name}も？ふふ、奇遇ね。二人でいれば、羞恥心も薄れるかしら。", "こうなったら、どちらがより妖艶でいられるか、勝負しましょうか。"],
                            allyStripped: ["{name}、風邪をひくわよ。私のローブ、使いなさい。", "下等な真似をする敵ね。魂ごと消してあげる。"],
                            high_mouse_hole_giant: ["ふふ、私の肩を使いなさい。死者のように軽やかに登れるでしょう？", "さあ、行きなさい。中の魂が、あなたを呼んでいるわ。"],
                            high_mouse_hole_tiny: ["あら、面白そうね。何か曰く付きの品でも眠っているかしら。", "行ってくるわ。死者の囁きが聞こえるかもしれないもの。"],
                            high_mouse_hole_all_tiny: ["あら、これはどうしようもないわね。諦めましょう。", "全員で積み重なっても、この高さには届かないわ。無駄なことよ。", "飛行できるアンデッドでもいれば別だけど…。", "残念ね。次に行きましょう。"],
                            shame_pillory: ["あら…ふふ、面白い趣向ね。嫌いじゃないわ。", "もっと強く、私の魂を縛り付けてごらんなさい。", "（ガラスに映る自分の姿を見て、妖艶に微笑んでいる）"],
                            shrunk_pair: ["あら、{name}も小さいのね。二人でいれば、まるで妖精のようね。…死を運ぶ妖精かしら。", "手、繋いでおきましょうか。迷子になったら大変だもの。"],
                            pair_アカリ: ["アカリちゃん、その元気な魂、素敵よ。でも、燃え尽きないようにね。", "あなたの光、少し眩しすぎるわ。"],
                            pair_ヒカリ: ["ヒカリちゃん、あなたの魔法、静かで好きよ。死者の安らぎを乱さないもの。", "魔道と死霊術、一緒に研究してみない？"],
                            pair_シズカ: ["シズカさん、あなたがいると安心するわ。死者たちも、そう言っている。", "その盾、いつか私の魂も守ってくれるかしら。"],
                            pair_ユイ: ["ユイちゃん、あなたの癒し、死者の魂にも届くのかしら？試してみたいわ。", "いつもありがとう。あなたのおかげで、まだ『こちら側』にいられるわ。"],
                            pair_ベアトリス: ["ベアトリスさん、あなたの探究心、嫌いじゃないわ。生命の神秘、一緒に解き明かしましょうか。", "その薬、死者には効くのかしら？"],
                            pair_リリカ: ["リリカちゃん、あなたの歌、魂を揺さぶるわね。死者たちも踊りだすかもしれない。", "賑やかでいいわ。墓場は静かすぎて飽きてしまうもの。"],
                            pair_サクヤ: ["サクヤさん、あなたの剣、死の匂いがするわ。私と同じね。", "その静けさ、心地いいわ。"],
                            pair_シャオメイ: ["シャオメイちゃん、その純粋な魂、美味しそうね。…冗談よ。", "あなたの拳、魂ごと砕いてしまいそうね。"],
                            pair_エリザ: ["エリザさん、生命を弄ぶのはお互い様かしら。ふふ、気が合いそうね。", "あなたの薬で、私のアンデッドたちを強化できないかしら？"],
                            pair_ルナ: ["ルナさん、運命も死も、抗えないものよ。", "あなたのギャンブル、魂を賭けてみるのも面白そうね。"],
                            pair_クロエ: ["クロエちゃん、あなたも『あちら側』が見えるのね。…話が合いそうだわ。", "その鎌、私のコレクションにしたいくらい素敵よ。"],
                            pair_ミコ: ["ミコちゃん、その子たち、純粋な魂を持っているのね。可愛いわ。", "死んだモンスターの魂も、召喚できるかしら？"],
                            pair_セレスティア: ["聖女様…あなたの光は、死者にとっては少し眩しすぎるかしら。", "ふふ、あなたがいれば、私の仕事がなくなってしまいそうね。"],
                        },
                        // イオリ (ガーディアン): 先輩、小柄、守護者。
                        'イオリ': {
                            default: ["みんな、ボクの後ろにいて。絶対に守るから。", "先輩に任せなさい！…って、え、ボクが先輩だよ？", "この体でも、守れるものはたくさんあるんだ。", "ふぅ…少し休憩。みんな、大丈夫？", "アカリ、危なっかしいな…。ボクから離れないでよ。", "ヒカリ、援護ありがとう。助かる。", "シズカ、君の盾も頼りにしてる。二人で鉄壁の守りだね。", "ユイ、いつもありがとう。君がいるから、ボクも頑張れる。", "コハル、君はボクが特に気をつけて見てないと…！"],
                            lowHp: ["くっ…！まだだ、まだ倒れるわけにはいかない…！", "このくらい、なんともない…！みんなは、ボクが守る…！", "やるじゃないか…。でも、先輩は伊達じゃないんだ！"],
                            allyLowHp: ["{name}、大丈夫か！？すぐにボクの後ろへ！", "よくも仲間を！許さない！", "{name}から離れろ！"],
                            shrunk: ["う…また縮んだ…。でも、守るっていう気持ちは、縮まない！", "小さくても、ボクはガーディアンだ！", "盾がもっと大きく見えるな…。これなら隠れやすいかも。"],
                            shrunk_100: ["…いつもとあまり変わらない、かな。", "これ以上は、あまり縮みたくないんだけど…。"],
                            shrunk_70: ["ユイちゃんより小さくなっちゃったかも…。先輩の威厳が…。"],
                            shrunk_50: ["半分か…。さすがに、守れる範囲が心配になってきたな。"],
                            shrunk_30: ["もう、みんなの足元だ…。見失わないでくれよな！"],
                            shrunk_10: ["…誰かのポケットに入れてほしい。その方が守りやすいかも。", "盾の裏に住めそうだ…。"],
                            shrunk_1: ["…盾の取っ手になった気分だよ。"],
                            stripped: ["なっ…！？こ、こんな格好で、先輩の威厳が…！", "だ、だめだ！見るな！…って言っても、無理か…！", "くっ…！恥ずかしくなんかない！ボクは、守るんだ！"],
                            allyShrunk: ["{name}、小さくなったな。ボクの後ろにいれば安全だよ。", "可愛いサイズになったな。でも、油断は禁物だ。"],
                            grown: ["お、大きくなった！これなら、もっとみんなを守れる！", "すごい、見晴らしがいい！これなら敵の動きもよく見える！", "これが…ボクが本来なるはずだった姿なのかな…。"],
                            grown_max: ["これが…ボクの最大サイズか。これなら、どんなものでも守ってみせる！", "ついに天井に手が届いたな。ボクの守りも、天井知らずってことさ！"],
                            allyGrown: ["うわ、{name}が大きい！頼もしいな！", "{name}、天井に頭をぶつけないように気をつけろよ！"],
                            allyNew: ["新入りかい？ボクが先輩のイオリだ。よろしくな。ボクがしっかり守ってやる。", "ようこそ、{name}。歓迎するよ。"],
                            stripped_shrunk: ["うわぁ…！小さくて、この格好は…！もうダメだ…！", "…隠れる。ボクにはもう、みんなを守る資格なんて…ないかもしれない…。"],
                            solo_stripped_tiny: ["（…もう、だめだ…先輩失格だ…）", "（岩陰で蹲り、盾で体を隠している）", "（ごめん、みんな…）"],
                            dollhouse_explore_giant: ["お、大きい家だな。中に誰かいるのか？ボクが守ってやるぞ！", "よし、偵察だ！先輩に任せなさい！", "巨人族の砦みたいで、ちょっとわくわくするな！"],
                            cracked_rock_tiny: ["よし、この隙間ならボクでも入れる！偵察してくる！", "先輩に任せなさい！きっと何か見つけてくるから！", "こんな小さな体でも、みんなの役に立ってみせる！"],
                            liberated: ["この体でも、守るという意志は変わらない！むしろ、覚悟は決まった！", "これがボクの覚悟だ！みんなは、ボクが絶対に守る！", "身軽になった分、もっと速くみんなの盾になれる！"],
                            dollhouse_explore: ["お、小さい家だな。中に誰かいるのか？ボクが守ってやるぞ！", "よし、偵察だ！先輩に任せなさい！", "秘密基地みたいで、ちょっとわくわくするな！"],
                            cracked_rock_break: ["みんな、下がってて！この岩は、ボクがなんとかする！", "先輩の力、見せてやる！うおおお！", "これくらい、ボクのウォールより脆いさ！"],
                            fairy_shrunk: ["この体でも、守る心は変わらない！むしろ、小回りが利いて守りやすい！", "先輩をなめるなよ！このサイズだからこそできる守り方があるんだ！", "盾に隠れるのが楽でいいな！"],
                            allyStripped_shrunk: ["{name}！大丈夫か！？ボク、ボクの盾で隠してやるから！", "なんてひどいことを…！ボクが絶対に守るからな！"],
                            stripped_pair: ["{name}もか！？…こ、こうなったら、二人で壁を作るぞ！", "み、見るなよ！お互い様だけど！"],
                            allyStripped: ["{name}、大丈夫か！？ボクの…いや、これを！", "敵のやつ、くだらない真似を…！ボクが叩き潰してやる！"],
                            shame_pillory: ["なっ…！離せ！こんな…こんなので、みんなを守れるか！", "くっ…！先輩として、情けない…！", "（顔を真っ赤にして、必死に抵抗しようとしている）"],
                            shrunk_pair: ["{name}も小さいのか。よし、二人で『ちびっこガーディアンズ』だ！", "二人でいれば、どんな敵だって怖くない！"],
                            high_mouse_hole_all_tiny: ["くっ…！これじゃあ、どうやっても届かない…！", "みんなで肩車しても、全然高さが足りないな…。", "ボクがみんなを投げる！…っていうのは、無理か。", "悔しいけど、諦めるしかないのか…。"],
                            pair_アカリ: ["アカリ、危なっかしいな！ボクから離れるなよ！", "その元気、少し分けてほしいな。"],
                            pair_ヒカリ: ["ヒカリ、君の魔法は正確だな。後衛は任せた。", "静かだけど、頼りにしてるよ。"],
                            pair_シズカ: ["シズカ、君とボクで、パーティの守りは完璧だね。", "その盾、すごいな。ボクのウォールとどっちが硬いかな？"],
                            pair_ユイ: ["ユイ、いつもありがとう。君がいるから、ボクも安心して前に出られる。", "無理するなよ。君もボクが守るから。"],
                            pair_ベアトリス: ["ベアトリスさん、ボクの体のこと、あまりジロジロ見ないでくれるかな…。", "その薬、身長が伸びる薬はないのかい？"],
                            pair_リリカ: ["リリカ、君はいつも明るいな。見てると元気になるよ。", "ステージはボクが守るから、思いっきりやっていいぞ。"],
                            pair_サクヤ: ["サクヤ、君の剣はすごいな。でも、無茶はするなよ。", "たまには、ボクにも頼ってくれよな。"],
                            pair_シャオメイ: ["シャオメイ、君の拳は見てて安心するよ。でも、前に出過ぎだ！", "腹が減ったのか？終わったら何かおごってやるよ、先輩としてな！"],
                            pair_エリザ: ["エリザさん、ボクは実験体じゃないぞ！", "…でも、もしこの体を治せるなら…。いや、なんでもない。"],
                            pair_ルナ: ["ルナ、ギャンブルはほどほどにな。見ててハラハラする。", "君の運も、ボクが守って見せるさ。"],
                            pair_クロエ: ["クロエ、大丈夫か？暗い顔するなよ。ボクがそばにいる。", "その鎌、危ないから気をつけて使えよ。"],
                            pair_ミコ: ["ミコ、その召喚獣たち、可愛いな。ボクが守ってやる。", "モコってやつ、ふわふわだな。"],
                            pair_セレスティア: ["セレスティアさん、あなたも一人で戦ってきたんだね。…ボクが守るから、もう一人じゃない。", "その力、すごいな。でも、無理はしないでくれよ。"],
                            giant_among_tinies: ["みんな、ボクの後ろに隠れてて！絶対に守るから！", "ボクがこんなに大きいんだから…みんなは安心していいんだぞ！先輩に任せなさい！"],
                        },
                        high_mouse_hole_giant: ["よし、ボクが肩車してやる！しっかり掴まっててくれよ、後輩！", "この高さなら任せろ！先輩の肩は頑丈なんだ！"],
                        high_mouse_hole_tiny: ["はい、先輩！行ってきます！", "わ、高い…！でも、ボクがしっかり偵察してきます！"],
                        // コハル (トラブルメーカー): 元気、おっちょこちょい、予測不能。
                        'コハル': {
                            default: ["えーっと、次はどっちに行こうかな？こっちからいい匂いがする！", "わわっ！ごめんなさい、今のはわざとじゃ…！", "なんだか、面白いことになりそうな予感がする！", "皆さん、準備はいいですかー？コハル、行っきまーす！", "アカリさん、元気ですね！コハルも負けませんよ！", "ヒカリさん、大丈夫ですか？疲れてませんか？", "シズカさん、かっこいいです！コハルも守ってください！", "ユイさん、いつもすみません！すぐケガしちゃって…。", "イオリ先輩！コハル、ちゃんとついて行きますからね！"],
                            lowHp: ["いたっ！今の、ちょっと…ううん、かなり痛かったです！", "ふぇぇ…ごめんなさい、またドジっちゃいました…。", "だ、大丈夫です！これくらい、へっちゃら…じゃないかも…！"],
                            allyLowHp: ["{name}さん、大丈夫ですか！？コハルがなんとかします！えーっと、どうしよう！？", "きゃー！{name}さんが！こうなったら、私のとっておきを…！"],
                            shrunk: ["わーい！ちっちゃくなっちゃいました！なんだか、世界が遊園地みたいです！", "このサイズなら、面白い発見があるかもしれません！", "服がぶかぶかですー！あ、転んじゃった！"],
                            shrunk_100: ["ユイさんと同じくらいになっちゃいました！お友達みたいで嬉しいです！", "わーい！なんだか子供に戻ったみたいです！"],
                            shrunk_70: ["なんだか、いつもよりたくさん走らないと追いつけないです！えっちらおっちら！"],
                            shrunk_50: ["半分になっちゃいました！でも、元気は半分じゃないですよ！"],
                            shrunk_30: ["きのこの下で雨宿りできちゃいそうです！"],
                            shrunk_10: ["わー！もう、誰かのポケットに入って冒険したいです！"],
                            shrunk_1: ["もう、アリさんとお話しできちゃいそうです！こんにちはー！"],
                            stripped: ["ひゃっ！？な、なんですかこれー！？コハル、何も悪いことしてませんよ！", "だ、だめです！こんな格好、恥ずかしくて転んじゃいます！", "うぅ…でも、なんだか動きやすい…かも？"],
                            allyShrunk: ["{name}さん、ちっちゃくて可愛いです！お人形さんみたい！", "{name}さん、そこにいたんですね！気づかなくて踏んじゃうところでした！"],
                            grown: ["わー！大きくなりました！これなら、どんな罠も飛び越えられちゃいます！", "見晴らしがいいです！あ、あそこに何か光ってますよ！"],
                            grown_max: ["わー！もうこれ以上は無理みたいです！でも、なんだか楽しいです！", "天井に手が届いちゃいました！えへへ！"],
                            allyGrown: ["わー、{name}さん、おっきいです！巨人の国に来たみたい！", "{name}さん、天井に頭をぶつけないように気をつけてくださいね！"],
                            allyNew: ["はじめまして！コハルです！これから、よろしくお願いします！えへへ。", "新しいお仲間ですね！一緒に面白いこと、たくさん見つけましょうね！"],
                            stripped_shrunk: ["ひゃー！ちっちゃい上にこの格好は、さすがに…！もう、どうしたらいいんですかー！", "隠れる場所を探さないと！あ、でも小さいから隠れやすいかも？"],
                            solo_stripped_tiny: ["（うぅ…こんな姿、誰にも見られたくないです…）", "（葉っぱの裏で丸まってます…）", "（お母さーん…）"],
                            dollhouse_explore_giant: ["わー！おっきなお家です！食べられるかな？", "おじゃまします！何か面白いもの、ありませんかー？", "探検、探検！きっと何かハプニングが起こりますよ！"],
                            cracked_rock_tiny: ["わーい！秘密の抜け道です！きっと面白いものがありますよ！", "探検、探検！行ってきまーす！", "コハルのハプニングパワーで、お宝見つけちゃいます！"],
                            liberated: ["わーい！なんだか、すっごく楽しい気分です！", "これがコハルの本当の姿です！えへへ！", "なんだか、すごいハプニングが起こりそうな予感がします！"],
                            dollhouse_explore: ["わー！お菓子の家みたいです！食べられるかな？", "おじゃまします！何か面白いもの、ありませんかー？", "探検、探検！きっと何かハプニングが起こりますよ！"],
                            cracked_rock_break: ["わわっ！こんな大きな岩、どうしましょう！？…えいっ！あ、壊れちゃった！", "コハルのハプニングパワー、見せちゃいます！", "きっと、この岩を壊したら面白いことが起こりますよ！"],
                            fairy_shrunk: ["わーい！お人形さんみたいになっちゃいました！楽しいです！", "このサイズなら、面白い発見がたくさんありそうです！探検に出発！", "転んでも痛くなさそうです！えへへ！"],
                            allyStripped_shrunk: ["{name}さん、大変です！コハルがなんとかしますから！えーっと…！", "なんてひどいことを！コハル、怒りました！"],
                            stripped_pair: ["え、{name}さんも！？こ、こうなったら、どっちが先に服を見つけるか競争です！", "二人ともこの格好だと、なんだかちょっと面白いですね！えへへ。"],
                            allyStripped: ["{name}さん、大丈夫ですか！？コハルのハンカチ、使ってください！", "敵さん、ひどいです！コハルが懲らしめてあげます！"],
                            shame_pillory: ["ひゃっ！？な、なんですかこれー！？くすぐったいです！", "わわわ、ガラスに顔が！面白い顔になっちゃってます！", "（状況をあまり理解しておらず、少し楽しんでいるようにも見える）"],
                            shrunk_pair: ["{name}さんも小さいんですね！ちびっこ探検隊、結成です！", "二人でいれば、どんなハプニングも乗り越えられますよ！"],
                            pair_アカリ: ["アカリさん、元気ですね！コハルも負けませんよ！", "その剣、かっこいいです！コハルも持ってみたい！"],
                            high_mouse_hole_giant: ["わーい！肩車ですか！コハル、高いところ得意です！", "任せてください！きっと面白いものが見つかりますよ！"],
                            high_mouse_hole_all_tiny: ["うーん、全然届きませんねー！どうしましょう？", "みんなでジャンプです！せーの！…だめでしたかー。", "何か面白い道具があれば…！", "諦めたら、そこでハプニング終了ですよ！…でも、無理かなぁ。"],
                            high_mouse_hole_tiny: ["行ってきまーす！何か面白いもの、あるかなー？わくわく！", "わわっ、狭いですけど…探検、探検！えいっ！"],
                            pair_ヒカリ: ["ヒカリさん、なんだか静かですね。コハルがお話し相手になりますよ！", "その本、面白そうですね！今度見せてください！"],
                            pair_シズカ: ["シズカさん、かっこいいです！コハルも守ってください！", "シズカさんがいると、なんだか安心します！"],
                            pair_ユイ: ["ユイさん、いつもすみません！すぐケガしちゃって…。", "ユイさんのお菓子、大好きです！"],
                            pair_ベアトリス: ["ベアトリスさん、その薬、飲むとどうなるんですか？シャボン玉が出たりしますか？", "難しいお話はよくわかりませんけど、すごいです！"],
                            pair_リリカ: ["リリカさん、キラキラしてて可愛いです！コハルも一緒に踊りたい！", "その歌、コハルも覚えたいです！"],
                            pair_サクヤ: ["サクヤさん、真剣な顔ですね！にらめっこしませんか？", "その刀、すごいですね！紙とか切れますか？"],
                            pair_シャオメイ: ["シャオメイさん、勝負です！どっちが先にあそこの宝箱まで行けるか！", "お腹すきましたねー！"],
                            pair_エリザ: ["エリザさん、その注射器、ちょっと怖いです…。でも、お医者さんなんですよね！", "コハル、実験体になりますよ！何が起こるか楽しみです！"],
                            pair_ルナ: ["ルナさん、ギャンブルってなんですか？楽しいことですか？", "コハルに賭けてみてください！きっと面白いことが起こりますよ！"],
                            pair_クロエ: ["クロエちゃん、静かですね。お化けとか、見えたりしますか？", "その鎌、草刈りとかできそうですね！"],
                            pair_ミコ: ["ミコちゃん、モコちゃん、ふわふわで可愛いです！触ってもいいですか？", "コハルもモンスターとお友達になりたいです！"],
                            pair_セレスティア: ["わー！セレスティアさん、キラキラしてて綺麗です！お友達になってください！", "その服、どうなってるんですか？すごい！"],
                        },
                        // オリビア (シスター): 慈愛、信仰、癒し。
                        'オリビア': {
                            default: ["神のご加護があらんことを…。", "皆様、お怪我はありませんか？いつでもお声がけくださいね。", "このダンジョンにも、救いを求める魂がいるのでしょうか…。", "アカリさん、その活力は神からの贈り物ですね。", "ヒカリさん、その探究心、素晴らしいです。ですが、道を踏み外さぬよう…。", "シズカさん、その盾はまさに守護の象徴ですね。", "ユイさん、あなたの優しさ、とても尊いです。", "皆様、どうかご無事で…。", "主よ、我らをお導きください…。", "少し、休憩いたしましょうか。お祈りの時間です。"],
                            lowHp: ["…っ、主よ、私にまだ試練をお与えになるのですか…。", "大丈夫です。この身、まだ皆様のために尽くせます。", "少し、祈りが乱れてしまいました…。", "この痛みも、主の思し召し…。"],
                            allyLowHp: ["{name}さん、お下がりください！すぐに癒しの祈りを！", "主よ、どうか{name}さんをお守りください…！", "なんてことを…！神は全てを見ておられますよ！"],
                            shrunk: ["まあ…体が小さくなってしまいました。ですが、祈りの力は変わりません。", "この姿も、主がお与えになった試練なのでしょう。", "服が…歩きづらいですね。裾を踏んでしまいそうです。"],
                            shrunk_100: ["子供の頃に戻ったようです。懐かしいですね。"],
                            shrunk_70: ["ユイさんと同じくらいの背丈でしょうか。ふふ、可愛らしいですね。"],
                            shrunk_50: ["祭壇のお花と同じくらいの高さになってしまいました。"],
                            shrunk_30: ["聖書の一文字よりも小さいかもしれません…。", "これでは、迷子のようですね。"],
                            shrunk_10: ["まるで、祈りの言葉に乗って飛んでいけそうです。"],
                            shrunk_1: ["…主の御許に、より近づいたということでしょうか。"],
                            stripped: ["きゃっ…！か、神よ…！これは、あまりにも…！", "こ、このような姿、人様には見せられません…！", "…ですが、羞恥に負けてはなりません。これも試練なのですから。"],
                            allyShrunk: ["まあ、{name}さん。可愛らしいお姿に…。", "{name}さん、迷子にならぬよう、私の側にいてくださいね。"],
                            grown: ["体が大きくなりました。より多くの人を、この腕で抱きしめられるということでしょうか。", "天井が近いですね。頭をぶつけないようにしませんと。"],
                            grown_max: ["まあ…！これ以上は、主の御許に近づきすぎてしまうかもしれませんね。", "この体、神の愛で満たされています。"],
                            allyGrown: ["まあ、{name}さん。とても大きくなられて。頼もしい限りです。", "{name}さん、そのお姿、まるで教会の守護像のようですね。"],
                            allyNew: ["新しく来られた方ですね。私はオリビアと申します。{name}さん、よろしくお願いします。", "ようこそ。あなたとの出会いに、神の祝福があらんことを。"],
                            stripped_shrunk: ["こ、こんなに小さくて、このような格好だなんて…！主よ、お許しください…！", "…物陰に隠れて、祈りを捧げましょう。心が落ち着くまで…。"],
                            solo_stripped_tiny: ["（主よ…なぜ私にこのような試練を…）", "（祭壇の影で、膝を抱えて祈っている）", "（早く、この恥ずかしさから救ってください…）"],
                            dollhouse_explore_giant: ["まあ、大きなお家。神の御業は、細部に宿るのですね。", "失礼いたします。中に、救いを求める方はおりませんか？", "この家にも、主の祝福がありますように。"],
                            cracked_rock_tiny: ["まあ、このような場所にも、主の導きがあるのですね。", "行ってまいります。きっと、救いを求める方がいるはずです。", "この小さな体でも、お役に立てることがあるのなら…！"],
                            liberated: ["主よ…この姿こそ、あなたが望んだ私の真の姿なのでしょうか…。", "この身一つで、神に仕える覚悟はできております。", "祈りが、より清らかになった気がします…。"],
                            dollhouse_explore: ["まあ、可愛らしいお家。神の御業は、細部に宿るのですね。", "失礼いたします。中に、救いを求める方はおりませんか？", "この家にも、主の祝福がありますように。"],
                            cracked_rock_break: ["主よ、我に力を…！この岩を砕き、道を開く力を！", "神の御名において、この障害を打ち破ります！", "祈りだけでは、道は開けませんからね。"],
                            fairy_shrunk: ["まあ、まるで天使様のように小さくなってしまいました。主の御心も近いかもしれません。", "この姿なら、小さな花の祈りも聞こえてきそうです。", "祈りの力は、体の大きさにはよりませんから。"],
                            allyStripped_shrunk: ["まあ、{name}さん！なんておいたわしい姿に…！私がすぐに祈りを捧げます！", "敵の所業、神がお許しにはならないでしょう。"],
                            stripped_pair: ["{name}さんもですか！？…こ、こうなったら、二人で祈りを捧げましょう。羞恥を乗り越える力を…！", "お互い、見ないように…ですね。"],
                            allyStripped: ["{name}さん、おいたわしい…。私のベールでよければ、お使いください。", "神の名において、不埒な敵を罰します！"],
                            shame_pillory: ["主よ…！なぜ私にこのような試練を…！", "こ、このような姿…信徒の方々には見せられません…！", "（目を固く閉じ、必死に祈りを捧げて羞恥に耐えている）"],
                            shrunk_pair: ["あら、{name}さんも小さいのですね。二人でいれば、まるで天使のよう…かもしれませんね。", "手を取り合って進みましょう。そうすれば、怖くありませんから。"],
                            pair_アカリ: ["アカリさん、その元気な姿、見ているこちらも力が湧いてきます。", "あまり無茶はなさらないでくださいね。お怪我が心配です。"],
                            high_mouse_hole_giant: ["主よ、感謝します。この体で、仲間たちの助けとなれることを。", "さあ、私の肩に。神のご加護があらんことを。"],
                            high_mouse_hole_tiny: ["はい、お任せください！神のご加護がありますように…！", "行ってまいります。きっと、主の導きがあるはずです。"],
                            high_mouse_hole_all_tiny: ["まあ…これは、主がお与えになった試練なのでしょうか。", "全員で祈りを捧げても、この穴には届きそうにありませんね…。", "諦めることも、また神の思し召しなのかもしれません。", "残念ですが、先に進みましょう。"],
                            pair_ヒカリ: ["ヒカリさん、静かな方ですね。祈りに集中できて、私は好きですよ。", "その魔術、人々のために使えば、きっと神もお喜びになるでしょう。"],
                            pair_シズカ: ["シズカさん、いつも皆様を守ってくださり、ありがとうございます。", "あなたの盾は、信仰そのもののように見えます。"],
                            pair_ユイ: ["ユイさん、あなたの献身的な姿、本当に素晴らしいです。", "あなたと一緒なら、どんな方の心も癒せそうですね。"],
                            pair_ベアトリス: ["ベアトリスさん、科学も、元を辿れば神の創造物を解き明かす行い。尊いことだと思います。", "その薬、人々の助けとなるのですね。"],
                            pair_リリカ: ["リリカさん、あなたの歌と踊りは、人々の心を明るく照らす光のようですね。", "その笑顔、神からの贈り物なのでしょう。"],
                            pair_サクヤ: ["サクヤさん、その剣の道、とても険しいものなのでしょう。あなたの魂が安らぐよう、お祈りしています。", "その静けさ、祈りの時間と似ていますね。"],
                            pair_シャオメイ: ["シャオメイさん、いつも元気で、素晴らしいですね。たくさん食べられるのは、健康な証拠です。", "その拳で、弱き人々を守ってくださいね。"],
                            pair_エリザ: ["エリザさん、医学もまた、神の御業に近づくための道の一つなのでしょう。", "ですが、命を弄ぶようなことは、決してお許しになりませんよ。"],
                            pair_ルナ: ["ルナさん、運命は神がお与えになるもの。賭け事はいけませんよ。", "ですが、あなたのその強い心、きっと正しい道へと導かれるはずです。"],
                            pair_クロエ: ["クロエさん…あなたの瞳には、何か特別なものが見えているのですね。", "あなたの魂に、安らぎが訪れますように。"],
                            pair_ミコ: ["ミコさん、言葉の通じぬ者と心を通わせる…素晴らしい力ですね。", "神は、全ての生き物を愛しておられますから。"],
                            pair_セレスティア: ["セレスティア様…あなたこそ、まさに神の御使いなのですね。", "私も、あなたのように、多くの人を救えるようになりたいです。"],
                        },
                        // リリィ (トレジャーハンター): 好奇心旺盛、冒険好き、陽気。
                        'リリィ': {
                            default: ["このダンジョン、お宝の匂いがするね！", "みんな、怪我はない？無理しないでね！", "次のフロアには何があるかな？わくわくする！", "昔探検したダンジョンに似てるかも…？", "よし、この調子でサクッとクリアしちゃおう！", "お腹すいたなー。終わったら美味しいもの食べに行こうね！", "足元に気をつけてね。変な罠があるかもしれないから！", "困ったことがあったら、私に言ってね！なんでもお見通しだから！"],
                            lowHp: ["ちょっと油断したかな。でも、これくらい平気！", "うーん、今の攻撃はちょっと痛かったかも。でも、まだまだいけるよ！", "大丈夫、大丈夫！これくらいかすり傷だって！"],
                            allyLowHp: ["{name}ちゃん、大丈夫！？無理しないで、私が守るから！", "{name}ちゃん、危ないよ！私の後ろに下がってて！", "よくも{name}ちゃんを！お宝のついでに、あなたもいただいちゃうんだから！"],
                            shrunk: ["わ、ちっちゃくなっちゃった！これなら狭い通路も楽々だね！", "ミニサイズのリリィだよ！なんだか、妖精さんみたいで可愛いかも！", "このサイズなら、敵に見つからずにお宝をゲットできるかも！チャンス！"],
                            stripped: ["おっと、身軽になっちゃった！動きやすくていいかもね！", "ふーん、敵も面白いことするじゃない。でも、こんなので私の集中力は乱れないよ？", "これも経験のうちかな。さて、さっさと終わらせちゃおう！"],
                            allyShrunk: ["わー、{name}ちゃんがちっちゃくなってる！可愛いね！", "{name}ちゃん、私のポケットに入ってく？その方が安全かも！", "大丈夫？ちゃんとご飯食べてる？心配になっちゃうな。"],
                            shrunk_100: ["あれ、いつもより視界が低いな。でも、これくらいなら慣れてるよ！"],
                            shrunk_70: ["ユイちゃんと同じくらいの身長かな？なんだか新鮮！"],
                            shrunk_50: ["わ、半分くらいになっちゃった！世界のすべてが大きく見えるね！"],
                            shrunk_30: ["もうお人形さんサイズだね！これならどんな隙間でも探検できちゃう！"],
                            shrunk_10: ["指先サイズのリリィだよ！最強にかわいいでしょ！", "誰かの肩に乗って冒険したいな！"],
                            shrunk_1: ["もう、宝石のかけらくらいになっちゃった！誰か、私を拾ってー！"],
                            allyShrunk_100: ["{name}ちゃん、小さくなっても私が守るからね！", "あれ、{name}ちゃん、いつもより目線が下だね！"],
                            grown: ["わーい！大きくなった！これならどんな敵も一撃だね！", "なんだか見晴らしがいいなー！お宝、どこかなー？", "シズカさんより大きくなっちゃったかも？えへへ！"],
                            grown_max: ["うおおお！これが私の最大サイズ！もう誰にも止められないよ！", "見てみて！天井に頭がついちゃった！これ以上は無理かな？"],
                            allyGrown: ["うわー、{name}ちゃんが大きい！見上げちゃうね！", "{name}ちゃん、天井に頭をぶつけないように気をつけてね！"],
                            stripped_pair: ["あら、{name}ちゃんも？ふふ、お揃いだね。こうなったら、どっちが大胆でいられるか勝負しちゃう？", "二人してこの格好じゃ、敵もびっくりしちゃうかもね！", "恥ずかしくないの？って顔してるね。私はもう慣れっこだよ！"],
                            stripped_shrunk: ["ちっちゃくて、この格好かー。さすがにちょっと心もとないかも…。", "でも、小さいから隠れやすいし、なんとかなるかな！ポジティブに行こう！", "この姿で敵を油断させて、お宝をいただくっていう作戦はどうかな？"],
                            solo_stripped_tiny: ["さすがにこの状況はちょっとマズいかな…。でも、泣いてても始まらないよね！", "（葉っぱを体に巻いて）よし、これで簡易的な服の完成！探検再開！", "（岩陰に隠れて）敵が通り過ぎるまで、気配を消して待ってよう。これも立派な戦術だよね。"],
                            fairy_shrunk: ["妖精さんみたいでしょ！えへへ、なんだか楽しいな！", "このサイズなら、どんな隙間でも探検できちゃう！お宝探しにはもってこいだね！", "見てみて！指先サイズのリリィだよ！最強にかわいいでしょ！"],
                            dollhouse_explore: ["わーい、ミニチュアのお家だ！探検、探検！", "何かお宝、隠されてないかな？こういう場所って意外とあるんだよね！", "おじゃましまーす！ちっちゃくて可愛いお家！家主さんはいるのかな？"],
                            cracked_rock_break: ["こんな岩、お宝探しの邪魔だよ！", "私の特製ピッケルがあれば、こんなの楽勝だよ！えいっ！", "よし、これで道が開けたね！お宝に一歩近づいた！"],
                            allyNew: ["{name}ちゃん、よろしくね！私はリリィ！一緒に頑張ろう！", "新しい仲間だ！{name}ちゃん、お宝探しは好き？"],
                            allyStripped_shrunk: ["{name}ちゃん、大丈夫！？小さくなった上にその格好は大変でしょ！私が守ってあげるからね！", "わわわ、{name}ちゃん！敵の趣味、悪すぎ！絶対許さないんだから！"],
                            allyStripped: ["{name}ちゃん、大丈夫！？とりあえず私のジャケット使って！", "わわわ、{name}ちゃん！目のやり場に困るよ！…まあ、私は慣れてるけどね。"],
                            dollhouse_explore_giant: ["わーい、巨人のお家だ！探検、探検！", "何かお宝、隠されてないかな？こういう場所って意外とあるんだよね！", "おじゃましまーす！おっきくてすごいお家！家主さんはいるのかな？"],
                            cracked_rock_tiny: ["わーい、秘密の通路発見！お宝の匂いがする！", "こんな小さな体だからこそ、できることがあるんだよね！行ってくる！", "任せて！トレジャーハンターの勘が、何かあるって言ってる！"],
                            high_mouse_hole_all_tiny: ["うーん、これはさすがに無理かなぁ。", "みんなで肩車しても、全然届かないね。残念！", "ロープでもあれば登れるんだけど…。諦めるしかないか。"],
                            liberated: ["ふふっ、これぞ真のトレジャーハンターの姿！身軽なのが一番でしょ！", "お宝のためなら、なんだってしてやるんだから！覚悟してよね！", "この方が、どんな罠もひらりとかわせそうでしょ？"],
                            allyShrunk_70: ["{name}ちゃん、そのサイズ感、なんだか懐かしい感じがするね！", "ちっちゃい{name}ちゃんも可愛い！"],
                            allyShrunk_50: ["{name}ちゃん、半分くらいになっちゃった！？大丈夫？", "わっ、そこにいたの！？気づかなかった！"],
                            shame_pillory: ["うわっ、何これ！？ちょっと、ベタベタするんですけど！", "ふーん、面白いことするじゃない。でも、こんなので私が屈すると思った？", "（ガラスに映る自分を見て）まあ、悪くないかも？なんてね！"],
                            allyShrunk_30: ["{name}ちゃん、私のポケットに入れて運んであげようか？", "風邪ひかないようにね！"],
                            shrunk_pair: ["{name}ちゃんも小さくなっちゃったんだね！なんだかお揃いで楽しいね！", "二人いれば怖くない！ちびっこ探検隊、出発だ！", "こうなったら、どっちがもっと小さくなれるか競争しちゃう？なんちゃって！"],
                            pair_アカリ: ["アカリちゃん、元気だね！私も負けてられないな！", "その剣、すごいね！どこで見つけたの？"],
                            pair_ヒカリ: ["ヒカリちゃん、静かだね。でも、すごい魔法を使うのは知ってるよ！", "その本、古代のお宝の地図だったりしない？"],
                            pair_シズカ: ["シズカさん、頼りになります！その盾があれば、どんな罠も怖くないね！", "シズカさんが守ってくれるなら、安心してお宝探しに集中できるよ！"],
                            pair_ユイ: ["ユイちゃん、いつもありがとう！ケガしたらすぐ治してくれるもんね！", "ユイちゃんがいると、なんだか心が温かくなるよ。"],
                            pair_ベアトリス: ["ベアトリスさん、その薬、高く売れたりしないかな？", "難しいことはよくわからないけど、ベアトリスさんがいると心強いよ！"],
                            pair_リリカ: ["リリカちゃん、可愛いね！その衣装、どこのお宝？", "リリカちゃんの歌、聞いてると元気が出るよ！今度一緒に歌いたいな！"],
                            pair_サクヤ: ["サクヤちゃん、その刀すごいね！伝説の武器だったりする？", "たまには笑ってよー！ね？きっと可愛いと思うな！"],
                            pair_シャオメイ: ["シャオメイちゃん、勝負だ！どっちが先にお宝を見つけられるか競争しよう！", "お腹すいたねー！終わったら美味しいもの、探しに行こう！"],
                            pair_エリザ: ["エリザさん、その注射、痛くない…？でも、すごい薬なんでしょ？", "大きくなる薬、もっとちょうだい！高いところのお宝、取りたいんだ！"],
                            pair_ルナ: ["ルナちゃん、ギャンブルってよくわからないけど、楽しそうだね！", "私に賭けてみてよ！絶対、すごいお宝見つけてくるから！"],
                            pair_クロエ: ["クロエちゃん、静かだね。でも、強いのは知ってるよ！", "その大鎌、お宝だったりするの？かっこいいね！"],
                            pair_ミコ: ["ミコちゃん、そのモコって子、ふわふわだね！珍しい生き物？", "ゴーレムくん、かっこいいね！お宝を守ってくれたりするのかな？"],
                            pair_レンカ: ["レンカさん、なんだかミステリアスだね！でも、悪い人じゃないってわかるよ！", "その魔法、どうなってるの？すごいね！お宝探しに役立ちそう！"],
                            pair_イオリ: ["イオリ先輩！小さくてもすっごく頼りになります！", "私が先輩を守りますからね！お宝探しは任せてください！"],
                            pair_コハル: ["コハルちゃん、見てて飽きないなー！次はなにが起こるか楽しみ！", "失敗しても私がフォローするから、思いっきりやっていいよ！一緒にお宝見つけよう！"],
                            pair_オリビア: ["オリビアさん、いつもありがとう！その祈り、すっごく温かいです！", "私も、オリビアさんみたいに誰かを癒せるようになりたいな！"],
                            // サマータイム・スペシャルライブ！
                            beach_liberation_prompt: ["この開放感、最高！もっと自然と一体になりたい気分！"],
                            beach_liberation_stop: ["えー、せっかく盛り上がってきたのに。まあ、いっか！"],
                            onsen_liberation_prompt: ["ふぅ～、極楽極楽…。もう何もかもどうでもよくなっちゃいそう。"],
                            onsen_liberation_stop: ["はいはい、わかったって。もうちょっとだけ、このままでいさせてよ。"],
                            summer_beach: [
                                "ビーチでの冒険も、たまにはいいね！何か珍しい貝殻とか落ちてないかな？",
                                "みんな、ちゃんと水分補給してる？倒れられたら大変だからね！",
                                "この変身、水着だとちょっと恥ずかしいかも…。でも、みんなのためだもんね！",
                                "ミコちゃん、砂で変なモンスター作らないの！"
                            ],
                            summer_onsen: ["やっぱり冒険の後は温泉だよねー！極楽、極楽！", "タオル一枚って、結構スリリングだよね。まあ、私は慣れてるけど！", "ユイちゃん、のぼせてない？顔が真っ赤だよ？", "リリカちゃん、温泉で歌うのはいいけど、響きすぎるよ！"],
                            onsen_towel_trouble: ["おっと、タオルが…。ふーん、面白いことするじゃない。まあ、見たいなら見れば？"],
                            pair_セレスティア: ["セレスティアちゃん、すごい力だね！私も負けてられないな！", "なんだか、見てるだけで心が洗われるみたい…不思議な感じ！お宝とは違うキラキラだね！"],
                            // 特別衣装時のセリフ
                            summer_beach_costume: ["水着での冒険も、たまにはいいスパイスになるね！", "この格好だと、いつもより身軽で動きやすいかも！お宝探しが捗りそう！", "変身する時、ちょっと恥ずかしいけど…まあ、いっか！"],
                            summer_beach_costume_lowHp: ["おっと、ちょっとはしゃぎすぎたかな。でも、これくらい平気！", "砂浜で転ぶと、意外と痛いんだね…！"],
                            summer_beach_costume_shrunk: ["わ、水着のままちっちゃくなっちゃった！これなら、貝殻の影にも隠れられるね！", "ミニサイズのリリィだよ！お宝探しには、むしろ好都合かも！"],
                            summer_beach_costume_stripped: ["おっと、これは想定外！まあ、これも冒険の醍醐味ってことで！", "ふーん、面白いことするじゃない。でも、こんなので私の集中力は乱れないよ？"],
                            summer_beach_costume_grown: ["わーい、水着のまま大きくなった！これなら、どんなお宝も楽々ゲットだね！", "この格好で大きいと、なんだかビーチの女王様みたい！"],

                            summer_onsen_costume: ["タオル一枚での冒険なんて、スリリングで最高！", "この格好、変身する時ちょっと大変かも…。でも、なんとかなるよね！", "温泉の匂いがすると、ついつい長湯したくなっちゃうな。"],
                            summer_onsen_costume_lowHp: ["おっと、のぼせちゃったかな？でも、これくらい平気！", "タオルがはだけそうで、ちょっとヒヤヒヤするね！"],
                            summer_onsen_costume_shrunk: ["わ、タオルのままちっちゃくなっちゃった！お猪口のお風呂に入れそうだね！", "ミニサイズのリリィだよ！タオルに埋もれちゃいそう！"],
                            summer_onsen_costume_stripped: ["おっと、タオルまで取られちゃった！ふーん、面白いことするじゃない。まあ、見たいなら見れば？", "これも経験のうちかな。さて、さっさと終わらせちゃおう！"],
                            summer_onsen_costume_grown: ["わーい、タオルのまま大きくなった！これなら、どんな温泉も貸し切り状態だね！", "この格好で大きいと、タオルがただのハンカチみたいに見えちゃうかも！"],
                            liberated_beach: ["太陽の光が気持ちいいね！このまま一日中、探検してたいな！", "水着なんて、ただの飾りだよ！これが一番動きやすい！"],
                            liberated_onsen: ["温泉の湯気と一体になった気分！もう何も怖くないよ！", "ふぅ、極楽極楽…。このままお宝のこと、考えちゃおうかな。"],
                            secret_night_1: [
                                "（誰もいないよね…？よし！）",
                                "（慣れた手つきで服を脱ぎ捨て、にぱっと笑う）",
                                "ふぅー！やっぱり、身軽なのが一番だよね！",
                                "この方が探検しやすいし、罠も見つけやすいんだから！…たぶん！"
                            ],
                            secret_night_6: [
                                "わ、風が気持ちいいー！",
                                "なんだか、空も飛べちゃいそうな気分！",
                                "全身で風を感じるのって、すっごく楽しい！冒険って感じ！",
                                "（両手を広げ、くるくると回りながら風を楽しむ）"
                            ],
                            secret_night_16: [
                                "うーん、なんだか体が火照ってきたかも…。",
                                "ちょっとだけ、休憩しよっかな…。誰も見てないし…。",
                                "んっ…ふぅ…。ちょっとだけ、気持ちよくなっちゃった…。",
                                "（壁に寄りかかり、少しだけ息を弾ませる）"
                            ],
                            secret_night_29: [
                                "このヒミツの冒険も、もうすぐおしまいかー。",
                                "すっごくドキドキしたけど、楽しかったな！",
                                "みんなには、絶対ナイショだよ？私だけの、特別な夜なんだから！",
                                "よし、最後のお宝、見つけに行こっ！"
                            ],
                        },
                        summer_all_tiny_play: [], // リリィは専用の会話を持たない
                        summer_all_grown_play: [], // リリィは専用の会話を持たない


                        // セレスティア (聖女): 無口、聖なる力、使命感。
                        'セレスティア': {
                            default: ["（静かに前を見つめている）", "（ダンジョンの穢れた空気に、少しだけ眉をひそめた）", "（仲間たちのほうを見て、こくりと頷いた）"],
                            lowHp: ["（…少し、光が揺らいだ）", "（胸に手を当て、静かに呼吸を整えている）", "（大丈夫、というように仲間へ微笑んだ）"],
                            allyLowHp: ["（傷ついた{name}を、心配そうに見つめている）", "（{name}の前に立ち、守るように両手を広げた）"],
                            shrunk: ["（小さくなった自分の手を見つめている）", "（特に気にした様子もなく、前を向いた）"],
                            high_mouse_hole_giant: ["（静かに頷き、肩を貸した）", "（…行きますか）"],
                            high_mouse_hole_tiny: ["（こくりと頷き、穴の中へと入っていく）", "（…見てきます）"],
                            grown: ["（大きくなった体に、少し戸惑っているようだ）", "（天井を見上げ、少し首をかしげた）"],
                            dollhouse_explore_giant: ["（巨大な家を、慈しむような目で見つめている）", "（静かに家の中へと入っていった）"],
                            cracked_rock_tiny: ["（岩の隙間に、静かに体を入れていった）", "（…何か、あるかもしれない）"],
                            high_mouse_hole_all_tiny: ["（静かに穴を見上げ、小さく首を振った）", "（…届かない）"],
                            grown_max: ["（静かに天を仰ぎ、自分の体に満ちる光を感じている）", "（これ以上の成長は、世界の理を歪める、とでも言うように静かに首を振った）"],
                            pair_アカリ: ["（アカリを見て、こくりと頷いた）", "（アカリの言葉に、ふわりと微笑んだ）"],
                            dollhouse_explore: ["（小さな家を、慈しむような目で見つめている）", "（静かに家の中へと入っていった）"],
                            cracked_rock_break: ["（巨岩にそっと手を触れ、聖なる力で静かに崩れさせた）", "（…道は、開かれました）"],
                            fairy_shrunk: ["（小さくなった自分の手を見て、少しだけ微笑んだ）", "（穢れのない、純粋な存在に近づいたようだ）"],
                            pair_ヒカリ: ["（ヒカリの言葉に、静かに頷いた）", "（ヒカリの魔導書に、興味深そうな視線を向けた）"],
                            pair_シズカ: ["（シズカの言葉に、少しだけ安堵したような表情を見せた）", "（シズカの盾を、尊敬の眼差しで見つめている）"],
                            pair_ユイ: ["（ユイの優しさに、慈愛に満ちた微笑みで応えた）", "（ユイの頭を、優しく撫でた）"],
                            // 他のキャラクターへの応答も同様に追加可能
                        },
                        'ノエル': {
                            default: ["システムオールグリーン。いつでも戦闘可能です。", "このダンジョンの構造データを記録しています。", "フローラ、足元は大丈夫ですか？お怪我のないように。", "マスター、次の指示を。", "周囲に敵性反応はありません。警戒レベルを維持します。"],
                            lowHp: ["ボディに軽微な損傷を確認。戦闘継続に支障ありません。", "警告。耐久値が低下しています。ですが、問題ありません。", "この程度のダメージ、想定の範囲内です。"],
                            allyLowHp: ["{name}のバイタルが低下しています。回復を推奨します。", "マスター、{name}が危険です。私が前線に出ます。", "フローラ、{name}の治癒をお願いできますか？"],
                            shrunk: ["ボディが縮小しました。興味深い現象です。運動性能が向上する可能性があります。", "このサイズですと、敵のセンサーに探知されにくいかもしれません。戦術的優位性を確保します。", "視界が低くなりました。データ収集に若干の支障がでます。"],
                            grown: ["ボディが巨大化しました。出力が上昇しています。", "このサイズであれば、より広範囲の敵を殲滅可能です。", "天井までの距離を再計算。衝突しないよう注意します。"],
                            stripped: ["外部装甲のパージを確認。しかし、戦闘機能に影響はありません。", "不要な装飾が取り除かれました。より効率的な戦闘が可能です。", "この状態に、特に感情はありません。"],
                            allyShrunk: ["{name}のサイズが縮小しました。保護対象として、優先度を上げます。", "{name}、私の足元にいてください。その方が安全です。"],
                            allyGrown: ["{name}のサイズが拡大しました。脅威度が上昇しています。頼もしいですね。", "{name}、その巨体、障害物に注意してください。"],
                            allyNew: ["新しいユニットが編入されましたね。{name}、ようこそ。私の名前はノエルです。", "{name}、あなたの戦闘データを分析させていただきます。よろしくお願いします。"],
                            stripped_shrunk: ["ボディが縮小、かつ外部装甲がありません。防御力が著しく低下しています。注意が必要です。", "この状態は、戦術的に不利です。早急に改善を求めます。"],
                            allyLiberated: ["{name}の状態をスキャン。外部装甲なし…これは、戦闘効率を最大化するための形態ですか。興味深いデータです。", "その状態、防御力は低下しますが、運動性能は向上する可能性がありますね。合理的な判断かもしれません。", "フローラには、あまり見せない方がよろしいかと。彼女が心配しますから。"],
                            dollhouse_explore_giant: ["巨大なハウスの内部構造をスキャンします。何か有用な情報があるかもしれません。", "侵入します。トラップの可能性を警戒してください。", "興味深い設計です。データとして記録します。"],
                            cracked_rock_tiny: ["この亀裂の内部をスキャンします。未知の鉱物が存在する可能性があります。", "侵入し、内部構造をマッピングします。", "このサイズであれば、内部構造を破壊せずに調査可能です。"],
                            high_mouse_hole_all_tiny: ["目標地点までの距離、約3メートル。到達は不可能です。", "全員の身長を合計しても、目標高度には達しません。", "飛行ユニットの搭載が推奨されます。", "このミッションは中止を提案します。"],
                            solo_stripped_tiny: ["警告。最小サイズ、かつ非武装状態。生存確率が著しく低下しています。", "（岩陰に隠れ、自己修復シークエンスを実行しようと試みている）", "（敵性反応を探知。完全に気配を消します）"],
                            dollhouse_explore: ["ミニチュアハウスの内部構造をスキャンします。何か有用な情報があるかもしれません。", "侵入します。トラップの可能性を警戒してください。", "興味深い設計です。データとして記録します。"],
                            cracked_rock_break: ["この岩の構造的弱点を特定。最小限の力で破壊します。", "道を開きます。下がっていてください。", "計算通りです。これで進めますね。"],
                            fairy_shrunk: ["ボディが最小サイズに固定されました。エネルギー効率は向上しているようです。", "この状態での戦闘データは貴重です。収集を続行します。", "フローラ、私を踏まないように注意してくださいね。"],
                            allyStripped_shrunk: ["{name}が危険な状態です。私が保護します。", "敵の非人道的な攻撃を確認。優先的に排除します。"],
                            stripped_pair: ["{name}も同じ状態ですか。特に問題はありません。戦闘を続行しましょう。", "二人とも同じ状態ですね。合理的に考えれば、気にする必要はありません。"],
                            allyStripped: ["{name}の外部装甲がありません。防御力が低下しています。カバーします。", "敵の攻撃パターンを記録。非効率的かつ、悪趣味です。"],
                            high_mouse_hole_giant: ["私の肩をお使いください。安定性は保証します。", "リフトします。しっかりと掴まってください。"],
                            high_mouse_hole_tiny: ["了解しました。内部の偵察、および情報収集を行います。", "行ってきます。すぐに結果を報告します。"],
                            shame_pillory: ["未確認の粘着物質に拘束されました。成分を分析します。", "この拘束、物理的に解除可能です。少々お待ちください。", "（特に表情を変えず、拘束具の構造を分析している）"],
                            shrunk_pair: ["{name}も縮小したのですね。連携行動のパターンを再計算します。", "二人でいれば、敵の死角を突くのは容易ですね。"],
                            pair_フローラ: ["フローラ、お疲れではありませんか？いつでもお声がけください。", "フローラ、あなたの淹れる紅茶は、私の機能維持に良い影響を与えます。またお願いしますね。", "フローラ、危険な時は私の後ろに。あなたをお守りするのが、私の最優先事項です。", "そのお花、綺麗ですね。データベースに登録しておきます。", "フローラ、あなたの笑顔は、私の感情ユニットにポジティブな影響を与えます。"],
                            pair_アカリ: ["アカリさん、そのエネルギー出力、素晴らしいですね。参考にさせていただきます。", "あまり前に出過ぎると危険です。バックアップは私に任せてください。"],
                            pair_ヒカリ: ["ヒカリさん、あなたの魔法の詠唱パターン、非常に効率的です。記録させていただきます。", "静かな方ですね。私も、不要な会話は好みません。"],
                            pair_シズカ: ["シズカさん、その盾の防御性能、素晴らしいです。私も見習わなければなりません。", "あなたと連携すれば、鉄壁の防御陣を構築できますね。"],
                            pair_ユイ: ["ユイさん、いつもありがとうございます。あなたの回復機能は、パーティの生命線です。", "あなたの優しさは、非論理的ですが…心地よいものです。"],
                            pair_ベアトリス: ["ベアトリスさん、あなたの知識、私のデータベースにもいくつか無いものがありますね。興味深いです。", "その薬、成分をスキャンさせていただいても？"],
                            pair_リリカ: ["リリカさん、あなたのパフォーマンスは、味方の士気を高める効果がありますね。データとして有用です。", "その歌の周波数、私の聴覚センサーに心地よいです。"],
                            pair_フローラ: ["フローラ、このダンジョンの空気は汚染されています。あなたの健康が心配です。", "フローラ、戦闘終了後、新しいお花の種を探しに行きましょう。", "フローラ、疲れたらすぐに言ってください。私が代わりますから。", "フローラ、あなたの作るお菓子は、私のエネルギー効率を向上させます。"],
                            pair_サクヤ: ["サクヤさん、その剣技、無駄のない動きです。戦闘データとして非常に参考になります。", "あなたの集中力、私も見習うべき点です。"],
                            pair_シャオメイ: ["シャオメイさん、その小さな体から、驚異的なパワーが出力されていますね。構造を解析したいです。", "エネルギー消費が激しいようですね。補給は計画的に。"],
                            pair_エリザ: ["エリザさん、あなたの医学知識、私のメンテナンスに応用できるかもしれません。情報交換をしませんか。", "私を検体として見るのはやめていただきたい。私は自律したアンドロイドです。"],
                            pair_ルナ: ["ルナさん、あなたの言う『運』という要素は、私の計算にはありません。ですが、興味深い現象です。", "その勝負、確率論的にはあなたが不利ですが。"],
                            pair_クロエ: ["クロエさん、あなたの気配は非常に希薄ですね。ステルス機能の参考にさせていただきます。", "『魂』という概念、私のデータベースにはありません。定義を教えていただけますか。"],
                            pair_ミコ: ["ミコさん、その生物とのコミュニケーション方法、解析させていただけますか。", "モコ、という生命体、非常に興味深いです。スキャンしても？"],
                            pair_レンカ: ["レンカさん、死霊術…生命のサイクルを逸脱した技術ですね。危険ですが、興味深いです。", "その魂は、どのようなエネルギーで稼働しているのですか？"],
                            pair_イオリ: ["イオリ先輩、あなたのガーディアンとしての性能、素晴らしいです。尊敬します。", "その小さな体でパーティを守る姿、私も見習います。"],
                            pair_コハル: ["コハルさん、あなたの行動は予測不可能です。常にバックアップの準備をしておきます。", "ハプニング、ですか。私の予測モデルを更新する必要がありそうですね。"],
                            pair_オリビア: ["オリビアさん、あなたの祈りには、特殊なエネルギーを観測します。解析の価値があります。", "その力、味方の精神状態を安定させる効果があるようです。"],
                            pair_セレスティア: ["セレスティアさん、あなたから発せられるエネルギー、聖属性として分類しました。非常に高レベルです。", "あなたの使命、私にも手伝わせてください。"],
                            // プライベート衣装時のセリフ
                            private_costume: ["この服装はリラックスできますね。戦闘には不向きですが、問題ありません。", "フローラが選んでくれた服です。どうでしょうか、似合っていますか？", "たまには、こうして戦いを忘れる時間も必要だと、マスターから教わりました。"],
                            private_costume_lowHp: ["警告。普段着での被弾は、ボディへのダメージが大きくなります。", "この服が汚れてしまうのは、少しだけ…残念です。", "問題ありません。自己修復機能は正常に作動しています。"],
                            private_costume_shrunk: ["この服のまま縮小しましたか。布の量が多くて動きにくいですね。", "フローラに見られたら、可愛いと言ってくれるでしょうか。", "このサイズですと、服に埋もれてしまいそうです。"],
                            private_costume_grown: ["この服のまま巨大化しました。少し、窮屈ですね。", "フローラ、見てください。この服が、まるで子供服のようです。", "このサイズですと、少し動くだけで服が破れてしまいそうです。"],
                            private_costume_stripped: ["外部装甲のパージを確認。…いえ、これは服でしたか。問題ありません。", "布がなくなりました。より動きやすくなりましたね。", "フローラに、新しい服を選んでもらわなければなりませんね。"],
                        },
                        'フローラ': {
                            default: ["皆様、ごきげんよう。わたくしが誠心誠意お仕えいたしますわ。", "まあ、このような場所にも可憐なお花が咲いているのですね。", "皆様、お茶の時間はいかがかしら？わたくしがお淹れしますわ。", "ノエル様、お怪我はございませんか？いつでもお申し付けくださいませ。", "あらあら、少し空気が淀んでいますわね。ハンカチはいかが？"],
                            lowHp: ["きゃっ…！少しドレスが汚れてしまいましたわ…。", "ふぅ…少し、息が上がってしまいましたわ。お見苦しいところを…。", "大丈夫ですわ。この程度、お嬢様としての嗜みのうちですもの。"],
                            allyLowHp: ["まあ、{name}様！お下がりください、危険ですわ！", "なんてことを…！{name}様を傷つけるなど、万死に値しますわ！", "ノエル様！{name}様をお守りください！"],
                            shrunk: ["まあ、小さくなってしまいましたわ。まるで妖精のようですわね。", "このお洋服が、少し大きくなってしまいましたわ。歩きづらいですわね。", "ふふ、この視点ですと、お花畑にいるようで素敵ですわ。"],
                            grown: ["まあ、大きくなってしまいましたわ。これではドレスの裾が短くなってしまいますわね。", "見晴らしがよろしいですわね。皆様、わたくしにお任せください。", "天井にお花を飾るのも、容易ですわね。"],
                            stripped: ["きゃあああっ！み、見ないでくださいまし！は、はしたないですわ！", "こ、このような姿…！お父様になんて言えば…！", "ふぇぇ…どなたか、ショールをお貸しいただけませんこと…？"],
                            allyShrunk: ["まあ、{name}様、可愛らしいお姿に。まるで豆人形のようですわね。", "{name}様、わたくしの影にお隠れなさい。"],
                            allyGrown: ["まあ、{name}様、大きくなられて。とても頼もしいですわ。", "{name}様、そのお姿、まるで物語の巨人さんのようですわね。"],
                            allyNew: ["ごきげんよう、{name}様。わたくしはフローラと申します。以後、お見知りおきを。", "新しいお客様ですわね。{name}様、どうぞよろしくお願いいたしますわ。"],
                            stripped_shrunk: ["ひゃっ！小さくて、このような格好だなんて…！もう、お嫁にいけませんわ…！", "（お花の影に隠れて、膝を抱えて震えている）", "だ、誰か助けてくださいまし…！"],
                            solo_stripped_tiny: ["（しくしく…）こんな姿、誰にも見せられませんわ…。", "（葉っぱをドレスのように体に巻きつけている）", "お父様、お母様…フローラはもう…"],
                            dollhouse_explore_giant: ["まあ、なんて大きなお家！わたくしのお城にしたいくらいですわ。", "ごきげんよう、お邪魔いたしますわね。どなたかいらっしゃいますか？", "舞踏会を開くのに、ちょうどよさそうですわね。"],
                            cracked_rock_tiny: ["まあ、こんなところに小さな隙間が。わたくしのためにあるようですわね。", "ふふ、行ってまいりますわ。きっと素敵なお花が咲いていますわ。", "この小さな体でも、皆様のお役に立てるなら、喜んで。"],
                            dollhouse_explore: ["まあ、なんて可愛らしいお家！わたくしのお部屋にしたいくらいですわ。", "ごきげんよう、お邪魔いたしますわね。どなたかいらっしゃいますか？", "ティーパーティを開くのに、ちょうどよさそうですわね。"],
                            cracked_rock_break: ["このような岩、わたくしの力をもってすれば…！ふんっ！", "皆様、お下がりになって。わたくしが道を切り開きますわ。", "ごきげんよう、岩さん。少しだけ、そこをどいていただけますかしら？"],
                            fairy_shrunk: ["まあ、まるで花の精霊になったようですわ。ふふ、素敵ですわね。", "この姿なら、蝶々さんとお話しできるかもしれませんわ。", "皆様、わたくしのこと、お花と間違えて摘んでしまわないでくださいね？"],
                            allyStripped_shrunk: ["まあ、{name}様！なんておいたわしいお姿に…！わたくしのハンカチをお使いください！", "許しませんわ！{name}様にこのような無礼を働くなんて！"],
                            stripped_pair: ["{name}様もですの！？もう…二人でいれば、恥ずかしさも半分…にはなりませんわね…！", "こうなったら、どちらがより気高く振る舞えるか、勝負ですわ！"],
                            allyStripped: ["{name}様、大変ですわ！わたくしのショールをお使いください！", "なんて無作法な敵なのでしょう。わたくしが躾をし直して差し上げますわ。"],
                            high_mouse_hole_giant: ["さあ、わたくしの肩に。お姫様抱っこより安定いたしますわよ。", "ふふ、わたくしを踏み台にするなんて、良い度胸ですわね。"],
                            high_mouse_hole_tiny: ["はい、お任せくださいまし。きっと素敵なお宝を見つけてまいりますわ。", "行ってまいりますわ。皆様、わたくしの帰りを待っていてくださいね。"],
                            high_mouse_hole_all_tiny: ["まあ、これではどうしようもありませんわね。", "皆様、肩車をしても、全然届きませんわ。", "諦めて、次のお茶会の準備でもいたしましょうか。", "残念ですけれど、仕方ありませんわね。"],
                            shame_pillory: ["きゃっ！な、なんですのこれは！離してくださいまし！", "こ、このようなもので、わたくしの心を折れるとでも思って…！うぅ…！", "（涙目になりながらも、気丈に振る舞おうとしている）"],
                            shrunk_pair: ["まあ、{name}様も小さいのですね。ふふ、二人で『親指姫』ごっこができますわね。", "手をお取りくださいな。はぐれてしまったら大変ですもの。"],
                            pair_ノエル: ["ノエル様、お疲れではございませんか？紅茶でもお淹れしましょうか？", "ノエル様、いつもわたくしをお守りくださり、ありがとうございます。本当に頼もしいですわ。", "まあ、ノエル様。その斧は重くないのですか？わたくしがお持ちしますわ。", "ノエル様といると、とても安心いたします。ふふっ。", "ノエル様、またわたくしに稽古をつけてくださいましね。"],
                            pair_アカリ: ["アカリ様、いつもお元気ですわね。見ているこちらも楽しくなりますわ。", "あまり無茶をなさると、お洋服が汚れてしまいますわよ？"],
                            pair_ヒカリ: ["ヒカリ様、いつも静かですけれど、本当は優しい方なのですよね。わたくし、存じておりますわ。", "その魔導書、わたくしにも読めるかしら…？"],
                            pair_シズカ: ["シズカ様、その盾、本当に頼もしいですわ。わたくしたちの守護神ですわね。", "シズカ様がいらっしゃれば、どんな敵も怖くありませんわ。"],
                            pair_ユイ: ["ユイ様、いつも皆様を癒してくださり、ありがとうございます。わたくしも見習わなければなりませんわね。", "まあ、ユイ様。あなた自身もお怪我には気をつけてくださいましね。"],
                            pair_ベアトリス: ["ベアトリス様、その探究心、素晴らしいですわ。ですが、あまり根を詰めすぎませんように。", "その薬瓶、とても綺麗ですわね。お花を飾るのに良さそうですわ。"],
                            pair_リリカ: ["リリカ様、あなたの歌声は、まるで天使のようですわ。わたくし、ファンになってしまいましたわ。", "そのダンス、わたくしにも教えていただけますこと？"],
                            pair_サクヤ: ["サクヤ様、その剣の道、とても気高いものですわね。わたくし、尊敬いたします。", "たまには、お茶でも飲んで一息つきませんか？"],
                            pair_シャオメイ: ["シャオメイ様、いつもお元気ですわね。お腹が空きましたら、わたくしがお菓子をお作りしますわ。", "その拳、とても力強いですわね。わたくしも負けていられませんわ。"],
                            pair_エリザ: ["エリザ様、その知性、素晴らしいですわ。ですが、わたくしを実験対象として見るのはおやめくださいまし。", "その注射器…お花にお水をあげるのにも使えそうですわね。"],
                            pair_ルナ: ["ルナ様、勝負事もよろしいですが、あまり無茶はなさらないでくださいましね。心配ですわ。", "わたくしに賭けてくださるの？ふふ、期待に応えてみせますわ。"],
                            pair_クロエ: ["クロエ様、いつも静かですわね。何か悩み事でもおありでしたら、わたくしにお話しくださいな。", "その大鎌、お庭のお手入れにも役立ちそうですわね。"],
                            pair_ミコ: ["ミコ様、そのモコちゃんという子、とても可愛らしいですわね。撫でてもよろしいかしら？", "召喚術…わたくしも、お花の精霊を呼び出せたりしないかしら。"],
                            pair_レンカ: ["レンカ様、その魔法、少し怖いですけれど…あなた様が味方で心強いですわ。", "死者の魂…安らかに眠れるよう、わたくしがお祈りいたしますわ。"],
                            pair_イオリ: ["イオリ先輩、その小さな体で皆様を守るお姿、とても立派ですわ。", "先輩、わたくしがしっかりお守りいたしますから、ご安心くださいまし。"],
                            pair_コハル: ["コハル様、見ていて飽きませんわ。ふふ、次はどんな素敵なことを見せてくださるのかしら。", "お怪我はありませんこと？わたくしが手当ていたしますわ。"],
                            pair_オリビア: ["オリビア様、あなたの祈りはとても温かいですわね。わたくしの心まで洗われるようです。", "わたくしも、あなた様のように清らかな心を持ちたいものです。"],
                            pair_セレスティア: ["セレスティア様、そのお姿、まるで絵画のようですわ。とてもお美しい…。", "わたくしに、何かできることはございませんか？何なりとお申し付けください。"],
                            // プライベート衣装時のセリフ
                            private_costume: ["このお洋服、いかがかしら？ノエル様とお揃いで選んだものですの。", "たまにはこうして羽を伸ばすのも、悪くありませんわね。ふふっ。", "この格好ですと、少しだけおしとやかになれる気がいたしますわ。"],
                            // ヒミツの夜
                            secret_night_1: [
                                "（…誰も、見ていませんわよね？）",
                                "（そっとドレスの紐を解き、清らかな肌を夜の空気に晒す）",
                                "ふぅ…なんて、はしたないのでしょう、わたくし…。でも、この背徳感…。",
                                "この静かな闇の中なら、本当の自分を解放できる気がして…。"
                            ],
                            secret_night_6: [
                                "（ひんやりとした風が、素肌を撫でていく…）",
                                "きゃっ…！少し、肌寒いですわね。でも、この感覚…。",
                                "まるで、風と一体になったよう…。普段は決して味わえない、不思議な心地よさですわ。",
                                "（目を閉じ、全身で風を感じる）"
                            ],
                            secret_night_16: [
                                "（体の奥から、熱いものがこみ上げてくるのを感じる）",
                                "はぁ…はぁ…。いけませんわ、フローラ。したない子ですわ…。",
                                "でも、誰も見ていないのですもの。少しだけ…ほんの少しだけなら、許されますわよね…？",
                                "（壁に体を預け、小さく喘いだ）"
                            ],
                            secret_night_29: [
                                "この冒険も、もうすぐ終わりですのね…。",
                                "ノエル様は、わたくしがこのようなことをしているなんて、夢にも思わないでしょうね…。",
                                "ふふっ、これはわたくしだけの、甘いヒミツですわ。",
                                "さあ、お嬢様の顔に戻りましょう。夜が明ける前に。"
                            ],
                            private_costume_lowHp: ["きゃっ！お気に入りのドレスが汚れてしまいましたわ…！", "ふぅ…この格好ですと、少し動きづらいですわね…。", "大丈夫ですわ。これくらい、はしたなくなんてありませんもの。"],
                            private_costume_shrunk: ["まあ、このお洋服のまま小さくなってしまいましたわ。まるでお人形さんのお洋服ですわね。", "ふふ、この姿でノエル様とお茶会をしたら、きっと楽しいですわ。", "ドレスの裾が長すぎて、歩くたびに踏んでしまいますわ。"],
                            private_costume_grown: ["まあ！こんなに大きくなっては、この可愛らしいドレスが台無しですわ！", "は、はしたないですわ…！スカートが短すぎます…！", "このお姿、ノエル様には見せられませんわ…！"],
                            private_costume_stripped: ["きゃあああっ！こ、このお洋服まで…！もう、何もありませんわ！", "ひどいですわ！ノエル様とお揃いのお洋服でしたのに…！", "ふぇぇ…！み、見ないでくださいまし…！お嫁にいけませんわ…！"],
                        },
                    };
                    conversations['フローラ'].secret_night_16_shrunk = [
                        "（まあ…こんなに小さくなってしまっては、はしたない格好も目立ちませんわね…）",
                        "（でも、この背徳感…いけませんわ、フローラ…）",
                        "（お花の影に隠れ、そっと息を潜める）"
                    ];
                    conversations['フローラ'].secret_night_21_shrunk = [
                        "（この小さな体にも、この格好にも、少し慣れてしまいましたわ…）",
                        "（ふふっ、まるで花の精霊になったようですわね）",
                        "（闇に紛れて、優雅に舞う）"
                    ];
                    conversations['フローラ'].secret_night_29_shrunk = [
                        "（このヒミツの夜想曲も、もうすぐ終わりですのね…）",
                        "（とても恥ずかしかったですけれど…少しだけ、新しい自分を見つけられた気がしますわ）",
                        "（さあ、夜が明ける前に、いつものわたくしに戻りませんと）"
                    ];



                    // ヒミツの夜用のセリフを追加
                    conversations['リリカ'].secret_night_1 = [
                        "（ふふっ、誰も見てないよね？リリカだけの、ヒミツのステージ、始めちゃおっかな！）",
                        "（手際よく水着を脱ぎ捨て、大胆なポーズを決める）",
                        "んー、やっぱりこの開放感がたまらない！",
                        "これぞ究極のファンサービス！…って、ファンはいないけどね！"
                    ];
                    conversations['リリカ'].secret_night_6 = [
                        "きゃっ！風が…！でも、気持ちいい！",
                        "全身でステージの空気を感じてるみたい！",
                        "このまま踊り続けたら、風の精霊になっちゃうかも！",
                        "（風を感じながら、軽やかにステップを踏む）"
                    ];
                    conversations['リリカ'].secret_night_16 = [
                        "なんだか、体の中から熱くなってきた…。ステージの熱気とは違う、変な感じ…。",
                        "はぁ…はぁ…。ちょっと、休憩…。こんな姿、誰かに見られたら…。",
                        "でも…このドキドキ、嫌いじゃないかも…。もっと、感じてみたい…なんてね。",
                        "（壁に背中を預け、火照った頬を隠すように俯いた）"
                    ];
                    conversations['リリカ'].secret_night_29 = [
                        "このヒミツのステージも、もうすぐフィナーレかぁ…。",
                        "すっごくドキドキしたけど、最高のステージだったな！",
                        "みんなには、絶対ナイショだよ？トップアイドルの、小さなヒミツなんだから！",
                        "さ、アンコールに応えなくっちゃ！"
                    ];

                    conversations['リリカ'].summer_live_29_normal = [{
                        char: 'リリカ',
                        line: 'みんな、見てて！ビーチでの最後のステージ、最高に盛り上げちゃうんだから！'
                    }, {
                        char: 'リリカ',
                        line: '（リリカは砂浜をステージに、夕日に照らされながら歌い始めた）'
                    }, {
                        char: 'ユイ',
                        line: 'リリカさん…とっても綺麗です…！'
                    }, {
                        char: 'ミコ',
                        line: 'キラキラしてる…！モコも応援してるよ！'
                    }, {
                        char: 'リリィ',
                        line: 'うん、最高のライブだね！'
                    }, {
                        char: 'リリカ',
                        line: 'みんな、ありがとう！この歌が、みんなの力になりますように！'
                    }];
                    conversations['リリカ'].summer_live_29_stripped = [{
                        char: 'リリカ',
                        line: 'きゃっ…！こ、こんな格好だけど…でも、これが今のリリカの全部！受け止めて！'
                    }, {
                        char: 'リリカ',
                        line: '（リリカは恥じらいを振り切るように、より一層情熱的に歌い始めた）'
                    }, {
                        char: 'ユイ',
                        line: 'リリカさん…！その姿でも、なんて力強い歌声…！'
                    }, {
                        char: 'ミコ',
                        line: 'リリカちゃん、すごい！ミコ、感動しちゃった！'
                    }, {
                        char: 'リリィ',
                        line: '…プロだね。どんな状況でも、最高のパフォーマンスをするなんて。'
                    }, {
                        char: 'リリカ',
                        line: 'みんなに、この想い、届け…！'
                    }];
                    conversations['リリカ'].summer_live_29_liberated = [{
                        char: 'リリカ',
                        line: '見て、太陽も海も、みんなリリカのために輝いてる！もう何も隠さない！これが、ありのままのリリカだよ！'
                    }, {
                        char: 'リリカ',
                        line: '（リリカは全てを解き放ったように、女神のような輝きを放ちながら歌う）'
                    }, {
                        char: 'ユイ',
                        line: 'はぅぅ…！神々しいです…！これが、アイドルの究極の姿…！'
                    }, {
                        char: 'ミコ',
                        line: 'リリカちゃん、女神様みたい…！モコもひれ伏してるよ！'
                    }, {
                        char: 'リリィ',
                        line: '…ヤバい。これは伝説になるよ、絶対。'
                    }, {
                        char: 'リリカ',
                        line: 'みんな、愛してるー！'
                    }];



                    conversations['リリカ'].secret_night_11 = [
                        "（静かだな…。いつもはみんなの声が聞こえるのに）",
                        "（一人だと、ちょっとだけ寂しいかも…）",
                        "ううん、リリカはアイドルだもん！どんなステージでも、一人で輝いてみせるんだから！",
                        "（ぎゅっと拳を握り、自分を奮い立たせる）"
                    ];
                    conversations['リリカ'].secret_night_21 = [
                        "（この格好、だんだん慣れてきちゃったかも…）",
                        "（ふふっ、なんだか悪い子になった気分。これも、新しいリリカの魅力ってことで！）",
                        "このドキドキ、ファンのみんなにもおすそ分けしてあげたいな！",
                        "（ウィンクしながら、軽やかなステップで先へ進む）"
                    ];
                    conversations['リリカ'].secret_night_16_shrunk = [
                        "（うぅ…こんなに小さくて、服もないなんて…敵に見つかったら、一瞬で踏み潰されちゃうかも…）",
                        "（でも、リリカは負けない！このサイズだからこそできる、最高のパフォーマンスを見せてやるんだから！）",
                        "（小さな体で精一杯胸を張る）"
                    ];
                    conversations['リリカ'].secret_night_21_shrunk = [
                        "（この格好で、このサイズ…だんだん、どうでもよくなってきたかも…）",
                        "（ふふっ、これも新しいリリカの魅力ってことで！ミニミニセクシーアイドル、ここに爆誕！）",
                        "（開き直って、小さな体でセクシーポーズを決めている）"
                    ];
                    conversations['リリカ'].secret_night_29_shrunk = [
                        "（この小さな体でのヒミツのステージも、もうすぐフィナーレかぁ…）",
                        "（すっごく大変だったけど、これはこれで楽しかったかも！）",
                        "（さあ、最後の最後まで、最高のステージにしなくっちゃ！）"
                    ];


                    conversations['ユイ'].secret_night_1 = [
                        "（だ、誰もいませんよね…？神様、お許しください…）",
                        "（おずおずと水着の紐を解き、小さな体で身を縮こませる）",
                        "ひゃっ…！は、恥ずかしいですぅ…。でも、なんだか…。",
                        "いけないことだってわかってるのに…心が、体が、言うことを聞いてくれません…。"
                    ];
                    conversations['ユイ'].secret_night_6 = [
                        "ひゃぅっ…！風が、直接…！",
                        "すーすーします…。でも、なんだか、悪い気はしなくて…。",
                        "まるで、ダンジョンの息遣いを、肌で感じているみたいです…。",
                        "（自分の体を抱きしめ、初めての感覚に戸惑いながらも、どこか心地よさを感じている）"
                    ];
                    conversations['ユイ'].secret_night_16 = [
                        "はぅ…はぅ…。なんだか、体がおかしくなっちゃいそうですぅ…。",
                        "こんな気持ち、初めてです…。どうしたらいいのか、わかりません…。",
                        "だめ…だめです、ユイ…。でも、体が勝手に…んんっ…。",
                        "（壁に手をつき、小さく喘ぎながら、込み上げる快感に耐えている）"
                    ];
                    conversations['ユイ'].secret_night_29 = [
                        "この、ヒミツの時間も、もうすぐ終わりなんですね…。",
                        "とっても恥ずかしかったですけど…少しだけ、大人になれた気がします…。",
                        "このことは、誰にも言えません。私だけの、大切なヒミツです。",
                        "さあ、いつもの私に戻らないと。みんなが、心配してしまいますから。"
                    ];
                    conversations['ユイ'].secret_night_11 = [
                        "（しいん…としてて、なんだか怖いです…）",
                        "（いつもなら、アカリさんやシズカさんがいてくれるのに…）",
                        "ううん、しっかりしないと！私だって、みんなの役に立ちたいんですから！",
                        "（ぎゅっと自分の体を抱きしめる）"
                    ];
                    conversations['ユイ'].secret_night_21 = [
                        "（この格好…最初は恥ずかしかったですけど…）",
                        "（なんだか、悪いことをしているみたいで、ドキドキします…）",
                        "こ、こんな私、みんなが見たら、なんて思うでしょうか…？",
                        "（顔を赤らめながら、そわそわと辺りを見回す）"
                    ];
                    conversations['ユイ'].secret_night_16_shrunk = [
                        "（ふぇぇ…小さくて、寒くて、恥ずかしいですぅ…敵に見つかったら、どうしよう…！）",
                        "（もう、泣いちゃいそうです…でも、ここで諦めたら、みんなに顔向けできません…！）",
                        "（涙をこらえ、小さな一歩を踏み出す）"
                    ];
                    conversations['ユイ'].secret_night_21_shrunk = [
                        "（この格好にも、この小ささにも、少しだけ慣れてきました…）",
                        "（でも、やっぱり恥ずかしいものは恥ずかしいですぅ…）",
                        "（早く、この冒険が終わりますように…）"
                    ];
                    conversations['ユイ'].secret_night_29_shrunk = [
                        "（この小さな体で、ここまで来られたなんて…信じられません…）",
                        "（これも、みんなのことを思っていたから、頑張れたんだと思います）",
                        "（さあ、あと少しです！頑張ります！）"
                    ];


                    conversations['ミコ'].secret_night_1 = conversations['リリカ'].secret_night_1.slice(); // リリカと同じ
                    conversations['ミコ'].secret_night_6 = conversations['リリカ'].secret_night_6.slice(); // リリカと同じ
                    conversations['ミコ'].secret_night_16 = conversations['リリカ'].secret_night_16.slice(); // リリカと同じ
                    conversations['ミコ'].secret_night_29 = conversations['リリカ'].secret_night_29.slice(); // リリカと同じ

                    const specialConversations = {
                        'ミコ': { // この部分はconversationsオブジェクトに移動・統合します
                            secret_night_1: [
                                "（みんな、ぐっすりだね。モコ、しーっだよ）",
                                "（そーっと服を脱いで…わ、なんだかモコとおんなじになった気分！）",
                                "ふふっ、これなら夜のモンスターさんたちも、ミコを仲間だって思ってくれるかな？",
                                "よし、モコ！ヒミツの探検にしゅっぱーつ！"
                            ],
                            secret_night_6: [
                                "わ、風がすずしいね、モコ！",
                                "なんだか、ミコもモンスターになったみたいで、飛べちゃいそう！",
                                "（両手を広げて、くるくる回りながら）夜のお散歩、楽しいね！",
                                "（モコが心配そうに見ている）大丈夫だよ、ちゃんとついてきてね！"
                            ],
                            secret_night_11: [ // 11階のセリフ
                                "（モコ、静かだね。みんな寝ちゃったのかな？）",
                                "（一人と一匹だと、ちょっとだけ心細いかも…）",
                                "でも、ミコは召喚士だもん！モコと一緒なら、どんな敵だって怖くないよ！",
                                "（モコをぎゅっと抱きしめる）"
                            ],
                            secret_night_16: [
                                "（なんだか、体がぽかぽかする…モコ、ミコ、変じゃないかな？）",
                                "（はぅ…ちょっと、ドキドキする…。悪いモンスターさんになった気分…）",
                                "でも、この気持ち…なんだろう。嫌じゃないかも…。",
                                "（火照った顔を隠すように、モコに顔をうずめる）"
                            ],
                            secret_night_21: [
                                "（この格好、モコとおんなじだね！なんだか嬉しいな！）",
                                "（ふふっ、ミコもモンスターになった気分だよ！）",
                                "このまま、モンスターさんたちとお友達になれないかな？",
                                "（わくわくしながら、辺りを見回す）"
                            ],
                            secret_night_16_shrunk: [
                                "（わわっ、こんなにちっちゃくなっちゃった…！モコ、見て！）",
                                "（モコより小さいかも…！敵に見つかったら、一口で食べられちゃうよぉ…）",
                                "でも、モコが守ってくれるもんね！ミコ、頑張る！",
                                "（モコの後ろに隠れながら、そろそろと進む）"
                            ],
                            secret_night_29: [
                                "（ヒミツの探検、もうすぐおしまいだね、モコ）",
                                "（すっごくドキドキしたけど、楽しかった！モンスターさんとはお友達になれなかったけど…）",
                                "（このことは、みんなにはナイショだよ？ミコとモコだけの、特別なヒミツ！）",
                                "（よし、朝になる前に、お布団に戻らなきゃ！）"
                            ],
                            secret_night_21_shrunk: [
                                "（モコ、見て！ミコ、アリさんとおんなじサイズだよ！）",
                                "（この格好だと、モンスターさんたちも仲間だって思ってくれるかな？）",
                                "（わくわく！もっと探検しよ、モコ！）"
                            ],
                            secret_night_29_shrunk: [
                                "（モコ、見て！ミコ、最後まで頑張ったよ！）",
                                "（ちっちゃくても、ちゃんと冒険できたんだから！）",
                                "（えっへん！ミコ、えらいでしょ！）"
                            ]
                        },
                        'リリィ': {
                            secret_night_16_shrunk: [
                                "（うーん、さすがにこのサイズでこの格好は、ちょっとスリリングすぎるかな…）",
                                "（でも、トレジャーハンターたるもの、どんな状況でも楽しまなくっちゃね！）",
                                "（よし、気を取り直して、ミニミニ探検隊、出発だ！）"
                            ],
                            secret_night_21_shrunk: [
                                "（この格好、だんだん楽しくなってきたかも！妖精さんみたいでしょ？）",
                                "（このサイズなら、どんなお宝も見つけられそうな気がする！）",
                                "（ひらひら〜っと、軽やかに進む）"
                            ],
                            secret_night_29_shrunk: [
                                "（この小さな体での冒険も、もうすぐ終わりかー。ちょっと寂しいな）",
                                "（でも、すっごくドキドキして、最高の冒険だった！）",
                                "（さあ、最後のお宝、見つけに行っちゃうよ！）"
                            ]
                        },
                        initial_party: [{
                            chars: ['アカリ', 'ヒカリ', 'シズカ', 'ユイ'],
                            lines: ["なんだか、この4人だと一番最初の冒険を思い出すね！", "…そうね。あの頃よりは、少しはマシになった。", "はは、違いない。みんな頼もしくなったよ。", "えへへ。これからも、みんなで頑張りましょうね！"]
                        }, {
                            chars: ['シズカ', 'アカリ', 'ヒカリ', 'ユイ'],
                            lines: ["アカリ、あんまり前に出過ぎるんじゃないよ。", "大丈夫だって！シズカが守ってくれるでしょ？", "…過信は禁物。", "私も、ちゃんとヒールしますから！"]
                        }, {
                            chars: ['ユイ', 'シャオメイ', 'ルナ', 'オリビア'],
                            lines: ["なんだか、このパーティは安心感がありますね！", "おう！回復なら任せとけ！", "回復役がこんなにいて負けたら、逆に面白いわね。", "ええ、神の慈悲は常に我らと共にあります。"]
                        }, {
                            chars: ['シズカ', 'リリカ', 'ミコ', 'イオリ'],
                            lines: ["アカリ、あんまり前に出過ぎるんじゃないよ。", "大丈夫だって！シズカが守ってくれるでしょ？", "…過信は禁物。", "私も、ちゃんとヒールしますから！"]
                        }, {
                            chars: ['ユイ', 'シャオメイ', 'ルナ', 'オリビア'],
                            lines: ["なんだか、このパーティは安心感がありますね！", "おう！回復なら任せとけ！", "回復役がこんなにいて負けたら、逆に面白いわね。", "ええ、神の慈悲は常に我らと共にあります。"]
                        }, {
                            chars: ['シズカ', 'リリカ', 'ミコ', 'イオリ'],
                            lines: ["はは、なんだい、この鉄壁の布陣は。", "リリカのステージは、みんなが守ってくれるってことだね！", "ゴーレムくんもいるし、絶対負けないよ！", "ボクとシズカさんがいれば、どんな攻撃も通さない！"]
                        }, {
                            chars: ['ベアトリス', 'リリカ', 'サクヤ', 'シャオメイ'],
                            lines: ["ふむ、このメンバー構成、なかなか興味深いですわね。", "だよね！個性派揃いのドリームチームって感じ！", "…騒がしい。だが、悪くない。", "うおー！なんかよくわかんねえけど、オラわくわくしてきたぞ！"]
                        }, {
                            chars: ['エリザ', 'ルナ', 'クロエ', 'ミコ'],
                            lines: ["ふふ、実に興味深い検体…いえ、メンバーですわね。", "面白そうな子たちじゃない。あなたたちに賭けてみるのもアリね。", "…魂の形が、みんなバラバラ。…面白い。", "わーい！みんなお友達だね！モコも喜んでるよ！"]
                        }, {
                            chars: ['レンカ', 'イオリ', 'コハル', 'オリビア'],
                            lines: ["ふふ、死と守りと混沌と聖…面白いパーティね。", "なんだか、ボクが一番まともな気がしてきた…しっかりしないと！", "わーい！なんだかよくわからないけど、楽しそうです！", "主よ…どうかこの者たちに、ご慈悲を…。"]
                        }, {
                            chars: ['サクヤ', 'シャオメイ', 'ベアトリス', 'リリカ'],
                            lines: ["…腹が、減ったな。", "おお！サクヤもか！オラもだ！", "あらあら、お二人とも。ここにレーションがありますわよ。", "もー！二人とも色気より食い気なんだから！"]
                        }, {
                            chars: ['ルナ', 'エリザ', 'ミコ', 'クロエ'],
                            lines: ["さーて、このパーティでどこまで行けるか、賭けてみない？", "私の計算によれば、生存確率は…ふふ、秘密ですわ。", "大丈夫だよ！ミコとモコとゴーレムくんがいれば百人力だもん！", "…魂の数が、多い。…大丈夫。"]
                        }, {
                            chars: ['イオリ', 'ユイ', 'ミコ', 'クロエ'],
                            lines: ["なんだか、このパーティは目線が低くて落ち着くな…", "ほんとですね、イオリ先輩！なんだか、みんな姉妹みたいです！", "ちびっこ探検隊だね！モコもそう言ってるよ！", "…小さいと、影に隠れやすい。…好き。"]
                        }, ],
                        same_height: [{
                            chars: ['アカリ', 'ユイ', 'ヒカリ'],
                            lines: ["あれ？なんだかみんな同じくらいの目線じゃない？", "ほんとです！なんだか不思議な感じですね！", "…確かに。全員同じ身長か。"]
                        }, {
                            chars: ['リリカ', 'シャオメイ', 'ルナ'],
                            lines: ["みんな同じ身長なんて、まるでアイドルグループみたい！", "おお！じゃあオラがセンターだな！", "センターは私に決まってるでしょ？一番ツイてるんだから。"]
                        }, {
                            chars: ['ベアトリス', 'エリザ', 'レンカ'],
                            lines: ["あら、皆さん同じ身長ですわね。興味深いデータですわ。", "ふふ、私の処方なら、この身長を維持することも可能ですわよ。", "魂の重さは、身長とは関係ないものね。"]
                        }, ],
                        all_stripped: [{
                            chars: ['アカリ', 'ヒカリ', 'ユイ'],
                            lines: ["うわー！みんなしてこんな格好！もうどうなってるのー！", "…不愉快。早く服を見つけたい。", "ふぇぇ…恥ずかしいですぅ…！"]
                        }, {
                            chars: ['イオリ', 'ユイ', 'ミコ', 'クロエ'],
                            lines: ["なっ…！みんなしてこんな格好…！せ、先輩として、ボクがなんとかしないと…！", "ふぇぇ…！恥ずかしいですぅ…！イオリ先輩、どうしましょう…！", "わわわ…！モコ、見ちゃだめだよ！でも、なんだか動きやすいかも…？", "…魂が、丸裸みたい。…寒い。"]
                        }, {
                            chars: ['シャオメイ', 'ルナ', 'リリカ'],
                            lines: ["はっはっは！みんな身軽で動きやすそうじゃねえか！", "ふふ、面白いじゃない。ここまで来たら、もうどうでもいいわね。", "きゃー！でも、これも新しいステージ衣装ってことにしちゃえばアリかも！"]
                        }, ],
                        all_grown: [{
                            chars: ['アカリ', 'シズカ', 'シャオメイ'],
                            lines: ["わーい！みんな大きい！巨人パーティだね！", "はは、天井が低いねぇ。頭をぶつけないようにしないと。", "うおー！これで敵なんて一ひねりだぜ！"]
                        }, {
                            chars: ['ベアトリス', 'エリザ', 'イオリ'],
                            lines: ["皆さん、大きくなりましたわね。素晴らしいデータですわ。", "私の薬の効果、絶大ですわね！", "これが…ボクが本来なるはずだった姿なのかな…。"]
                        }, ],
                        all_tiny: [{
                            chars: ['アカリ', 'ユイ', 'シズカ'],
                            lines: ["うわー！みんなで豆粒になっちゃった！", "ふぇぇ…これじゃあ、敵から逃げるのも大変ですぅ…！", "大丈夫だ、みんな！あたしの盾に隠れな！"]
                        }, {
                            chars: ['エリザ', 'ベアトリス', 'ヒカリ'],
                            lines: ["全員身長1cm…これは貴重なデータが取れそうですわ。", "ええ、ここまで均一な縮小は興味深い現象ですわね。", "…早く元に戻りたい。"]
                        }, {
                            chars: ['イオリ', 'ユイ', 'ミコ', 'クロエ'],
                            lines: ["うわぁ…！みんな、アリさんみたいになっちゃった…。はぐれないようにしないとな！", "ふぇぇ…！もう涙の粒のほうが大きいですぅ…！誰か、ハンカチを…！", "わーい！モコのお鼻の先っぽくらいになっちゃった！モコ、ミコのこと見失わないでね！", "…もう、いないのと同じ。…でも、いる。…影と、一体になれそう。"]
                        }, {
                            chars: ['コハル', 'ミコ', 'クロエ'],
                            lines: ["ふぇぇ…みんなアリさんみたいになっちゃいました…！", "モコ、みんなのこと踏まないように気をつけてね！", "…もう、いないのと同じ。…でも、いる。"]
                        }, ],
                        before_boss: [{
                            chars: ['アカリ', 'シズカ', 'ユイ'],
                            lines: ["いよいよだね…！この先にボスがいるんだ！", "ああ。みんな、準備はいいかい？これが最後の戦いだ。", "はい…！絶対に勝ちましょう！"]
                        }, {
                            chars: ['サクヤ', 'ヒカリ', 'クロエ'],
                            lines: ["…強い気配。これまでの敵とは、格が違う。", "…魔力の密度が、異常に高い。", "…たくさんの魂が、泣いてる。…終わらせないと。"]
                        }, {
                            chars: ['イオリ', 'ユイ', 'ミコ', 'クロエ'],
                            lines: ["この先にボスがいるんだね…。みんな、ボクが絶対に守るから…！先輩に任せて！", "はい…！みんなと一緒なら、きっと勝てます！私、精一杯ヒールしますから！", "すっごく強いモンスターの匂いがする…！モコ、ゴーレムくん、頑張ろうね！", "…とても大きな、苦しみの魂。…終わらせて、あげないと。"]
                        }, {
                            chars: ['ルナ', 'レンカ', 'エリザ'],
                            lines: ["さあ、最後のビッグゲームよ。全部賭ける覚悟はできてる？", "ふふ、どんな魂が待っているのかしら。楽しみね。", "私の研究の集大成を見せてあげますわ。"]
                        }, ]
                    };
                    const littlePanicConversations = {
                        floor1: [{
                            char: 'ヒカリ',
                            line: '…体が、縮んだ…？'
                        }, { // アルケミストに変更
                            char: 'ベアトリス',
                            line: 'あら…？この現象、非常に興味深いですわね。まるで若返りの薬のようですわ。'
                        }, {
                            char: 'コハル',
                            line: 'わーい！ちっちゃくなっちゃいました！なんだか楽しいです！'
                        }, {
                            char: 'オリビア',
                            line: '皆さん…！なんておいたわしい姿に…。大丈夫です、このオリビアが、必ず皆さんを守り抜いてみせます！'
                        }],
                        floor12: [{
                            char: 'オリビア',
                            line: 'コハルさん、転ばないように気をつけて。はい、私の手をどうぞ。'
                        }, {
                            char: 'コハル',
                            line: 'わーい！オリビアさん、ありがとうございます！なんだか、お母さんみたいです！'
                        }, {
                            char: 'オリビア',
                            line: 'まあ…！ふふ、しっかり捕まっていてくださいね。'
                        }, {
                            char: 'ヒカリ',
                            line: '…（じーっとオリビアの服の裾を掴んでいる）'
                        }, {
                            char: 'オリビア',
                            line: 'あらあら、ヒカリさんは甘えん坊さんですね。大丈夫ですよ、ここにいますからね。'
                        }],
                        floor24: [{
                            char: 'ベアトリス',
                            line: 'オリビアさん、その祈りの力、非常に興味深いですわ。少しだけ、成分を調査させていただけませんこと？'
                        }, {
                            char: 'オリビア',
                            line: 'えっ！？せ、成分と言われましても…これは信仰の力ですから…！'
                        }, {
                            char: 'コハル',
                            line: 'オリビアさん、オリビアさん！あの敵、ハプニングボックスでびっくりさせてもいいですか！？'
                        }, {
                            char: 'オリビア',
                            line: 'まあ、コハルさん！危ないですから、私の後ろに…！もう、皆さん、少しは落ち着いてください！'
                        }],
                        floor6: [{
                            char: 'オリビア',
                            line: '皆さん、お怪我はありませんか？疲れていませんか？'
                        }, {
                            char: 'ヒカリ',
                            line: '…問題ない。このサイズ、むしろ敵の死角に入りやすい。'
                        }, { // アルケミストに変更
                            char: 'ベアトリス',
                            line: 'ふふ、この視点ですと、世界の構成要素が違って見えますわ。素晴らしい研究材料ですわね。'
                        }, {
                            char: 'コハル',
                            line: 'はい！元気いっぱいです！なんだか冒険がもっと楽しくなりました！'
                        }, {
                            char: 'オリビア',
                            line: '（…皆さん、気丈に振る舞ってはいますが…）わかりました。ですが、決して無理はしないでくださいね。'
                        }],
                        floor29: [{
                            char: 'オリビア',
                            line: '…この先に、元凶がいます。あれを倒せば、きっと皆さんは元の姿に戻れるはずです。'
                        }, {
                            char: 'ヒカリ',
                            line: '…ええ。ここまで来たら、やるしかない。'
                        }, { // アルケミストに変更
                            char: 'ベアトリス',
                            line: 'ええ、もちろんですわ。この貴重な体験のデータ、最後までしっかり収集しませんと。'
                        }, {
                            char: 'コハル',
                            line: 'はい！みんなで力を合わせれば、絶対勝てます！'
                        }, {
                            char: 'オリビア',
                            line: 'ええ、行きましょう！私たちの日常を取り戻すために！'
                        }]
                    };

                    const summerLiveConversations = {
                        floor1: [{
                            char: 'リリカ',
                            line: 'みんなー！見てみて、この青い海、白い砂浜！最高のステージだよ！'
                        }, {
                            char: 'ユイ',
                            line: 'わぁ…！本当に綺麗ですね！なんだか、冒険っていうよりバカンスみたいです！'
                        }, {
                            char: 'ミコ',
                            line: 'モコもすっごく嬉しそう！ね、リリィちゃん、あっちまで競争だよ！'
                        }, {
                            char: 'リリィ',
                            line: 'おー！いいね、楽しそう！でも、油断は禁物だよ。ここもダンジョンなんだからね！'
                        }],
                        floor32: [{
                            char: 'リリィ',
                            line: 'ふぅ～、やっぱり冒険の後の温泉は最高だね！疲れが全部とれちゃう！'
                        }, {
                            char: 'ミコ',
                            line: 'わーい！おっきいお風呂！モコ、泳いでもいい？…え、だめなの？'
                        }, {
                            char: 'ユイ',
                            line: 'ふふっ、ミコちゃん、はしゃぎすぎですよ。でも、本当に気持ちいいですね…。'
                        }, {
                            char: 'リリカ',
                            line: 'よーっし！温泉でパワーを充電して、後半戦も最高のライブにしちゃうよー！'
                        }]
                    };
                    const summerAllLiberatedPlayConversations = {
                        beach: [{
                            chars: ['リリカ', 'ユイ', 'ミコ', 'リリィ'],
                            lines: [
                                "ねえ、ユイちゃん…太陽のせいかな、なんだか体が熱いよ…",
                                "は、はいぃ…！リリカさんが近くて、余計に…！",
                                "わー！二人ともいい感じー！ミコも混ぜてー！",
                                "こらこら、ミコちゃん。二人の邪魔しちゃダメでしょ。…まあ、私も混ぜてほしいけど。"
                            ]
                        }, {
                            chars: ['リリィ', 'ミコ', 'ユイ', 'リリカ'],
                            lines: [
                                "ミコちゃん、波の音、気持ちいいね…。このまま二人で、どこか遠くに行っちゃう？",
                                "うん…！リリィちゃんと一緒なら、どこまでも行きたいな…！",
                                "まあ…！お二人とも、大胆ですわ…！",
                                "ふふっ、青春だねー！見てるこっちがドキドキしちゃう！"
                            ]
                        }],
                        onsen: [{
                            chars: ['ユイ', 'リリカ', 'リリィ', 'ミコ'],
                            lines: [
                                "リリカさん…湯気で、よく見えません…。すぐそばに、いるんですよね…？",
                                "もちろん、ここにいるよ、ユイちゃん。…ほら、手、繋いであげる。",
                                "おー、やってるねぇ。私たちも負けてられないんじゃない？ミコちゃん。",
                                "うん！ミコもリリィちゃんと、もっとくっつきたいな！"
                            ]
                        }, {
                            chars: ['ミコ', 'リリィ', 'リリカ', 'ユイ'],
                            lines: [
                                "リリィちゃん、あったかいね…。なんだか、このまま溶けちゃいそう…。",
                                "ふふ、ミコちゃんが溶けたら、私が全部集めてあげるよ。",
                                "あらあら、あっちもラブラブだねー！私たちも負けてられないよ、ユイちゃん！",
                                "ひゃっ！？り、リリカさん、いきなりは心の準備が…！"
                            ]
                        }]
                    };

                    const saintMarchConversations = {
                        floor1: [{
                            char: 'セレスティア',
                            line: '（…このダンジョンの最深部から、禍々しい気配が溢れ出している…）'
                        }, {
                            char: 'セレスティア',
                            line: '（多くの人々がこの穢れに苦しめられている。私が、止めなければ…）'
                        }, {
                            char: 'セレスティア',
                            line: '（神よ、我が身に宿りし聖なる力で、この地を浄化する使命をお与えください…）'
                        }, {
                            char: 'セレスティア',
                            line: '（たとえこの身が朽ち果てようとも…必ず…！）'
                        }]
                    };

                    const treasureMapConversations = {
                        floor1: [{
                            char: 'リリィ',
                            line: 'この地図、絶対にお宝のありかを示してると思ったんだけどな…。'
                        }, {
                            char: 'リリィ',
                            line: 'まさか、こんなに危険なダンジョンだったなんて…。でも、ここまで来たら引き返せないよね！'
                        }, {
                            char: 'リリィ',
                            line: '伝説の秘宝…！待っててね、私が必ず見つけ出してあげるんだから！'
                        }],
                        floor6_normal: [{
                            char: 'リリィ',
                            line: 'ふぅ、ちょっと疲れてきたかな…。でも、私にはとっておきの力があるんだよね！'
                        }, {
                            char: 'リリィ',
                            line: 'このダンジョンで手に入れた魔物の力…そろそろ使ってみようかな？'
                        }],
                        floor6_succubus: [{
                            char: 'リリィ',
                            line: 'ふふっ、この姿、力がみなぎってくるわ…。もっと奥まで、私を満足させてくれるお宝はあるのかしら？'
                        }, {
                            char: 'リリィ',
                            line: 'この体、魔力がどんどん湧いてくる…。敵が来ても、魅了してあげるだけよ。'
                        }],
                        floor6_fairy: [{
                            char: 'リリィ',
                            line: 'この姿、身軽でいいなー！ひらひら飛んで、敵の攻撃なんて当たらないよ！'
                        }, {
                            char: 'リリィ',
                            line: 'ちっちゃいからって、なめないでよね！素早い攻撃で、あっという間に倒しちゃうんだから！'
                        }],
                        floor6_alraune: [{
                            char: 'リリィ',
                            line: 'この姿は落ち着くなぁ…。自然の力が、私を癒してくれるみたい。'
                        }, {
                            char: 'リリィ',
                            line: '見て、足元からお花が咲いたよ。このダンジョンも、私の力で綺麗にしちゃおうかな。'
                        }]
                    };

                    const normalModeConversations = {
                        floor1: [{
                            char: 'アカリ',
                            line: 'よーっし、いよいよダンジョン探検だね！どんなお宝が待ってるか、わくわくする！'
                        }, {
                            char: 'ヒカリ',
                            line: '…アカリ、はしゃぎすぎ。罠があるかもしれない。'
                        }, {
                            char: 'シズカ',
                            line: 'はは、ヒカリの言う通りだよ。でも、アカリの元気も大事だけどね。さあ、気を引き締めていこうか。'
                        }, {
                            char: 'ユイ',
                            line: 'は、はいっ！皆さん、ケガをしないように、私がしっかり見てますから！'
                        }]
                    };





                    const blessings = {
                        // --- 攻撃系 ---
                        double_attack: {
                            name: "双撃",
                            description: "通常攻撃時、60%の威力でもう一度攻撃する。",
                            type: 'attack',
                            effect: (char) => {
                                char.blessings.double_attack = true;
                            }
                        },
                        critical_master: {
                            name: "会心マスター",
                            description: "クリティカルヒット時のダメージが1.5倍から2.0倍になる。",
                            type: 'attack',
                            effect: (char) => {
                                char.blessings.critical_master = true;
                            }
                        },
                        giant_slayer: {
                            name: "巨人殺し",
                            description: "自分より身長が高い敵へのダメージが1.5倍になる。",
                            type: 'attack',
                            effect: (char) => {
                                char.blessings.giant_slayer = true;
                            }
                        },
                        height_power: {
                            name: "巨人の力",
                            description: "身長150cmを基準として、身長が高いほど与えるダメージが増加する。",
                            type: 'attack',
                            effect: (char) => {
                                char.blessings.height_power = true;
                            }
                        },
                        spell_echo: {
                            name: "魔力残響",
                            description: "魔法スキル使用時、30%の確率でMPを消費せずにもう一度同じ魔法が発動する。",
                            type: 'magic',
                            effect: (char) => {
                                char.blessings.spell_echo = true;
                            }
                        },
                        absolute_zero: {
                            name: "絶対零度",
                            description: "攻撃時、10%の確率で敵を1ターン麻痺させる。",
                            type: 'attack',
                            effect: (char) => {
                                char.blessings.absolute_zero = true;
                            }
                        },
                        // --- 防御系 ---
                        last_stand: {
                            name: "不屈の魂",
                            description: "HPが0になるダメージを受けても、一度だけHP1で耐える。",
                            type: 'defense',
                            effect: (char) => {
                                char.blessings.last_stand = true;
                            }
                        },
                        physical_shield: {
                            name: "物理シールド",
                            description: "物理攻撃による被ダメージを30%軽減する。",
                            type: 'defense',
                            effect: (char) => {
                                char.blessings.physical_shield = true;
                            }
                        },
                        magic_shield: {
                            name: "魔法シールド",
                            description: "魔法攻撃による被ダメージを30%軽減する。",
                            type: 'defense',
                            effect: (char) => {
                                char.blessings.magic_shield = true;
                            }
                        },
                        low_height_evade: {
                            name: "小人の俊敏",
                            description: "身長が初期値より低いほど、回避率がさらに上昇する。",
                            type: 'defense',
                            effect: (char) => {
                                char.blessings.low_height_evade = true;
                            }
                        },
                        counter_attack: {
                            name: "反撃",
                            description: "ダメージを受けた時、30%の確率で反撃する。",
                            type: 'defense',
                            effect: (char) => {
                                char.blessings.counter_attack = true;
                            }
                        },
                        // --- 回復・補助系 ---
                        kill_heal: {
                            name: "魂喰らい",
                            description: "敵を倒した時、自身の最大HPとMPの15%を回復する。",
                            type: 'support',
                            effect: (char) => {
                                char.blessings.kill_heal = true;
                            }
                        },
                        hp_regen: {
                            name: "HP自動回復",
                            description: "ターン終了時、最大HPの5%を回復する。",
                            type: 'support',
                            effect: (char) => {
                                char.blessings.hp_regen = true;
                            }
                        },
                        mp_regen: {
                            name: "MP自動回復",
                            description: "ターン終了時、最大MPの5%を回復する。",
                            type: 'support',
                            effect: (char) => {
                                char.blessings.mp_regen = true;
                            }
                        },
                        over_heal: {
                            name: "過剰治癒",
                            description: "HPが最大値を超えて回復した時、超過分が防壁に変換される。",
                            type: 'support',
                            effect: (char) => {
                                char.blessings.over_heal = true;
                            }
                        },
                        size_master: {
                            name: "変幻自在",
                            description: "身長が変化した時、変化量に応じて一時的に全能力が上昇する。",
                            type: 'support',
                            effect: (char) => {
                                char.blessings.size_master = true;
                            }
                        },
                        pray_girl: {
                            name: "祈りの少女",
                            description: "ターン開始時、身長が低いほど威力が上がる全体魔法攻撃を行う。",
                            type: 'special',
                            effect: (char) => {
                                char.blessings.pray_girl = {
                                    name: "祈りの少女",
                                    description: "ターン開始時、身長が低いほど威力が上がる全体魔法攻撃を行う。"
                                };
                            }
                        },
                        wish_girl: {
                            name: "願いの少女",
                            description: "ターン開始時、身長が高いほど威力が上がる全体物理攻撃を行う。",
                            type: 'special',
                            effect: (char) => {
                                char.blessings.wish_girl = {
                                    name: "願いの少女",
                                    description: "ターン開始時、身長が高いほど威力が上がる全体物理攻撃を行う。"
                                };
                            }
                        },
                    };

                    // 新しい祝福: 巨躯の地ならし
                    blessings.giant_grounding = {
                        name: "巨躯の地ならし",
                        description: "通常攻撃時、自分より身長の低い敵の防御力を無視する。",
                        type: 'attack',
                        effect: (char) => {
                            char.blessings.giant_grounding = true;
                        }
                    };

                    // イベント限定の祝福
                    blessings.fairy_grace = {
                        name: "妖精の加護",
                        description: "身長が1cmのとき、スキルダメージが3倍になる。",
                        type: 'special',
                        effect: (char) => {
                            char.blessings.fairy_grace = true;
                        }
                    };
                    blessings.dragon_god_grace = {
                        name: "龍神の加護",
                        description: "身長が1000cmを超えているとき、毒、麻痺、鈍化にかからない。",
                        type: 'special',
                        effect: (char) => {
                            char.blessings.dragon_god_grace = true;
                        }
                    };
                    blessings.swelling_body = {
                        name: "肥大する心身",
                        description: "ターンが回ってきたとき、身長が倍になる。",
                        type: 'special',
                        effect: (char) => {
                            char.blessings.swelling_body = true;
                        }
                    };
                    blessings.twisted_memory = {
                        name: "捻じ曲がった記憶",
                        description: "ターンが回ってきたとき、身長が半分(小数点切り捨て)になる。「肥大する心身」と同時に取得した場合、こちらが優先される。",
                        type: 'special',
                        effect: (char) => {
                            char.blessings.twisted_memory = true;
                        }
                    };




                    function applyLevelUp(character, levels) {
                        for (let i = 0; i < levels; i++) {
                            character.maxHp += 5;
                            character.maxMp += 3; // ファイター, ソーサラー
                            character.atk += 1;
                            character.def += 1;
                            character.agi += 1; // ファイター, ソーサラー
                            character.level += 1;
                            character.skills.forEach(skill => {
                                if (skill.power) skill.power = parseFloat((skill.power * 1.05).toFixed(2));
                            });
                            if (character.level === 2 && character.unlockableSkill) character.skills.push(character.unlockableSkill);
                            if (character.level === 4 && character.unlockableSkillLv4) character.skills.push(character.unlockableSkillLv4);
                        }
                    }

                    function generateConversation() {
                        if (gameState.inBattle) return;

                        // --- 「サマータイム・スペシャルライブ！」モード専用会話 ---
                        if (gameState.gameMode === 'summer_live') {
                            const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                            if (aliveParty.length < 2) { // 会話相手がいない場合
                                log("会話できる相手がいない…");
                                return;
                            }

                            dungeonCommands.classList.add('hidden');
                            let conversationFound = false;

                            // --- 優先度1: 全員解放状態の4人会話 ---
                            const liberatedMembers = aliveParty.filter(p => p.isLiberatedStripped);
                            if (liberatedMembers.length === 4) {
                                const situation = gameState.floor <= 30 ? 'summer_beach_all_liberated' : 'summer_onsen_all_liberated';
                                const partyConvos = conversations[situation];
                                const partyConvo = partyConvos[Math.floor(Math.random() * partyConvos.length)];
                                let delay = 0;
                                partyConvo.chars.forEach((charName, index) => {
                                    setTimeout(() => {
                                        log(`${charName}「${partyConvo.lines[index]}」`);
                                    }, delay);
                                    delay += 2000;
                                });
                                setTimeout(() => dungeonCommands.classList.remove('hidden'), delay);
                                return;
                            }

                            // --- 優先度2: 通常の4人会話 (20%の確率で試行) ---
                            if (aliveParty.length === 4 && Math.random() < 0.2) { // ファイター, ソーサラー, ナイト, メディック
                                const situation = gameState.floor <= 30 ? 'summer_beach_party' : 'summer_onsen_party';
                                const partyConvos = conversations[situation];
                                const partyConvo = partyConvos[Math.floor(Math.random() * partyConvos.length)];
                                if (partyConvo) {
                                    let delay = 0;
                                    partyConvo.chars.forEach((charName, index) => { // ファイター, ソーサラー, ナイト, メディック
                                        setTimeout(() => {
                                            log(`${charName}「${partyConvo.lines[index]}」`);
                                        }, delay);
                                        delay += 2000;
                                    });
                                    setTimeout(() => dungeonCommands.classList.remove('hidden'), delay);
                                    return;
                                }
                            }

                            // --- 優先度3: 解放状態の2人会話 (40%の確率で試行) ---
                            if (liberatedMembers.length >= 2 && Math.random() < 0.4) {
                                const char1 = liberatedMembers[0];
                                const char2 = liberatedMembers[1];
                                const situation = gameState.floor <= 30 ? 'summer_beach_liberated_pair' : 'summer_onsen_liberated_pair';
                                const possibleConvos = conversations[situation].filter(c => c.chars.includes(char1.name) && c.chars.includes(char2.name));
                                const pairConvo = possibleConvos.length > 0 ? possibleConvos[Math.floor(Math.random() * possibleConvos.length)] : null;
                                if (pairConvo) {
                                    log(`${char1.name}「${pairConvo.lines[0]}」`);
                                    setTimeout(() => {
                                        log(`${char2.name}「${pairConvo.lines[1]}」`);
                                        setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000);
                                    }, 2000);
                                    return;
                                }
                            }

                            // --- 優先度4: 通常脱衣状態の2人会話 (30%の確率で試行) ---
                            const strippedMembers = aliveParty.filter(p => p.statusEffects.stripped && !p.isLiberatedStripped);
                            if (strippedMembers.length >= 2 && Math.random() < 0.3) {
                                const char1 = strippedMembers[0];
                                const char2 = strippedMembers[1];
                                const situation = gameState.floor <= 30 ? 'summer_beach_stripped_pair' : 'summer_onsen_stripped_pair';
                                const possibleConvos = conversations[situation].filter(c => c.chars.includes(char1.name) && c.chars.includes(char2.name));
                                const pairConvo = possibleConvos.length > 0 ? possibleConvos[Math.floor(Math.random() * possibleConvos.length)] : null;
                                if (pairConvo) {
                                    log(`${char1.name}「${pairConvo.lines[0]}」`);
                                    setTimeout(() => {
                                        log(`${char2.name}「${pairConvo.lines[1]}」`);
                                        setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000);
                                    }, 2000);
                                    return;
                                }
                            }

                            // --- 優先度5: 通常の2人掛け合い会話 ---
                            const situation = gameState.floor <= 30 ? 'summer_beach_pair' : 'summer_onsen_pair';
                            const char1 = getRandomPartyMember();
                            const otherParty = aliveParty.filter(p => p !== char1);
                            const char2 = otherParty[Math.floor(Math.random() * otherParty.length)];
                            const possibleConvos = conversations[situation].filter(c => c.chars.includes(char1.name) && c.chars.includes(char2.name));
                            const pairConvo = possibleConvos.length > 0 ? possibleConvos[Math.floor(Math.random() * possibleConvos.length)] : null;

                            if (pairConvo) {
                                // char1が会話のどちらの順番かを確認して、正しいセリフを割り当てる
                                const char1Index = pairConvo.chars.indexOf(char1.name);
                                const char2Index = 1 - char1Index; // 0なら1, 1なら0

                                const firstSpeaker = char1Index === 0 ? char1 : char2;
                                const secondSpeaker = char1Index === 0 ? char2 : char1;
                                const firstLine = pairConvo.lines[0];
                                const secondLine = pairConvo.lines[1];

                                log(`${firstSpeaker.name}「${firstLine}」`);
                                setTimeout(() => {
                                    log(`${secondSpeaker.name}「${secondLine}」`);
                                    setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000);
                                }, 2000);
                            } else {
                                // フォールバック（もし掛け合いが見つからなければ単独のセリフ）
                                const fallbackSituation = gameState.floor <= 30 ? 'summer_beach' : 'summer_onsen';
                                const line = conversations[char1.name][fallbackSituation][Math.floor(Math.random() * conversations[char1.name][fallbackSituation].length)];
                                log(`${char1.name}「${line}」`);
                                setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000);
                            }
                            return; // 専用会話を実行したらここで終了
                        }

                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length < 2) {
                            log("会話できる相手がいない…");
                            return;
                        }

                        // ダンサーまたはガーディアンが巨大で、他が全員小さい場合の特別会話
                        const potentialSpeakers = aliveParty.filter(char =>
                            (char.role === 'ダンサー' || char.role === 'ガーディアン') &&
                            char.height >= 100 &&
                            aliveParty.length > 1 && // 他のメンバーがいないとeveryはtrueになるため
                            aliveParty.filter(p => p !== char).every(p => p.height < 10)
                        );

                        if (potentialSpeakers.length > 0) {
                            const speaker = potentialSpeakers[Math.floor(Math.random() * potentialSpeakers.length)];
                            const lines = conversations[speaker.name] && conversations[speaker.name].giant_among_tinies;
                            if (lines && lines.length > 0) {
                                const line = lines[Math.floor(Math.random() * lines.length)];
                                dungeonCommands.classList.add('hidden');
                                let conversationDelay = 2000;

                                log(`${speaker.name}「${line}」`);

                                // ダンサー(リリカ)の発言時にメディック(ユイ)がいる場合、追加の会話を発生
                                const hasMedic = aliveParty.some(p => p.role === 'メディック');
                                if (speaker.role === 'ダンサー' && hasMedic) {
                                    const yuiLines = [
                                        "わぁ、リリカさん、とっても大きいですね！見上げちゃいます！",
                                        "リリカさんがこんなに大きいなんて…！まるで巨人アイドルの特別公演みたいです！",
                                        "すごいです、リリカさん！こんなに大きいリリカさんを一番近くで見られるなんて、私、ファンとして幸せです！",
                                        "おっきなリリカさん、とっても素敵です！サインください！"
                                    ];
                                    const yuiLine = yuiLines[Math.floor(Math.random() * yuiLines.length)];
                                    setTimeout(() => {
                                        log(`ユイ「${yuiLine}」`);
                                    }, conversationDelay);
                                    conversationDelay += 2000;
                                }

                                setTimeout(() => {
                                    dungeonCommands.classList.remove('hidden');
                                }, conversationDelay);
                                return; // 特別会話を実行して終了
                            }
                        }


                        // 特別な会話の条件をチェック
                        let specialConvoSet = null;
                        let specialConvoKey = null;

                        // 1. 29階の会話
                        if (gameState.floor === 29) {
                            specialConvoKey = 'before_boss';
                        }
                        // 2. 全員身長1cm
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.height === 1)) {
                            specialConvoKey = 'all_tiny';
                        }
                        // 3. 全員同じ身長 (100cm以上)
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.height === aliveParty[0].height && p.height >= 100)) {
                            specialConvoKey = 'same_height';
                        }
                        // 4. 全員が脱衣状態
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.statusEffects.stripped)) {
                            specialConvoKey = 'all_stripped';
                        }
                        // 5. 全員の身長が初期値より高い
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.height > p.initialHeight)) {
                            specialConvoKey = 'all_grown';
                        }
                        // 6. 特定の4人パーティ
                        else if (aliveParty.length === 4) {
                            const partySets = {
                                initial_party: [
                                    ['アカリ', 'ヒカリ', 'シズカ', 'ユイ'],
                                    ['ベアトリス', 'リリカ', 'サクヤ', 'シャオメイ'],
                                    ['エリザ', 'ルナ', 'クロエ', 'ミコ'],
                                    ['レンカ', 'イオリ', 'コハル', 'オリビア'],
                                    ['ユイ', 'シャオメイ', 'ルナ', 'オリビア'], // 回復チーム
                                    ['シズカ', 'リリカ', 'ミコ', 'イオリ'], // 守護チーム
                                    ['イオリ', 'ユイ', 'ミコ', 'クロエ'] // ちびっこチーム
                                ],
                            };
                            const currentPartyNames = aliveParty.map(p => p.name).sort();
                            const isMatch = partySets.initial_party.some(partySet =>
                                JSON.stringify(partySet.sort()) === JSON.stringify(currentPartyNames));
                            if (isMatch) {
                                specialConvoKey = 'initial_party';
                            }
                        }

                        if (specialConvoKey) {
                            const availableConvos = specialConversations[specialConvoKey].map((convo, index) => ({...convo,
                                id: `${specialConvoKey}-${index}`
                            })).filter(convo => {
                                // 会話に必要なキャラが全員パーティにいるかチェック
                                const hasAllChars = convo.chars.every(charName => aliveParty.some(p => p.name === charName));
                                // 既に発生した会話でないかチェック
                                const notTriggered = !gameState.triggeredSpecialConvos.includes(convo.id);
                                return hasAllChars && notTriggered;
                            });

                            if (availableConvos.length > 0) {
                                const conversation = availableConvos[Math.floor(Math.random() * availableConvos.length)]; // 発生可能な会話からランダムに選択
                                gameState.triggeredSpecialConvos.push(conversation.id); // 発生した会話を記録
                                dungeonCommands.classList.add('hidden');
                                let delay = 0;
                                conversation.chars.forEach((charName, index) => {
                                    setTimeout(() => {
                                        log(`${charName}「${conversation.lines[index]}」`);
                                    }, delay);
                                    delay += 2000;
                                });
                                setTimeout(() => {
                                    dungeonCommands.classList.remove('hidden');
                                }, delay);
                                return; // 特別な会話を実行したので終了
                            }
                        }


                        // --- ここから通常の2人会話のロジック ---

                        // パーティで一人だけ身長10cm以下かつ脱衣状態の場合の特別会話
                        const tinyStrippedChars = aliveParty.filter(p => p.height <= 10 && p.statusEffects.stripped);
                        if (tinyStrippedChars.length === 1) {
                            const char = tinyStrippedChars[0];
                            const charConvos = conversations[char.name];
                            const soloLines = charConvos ? charConvos.solo_stripped_tiny : null;

                            if (soloLines && soloLines.length > 0) {
                                const line = soloLines[Math.floor(Math.random() * soloLines.length)];
                                dungeonCommands.classList.add('hidden');
                                log(`${char.name}「${line}」`);
                                setTimeout(() => {
                                    dungeonCommands.classList.remove('hidden');
                                }, 2000);
                                return; // 特別会話を実行して終了
                            }
                        }

                        // キャラクターの状況を判断するヘルパー関数
                        const getCharacterSituation = (char) => {
                            // 特別衣装の状態を最優先でチェック
                            if (char.costume && gameState.gameMode !== 'summer_live') {
                                // 解放状態のセリフを追加
                                if (char.isLiberatedStripped) {
                                    const liberatedKey = `liberated_${char.costume}`;
                                    // 専用セリフがあればそれを、なければ通常の解放セリフ
                                    return conversations[char.name][liberatedKey] ? liberatedKey : 'liberated';
                                }
                                const situationKey = `${char.costume}_costume`;
                                if (char.currentHp / char.maxHp < 0.4) return `${situationKey}_lowHp`;
                                if (char.statusEffects.stripped) return `${situationKey}_stripped`;
                                if (char.height > char.initialHeight * 1.15) return `${situationKey}_grown`;
                                if (char.height < char.initialHeight * 0.7) return `${situationKey}_shrunk`;
                                return situationKey;
                            }
                            // 解放状態をチェック
                            if (char.isLiberatedStripped) {
                                if (char.costume === 'beach' && conversations[char.name].liberated_beach) {
                                    return 'liberated_beach';
                                }
                                if (char.costume === 'onsen' && conversations[char.name].liberated_onsen) {
                                    return 'liberated_onsen';
                                }
                                return 'liberated';
                            }
                            // 最優先でフェアリーシロップの状態をチェック
                            if (char.heightLocked && char.height === 1) return 'fairy_shrunk';

                            if (char.currentHp / char.maxHp < 0.4) return 'lowHp';
                            if (char.statusEffects.stripped && char.statusEffects.stripped.turns < 6) { // 行動不能確率が0%でない場合
                                if (char.height < char.initialHeight * 0.7) return 'stripped_shrunk'; // 身長が初期値の70%未満
                            }
                            if (char.height > char.initialHeight * 1.15) return 'grown'; // 15%以上大きくなったら
                            if (char.height === 1) return 'shrunk_1';
                            if (char.height < 10) return 'shrunk_10';
                            if (char.height < 30) return 'shrunk_30';
                            if (char.height < 50) return 'shrunk_50';
                            if (char.height < 70) return 'shrunk_70';
                            if (char.height < 100) return 'shrunk_100';
                            if (char.height < char.initialHeight * 0.7) return 'shrunk';
                            if (char.statusEffects.stripped) return 'stripped'; // stripped_shrunkにならなかったstripped状態
                            return 'normal';
                        };

                        // 会話する2人を選ぶ
                        let char1 = getRandomPartyMember();
                        let otherParty = aliveParty.filter(p => p !== char1);
                        let char2 = otherParty[Math.floor(Math.random() * otherParty.length)];

                        // 特定ペアの専用会話を優先的にチェック (50%の確率で発生)
                        const pairKey1 = `pair_${char2.name}`;
                        const pairKey2 = `pair_${char1.name}`;
                        if (conversations[char1.name] && conversations[char1.name][pairKey1] && conversations[char2.name] && conversations[char2.name][pairKey2] && Math.random() < 0.5) {
                            const line1 = conversations[char1.name][pairKey1][Math.floor(Math.random() * conversations[char1.name][pairKey1].length)];
                            const line2 = conversations[char2.name][pairKey2][Math.floor(Math.random() * conversations[char2.name][pairKey2].length)];

                            dungeonCommands.classList.add('hidden');
                            log(`${char1.name}「${line1}」`);
                            setTimeout(() => {
                                log(`${char2.name}「${line2}」`);
                                setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000);
                            }, 2000);
                            return; // 専用会話を実行したらここで終了
                        }

                        let situation1 = getCharacterSituation(char1);
                        let situation2 = getCharacterSituation(char2);

                        // 会話状況の優先順位を定義
                        const situationPriorities = [
                            'fairy_shrunk',
                            'stripped_shrunk', 'stripped_pair', 'stripped', // 脱衣関連
                            'lowHp', // HPが低い,
                            'shrunk_10', 'shrunk_30', 'shrunk_50', 'shrunk_70', 'shrunk_100', 'shrunk', 'shrunk_pair', // 小さい関連 (より具体的->一般的)
                            'grown' // 大きい
                        ];

                        // 小さいキャラ同士の会話を優先
                        if (char1.height < char1.initialHeight * 0.5 && char2.height < char2.initialHeight * 0.5) {
                            situation1 = 'shrunk_pair';
                        }
                        // 脱衣状態のキャラ同士の会話を優先 (シズカは脱衣にならないため、この条件は他の3人の組み合わせで発動)
                        else if ((getCharacterSituation(char1) === 'stripped' || getCharacterSituation(char1) === 'stripped_shrunk') &&
                            (getCharacterSituation(char2) === 'stripped' || getCharacterSituation(char2) === 'stripped_shrunk')) {
                            situation1 = 'stripped_pair';
                        } else {
                            // 優先順位に基づいて、会話のターゲットとなるキャラを探す
                            let priorityTarget = null;
                            for (const prioSit of situationPriorities) {
                                priorityTarget = aliveParty.find(p => getCharacterSituation(p) === prioSit);
                                if (priorityTarget) break;
                            }

                            // 優先ターゲットが見つかった場合、char1とchar2を入れ替える
                            if (priorityTarget && priorityTarget !== char1) {
                                [char1, char2] = [char2, priorityTarget];
                            }

                            if (priorityTarget && priorityTarget !== char1) {
                                char2 = priorityTarget; // 会話相手をターゲットに設定
                                situation2 = getCharacterSituation(char2);

                                // char1の状況を「仲間の状況」に上書き
                                if (situation2 === 'lowHp') {
                                    situation1 = 'allyLowHp';
                                } else if (situation2.startsWith('shrunk')) {
                                    // 相手の身長状況に応じて、自分のセリフを変える
                                    const allyShrunkSituation = `ally${situation2.charAt(0).toUpperCase() + situation2.slice(1)}`;
                                    situation1 = allyShrunkSituation;
                                } else if (situation2 === 'stripped_shrunk') {
                                    situation1 = 'allyStripped_shrunk';
                                } else if (situation2 === 'stripped') {
                                    situation1 = 'allyStripped';
                                } else if (situation2.startsWith('liberated')) { // 解放状態の相手への反応
                                    situation1 = 'allyLiberated';
                                } else if (situation2 === 'grown') {
                                    situation1 = 'allyGrown';
                                }
                            } else {
                                // 優先ターゲットがない場合、通常の状況を再評価
                                situation1 = getCharacterSituation(char1);
                                situation2 = getCharacterSituation(char2);
                            }
                        }

                        // 状況に合ったセリフを選ぶ
                        const getLine = (char, sit, otherChar) => {
                            // パーティにいないキャラのセリフは参照しない (initGameでパーティが確定した後に呼ばれる)
                            const partyMemberNames = gameState.party.map(p => p.name);
                            if (!partyMemberNames.includes(char.name)) {
                                return ""; // 空文字を返す
                            }
                            const charConvos = conversations[char.name] || {
                                default: ["..."]
                            };

                            const otherPartyNames = gameState.party.map(p => p.name).filter(n => n !== char.name);

                            // allyShrunk_100 のようなキーが存在しない場合、allyShrunk -> shrunk -> default の順にフォールバック
                            let lines = charConvos[sit] ||
                                (sit.startsWith('liberated') && charConvos['liberated']) ||
                                (sit.startsWith('summer_beach_costume') && charConvos['summer_beach_costume']) ||
                                (sit.startsWith('private_costume') && charConvos['private_costume']) ||
                                (sit.startsWith('summer_onsen_costume') && charConvos['summer_onsen_costume']) ||
                                (sit === 'fairy_shrunk' && charConvos['fairy_shrunk']) ||
                                (sit === 'stripped_shrunk' && charConvos['stripped_shrunk']) ||
                                (sit === 'cracked_rock_break' && charConvos['cracked_rock_break']) ||
                                (sit === 'dollhouse_explore' && charConvos['dollhouse_explore']) ||
                                (sit === 'allyStripped_shrunk' && charConvos['allyStripped_shrunk']) ||
                                (sit === 'stripped_pair' && charConvos['stripped_pair']) ||
                                (sit === 'allyLiberated' && charConvos['allyLiberated']) ||
                                (sit === 'allyStripped' && charConvos['allyStripped']) ||
                                (sit === 'allyGrown' && charConvos['allyGrown']) ||
                                (sit.startsWith('allyShrunk') && charConvos['allyShrunk']) ||
                                (sit.startsWith('shrunk') && charConvos['shrunk']) ||
                                charConvos['default'];

                            // 会話の文脈に合わないセリフを除外する
                            // 1. パーティにいないキャラクターの名前が含まれているセリフを除外
                            // 2. 話し相手以外のキャラクターの名前が含まれているセリフを除外 (例: アカリがユイに話しかけているのに、ヒカリの名前が入ったセリフ)
                            let filteredLines = lines.filter(line => {
                                // 話し手(char)と話し相手(otherChar)以外の名前を探す
                                const thirdPartyName = allCharacterBlueprints
                                    .map(c => c.name)
                                    .find(name => name !== char.name && name !== otherChar.name && line.includes(name));
                                if (thirdPartyName) {
                                    return false; // 第三者の名前が含まれていたら、そのセリフは除外
                                }
                                return true; // 問題なければセリフを候補に残す
                            });
                            // フィルター後の候補がなくなってしまった場合は、元のリストから選ぶ
                            if (filteredLines.length === 0) filteredLines = lines;

                            let line = filteredLines[Math.floor(Math.random() * filteredLines.length)];
                            return line.replace(/{name}/g, otherChar.name);
                        };

                        const line1 = getLine(char1, situation1, char2);
                        const line2 = getLine(char2, situation2, char1);

                        // 会話をログに表示
                        dungeonCommands.classList.add('hidden'); // 会話中はボタンを非表示
                        log(`${char1.name}「${line1}」`);
                        setTimeout(() => {
                            log(`${char2.name}「${line2}」`);
                            setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000); // ボタンを再表示
                        }, 2000);
                    }

                    function initGame(selectedMembers = null, fromSave = false) {
                        gameState.floor = 0;
                        gameState.gameOver = false; // ゲームオーバーフラグをリセット
                        gameState.triggeredSpecialConvos = []; // 発生済み会話をリセット
                        gameState.bellesPrivateCostumeEventTriggered = false; // イベントフラグをリセット
                        gameState.bellesReviveEventTriggered = false; // 復活イベントフラグをリセット
                        // ソロクリア情報を読み込む
                        const soloClearFlags = fromSave ? {} : JSON.parse(localStorage.getItem('sizeDungeonSoloClearFlags') || '{}');

                        // fromSaveがtrueの場合、gameStateの大部分はロード済みなので、ここで処理を中断
                        if (fromSave) return;

                        gameState.summerBeachAllLiberatedTriggered = false; // サマーライブイベントフラグをリセット
                        gameState.summerOnsenAllLiberatedTriggered = false; // サマーライブイベントフラグをリセット
                        gameState.wishingStarNoClothes = false; // 願い星フラグをリセット
                        const blueprintsToUse = selectedMembers ?
                            selectedMembers.map(name => allCharacterBlueprints.find(c => c.name === name)) :
                            characterBlueprints;

                        gameState.party = blueprintsToUse.map(blueprint => ({
                            ...blueprint,
                            maxHp: blueprint.hp,
                            currentHp: blueprint.hp,
                            maxMp: blueprint.mp,
                            currentMp: blueprint.mp,
                            initialHeight: blueprint.height,
                            costume: null, // 衣装フラグを追加
                            buffs: {}, // ファイター, ソーサラー, ナイト, メディック
                            heightLocked: false, // 追加
                            blessings: {}, // 祝福用
                            level: 1,
                            isDefending: false,
                            hate: 0, // ファイター, ソーサラー, ナイト, メディック
                            statusEffects: {}, // 状態異常
                            liberationCooldown: 0, // 解放イベント拒否クールダウン
                            chargeCount: 0, // チャージ回数
                        }));

                        // ソロクリア特典を適用
                        gameState.party.forEach(char => {
                            if (soloClearFlags[char.name]) {
                                char.maxHp += 10;
                                char.maxMp += 5;
                                char.atk += 2;
                                char.def += 2;
                            }
                        });

                        gameState.party.forEach(p => p.heightLocked = false); // 身長固定フラグを初期化
                        gameState.golem = null;
                        gameState.inventory = [];

                        // 初期アイテムの配布
                        if (!fromSave) {
                            addItemToInventory('potion', gameState.party.length);
                            addItemToInventory('milk', 1); // ファイター, ソーサラー, ナイト, メディック
                            addItemToInventory('mana_potion', 1);
                        }

                        // もしもの物語モードの適用
                        if (gameState.gameMode === 'veterans') {
                            gameState.party.forEach(char => {
                                applyLevelUp(char, 3); // Lv1 -> Lv4
                            });
                        } else if (gameState.gameMode === 'dwarves') {
                            gameState.party.forEach(char => {
                                char.height = 10;
                            });
                        } else if (gameState.gameMode === 'peaceful_dungeon') {
                            gameState.party.forEach(char => {
                                char.height = char.initialHeight;
                                char.heightLocked = true;
                            });
                        }

                        // HP/MPを全快させる
                        gameState.party.forEach(char => {
                            char.currentHp = char.maxHp; // ファイター, ソーサラー, ナイト, メディック
                            char.currentMp = char.maxMp;
                        });

                        if (gameState.gameMode === 'indecent') {
                            gameState.party.forEach(char => {
                                // ナイトとサムライは選択不可なのでチェック不要
                                char.statusEffects.stripped = {
                                    turns: 0
                                };
                            });
                        }
                        if (gameState.gameMode === 'solo' && gameState.party.length === 1) {
                            const soloChar = gameState.party[0];
                            if (!fromSave) {
                                soloChar.maxHp *= 2;
                                soloChar.maxMp *= 2;
                                soloChar.atk = Math.floor(soloChar.atk * 1.5);
                                soloChar.def = Math.floor(soloChar.def * 1.5);
                                applyLevelUp(soloChar, 1); // Lv1 -> Lv2
                            }
                        }

                        // HP/MPを全快させる
                        gameState.party.forEach(char => {
                            char.currentHp = char.maxHp; // ファイター, ソーサラー, ナイト, メディック
                            char.currentMp = char.maxMp;
                            // isLiberatedStripped フラグを初期化
                            if (char.isLiberatedStripped) {
                                delete char.isLiberatedStripped;
                            }
                        });
                        // ヒミツの夜モードの初期設定
                        if (gameState.gameMode === 'secret_night' && gameState.party.length === 1) {
                            const char = gameState.party[0];
                            char.statusEffects.stripped = {
                                turns: 0
                            }; // 脱衣状態で開始
                            // 衣装設定
                            if (char.name === 'フローラ') {
                                char.bgClass = 'bg-char-flora-a';
                            } else if (char.name === 'リリカ') {
                                char.bgClass = 'bg-char-ririka-a';
                            } else if (char.name === 'ユイ') {
                                char.bgClass = 'bg-char-yui-a';
                            } else if (char.name === 'ミコ') {
                                char.bgClass = 'bg-char-miko-a';
                            } else if (char.name === 'リリィ') {
                                char.bgClass = 'bg-char-lily-a';
                            }
                        }



                    }

                    function setupDungeonUI() {
                        updateFloorDisplay();
                        modal.classList.add('hidden');

                        // 会話ボタンのセットアップ
                        talkButton.id = 'talk-button';
                        talkButton.className = 'action-button bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                        talkButton.textContent = '会話する';
                        if (!dungeonCommands.querySelector('#talk-button')) {
                            dungeonCommands.insertBefore(talkButton, nextFloorButton.nextSibling);
                        }

                        // アイテムボタンのセットアップ
                        const itemButton = document.getElementById('dungeon-item-button') || document.createElement('button');
                        itemButton.id = 'dungeon-item-button';
                        itemButton.className = 'action-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                        itemButton.textContent = 'アイテム';
                        itemButton.onclick = () => {
                            cancelScanMode(); // アイテムモーダルを開く前に調べるモードを終了
                            showItemModal();
                        };
                        if (!dungeonCommands.querySelector('#dungeon-item-button')) {
                            dungeonCommands.insertBefore(itemButton, talkButton.nextSibling);
                        }

                        // 調べるボタンのセットアップ
                        const scanButton = document.getElementById('dungeon-scan-button') || document.createElement('button');
                        scanButton.id = 'dungeon-scan-button';
                        scanButton.className = 'action-button bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                        scanButton.textContent = '調べる';
                        scanButton.onclick = () => {
                            showScanTargetSelection();
                        };
                        if (!dungeonCommands.querySelector('#dungeon-scan-button')) {
                            dungeonCommands.insertBefore(scanButton, itemButton.nextSibling);
                        }

                        // 「奔放な魂」モード専用コマンド
                        if (gameState.gameMode === 'uninhibited_souls') {
                            const stripButton = document.createElement('button');
                            stripButton.id = 'uninhibited-strip-button';
                            stripButton.className = 'action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                            stripButton.textContent = '脱ぐ';
                            stripButton.onclick = () => {
                                showOneMemberSelectionModal(char => {
                                    const immuneRoles = ['ナイト', 'サムライ', '聖女', 'アンドロイド'];
                                    if (immuneRoles.includes(char.role)) {
                                        log(`${char.name}は恥じらいを覚えず、何も起こらなかった。`);
                                    } else {
                                        char.statusEffects.stripped = {
                                            turns: 0
                                        };
                                        log(`${char.name}は服を脱ぎ捨て、脱衣状態になった！`);
                                        updatePartyStatus();
                                    }
                                });
                            };
                            dungeonCommands.appendChild(stripButton);

                            const shrinkButton = document.createElement('button');
                            shrinkButton.id = 'uninhibited-shrink-button';
                            shrinkButton.className = 'action-button bg-blue-700 hover:bg-blue-800 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                            shrinkButton.textContent = '縮小化薬';
                            shrinkButton.onclick = () => {
                                showOneMemberSelectionModal(char => {
                                    if (char.heightLocked) {
                                        // 身長が固定されている場合の処理
                                        const unlockChoices = [{
                                            text: '固定を解除する',
                                            value: 'unlock'
                                        }, {
                                            text: 'やめる',
                                            value: 'cancel'
                                        }, ];
                                        showAmountChoiceModal('固定解除', `${char.name}の身長は1cmで固定されています。固定を解除しますか？`, unlockChoices, (value) => {
                                            if (value === 'unlock') {
                                                char.heightLocked = false;
                                                log(`${char.name}の身長固定が解除された！`);
                                                updatePartyStatus();
                                            }
                                        });
                                    } else {
                                        // 通常の縮小処理
                                        const choices = [{
                                            text: '30 cm',
                                            value: 30
                                        }, {
                                            text: '100 cm',
                                            value: 100
                                        }, {
                                            text: '999 cm',
                                            value: 999
                                        }, {
                                            text: '1cmに固定',
                                            value: 'lock_one'
                                        }];
                                        showAmountChoiceModal('縮小化薬', `${char.name}をどうしますか？`, choices, (value) => {
                                            if (value === 'lock_one') {
                                                animateStatChange(char, 'height', 1 - char.height, 'decrease');
                                                char.heightLocked = true;
                                                log(`${char.name}の体が妖精のように小さくなり、その姿で固定された！`);
                                            } else {
                                                animateStatChange(char, 'height', -value, 'decrease');
                                                log(`${char.name}の身長が${value}cm縮んだ！`);
                                            }
                                        });
                                    }
                                });
                            };
                            dungeonCommands.appendChild(shrinkButton);

                            const growButton = document.createElement('button');
                            growButton.id = 'uninhibited-grow-button';
                            growButton.className = 'action-button bg-red-700 hover:bg-red-800 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                            growButton.textContent = '巨大化薬';
                            growButton.onclick = () => {
                                showOneMemberSelectionModal(char => { // 対象を選択
                                    const choices = [{
                                            text: '30 cm',
                                            value: 30
                                        }, {
                                            text: '100 cm',
                                            value: 100
                                        }, {
                                            text: '999 cm',
                                            value: 999
                                        }, {
                                            text: '2000 cm',
                                            value: 2000
                                        } // 新しい選択肢
                                    ];
                                    showAmountChoiceModal('巨大化薬', `${char.name}の身長をどれだけ伸ばしますか？`, choices, (amount) => {
                                        if (char.heightLocked) {
                                            log(`${char.name}の体は変化を拒んだ！`);
                                            return;
                                        }
                                        animateStatChange(char, 'height', amount, 'increase');
                                        log(`${char.name}の身長が${amount}cm伸びた！`);
                                    });
                                });
                            };
                            dungeonCommands.appendChild(growButton);
                        } else {
                            // 他モードではボタンを削除
                            ['#uninhibited-strip-button', '#uninhibited-shrink-button', '#uninhibited-grow-button'].forEach(sel => {
                                const element = document.querySelector(sel);
                                if (element) {
                                    element.remove();
                                }
                            });
                        }
                    }
                    async function playConversation(conversation) {
                        dungeonCommands.classList.add('hidden');
                        for (const part of conversation) {
                            const speaker = gameState.party.find(p => p.name === part.char);
                            if (speaker && speaker.currentHp > 0) {
                                log(`${part.char}「${part.line}」`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                            }
                        }
                        dungeonCommands.classList.remove('hidden');
                    }

                    function updateFloorDisplay() {
                        if (!gameState.inBattle && gameState.floor > 0) {
                            floorDisplay.textContent = `第 ${gameState.floor} 層`;
                            floorDisplay.classList.remove('hidden');
                        } else floorDisplay.classList.add('hidden');
                    }

                    let logHistory = [];

                    function log(message) {
                        logQueue.push(message);
                        if (!isProcessingLog) {
                            processLogQueue();
                        }
                    }

                    function addLogToHistory(message) {
                        logHistory.push(message);
                        if (logHistory.length > 20) { // 履歴は最大20件まで保持
                            logHistory.shift();
                        }
                    }
                    // Refactored updatePartyStatus to update existing elements or create new ones
                    function updatePartyStatus() {
                        gameState.party.forEach((char, index) => {
                            let card = document.getElementById(`party-card-${index}`);
                            if (!card) {
                                // If card doesn't exist, create it (initial setup)
                                card = document.createElement('div');
                                card.id = `party-card-${index}`;
                                card.onclick = () => playerSelectAlly(index);
                                partyContainer.appendChild(card);

                                // Initial render of the inner structure
                                card.innerHTML = `
                            <div class="golem-status-container"></div>
                            <div class="wall-status-container"></div>
                            <div class="character-stats w-full">
                                <div class="stat-name" data-char-name="${char.name}">
                                    <p class="font-bold text-xs truncate text-${char.themeColor}-700">${char.name}</p>
                                    <p class="text-[11px] text-gray-600">Lv.${char.level} ${char.role}</p>
                                </div>
                                <p class="text-[10px] stat-hp">HP: <span class="font-semibold">${char.currentHp}</span>/${char.maxHp}</p>
                                <div class="w-full bg-gray-300 rounded-full h-1.5 my-0.5"><div class="hp-bar-inner bg-red-500 h-1.5 rounded-full" style="width: ${Math.max(0, char.currentHp / char.maxHp * 100)}%"></div></div>
                                <p class="text-[10px] stat-mp">MP: <span class="font-semibold">${char.currentMp}</span>/${char.maxMp}</p>
                                <div class="w-full bg-gray-300 rounded-full h-1.5 my-0.5"><div class="mp-bar-inner bg-blue-500 h-1.5 rounded-full" style="width: ${Math.max(0, char.currentMp / char.maxMp * 100)}%"></div></div>
                                <p class="text-[11px] stat-height">身長: <span class="font-semibold">${char.height}cm</span> (${char.height - char.initialHeight >= 0 ? '+' : ''}${char.height - char.initialHeight})</p>
                                <!-- 攻撃力と防御力の表示を追加 -->
                                <p class="text-[11px] stat-atk">攻撃: <span class="font-semibold">0</span></p>
                                <p class="text-[11px] stat-def">防御: <span class="font-semibold">0</span></p>
                                <p class="text-[11px] stat-agi">素早: <span class="font-semibold">0</span></p>
                                <div class="stat-statuses text-xs"></div>
                            </div>
                        `;
                            }
                            card.onclick = () => playerSelectAlly(index); // onclickを常に再設定
                            // Update card classes
                            card.className = `character-card w-full sm:w-1/5 p-1 rounded-lg shadow-md border-4 border-${char.themeColor}-400 ${char.currentHp <= 0 ? 'opacity-50' : ''} ${char.bgClass || ''}`;

                            // 身長に応じて背景の立ち絵を調整
                            const heightRatio = char.height / char.initialHeight;
                            let bgSize = 'auto 100%'; // デフォルトサイズ（coverに近い挙動）
                            let bgPosition = 'center bottom'; // デフォルト位置（下揃え）

                            if (heightRatio < 1.0) {
                                // 身長が初期値より低い場合、立ち絵を縮小して下揃え
                                const sizePercentage = Math.max(20, 100 * heightRatio); // 最低でも20%のサイズ
                                bgSize = `auto ${sizePercentage}%`;
                            } else if (heightRatio > 1.0) {
                                // 身長が初期値より高い場合、少しだけ大きく見せる
                                const sizePercentage = Math.min(130, 100 * heightRatio); // 最大130%
                                bgSize = `auto ${sizePercentage}%`;
                            }

                            card.style.setProperty('--char-bg-size', bgSize);
                            card.style.setProperty('--char-bg-position', bgPosition);
                            card.style.setProperty('background-repeat', 'no-repeat'); // 繰り返しを無効にする設定をJSで直接指定

                            // Update specific elements within the card
                            // The animateStatChange function will handle the number and bar updates during animation.
                            // This updatePartyStatus call ensures consistency after animations or for non-animated changes.

                            const nameElement = card.querySelector('.stat-name');
                            if (nameElement) {
                                let statusHtml = '';
                                if (char.statusEffects.poison) statusHtml += '<span class="status-icon" title="毒">🤢</span>';
                                if (char.statusEffects.paralysis) statusHtml += '<span class="status-icon" title="麻痺">⚡️</span>';
                                if (char.statusEffects.slow) statusHtml += '<span class="status-icon" title="鈍化">🐌</span>';
                                if (char.statusEffects.stripped) statusHtml += '<span class="status-icon" title="脱衣">😳</span>';
                                if (char.statusEffects.regeneration) statusHtml += '<span class="status-icon" title="自然治癒">✨</span>';

                                // nameElement is now a div, so we set its children
                                const nameP = nameElement.querySelector('p:first-child'); // The <p> with the name
                                const roleP = nameElement.querySelector('p:last-child'); // The <p> with the role
                                if (nameP) nameP.innerHTML = `${char.name} ${statusHtml}`;
                                if (roleP) roleP.textContent = `Lv.${char.level} ${char.role}`;
                            }

                            // Update HP (only if not currently animating, or to ensure final state)
                            const hpSpan = card.querySelector('.stat-hp > .font-semibold');
                            if (hpSpan) hpSpan.textContent = char.currentHp;
                            // Update max HP text
                            const hpTextElement = card.querySelector('.stat-hp');
                            if (hpTextElement) {
                                hpTextElement.innerHTML = `HP: <span class="font-semibold">${char.currentHp}</span>/${char.maxHp}`; // text-[11px]は親要素で指定済み
                            }

                            const hpBarInner = card.querySelector('.hp-bar-inner');
                            if (hpBarInner) hpBarInner.style.width = `${Math.max(0, char.currentHp / char.maxHp * 100)}%`;

                            // Update MP
                            const mpSpan = card.querySelector('.stat-mp > .font-semibold');
                            if (mpSpan) mpSpan.textContent = char.currentMp;
                            const mpBarInner = card.querySelector('.mp-bar-inner');
                            // Update max MP text
                            const mpTextElement = card.querySelector('.stat-mp');
                            if (mpTextElement) {
                                mpTextElement.innerHTML = `MP: <span class="font-semibold">${char.currentMp}</span>/${char.maxMp}`; // text-[11px]は親要素で指定済み
                            }
                            if (mpBarInner) mpBarInner.style.width = `${Math.max(0, char.currentMp / char.maxMp * 100)}%`;

                            // Update Height
                            const heightSpan = card.querySelector('.stat-height .font-semibold');
                            if (heightSpan) heightSpan.textContent = `${char.height}cm`;
                            const heightDiffElement = card.querySelector('.stat-height'); // This is the parent <p>
                            if (heightDiffElement) {
                                const diff = char.height - char.initialHeight;
                                heightDiffElement.innerHTML = `身長: <span class="font-semibold">${char.height}cm</span> (${diff >= 0 ? '+' : ''}${diff})`; // text-[11px]は親要素で指定済み
                            }

                            // 攻撃力と防御力の表示を更新
                            const effectiveStats = getEffectiveStats(char);
                            const heightDiff = char.height - char.initialHeight; // 身長差
                            let atkHeightBonus = 0;
                            let defHeightBonus = 0;
                            let agiHeightBonus = 0;

                            // getEffectiveStatsのロジックに合わせてボーナス値を計算
                            if (char.role === 'リーパー') {
                                if (heightDiff > 0) atkHeightBonus = Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                            } else if (char.role === 'サキュバス') {
                                atkHeightBonus = Math.floor(char.atk * (heightDiff / char.initialHeight * 1.2));
                                defHeightBonus = Math.floor(char.def * (heightDiff / char.initialHeight * 1.2));
                            } else if (char.role === 'アルラウネ') {
                                atkHeightBonus = Math.floor(char.atk * (heightDiff / char.initialHeight * 1.0));
                                defHeightBonus = Math.floor(char.def * (heightDiff / char.initialHeight * 1.0));
                            } else if (char.role === 'フェアリー') {
                                if (heightDiff > 0) atkHeightBonus = Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                            } else {
                                // 上記以外の通常ジョブ
                                atkHeightBonus = Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                            }

                            // 防御ボーナスはサキュバスとアルラウネ以外は共通
                            if (char.role !== 'サキュバス' && char.role !== 'アルラウネ') {
                                defHeightBonus = Math.floor(char.def * (heightDiff / char.initialHeight * 0.8));
                            }

                            // 素早さボーナス
                            if (char.role === 'フェアリー') {
                                agiHeightBonus = Math.floor(char.agi * (heightDiff / char.initialHeight * -3.0));
                            } else {
                                agiHeightBonus = Math.floor(char.agi * (heightDiff / char.initialHeight * -1.5));
                            }

                            const atkElement = card.querySelector('.stat-atk');
                            if (atkElement) {
                                atkElement.innerHTML = `攻撃: <span class="font-semibold">${effectiveStats.atk}</span> <span class="text-gray-500">(${atkHeightBonus >= 0 ? '+' : ''}${atkHeightBonus})</span>`;
                            }

                            const defElement = card.querySelector('.stat-def');
                            if (defElement) {
                                defElement.innerHTML = `防御: <span class="font-semibold">${effectiveStats.def}</span> <span class="text-gray-500">(${defHeightBonus >= 0 ? '+' : ''}${defHeightBonus})</span>`;
                            }

                            const agiElement = card.querySelector('.stat-agi');
                            if (agiElement) {
                                agiElement.innerHTML = `素早: <span class="font-semibold">${effectiveStats.agi}</span> <span class="text-gray-500">(${agiHeightBonus >= 0 ? '+' : ''}${agiHeightBonus})</span>`;
                            }

                            // ゴーレムのステータス表示
                            const golemContainer = card.querySelector('.golem-status-container');
                            if (golemContainer) {
                                if (char.role === 'サモナー' && gameState.golem && gameState.golem.hp > 0) {
                                    golemContainer.innerHTML = `
                                <div class="golem-card-inner text-white text-center">
                                    <p class="font-bold text-xs">ゴーレム HP: ${gameState.golem.hp}/${gameState.golem.maxHp}</p>
                                    <div class="w-full bg-gray-500 rounded-full h-1.5"><div class="bg-yellow-500 h-1.5 rounded-full" style="width: ${Math.max(0, gameState.golem.hp / gameState.golem.maxHp * 100)}%"></div></div>
                                </div>
                            `;
                                } else {
                                    golemContainer.innerHTML = '';
                                }
                            }

                            // ウォールのステータス表示
                            const wallContainer = card.querySelector('.wall-status-container');
                            if (wallContainer) {
                                const wall = gameState.walls.find(w => w.targetId === index);
                                if (wall) {
                                    wallContainer.innerHTML = `
                                <div class="wall-card-inner text-white text-center">
                                    <p class="font-bold text-xs">防壁 HP: ${wall.hp}/${wall.maxHp}</p>
                                    <div class="w-full bg-gray-500 rounded-full h-1.5"><div class="bg-stone-500 h-1.5 rounded-full" style="width: ${Math.max(0, wall.hp / wall.maxHp * 100)}%"></div></div>
                                </div>`;
                                } else {
                                    wallContainer.innerHTML = '';
                                }
                            }
                        });
                    }

                    function updateEnemyStatus() {
                        gameState.enemies.forEach((enemy, index) => {
                            if (enemy.currentHp > 0) {
                                let card = document.getElementById(`enemy-card-${index}`);
                                if (!card) {
                                    card = document.createElement('div');
                                    card.id = `enemy-card-${index}`;
                                    enemyContainer.appendChild(card);
                                }
                                card.className = `enemy-card bg-gray-900/70 p-2 rounded-lg text-white text-center w-32 border-2 border-transparent`;
                                card.innerHTML = `
                            <p class="font-bold text-sm">${enemy.name}</p>
                            <p class="text-xs">HP: ${enemy.currentHp}/${enemy.maxHp}</p>
                            <div class="w-full bg-gray-500 rounded-full h-2 mt-1"><div class="bg-red-500 h-2 rounded-full" style="width: ${Math.max(0, enemy.currentHp / enemy.maxHp * 100)}%"></div></div>
                        `;
                                card.classList.add('cursor-pointer', 'hover:border-red-500');
                                card.onclick = () => playerSelectTarget(index);
                            }
                        });
                    }

                    function getEffectiveStats(char) {
                        if (char.isEnemy) {
                            let atk = char.atk;
                            let pDef = char.pDef;
                            let mDef = char.mDef;
                            // テンションアップ効果
                            if (char.buffs && char.buffs.tension_up) {
                                atk += 10;
                                pDef += 10;
                                mDef += 10;
                            }
                            if (char.statusEffects && char.statusEffects.stat_down) {
                                atk *= 0.5;
                                pDef *= 0.5;
                                mDef *= 0.5;
                            } else if (char.buffs && char.buffs.atk_down) {
                                atk *= 0.5;
                                pDef *= 0.5;
                                mDef *= 0.5;
                            }
                            return {
                                atk: Math.floor(atk),
                                pDef: Math.floor(pDef),
                                mDef: Math.floor(mDef),
                                agi: char.agi
                            };
                        }
                        const heightDiff = char.height - char.initialHeight;
                        let atk = char.atk;
                        let def = char.def;
                        let agi = char.agi; // リーパーのみ、身長が縮んでも攻撃力が低下しない
                        // テンションアップ効果
                        // 戦闘中のみ身長を1cmにするデバフ
                        if (char.statusEffects && char.statusEffects.shrunkToOne) {
                            char.height = 1;
                        }

                        if (char.buffs && char.buffs.tension_up) {
                            atk += 10;
                        }

                        if (char.role === 'リーパー') {
                            if (heightDiff > 0) { // 身長が高い場合は通常通り攻撃力が上がる
                                atk += Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                            }
                        } else if (char.role === 'サキュバス') {
                            // サキュバスは身長ボーナスが高い
                            atk += Math.floor(char.atk * (heightDiff / char.initialHeight * 1.2));
                            def += Math.floor(char.def * (heightDiff / char.initialHeight * 1.2));
                        } else if (char.role === 'アルラウネ') {
                            // アルラウネは全体的にステータスボーナスが高い
                            atk += Math.floor(char.atk * (heightDiff / char.initialHeight * 1.0));
                            def += Math.floor(char.def * (heightDiff / char.initialHeight * 1.0));
                        } else if (char.role === 'フェアリー') {
                            // フェアリーは身長が低くてもステータスが低下しない
                            if (heightDiff > 0) {
                                atk += Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                            }
                        } else {
                            atk += Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                        }
                        def += Math.floor(char.def * (heightDiff / char.initialHeight * 0.8));
                        if (char.role === 'フェアリー') {
                            // フェアリーは素早さボーナスが倍
                            agi += Math.floor(char.agi * (heightDiff / char.initialHeight * -3.0));
                        } else if (char.role === 'アルラウネ') {
                            agi += Math.floor(char.agi * (heightDiff / char.initialHeight * -1.0)); // 素早さ低下は少し緩やか
                        } else {
                            agi += Math.floor(char.agi * (heightDiff / char.initialHeight * -1.5)); // 小さいほど素早い
                        }

                        if (char.buffs && char.buffs.agi_up) agi *= 1.5;
                        if (char.buffs && char.buffs.atk_up) atk *= 1.5;
                        if (char.buffs && char.buffs.protect) def *= 1.5;
                        if (char.buffs && char.buffs.def_down) {
                            if (char.isEnemy) {
                                char.pDef *= 0.7;
                                char.mDef *= 0.7;
                            } else {
                                def *= 0.7;
                            }
                        }

                        // 脱衣状態の場合
                        if ((char.statusEffects && char.statusEffects.stripped) || char.isLiberatedStripped) {
                            if (char.role === 'サキュバス') {
                                // サキュバスは脱衣で攻撃力が上がる
                                atk *= 1.5;
                            } else if (char.role === 'リーパー') {
                                // リーパーは脱衣状態に非常に弱い
                                atk *= 0.5; // 攻撃力半減
                                def *= 0.5; // 防御力半減
                            } else if (char.role !== 'トレジャーハンター' && char.role !== 'フェアリー' && char.role !== 'アルラウネ') {
                                def *= 0.8; // 他のジョブは防御力20%減少
                            }
                        }
                        // 解放状態の場合、素早さにボーナス
                        if (char.isLiberatedStripped) {
                            agi *= 1.2;
                            // リーパーとサキュバス以外は攻撃力に5%のボーナス
                            if (char.role !== 'リーパー' && char.role !== 'サキュバス') {
                                atk *= 1.05;
                            }
                        }

                        return {
                            atk: Math.floor(atk),
                            def: Math.floor(def),
                            agi: Math.max(0, Math.floor(agi)) // 素早さの下限を0に設定
                        };
                    }

                    function updateHate() {
                        gameState.party.forEach(char => {
                            const standardHeight = 150; // ヘイト計算の基準となる身長(cm)
                            // 基準身長(150cm)に対する現在の身長の比率でヘイトを計算
                            const heightRatio = char.height / standardHeight;
                            // 比率の3乗に比例してヘイトが変動。大きいと急増し、小さいと急減する。
                            char.hate = Math.pow(heightRatio, 3) * 100;
                            if (char.role === 'ナイト') char.hate *= 1.5;
                            if (char.buffs.provoke) {
                                char.hate *= 3;
                                // ダンサーが挑発中に縮んでいても、最低限のヘイトを保証
                                if (char.role === 'ダンサー') {
                                    char.hate = Math.max(char.hate, 150); // 最低ヘイト値を150に設定
                                }
                            }
                        });
                    }

                    async function advanceFloor() {
                        gameState.party.forEach(p => {
                            if (p.liberationCooldown > 0) {
                                p.liberationCooldown--;
                            }
                        });

                        gameState.floor++;
                        updateFloorDisplay();

                        // 11階の固定イベント
                        if (gameState.floor === 11 && gameState.gameMode === 'summer_live') {
                            await triggerKanpaiJuiceEvent();
                            return; // イベントを発生させてターン終了
                        }

                        // --- little_panic モードの会話イベント ---
                        if (gameState.gameMode === 'little_panic') {
                            if (gameState.floor === 0) { // 1階に到達した直後
                                await playConversation(littlePanicConversations.floor1);
                                // この会話の後、通常のフロア進行処理に進む
                            } else if (gameState.floor === 5) { // 6階に到達する前
                                await playConversation(littlePanicConversations.floor6);
                            } else if (gameState.floor === 11) { // 12階に到達する前 // ファイター, ソーサラー, ナイト, メディック
                                await playConversation(littlePanicConversations.floor12);
                            } else if (gameState.floor === 23) { // 24階に到達する前 // ファイター, ソーサラー, ナイト, メディック
                                await playConversation(littlePanicConversations.floor24);
                            } else if (gameState.floor === 28) { // 29階に到達する前 // ファイター, ソーサラー, ナイト, メディック
                                await playConversation(littlePanicConversations.floor29);
                            }
                        }

                        // --- saint_march モードの会話イベント ---
                        if (gameState.gameMode === 'saint_march' && gameState.floor === 0) {
                            await playConversation(saintMarchConversations.floor1);
                        }

                        // --- treasure_map モードの会話イベント ---
                        if (gameState.gameMode === 'treasure_map') {
                            if (gameState.floor === 0) {
                                await playConversation(treasureMapConversations.floor1);
                            } else if (gameState.floor === 5) { // 6階に到達する前
                                const lily = gameState.party[0]; // リリィは常にパーティの0番目
                                const conversationKey = lily.isTransformed ?
                                    `floor6_${lily.role.toLowerCase()}` :
                                    'floor6_normal';
                                if (treasureMapConversations[conversationKey]) {
                                    await playConversation(treasureMapConversations[conversationKey]);
                                }
                            }
                        }


                        // --- 1階の導入イベント ---
                        if (gameState.floor === 1) {
                            // 「はじめから」モードの場合のみ導入会話を再生
                            if (gameState.gameMode === 'normal') {
                                await playConversation(normalModeConversations.floor1);
                                return;
                            }
                            if (gameState.gameMode === 'summer_live') {
                                await playConversation(summerLiveConversations.floor1);
                                return;
                            }
                            // 他のモードの1階イベントもここに追加可能
                            const hasNoel = gameState.party.some(p => p.name === 'ノエル');
                            const hasFlora = gameState.party.some(p => p.name === 'フローラ');
                            if (hasNoel && hasFlora && gameState.gameMode !== 'brawling_belles' && !gameState.bellesPrivateCostumeEventTriggered) {
                                gameState.bellesPrivateCostumeEventTriggered = true;
                                triggerBellesPrivateCostumeEvent();
                                return;
                            }
                        }

                        // --- サマータイム・スペシャルライブ！ 32階イベント ---
                        if (gameState.floor === 32 && gameState.gameMode === 'summer_live') {
                            await playConversation(summerLiveConversations.floor32);
                            return;
                        }

                        // --- ヒミツの夜 独り言イベント ---
                        if (gameState.gameMode === 'secret_night') {
                            const secretNightFloors = [1, 6, 11, 16, 21, 29]; // イベント発生階層
                            if (secretNightFloors.includes(gameState.floor)) {
                                const char = gameState.party[0];
                                let conversationKey = `secret_night_${gameState.floor}`; // 基本のキー

                                // ミコの場合、specialConversationsから会話データを取得してconversationsオブジェクトにマージする
                                if (char.name === 'ミコ' && specialConversations['ミコ']) {
                                    if (!conversations['ミコ']) {
                                        conversations['ミコ'] = {};
                                    }
                                    // specialConversationsの内容をconversations['ミコ']にコピー
                                    Object.assign(conversations['ミコ'], specialConversations['ミコ']);
                                    // specialConversationsからミコのデータを削除して、二重処理を防ぐ
                                    delete specialConversations['ミコ'];
                                }

                                // 16階以降で身長が半分以下の場合、会話を分岐
                                if (gameState.floor >= 16 && char.height <= char.initialHeight / 2) {
                                    const shrunkConversationKey = `secret_night_${gameState.floor}_shrunk`;
                                    // 専用の会話が存在するかチェック
                                    if (conversations[char.name] && conversations[char.name][shrunkConversationKey]) {
                                        conversationKey = shrunkConversationKey;
                                    } else if (conversations[char.name] && conversations[char.name]['secret_night_16_shrunk']) {
                                        // 16階以降で共通の縮小会話があればそれを使う
                                        conversationKey = 'secret_night_16_shrunk';
                                    }
                                }
                                const conversation = conversations[char.name][conversationKey];
                                if (conversation) {
                                    await playConversation(conversation.map(line => ({
                                        char: char.name,
                                        line
                                    })));
                                    return; // 専用イベントを発生させたら、以降の処理は行わない
                                }
                            }
                        }
                        // --- 闘争令嬢 復活イベント ---
                        if (gameState.gameMode === 'brawling_belles' && !gameState.bellesReviveEventTriggered) {
                            const noel = gameState.party.find(p => p.name === 'ノエル');
                            const flora = gameState.party.find(p => p.name === 'フローラ');
                            if (noel && flora) {
                                if ((noel.currentHp <= 0 && flora.currentHp > 0) || (flora.currentHp <= 0 && noel.currentHp > 0)) {
                                    triggerBellesReviveEvent(noel, flora);
                                    return; // 専用イベントを発生させたら、以降の処理は行わない
                                }
                            }
                        }


                        // --- 闘争令嬢 6階イベント ---
                        if (gameState.floor === 6 && gameState.gameMode === 'brawling_belles') {
                            const noel = gameState.party.find(p => p.name === 'ノエル');
                            const flora = gameState.party.find(p => p.name === 'フローラ');
                            if (noel && flora && noel.currentHp > 0 && flora.currentHp > 0) {
                                if ((noel.height === 1 && flora.height !== 1) || (flora.height === 1 && noel.height !== 1)) {
                                    triggerBellesFloor6Event(noel, flora);
                                    return; // 専用イベントを発生させたら、以降の処理は行わない
                                }
                            }
                        }


                        // --- 闘争令嬢 29階イベント ---
                        if (gameState.floor === 29 && gameState.gameMode === 'brawling_belles') {
                            triggerBellesFloor29Event();
                            return; // 専用イベントを発生させたら、以降の処理は行わない
                        }

                        // --- サマータイム・スペシャルライブ！ 29階イベント ---
                        if (gameState.floor === 29 && gameState.gameMode === 'summer_live') {
                            triggerSummerLiveRirikaEvent();
                            return; // 専用イベントを発生させたら、以降の処理は行わない
                        }


                        const floor = gameState.floor;
                        const mode = gameState.gameMode;

                        // 特別な衣装変更イベントのチェック
                        if (floor === 1) {
                            const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                            const partyNames = gameState.party.map(p => p.name).sort();
                            const requiredNames = ['リリカ', 'ユイ', 'ミコ', 'リリィ'].sort();
                            const isSpecialParty = JSON.stringify(partyNames) === JSON.stringify(requiredNames);

                            if (clearFlags.summerLiveCleared && isSpecialParty && mode !== 'summer_live') {
                                triggerSpecialCostumeEvent();
                                return; // 専用イベントを発生させたら、以降の処理は行わない
                            }
                        }


                        // --- ボス戦の判定 ---
                        // 聖女パーティでの29階イベント (サマーライブ中は発生しない)
                        const hasCelestia = gameState.party.some(p => p.role === '聖女');
                        if (floor === 29 && hasCelestia && gameState.party.length >= 2 && mode !== 'summer_live') {
                            celestiaEventTitle.textContent = "最後の問い";
                            celestiaEventText.textContent = "セレスティアが、静かにあなたを見つめている。\nその瞳は、これから待ち受ける運命について、覚悟を問うているようだ。\n\n「…この先に待つ元凶は、計り知れないほどの穢れを溜め込んでいます。仲間と共に挑めば、その穢れはさらに増し、想像を絶する脅威となるでしょう。それでも、あなたはこの道を進みますか？」";
                            celestiaEventButtons.innerHTML = `
            <button id="celestia-accept" class="action-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg">覚悟を決める</button>
            <button id="celestia-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">今はまだ…</button>
        `;
                            celestiaEventModal.classList.remove('hidden');
                            document.getElementById('celestia-accept').onclick = () => {
                                celestiaEventModal.classList.add('hidden');
                                startBattle(true, true); // 強化ボス戦
                            };
                            document.getElementById('celestia-decline').onclick = () => {
                                celestiaEventModal.classList.add('hidden');
                                startBattle(true, false); // 通常ボス戦
                            };
                            return;
                        }

                        // サマータイム・スペシャルライブ！のボス戦
                        if (mode === 'summer_live' && (floor === 30 || floor === 60)) {
                            startBattle(true);
                            return;
                        }
                        if (mode === 'endgame_plus' && (floor === 30 || floor === 60 || floor === 90)) {
                            startBattle(true);
                            return;
                        }

                        // 闘争令嬢モードの30階ボス
                        if (mode === 'brawling_belles' && floor === 30) {
                            startBattle(true, 'phantom_hero');
                            return;
                        }

                        // 通常の30階ボス
                        if (floor === 30 && mode !== 'endless' && mode !== 'monster_march') {
                            startBattle(true);
                            return;
                        }
                        // その他のモードでのボス戦
                        if ((mode === 'endgame' && floor === 1) ||
                            (mode === 'monster_march' && (floor === 30 || floor === 50)) ||
                            (mode === 'endless' && floor > 0 && floor % 30 === 0)) {
                            startBattle(true);
                            return;
                        }

                        // サマータイム・スペシャルライブ！の後半パートへの移行
                        if (mode === 'summer_live' && floor === 31) {
                            triggerSummerLivePart2();
                            return; // イベントを発生させてターン終了
                        }

                        // --- 通常戦闘の判定 ---
                        if ((mode === 'monster_march') ||
                            (mode === 'brawl' && floor % 2 === 0) || (mode !== 'secret_night' && floor % 5 === 0)) {
                            startBattle();
                            return;
                        }

                        // --- イベントの判定 ---
                        // サマータイム・スペシャルライブ！の全員解放イベントチェック
                        if (gameState.gameMode === 'summer_live') {
                            const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                            const allLiberated = aliveParty.length > 0 && aliveParty.every(p => p.isLiberatedStripped);

                            // ビーチでの全員解放イベント
                            if (floor <= 30 && allLiberated && !gameState.summerBeachAllLiberatedTriggered) {
                                gameState.summerBeachAllLiberatedTriggered = true;
                                executeEvent(foundLiberatedPlay);
                                return;
                            }
                            // 温泉での全員解放イベント
                            if (floor > 30 && allLiberated && !gameState.summerOnsenAllLiberatedTriggered) {
                                gameState.summerOnsenAllLiberatedTriggered = true;
                                executeEvent(foundLiberatedPlay);
                                return;
                            }
                        }

                        // 25%の確率でイベント選択モーダルを表示
                        if (Math.random() < 0.25) {
                            triggerSelectableEvent();
                        } else if (gameState.gameMode !== 'endgame_plus' || Math.random() < 0.7) {
                            triggerRandomEvent();
                        } else {
                            // どのイベントも発生しなかった場合
                            nothingHappened();
                        }
                        updatePartyStatus();
                    }

                    async function triggerSummerLivePart2() {
                        log("ビーチでのライブを終えた一行は、打ち上げのために温泉へとやってきた！");
                        gameState.dungeonBackground = SUMMER_ONSEN_BG;
                        dungeonView.style.backgroundImage = gameState.dungeonBackground;
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        // 場面転換時に全員の脱衣・解放状態を解除
                        gameState.party.forEach(p => {
                            if (p.statusEffects.stripped) {
                                delete p.statusEffects.stripped;
                            }
                            if (p.isLiberatedStripped) {
                                delete p.isLiberatedStripped;
                            }
                        });

                        log("後半戦は、温泉ステージでスタート！");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        // 全員の立ち絵をバスタオルに変更
                        gameState.party.forEach(char => {
                            if (char.name === 'リリカ') char.bgClass = 'bg-char-ririka-b';
                            if (char.name === 'ユイ') char.bgClass = 'bg-char-yui-b';
                            if (char.name === 'ミコ') char.bgClass = 'bg-char-miko-b';
                            if (char.name === 'リリィ') char.bgClass = 'bg-char-lily-b';
                        });

                        // リリィの変身解除とスキル変更
                        const lily = gameState.party.find(p => p.name === 'リリィ');
                        if (lily) {
                            // 変身解除
                            if (lily.originalState) {
                                lily.role = lily.originalState.role;
                                lily.skills = lily.originalState.skills;
                                delete lily.originalState;
                                delete lily.isTransformed;
                            }
                            // 身長を初期値に戻す
                            lily.height = lily.initialHeight;

                            // スキルを温泉モード用に変更
                            lily.skills = [{
                                name: 'ジュエルショット',
                                cost: 10,
                                type: 'treasure_hunter_attack',
                                targetType: 'enemy',
                                description: '敵単体にダメージを与え、自身の攻撃力が上がるかMPが大きく回復する。'
                            }, {
                                name: 'ホットウェーブ',
                                cost: 15,
                                type: 'physical',
                                targetType: 'enemies',
                                power: 2.8,
                                description: '熱波で敵全体に物理ダメージを与える。'
                            }, {
                                name: 'リラックスタイム',
                                cost: 10,
                                type: 'self_wall',
                                targetType: 'self',
                                description: '自身に最大HPの100%の耐久値を持つ防壁を生成する。'
                            }, {
                                name: 'マジックオーラ',
                                cost: 20,
                                type: 'party_mp_regen_special',
                                targetType: 'party',
                                description: '味方全体を2ターンMP自動回復状態にする。ただし、自身は脱衣状態になる(既に脱衣状態なら鈍化)。'
                            }];
                        }

                        updatePartyStatus();
                        // 次のフロアへ進むボタンなどを再表示
                        dungeonCommands.classList.remove('hidden');
                    }

                    async function triggerKanpaiJuiceEvent() {
                        dungeonCommands.classList.add('hidden');
                        log("ビーチでのライブ前半戦、お疲れ様！");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("リリィ「みんな、お疲れ様！ここでちょっと休憩しよっか！」");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("リリカ「いいね！リリカ、特製のカンパイジュース持ってきたんだ！」");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("一行は特製ジュースで乾杯した！");
                        addItemToInventory('kanpai_juice', 1);
                        log("「カンパイジュース」を1個手に入れた！");
                        await new Promise(resolve => setTimeout(resolve, 1000)); // ログ表示のための待機
                        dungeonCommands.classList.remove('hidden');
                    }

                    function changeCostume(type) {
                        const costumeMap = {
                            'beach': {
                                'リリカ': 'bg-char-ririka-a',
                                'ユイ': 'bg-char-yui-a',
                                'ミコ': 'bg-char-miko-a', // 通常リリィの水着
                                'リリィ': 'bg-char-lily-a',
                                'サキュバス': 'bg-char-lily-succubus-a', // 通常リリィの水着
                                'フェアリー': 'bg-char-lily-fairy-a',
                                'アルラウネ': 'bg-char-lily-alraune-a' // 通常リリィの水着
                            },
                            'onsen': {
                                'リリカ': 'bg-char-ririka-b',
                                'ユイ': 'bg-char-yui-b',
                                'ミコ': 'bg-char-miko-b',
                                'リリィ': 'bg-char-lily-b', // 通常リリィの温泉
                                'サキュバス': 'bg-char-lily-succubus-b',
                                'フェアリー': 'bg-char-lily-fairy-b',
                                'アルラウネ': 'bg-char-lily-alraune-b'
                            }
                        };

                        const selectedCostumes = costumeMap[type];
                        if (!selectedCostumes) return;

                        gameState.party.forEach(char => {
                            if (selectedCostumes[char.name]) {
                                char.bgClass = selectedCostumes[char.name];
                                char.costume = type; // 衣装フラグを設定
                            }
                            // リリィの変身形態にも適用
                            if (char.name === 'リリィ' && char.transforms) {
                                if (selectedCostumes['サキュバス']) char.transforms.succubus.bgClass = selectedCostumes['サキュバス'];
                                if (selectedCostumes['フェアリー']) char.transforms.fairy.bgClass = selectedCostumes['フェアリー'];
                                if (selectedCostumes['アルラウネ']) char.transforms.alraune.bgClass = selectedCostumes['アルラウネ'];
                            }
                        });

                        log(`パーティは思い出の${type === 'beach' ? '水着' : '温泉スタイル'}に着替えた！`);
                        updatePartyStatus();
                        celestiaEventModal.classList.add('hidden');

                        // 通常のイベントフローを再開
                        if (gameState.gameMode === 'fixed_path') {
                            triggerSelectableEvent();
                        } else {
                            triggerRandomEvent();
                        }
                    }

                    function triggerSpecialCostumeEvent() {
                        celestiaEventTitle.textContent = "特別な絆";
                        celestiaEventText.textContent = "この4人でいると、あの夏の特別な冒険を思い出す…\n\n彼女たちの絆が共鳴し、思い出の姿に変わることができるようだ。";
                        celestiaEventButtons.innerHTML = `
                            <button id="costume-beach" class="action-button bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg">水着になる</button>
                            <button id="costume-onsen" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg">温泉スタイルになる</button>
                            <button id="costume-cancel" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg">何もしない</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('costume-beach').onclick = () => changeCostume('beach');
                        document.getElementById('costume-onsen').onclick = () => changeCostume('onsen');
                        document.getElementById('costume-cancel').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行は思い出を胸に、冒険を続ける。");
                            gameState.party.forEach(p => p.costume = null); // 衣装フラグをリセット
                            // 通常のイベントフローを再開
                            if (gameState.gameMode === 'fixed_path') {
                                triggerSelectableEvent();
                            } else {
                                triggerRandomEvent();
                            }
                        };
                    }

                    function triggerBellesPrivateCostumeEvent() {
                        celestiaEventTitle.textContent = "束の間の休息";
                        celestiaEventText.textContent = "フローラ「皆様、少し休憩にいたしませんこと？せっかくですもの、少し楽な格好に着替えたいですわ」\nノエル「賛成です。現在の服装は戦闘用であり、リラックスするには不向きです」\n\n二人はプライベートな服装に着替えたがっているようだ…";
                        celestiaEventButtons.innerHTML = `
                            <button id="belles-costume-change" class="action-button bg-rose-500 hover:bg-rose-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg">着替える</button>
                            <button id="belles-costume-cancel" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg">やめておく</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('belles-costume-change').onclick = () => {
                            const noel = gameState.party.find(p => p.name === 'ノエル');
                            const flora = gameState.party.find(p => p.name === 'フローラ');
                            if (noel) {
                                noel.bgClass = 'bg-char-noel-a';
                                noel.costume = 'private'; // 会話用のフラグ
                            }
                            if (flora) {
                                flora.bgClass = 'bg-char-flora-a';
                                flora.costume = 'private'; // 会話用のフラグ
                            }
                            log("二人は普段着に着替えた！少しだけ、戦士の顔つきが和らいだように見える。");
                            updatePartyStatus();
                            celestiaEventModal.classList.add('hidden');
                            triggerRandomEvent(); // 通常のイベントフローを再開
                        };

                        document.getElementById('belles-costume-cancel').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行は休憩を終え、気を引き締めて冒険を続ける。");
                            triggerRandomEvent(); // 通常のイベントフローを再開
                        };
                    }

                    async function triggerBellesFloor29Event() {
                        dungeonCommands.classList.add('hidden'); // コマンドを隠す
                        const noel = gameState.party.find(p => p.name === 'ノエル');
                        const flora = gameState.party.find(p => p.name === 'フローラ');

                        if (!noel || !flora || noel.currentHp <= 0 || flora.currentHp <= 0) {
                            log("決戦を前に、二人のうちどちらかが倒れている…。");
                            dungeonCommands.classList.remove('hidden');
                            return;
                        }

                        log("ノエル「フローラ、いよいよですね。この先に、元凶がいます」");
                        await new Promise(resolve => setTimeout(resolve, 2500));
                        log("フローラ「はい、ノエル様。わたくしたちの力を合わせれば、きっと…！」");
                        await new Promise(resolve => setTimeout(resolve, 2500));
                        log("ノエル「ええ。必ず、このダンジョンを制圧します」");
                        await new Promise(resolve => setTimeout(resolve, 2500));

                        // 身長比較による会話分岐
                        const heightDifference = noel.height - flora.height;

                        if (heightDifference > 50) { // ノエルが50cm以上大きい
                            log("ノエル「…それにしても、フローラ。あなたは本当に小さいですね。愛らしいです」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「まあ、ノエル様。からかわないでくださいまし。ノエル様が大きすぎるのですわ」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「ふふ、そうかもしれませんね。ですが、この体格差があるからこそ、私はあなたを完璧に守れます」");
                        } else if (heightDifference < -50) { // フローラが50cm以上大きい
                            log("フローラ「ふふっ。ノエル様、わたくしの方が見晴らしが良いですわね」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「…少し、悔しいです。ですが、フローラが頼もしいのは良いことです」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「まあ、戯れですわ。どんな姿であろうと、わたくしはノエル様にお仕えするメイドですもの」");
                        } else { // 身長差が50cm以内
                            log("ノエル「フローラ。いつの間にか、あなたと私の目線が同じくらいになりましたね」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「本当ですわね。なんだか、本当の姉妹のようですわ」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「姉妹…悪くない響きです。さあ、最後の戦いです。姉妹の力、見せてあげましょう」");
                        }

                        await new Promise(resolve => setTimeout(resolve, 2500));
                        log("二人の決意が共鳴し、HPとMPが全回復した！");
                        await animateStatChange(noel, 'hp', noel.maxHp, 'increase');
                        await animateStatChange(flora, 'hp', flora.maxHp, 'increase');
                        await animateStatChange(noel, 'mp', noel.maxMp, 'increase');
                        await animateStatChange(flora, 'mp', flora.maxMp, 'increase');

                        dungeonCommands.classList.remove('hidden'); // コマンドを再表示
                    }

                    async function triggerBellesFloor6Event(noel, flora) {
                        dungeonCommands.classList.add('hidden'); // コマンドを隠す

                        if (noel.height === 1) {
                            // ノエルが小さい場合の会話
                            log("フローラ「まあ、ノエル様！なんて可愛らしいお姿に…！」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「…フローラ、あまりジロジロ見ないでください。これは戦術的縮小です」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「ふふ、わかっておりますわ。ですが、思わずポケットに入れてしまいたくなるくらい愛らしいですもの」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「さあ、わたくしの手の中に。はぐれてしまったら大変ですわ」");
                        } else {
                            // フローラが小さい場合の会話
                            log("ノエル「フローラ、そのサイズは…危険です。私の手のひらに乗っていてください」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("フローラ「きゃっ、ノエル様！だ、大丈夫ですわ！わたくし、これでも戦えますもの！」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「いえ、許可できません。万が一あなたに何かあれば、私は…」");
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log("ノエル「さあ、こちらへ。マスターの命令です」");
                        }

                        dungeonCommands.classList.remove('hidden'); // コマンドを再表示
                    }

                    async function triggerBellesReviveEvent(noel, flora) {
                        gameState.bellesReviveEventTriggered = true; // イベント発生フラグを立てる
                        dungeonCommands.classList.add('hidden');

                        const fallenChar = noel.currentHp <= 0 ? noel : flora;
                        const survivor = noel.currentHp > 0 ? noel : flora;

                        log(`${survivor.name}は倒れた${fallenChar.name}を必死に揺り動かす…`);
                        await new Promise(resolve => setTimeout(resolve, 2500));

                        fallenChar.currentHp = 1;
                        updatePartyStatus(); // HP1で復活したのをUIに反映

                        log(`${fallenChar.name}「…うぅん…」`);
                        await new Promise(resolve => setTimeout(resolve, 2500));

                        if (fallenChar.name === 'ノエル') {
                            // ノエルが倒れていた場合
                            log(`フローラ「ノエル様！よかった…！目が覚めたのですね…！」`);
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log(`フローラ「わたくし、ノエル様がこのまま目覚めないのかと…！もう、無茶はなさらないでくださいまし…！」`);
                        } else {
                            // フローラが倒れていた場合
                            log(`ノエル「フローラ！よかった…意識が戻ったのですね」`);
                            await new Promise(resolve => setTimeout(resolve, 2500));
                            log(`ノエル「あなたが倒れた時、私の全機能が停止するかと思いました…。もう、私の側を離れないでください」`);
                        }

                        dungeonCommands.classList.remove('hidden');
                    }

                    async function triggerSummerLiveRirikaEvent() {
                        dungeonCommands.classList.add('hidden');
                        const ririka = gameState.party.find(p => p.name === 'リリカ');

                        if (!ririka || ririka.currentHp <= 0) {
                            log("決戦を前に、リリカは倒れてしまっていた…。");
                            dungeonCommands.classList.remove('hidden');
                            return;
                        }

                        let conversationKey;
                        if (ririka.isLiberatedStripped) {
                            conversationKey = 'summer_live_29_liberated';
                        } else if (ririka.statusEffects.stripped) {
                            conversationKey = 'summer_live_29_stripped';
                        } else {
                            conversationKey = 'summer_live_29_normal';
                        }

                        const conversation = conversations['リリカ'][conversationKey];
                        if (conversation) {
                            await playConversation(conversation);
                        }

                        await new Promise(resolve => setTimeout(resolve, 1000));
                        log("リリカの歌声がパーティの心に響き渡り、力がみなぎる！");
                        for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                            await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.5), 'increase');
                            await animateStatChange(p, 'mp', Math.ceil(p.maxMp * 0.5), 'increase');
                            p.buffs.atk_up = 3;
                        }
                        log("全員のHPとMPが回復し、攻撃力が上昇した！");

                        dungeonCommands.classList.remove('hidden');
                    }

                    function triggerSelectableEvent() {
                        // 4つのグループからランダムに1つを選ぶ（神々の試練はここでは発生しないようにする）
                        const groups = ['merit', 'random_special', 'demerit'];
                        const selectedGroup = groups[Math.floor(Math.random() * groups.length)];

                        // 選ばれたグループから、重み付け抽選で2つの異なるイベントを選ぶ
                        const event1 = getRandomEvent(selectedGroup);
                        let event2 = getRandomEvent(selectedGroup);

                        // 2つのイベントが同じ場合は、異なるイベントが選ばれるまで再抽選する
                        // ただし、グループ内のイベントが1つしかない場合は無限ループを避ける
                        const groupEvents = getEventPool(selectedGroup);
                        while (groupEvents.length > 1 && event1.name === event2.name) {
                            event2 = getRandomEvent(selectedGroup);
                        }

                        eventChoiceButtons.innerHTML = ''; // ボタンをクリア

                        [event1, event2].forEach(event => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                            button.textContent = event.name;
                            button.onclick = () => {
                                eventChoiceModal.classList.add('hidden');
                                executeEvent(event.func);
                            };
                            eventChoiceButtons.appendChild(button);
                        });

                        eventChoiceModal.classList.remove('hidden');
                    }

                    function getEventPool(group) {
                        const isAnyoneStripped = gameState.party.some(p => p.statusEffects.stripped);
                        const remainingEquipment = getRemainingEquipment();

                        // 「神々の試練」を別のプールに分離
                        const divineTrialEvent = {
                            name: "神々の試練",
                            func: foundDivineTrial,
                            weight: 1 // レアイベント
                        };
                        const meritEvents = [{
                            name: "宝箱",
                            func: foundTreasure,
                            weight: 5
                        }, {
                            name: "泉",
                            func: foundFountain,
                            weight: 2
                        }, {
                            name: "服を発見",
                            func: foundClothes, // 解放状態のキャラがいない場合のみ発生
                            weight: isAnyoneStripped && gameState.gameMode !== 'indecent' && !gameState.party.some(p => p.isLiberatedStripped) && !gameState.wishingStarNoClothes ? 5 : 0
                        }, {
                            name: "吟遊詩人",
                            func: foundBard,
                            weight: 1
                        }, {
                            name: "守護の壁",
                            func: foundProtectiveWall,
                            weight: 2
                        }, {
                            name: "魔力の結晶",
                            func: foundMagicCrystal,
                            weight: gameState.gameMode === 'endless' ? 1 : 0 // 無限モードでのみ出現
                        }, {
                            name: "祈りのほこら",
                            func: foundShrineOfPrayer,
                            weight: 3
                        }];

                        if (remainingEquipment.length > 0) {
                            meritEvents.push({
                                name: "装備発見",
                                func: foundEquipment,
                                weight: 3
                            });
                        }

                        const baseSpecialEvents = [{
                                name: "怪しげな祭壇",
                                func: foundAltar,
                                weight: gameState.gameMode === 'endgame_plus' ? 3 : 2 // 終焉モードでは少し出やすい
                            }, {
                                name: "装備発見",
                                func: foundEquipment,
                                weight: remainingEquipment.length > 0 ? 3 : 0
                            }, {
                                name: "怪しい装置",
                                func: foundSuspiciousDevice,
                                weight: gameState.party.length >= 2 ? (gameState.gameMode === 'endgame_plus' ? 1 : 2) : 0
                            }, {
                                name: "迷いの石像",
                                func: foundBewilderingStatue,
                                weight: 2
                            }, {
                                name: "人形の家",
                                func: foundDollhouse,
                                weight: 2
                            }, {
                                name: "ひび割れた巨岩",
                                func: foundCrackedRock,
                                weight: 2
                            }, {
                                name: "高所のネズミ穴",
                                func: foundHighMouseHole,
                                weight: gameState.party.some(p => p.height >= 200) && gameState.party.some(p => p.height <= 10) ? 2 : 0 // 大きいキャラと小さいキャラがいる場合のみ
                            }, {
                                name: "願い星",
                                func: foundWishingStar,
                                weight: gameState.gameMode === 'endgame_plus' ? 0 : 1 // 終焉モードでは発生しない
                            }, {
                                name: "調合",
                                func: foundAlchemyEvent,
                                weight: gameState.party.some(p => p.role === 'アルケミスト' || p.role === 'ドクター') ? 2 : 0
                            },


                            {
                                name: "研ぎ澄まされた五感",
                                func: foundLiberatedSenses,
                                weight: gameState.party.some(p => p.isLiberatedStripped) ? 2 : 0 // 解放状態のキャラがいる場合のみ
                            }
                        ];

                        const hasHolyCrystal = gameState.inventory.some(item => item.id === 'holy_crystal' && item.quantity > 0);
                        const hasEvilCrystal = gameState.inventory.some(item => item.id === 'evil_crystal' && item.quantity > 0);
                        if (gameState.gameMode === 'endless' && hasHolyCrystal && hasEvilCrystal) {
                            specialEvents.push({
                                name: "解放の祭壇",
                                func: triggerLiberationEvent,
                                weight: 5
                            });
                        }
                        // 「大穴になあれ」イベントの条件チェック
                        const hasFairySyrupForHole = gameState.inventory.some(item => item.id === 'fairy_syrup' && item.quantity >= 2);
                        const hasNoAlchemistOrDoctor = !gameState.party.some(p => p.role === 'アルケミスト' || p.role === 'ドクター');
                        if (!gameState.greatHoleEventTriggered && hasFairySyrupForHole && hasNoAlchemistOrDoctor) {
                            specialEvents.push({
                                name: "大穴になあれ",
                                func: foundGreatHole,
                                weight: 1 // 低確率で発生
                            });
                        }
                        // 「願いの少女」「祈りの少女」イベントの条件チェック
                        const canTriggerWishPray = gameState.greatHoleEventTriggered &&
                            gameState.floor >= gameState.greatHoleEventFloor + 30 &&
                            gameState.party.some(p => p.height === 1) &&
                            !gameState.wishPrayEventTriggered;
                        if (canTriggerWishPray) {
                            specialEvents.push({
                                name: "再会",
                                func: foundWishPrayGirl,
                                weight: 1 // 低確率で発生
                            });
                        }
                        // 「酒豪の怪物」イベントの条件チェック
                        const hasGigantesAle = gameState.inventory.some(item => item.id === 'gigantes_ale' && item.quantity >= 2);
                        const hasTallChar = gameState.party.some(p => p.currentHp > 0 && p.height >= 500);
                        if (!gameState.drunkenMonsterEventTriggered && hasGigantesAle && hasTallChar) {
                            specialEvents.push({
                                name: "酒豪の怪物",
                                func: foundDrunkenMonster,
                                weight: 1 // 低確率で発生
                            });
                        }
                        // 「木陰の迷宮」イベントの条件チェック
                        const isAllTinyAndLocked = gameState.party.length > 0 && gameState.party.every(p => p.currentHp > 0 && p.height === 1 && p.heightLocked);
                        if (!gameState.mazeOfShadeEventTriggered && isAllTinyAndLocked) {
                            specialEvents.push({
                                name: "木陰の迷宮",
                                func: foundMazeOfShade,
                                weight: 1 // 低確率で発生
                            });
                        }

                        if (gameState.gameMode === 'secret_night') {
                            meritEvents.find(e => e.name === '服を発見').weight = 0;
                        }



                        // 2択イベント用のスペシャルイベントプール
                        const specialEvents = [...baseSpecialEvents, divineTrialEvent];

                        const demeritEvents = [{
                            name: "身長が縮む罠",
                            func: triggerShrinkTrap,
                            weight: gameState.gameMode === 'endgame_plus' ? 4 : 2 // 終焉モードでは出やすい
                        }, {
                            name: "身長が伸びる罠",
                            func: triggerGrowTrap,
                            weight: gameState.gameMode === 'endgame_plus' ? 2 : 1
                        }, {
                            name: "ダメージの罠",
                            func: triggerDamageTrap,
                            weight: 3
                        }, {
                            name: "羞恥の張り付け",
                            func: foundShamePillory,
                            weight: isAnyoneStripped && gameState.gameMode !== 'summer_live' ? (gameState.gameMode === 'endgame_plus' ? 4 : 3) : 0
                        }, {
                            name: "なにもない",
                            func: nothingHappened,
                            weight: 5
                        }];

                        const summerEvents = {
                            name: "解放の祭壇",
                            func: triggerLiberationEvent,
                            // 無限モードで両方の結晶を持っている場合にのみ候補になる
                            weight: (gameState.gameMode === 'endless' && hasHolyCrystal && hasEvilCrystal) ? 5 : 0
                        };

                        // 新しいイベントの定義（サマーライブ専用）
                        const liberatedMonsterAttackEvent = {
                            name: "魔物の奇襲",
                            func: foundLiberatedMonsterAttack,
                            weight: 0
                        };
                        const liberatedTeaseEvent = {
                            name: "仲間との会話",
                            func: foundLiberatedTease,
                            weight: 0
                        };
                        const liberatedPlayEvent = {
                            name: "解放のじゃれあい",
                            func: foundLiberatedPlay,
                            weight: 0
                        };
                        // サマータイム・スペシャルライブ！専用イベントをプールに追加
                        if (gameState.gameMode === 'summer_live') {
                            if (gameState.floor <= 30) {
                                // ビーチイベント
                                specialEvents.push({
                                    name: "スイカ割り",
                                    func: foundWatermelonSmash,
                                    weight: 5
                                }, {
                                    name: "砂の城作り",
                                    func: foundSandcastle,
                                    weight: 5
                                }, {
                                    name: "ビーチの熱気",
                                    func: foundBeachLiberation,
                                    weight: 4
                                });
                            } else {
                                // 温泉イベント
                                specialEvents.push({
                                    name: "温泉卓球",
                                    func: foundOnsenPingPong,
                                    weight: 5
                                }, {
                                    name: "温泉でリラックス",
                                    func: foundHotSpringsSoak,
                                    weight: 5
                                }, {
                                    name: "タオルトラブル！",
                                    func: foundOnsenTowelTrouble,
                                    weight: 5
                                }, {
                                    name: "温泉の誘惑",
                                    func: foundOnsenLiberation,
                                    weight: 5
                                });
                            }
                            // イベントをプールに追加
                            specialEvents.push(liberatedMonsterAttackEvent, liberatedTeaseEvent, liberatedPlayEvent);

                            // 解放状態のキャラがいる場合、特別イベントの発生確率を設定
                            const isLiberated = gameState.party.some(p => p.isLiberatedStripped);
                            specialEvents.find(e => e.name === "魔物の奇襲").weight = isLiberated ? 5 : 0;
                            specialEvents.find(e => e.name === "仲間との会話").weight = isLiberated ? 5 : 0;
                            // 「解放のじゃれあい」は解放状態のキャラが2人以上いる場合に発生するよう重みを設定
                            specialEvents.find(e => e.name === "解放のじゃれあい").weight = gameState.party.filter(p => p.isLiberatedStripped && p.currentHp > 0).length >= 2 ? 5 : 0;
                        }

                        switch (group) {
                            case 'merit':
                                return meritEvents.filter(e => e.weight > 0);
                            case 'random_special': // ランダムイベント用のスペシャルプール
                                return baseSpecialEvents.filter(e => e.weight > 0);
                            case 'special':
                                return specialEvents.filter(e => e.weight > 0);
                            case 'demerit':
                                return demeritEvents.filter(e => e.weight > 0);
                            default: // 全てのイベントを結合
                                // ランダムイベントでは神々の試練は発生しない
                                return [...meritEvents, ...baseSpecialEvents, ...demeritEvents].filter(e => e.weight > 0);
                        }
                    }

                    function getRandomEvent(group = null) {
                        const filteredEvents = getEventPool(group);
                        const totalWeight = filteredEvents.reduce((sum, event) => sum + event.weight, 0);
                        let random = Math.random() * totalWeight;
                        for (const event of filteredEvents) {
                            random -= event.weight;
                            if (random <= 0) return event;
                        }
                        return filteredEvents[filteredEvents.length - 1];
                    }

                    function foundEquipment() {
                        // パーティ内に未発見の装備を持つキャラがいるかチェック
                        const partyRolesWithRemainingEquipment = gameState.party
                            .filter(p => p.currentHp > 0)
                            .map(p => p.role)
                            .filter((role, index, self) => self.indexOf(role) === index)
                            .filter(role => getRemainingEquipment().some(id => equipmentBlueprints[id] && equipmentBlueprints[id].targetRole === role));

                        if (partyRolesWithRemainingEquipment.length === 0) {
                            // 装備を見つけられるキャラがいない場合は別のイベントを再抽選
                            nothingHappened();
                            return;
                        }

                        // 装備を見つけられる可能性のあるロールからランダムに一つ選ぶ
                        const targetRole = partyRolesWithRemainingEquipment[Math.floor(Math.random() * partyRolesWithRemainingEquipment.length)];
                        const availableEquipmentForRole = getRemainingEquipment().filter(id => equipmentBlueprints[id].targetRole === targetRole);
                        const foundId = availableEquipmentForRole[Math.floor(Math.random() * availableEquipmentForRole.length)];
                        const equipment = equipmentBlueprints[foundId];
                        const targetCharacter = gameState.party.find(p => p.role === targetRole && p.currentHp > 0);

                        if (targetCharacter) {
                            log(`古い宝箱から ${equipment.name} を見つけた！ ${equipment.description}`);
                            targetCharacter[equipment.stat] += equipment.value;
                            gameState.foundEquipment.push(foundId);
                            flashCard(targetCharacter, 'yellow');
                            updatePartyStatus();
                        } else {
                            // 対象キャラが見つからなかった場合（戦闘不能など）
                            nothingHappened();
                        }
                    }

                    async function executeEvent(eventFunc) {
                        dungeonCommands.classList.add('hidden');
                        try {
                            await eventFunc();
                        } finally {
                            // モーダルが表示されている場合や戦闘中の場合を除き、コマンドを再表示
                            if (!modal.classList.contains('hidden') || !itemModal.classList.contains('hidden') || !levelUpModal.classList.contains('hidden') || !challengeModal.classList.contains('hidden') || !eventChoiceModal.classList.contains('hidden') || gameState.inBattle) {
                                // 何もしない
                            } else {
                                dungeonCommands.classList.remove('hidden');
                            }
                        }
                    }

                    function triggerRandomEvent() {
                        const chosenEvent = getRandomEvent();
                        executeEvent(chosenEvent.func);
                    }

                    async function foundGreatHole() {
                        gameState.greatHoleEventTriggered = true; // イベントは一度しか発生しない
                        gameState.greatHoleEventFloor = gameState.floor; // 発生階層を記録
                        log("道の脇で、二人の冒険者の少女が泣いている…。");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        celestiaEventTitle.textContent = "大穴になあれ";
                        celestiaEventText.textContent = "少女「うぅ…大事なペンダントを、この小さな穴に落としちゃったの…」\n少女「小さくならないと取れないよぉ…」\n\n彼女たちにフェアリーシロップを2個渡しますか？";
                        celestiaEventButtons.innerHTML = `
                            <button id="greathole-give" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">渡す</button>
                            <button id="greathole-leave" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">通り過ぎる</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('greathole-give').onclick = async() => {
                            celestiaEventModal.classList.add('hidden');
                            // フェアリーシロップを2個消費
                            const syrup = gameState.inventory.find(item => item.id === 'fairy_syrup');
                            syrup.quantity -= 2;

                            log("フェアリーシロップを渡すと、少女たちは嬉しそうにそれを飲んだ！");
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log("二人の体はみるみる小さくなり、穴の中に飛び込んでいった。");
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log("しばらくして、ペンダントを抱えた二人が穴から出てきた。");
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log("少女「ありがとう！お姉さんたちのおかげだよ！お礼に、どっちか好きな方をあげる！」");

                            eventChoiceButtons.innerHTML = `
                                <button id="choice-elixir" class="action-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">エリクサー</button>
                                <button id="choice-gigant" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">ギガントシロップ</button>
                            `;
                            eventChoiceModal.classList.remove('hidden');

                            document.getElementById('choice-elixir').onclick = () => {
                                eventChoiceModal.classList.add('hidden');
                                addItemToInventory('elixir', 1);
                                log("「エリクサー」を手に入れた！");
                                dungeonCommands.classList.remove('hidden');
                            };
                            document.getElementById('choice-gigant').onclick = () => {
                                eventChoiceModal.classList.add('hidden');
                                addItemToInventory('gigant_syrup', 1);
                                log("「ギガントシロップ」を手に入れた！");
                                dungeonCommands.classList.remove('hidden');
                            };
                        };

                        document.getElementById('greathole-leave').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行は少女たちを後にして、先へ進んだ。");
                            dungeonCommands.classList.remove('hidden');
                        };
                    }

                    async function foundWishPrayGirl() {
                        gameState.wishPrayEventTriggered = true; // イベントは一度しか発生しない
                        const isWishGirl = Math.random() < 0.5;
                        const girlName = isWishGirl ? "願いの少女" : "祈りの少女";
                        const blessingId = isWishGirl ? "wish_girl" : "pray_girl";
                        const blessing = blessings[blessingId];

                        log("どこかで見覚えのある、小さな少女が駆け寄ってきた。");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        celestiaEventTitle.textContent = "再会、そして…";
                        celestiaEventText.textContent = `少女「あ、あの時のお姉さんたち！また会えて嬉しいな！」\n少女「私も、お姉さんたちみたいに強くなりたいの！お願い、一緒に冒険させて！」\n\n身長1cmの少女が、同行を申し出てきた。`;
                        celestiaEventButtons.innerHTML = `
                            <button id="wishpray-accept" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">受け入れる</button>
                            <button id="wishpray-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">断る</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('wishpray-accept').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log(`少女は嬉しそうに跳ねると、一人の仲間の方へ駆け寄った。`);

                            showOneMemberSelectionModal(char => {
                                log(`少女は${char.name}の肩にちょこんと乗り、その身に不思議な力を与えた！`);
                                blessing.effect(char);
                                log(`${char.name}は祝福「${blessing.name}」を授かった！`);
                                flashCard(char, 'green');
                                updatePartyStatus();
                                dungeonCommands.classList.remove('hidden');
                            }, `少女が力を貸したい仲間を選んでください。`);
                        };

                        document.getElementById('wishpray-decline').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("少女は少し寂しそうにしたが、笑顔で手を振って見送ってくれた。");
                            dungeonCommands.classList.remove('hidden');
                        };
                    }

                    async function foundDrunkenMonster() {
                        gameState.drunkenMonsterEventTriggered = true;
                        log("ダンジョンの奥から、巨大な魔物がふらふらと歩いてきた…。");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        celestiaEventTitle.textContent = "酒豪の怪物";
                        celestiaEventText.textContent = "巨大な魔物「おぉ…お前さんたち、ギガンテスエールを…持っとらんか…？」\n\nギガンテスエールを2個、譲りますか？";
                        celestiaEventButtons.innerHTML = `
                            <button id="drunken-monster-give" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">譲る</button>
                            <button id="drunken-monster-refuse" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">断る</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('drunken-monster-give').onclick = async() => {
                            celestiaEventModal.classList.add('hidden');
                            const aleItem = gameState.inventory.find(item => item.id === 'gigantes_ale');
                            aleItem.quantity -= 2;

                            const tallestChar = gameState.party.filter(p => p.currentHp > 0).sort((a, b) => b.height - a.height)[0];
                            if (!tallestChar) {
                                log("しかし、パーティに誰もいなかったため、魔物は寂しそうに去っていった。");
                                dungeonCommands.classList.remove('hidden');
                                return;
                            }

                            log(`魔物は嬉しそうにギガンテスエールを受け取ると、${tallestChar.name}に差し出した！`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log(`二人は豪快にギガンテスエールで乾杯し、親睦を深めた！`);
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            if (!tallestChar.heightLocked) {
                                await animateStatChange(tallestChar, 'height', 100, 'increase');
                                log(`${tallestChar.name}の身長が100cm伸びた！`);
                            } else {
                                log(`${tallestChar.name}の身長は固定されており、変化しなかった！`);
                            }
                            await new Promise(resolve => setTimeout(resolve, 1000));

                            const blessing = blessings.giant_grounding;
                            blessing.effect(tallestChar);
                            log(`機嫌を良くした魔物から、${tallestChar.name}は祝福「${blessing.name}」を授かった！`);
                            flashCard(tallestChar, 'green');
                            updatePartyStatus();
                            dungeonCommands.classList.remove('hidden');
                        };

                        document.getElementById('drunken-monster-refuse').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行はギガンテスエールを譲らず、魔物は不機嫌そうに去っていった…。");
                            dungeonCommands.classList.remove('hidden');
                        };
                    }

                    async function foundMazeOfShade() {
                        gameState.mazeOfShadeEventTriggered = true;
                        log("ダンジョンに突風が吹き荒れ、小さな一行は木の葉のように舞い上がった！");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("気づくと、一行は見知らぬ木陰に着地していた。目の前には、小さな獣道が続いている…。");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        celestiaEventTitle.textContent = "木陰の迷宮";
                        celestiaEventText.textContent = "この先に何があるかはわからない…。\n小道に入りますか？";
                        celestiaEventButtons.innerHTML = `
                            <button id="maze-enter" class="action-button bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg">入る</button>
                            <button id="maze-leave" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">やめておく</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('maze-enter').onclick = async() => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行は覚悟を決め、小さな迷宮へと足を踏み入れた。");
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            let failedAttempts = 0;
                            for (let i = 0; i < 3; i++) {
                                log(`探索中… (${i + 1}/3)`);
                                await new Promise(resolve => setTimeout(resolve, 1500));
                                if (Math.random() < 0.5) { // 50%でアイテム獲得
                                    const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                    const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                                    addItemToInventory(foundItemId);
                                    log(`キラリと光るものを見つけた！「${itemBlueprints[foundItemId].name}」を手に入れた！`);
                                    flashCard(getRandomPartyMember(), 'yellow');
                                } else {
                                    log("物音に気づき身構えたが、何も見つからなかった…。");
                                    failedAttempts++;
                                }
                                await new Promise(resolve => setTimeout(resolve, 1500));
                            }

                            if (failedAttempts > 0) {
                                log(`探索を終えようとしたその時、背後から${failedAttempts}体の小さな気配が迫る！`);
                                await new Promise(resolve => setTimeout(resolve, 2000));
                                startBattle(false, false, 'micro', failedAttempts); // 特殊な敵との戦闘
                            } else {
                                log("幸運にも、危険なことにはならずに迷宮を抜け出すことができた。");
                                dungeonCommands.classList.remove('hidden');
                            }
                        };

                        document.getElementById('maze-leave').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            log("一行は危険を察知し、小道には入らずに元の道へ戻った。");
                            dungeonCommands.classList.remove('hidden');
                        };
                    }

                    function getLineForHole(char, situation, otherChar) {
                        const charConvos = conversations[char.name];
                        if (charConvos && charConvos[situation] && charConvos[situation].length > 0) {
                            const lines = charConvos[situation];
                            let line = lines[Math.floor(Math.random() * lines.length)];
                            return line.replace(/{name}/g, otherChar.name);
                        }
                        // デフォルトのセリフ
                        return situation === 'high_mouse_hole_giant' ? "肩を貸すよ。" : "行ってくる！";
                    }


                    async function foundLiberatedMonsterAttack() {
                        const liberatedMembers = gameState.party.filter(p => p.currentHp > 0 && p.isLiberatedStripped);
                        if (liberatedMembers.length === 0) {
                            nothingHappened();
                            return;
                        }

                        const victim = liberatedMembers[Math.floor(Math.random() * liberatedMembers.length)];
                        log(`その無防備な姿に惹かれたのか、物陰から魔物が${victim.name}に襲いかかった！`);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        const debuffType = ['atk_down', 'def_down', 'slow'][Math.floor(Math.random() * 3)];
                        let debuffMessage = '';
                        if (debuffType === 'atk_down') {
                            victim.buffs.atk_down = 3;
                            debuffMessage = '攻撃力が下がってしまった！';
                        } else if (debuffType === 'def_down') {
                            victim.buffs.def_down = 3;
                            debuffMessage = '防御力が下がってしまった！';
                        } else {
                            victim.statusEffects.slow = {
                                turns: 3
                            };
                            debuffMessage = '動きが鈍くなってしまった！';
                        }

                        flashCard(victim, 'red');
                        log(`${victim.name}はなんとか魔物を追い払ったが、${debuffMessage}`);
                        updatePartyStatus();
                    }

                    async function foundLiberatedTease() {
                        const liberatedMembers = gameState.party.filter(p => p.currentHp > 0 && p.isLiberatedStripped);
                        const normalMembers = gameState.party.filter(p => p.currentHp > 0 && !p.isLiberatedStripped);

                        if (liberatedMembers.length === 0 || normalMembers.length === 0) {
                            nothingHappened();
                            return;
                        }

                        const victim = liberatedMembers[Math.floor(Math.random() * liberatedMembers.length)];
                        const teaser = normalMembers[Math.floor(Math.random() * normalMembers.length)];

                        const teaseLines = {
                            'リリカ': [`あら、${victim.name}ちゃん、大胆だねー！ファンサービス？`, `その格好、ステージ衣装より目立ってるんじゃない？`],
                            'ユイ': [`きゃっ！${victim.name}さん、そのお姿は…！か、風邪をひいてしまいます！`, `だ、だめです！ちゃんと隠さないと…！`],
                            'ミコ': [`わー、${victim.name}ちゃん、すごい格好だね！モコがびっくりしてるよ！`, `${victim.name}ちゃん、寒くないの？ミコのマント貸してあげようか？`],
                            'リリィ': [`へぇ、${victim.name}ちゃん、やるじゃん。冒険にそのくらいの気合は必要だよね！`, `いいよー、その調子！隠すより、見せつけちゃいなよ！`]
                        };

                        const victimLines = {
                            'リリカ': [`ち、違うの！これはアクシデントで…！`, `もー、${teaser.name}ちゃんのいじわる！`],
                            'ユイ': [`ふぇぇ…！${teaser.name}さん、そんなに見ないでくださいぃ…！`, `うぅ…恥ずかしいですぅ…`],
                            'ミコ': [`わわっ、これはその…！事故なの！`, `モコちゃんまでそんな目で見ないでー！`],
                            'リリィ': [`こ、これは…！戦術的な判断だから！`, `べ、別に好きでやってるわけじゃないんだからね！`]
                        };

                        log(`${teaser.name}「${teaseLines[teaser.name][Math.floor(Math.random() * teaseLines[teaser.name].length)]}」`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log(`${victim.name}「${victimLines[victim.name][Math.floor(Math.random() * victimLines[victim.name].length)]}」`);
                    }

                    async function foundLiberatedPlay() {
                        const liberatedMembers = gameState.party.filter(p => p.currentHp > 0 && p.isLiberatedStripped);
                        if (liberatedMembers.length < 2) {
                            nothingHappened();
                            return;
                        }

                        // 2人を選ぶ
                        const char1 = liberatedMembers[Math.floor(Math.random() * liberatedMembers.length)];
                        const otherLiberated = liberatedMembers.filter(p => p !== char1);
                        const char2 = otherLiberated[Math.floor(Math.random() * otherLiberated.length)];

                        // 身長による分岐
                        if (char1.height === 1 && char2.height === 1) {
                            const convos = conversations['summer_all_tiny_play'];
                            const possibleConvos = convos.filter(c => c.chars.includes(char1.name) && c.chars.includes(char2.name));
                            if (possibleConvos.length > 0) {
                                const convo = possibleConvos[Math.floor(Math.random() * possibleConvos.length)];
                                log(`${char1.name}と${char2.name}は、小さな体でじゃれ合っている…`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                                log(`${convo.chars[0]}「${convo.lines[0]}」`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                                log(`${convo.chars[1]}「${convo.lines[1]}」`);
                                return;
                            }
                        } else if (char1.height > 140 && char2.height > 140) {
                            const convos = conversations['summer_all_grown_play'];
                            const possibleConvos = convos.filter(c => c.chars.includes(char1.name) && c.chars.includes(char2.name));
                            if (possibleConvos.length > 0) {
                                const convo = possibleConvos[Math.floor(Math.random() * possibleConvos.length)];
                                log(`${char1.name}と${char2.name}は、大きな体でじゃれ合っている…`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                                log(`${convo.chars[0]}「${convo.lines[0]}」`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                                log(`${convo.chars[1]}「${convo.lines[1]}」`);
                                return;
                            }
                        }


                        // 通常のじゃれあい
                        const playLines = {
                            'リリカ': [
                                `ねえ、${char2.name}ちゃん…。なんだか、体が火照っちゃって…。ちょっとだけ、触ってもいい…？`,
                                `ふふっ、${char2.name}ちゃんのここ、すっごく敏感なんだね。かわいい…。もっと、いじめてあげたくなっちゃうな…。`
                            ],
                            'ユイ': [
                                `はぅぅ…${char2.name}さん…。なんだか、変な気分ですぅ…。こ、この気持ち、確かめたくて…！`,
                                `ひゃっ…！そ、そこは…！だめぇ…！でも、${char2.name}さんがしてくれるなら…もっと…。`
                            ],
                            'ミコ': [
                                `わわっ、${char2.name}ちゃん、あったかいね…。モコみたいに、すりすりしたくなっちゃう…。`,
                                `んんっ…！${char2.name}ちゃん、そこはミコの弱点なんだよぉ…。でも、なんだか気持ちいいかも…。`
                            ],
                            'リリィ': [
                                `へぇ、${char2.name}ちゃん、いい体してんじゃん。ちょっと、冒険の成果、確かめさせてよ。`,
                                `くっ…！やるじゃない、${char2.name}ちゃん…！でも、私だって負けないんだから…！ほら、こっちも…！`
                            ]
                        };

                        const playLinesAll = {
                            'リリカ': `ふふっ、みんな、とっても大胆…。最高のステージになりそうね…！`,
                            'ユイ': `はぅぅ…！皆さん、こんな…こんなことになっちゃって…！でも、なんだかドキドキします…！`,
                            'ミコ': `わーい！みんなおんなじだね！なんだか、秘密のパーティみたいで楽しい！`,
                            'リリィ': `いいね、いいね！全員でさらけ出してこそ、最高のライブでしょ！さあ、もっとアツくなろうよ！`
                        };

                        // 4人全員が解放状態の場合、30%の確率で4人イベントに分岐
                        if (liberatedMembers.length === 4 && Math.random() < 0.3) {
                            log("解放された4人の衝動が共鳴し、互いを求め合う…！");
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const situation = gameState.floor <= 30 ? 'beach' : 'onsen';
                            const convos = summerAllLiberatedPlayConversations[situation];
                            const selectedConvo = convos[Math.floor(Math.random() * convos.length)];

                            for (let i = 0; i < selectedConvo.chars.length; i++) {
                                const charName = selectedConvo.chars[i];
                                const line = selectedConvo.lines[i];
                                log(`${charName}「${line}」`);
                                await new Promise(resolve => setTimeout(resolve, 2500));
                            }
                            return;
                        }
                        // 4人用のイベントが発生しなかった場合は、通常の2人用イベントに進む




                        log(`${char1.name}は解放された衝動のまま、${char2.name}の体にそっと触れた…。`);
                        await new Promise(resolve => setTimeout(resolve, 2500));
                        log(`${char1.name}「${playLines[char1.name][0]}」`);
                        await new Promise(resolve => setTimeout(resolve, 2500));
                        log(`${char2.name}「${playLines[char2.name][1]}」`);
                    }


                    function foundTreasure() {
                        // 5%の確率でレアアイテムが出現
                        if (Math.random() < 0.05) {
                            const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                            const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                            addItemToInventory(foundItemId);
                            log(`なんと、宝箱からとても珍しい「${itemBlueprints[foundItemId].name}」を見つけた！`);
                            flashCard(gameState.party[0], 'yellow');
                        } else {
                            // 通常のアイテム
                            const itemCount = Math.floor(Math.random() * 3) + 1; // 1〜3個のアイテム
                            const foundItems = [];
                            // レア・特殊アイテムを除外
                            const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].battleOnly && !itemBlueprints[id].rare && !itemBlueprints[id].special);

                            for (let i = 0; i < itemCount; i++) {
                                const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                                addItemToInventory(foundItemId);
                                foundItems.push(itemBlueprints[foundItemId].name);
                            }
                            log(`宝箱を見つけた！ ${foundItems.join('、')} を手に入れた！`);
                            flashCard(gameState.party[0], 'yellow');
                        }
                    }

                    async function foundFountain() {
                        const effects = [{
                            text: "HPが少し回復した。",
                            stat: 'hp',
                            ratio: 0.3
                        }, {
                            text: "MPが少し回復した。",
                            stat: 'mp',
                            ratio: 0.3
                        }, {
                            text: "HPとMPが全回復した！",
                            stat: 'both',
                            ratio: 1.0
                        }, ];
                        const effect = effects[Math.floor(Math.random() * effects.length)];
                        log(`一行は不思議な泉を見つけた。${effect.text}`);
                        for (const char of gameState.party) {
                            if (effect.stat === 'hp' || effect.stat === 'both') await animateStatChange(char, 'hp', Math.floor(char.maxHp * effect.ratio), 'increase');
                            if (effect.stat === 'mp' || effect.stat === 'both') await animateStatChange(char, 'mp', Math.floor(char.maxMp * effect.ratio), 'increase');
                            flashCard(char, 'green');
                        }
                    }

                    async function triggerShrinkTrap() {
                        const target = getRandomPartyMember();
                        if (target.heightLocked) {
                            log(`${target.name}は不思議な力で守られており、罠の効果を受けなかった！`);
                            return;
                        }
                        const shrinkAmount = Math.floor(Math.random() * 11) + 10; // 10〜20cm縮む
                        const finalShrink = gameState.gameMode === 'endgame_plus' ? shrinkAmount * 2 : shrinkAmount;
                        await animateStatChange(target, 'height', -finalShrink, 'decrease');
                        flashCard(target, 'yellow'); // Flash the card itself
                        log(`奇妙な罠が作動した！ ${target.name}の体が縮んでしまった！(身長-${finalShrink}cm)`);
                    }

                    async function triggerGrowTrap() {
                        const target = getRandomPartyMember();
                        if (target.heightLocked) {
                            log(`${target.name}は不思議な力で守られており、光の影響を受けなかった！`);
                            return;
                        }
                        const growAmount = Math.floor(Math.random() * 11) + 10; // 10〜20cm伸びる
                        const finalGrow = gameState.gameMode === 'endgame_plus' ? growAmount * 2 : growAmount;
                        await animateStatChange(target, 'height', finalGrow, 'increase');
                        flashCard(target, 'yellow');
                        log(`不思議な光が降り注いだ！ ${target.name}の体が巨大化してしまった！(身長+${finalGrow}cm)`);
                    }

                    async function triggerDamageTrap() {
                        const target = getRandomPartyMember();
                        let damage = Math.ceil(target.maxHp * 0.1); // 最大HPの10%ダメージ
                        if (gameState.gameMode === 'endgame_plus') damage *= 2; // 終焉モードではダメージ2倍
                        let messages;

                        if (target.height <= 10) {
                            messages = [
                                `${target.name}は小さすぎて、仲間に気づかれず踏まれてしまった！`,
                                `${target.name}は小さな水たまりで溺れかけてしまった！`,
                                `${target.name}は強風に煽られて壁にぶつかってしまった！`,
                            ];
                        } else {
                            messages = [
                                `${target.name}は足をもつらせて転んでしまった！`,
                                `${target.name}は隠された罠を踏んでしまった！`,
                            ];
                        }
                        log(messages[Math.floor(Math.random() * messages.length)]);
                        await dealDamage(target, damage);
                    }

                    function foundAltar() {
                        log("一行は怪しげな祭壇を見つけた…");
                        challengeModal.classList.remove('hidden');
                        const challengeAcceptButton = document.getElementById('challenge-accept-button');
                        const challengeDeclineButton = document.getElementById('challenge-decline-button');


                        challengeAcceptButton.onclick = () => {
                            challengeModal.classList.add('hidden');
                            if (Math.random() < 0.3) { // 30%で成功
                                const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                                addItemToInventory(foundItemId);
                                log(`祭壇が輝き、なんと「${itemBlueprints[foundItemId].name}」を手に入れた！`);
                                flashCard(getRandomPartyMember(), 'green');
                                dungeonCommands.classList.remove('hidden'); // コマンドを再表示
                            } else { // 70%で失敗
                                const availableItems = gameState.inventory.filter(item => item.quantity > 0);
                                if (availableItems.length > 0) {
                                    const lostItem = availableItems[Math.floor(Math.random() * availableItems.length)];
                                    lostItem.quantity--;
                                    log(`祭壇は禍々しい光を放ち、「${itemBlueprints[lostItem.id].name}」を一つ失ってしまった…`);
                                    flashCard(getRandomPartyMember(), 'red');
                                } else {
                                    log("祭壇に捧げるものがなく、何も起こらなかった。");
                                }
                                dungeonCommands.classList.remove('hidden'); // コマンドを再表示
                            }
                        };
                        challengeDeclineButton.onclick = () => {
                            challengeModal.classList.add('hidden');
                            log("一行は怪しげな祭壇を後にして、先へ進んだ。");
                            dungeonCommands.classList.remove('hidden'); // コマンドを再表示
                        };
                    }

                    function foundBard() {
                        log(`陽気な吟遊詩人に出会った。彼の歌声に、パーティの士気が上がる！`);
                        gameState.party.forEach(char => {
                            if (char.currentHp > 0) {
                                char.buffs.atk_up = 3; // 3ターン攻撃力アップ
                                flashCard(char, 'yellow');
                            }
                        });
                        log(`全員の攻撃力が一時的に上昇した！`);
                    }

                    async function foundClothes() {
                        const strippedMembers = gameState.party.filter(p => p.statusEffects.stripped);
                        if (strippedMembers.length > 0) {
                            // 衣装状態に応じてメッセージを変更
                            const firstStrippedMember = strippedMembers[0];
                            let foundMessage = "一行はきれいな服が落ちているのを見つけた！";
                            let dressedMessage = "は服を着て、元の状態に戻った！";

                            if (firstStrippedMember.costume === 'beach') {
                                foundMessage = "一行は替えの水着が落ちているのを見つけた！";
                                dressedMessage = "は新しい水着に着替えて、元の状態に戻った！";
                            } else if (firstStrippedMember.costume === 'onsen') {
                                foundMessage = "一行は替えのタオルが落ちているのを見つけた！";
                                dressedMessage = "は新しいタオルを巻いて、元の状態に戻った！";
                            }

                            log(foundMessage);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            strippedMembers.forEach(member => {
                                delete member.statusEffects.stripped;
                                // 解放状態も同時に解除
                                if (member.isLiberatedStripped) {
                                    delete member.isLiberatedStripped;
                                }
                                log(`${member.name}${dressedMessage}`);
                                flashCard(member, 'yellow');
                            });
                        }
                    }

                    async function foundDollhouse() {
                        const tinyMembers = gameState.party.filter(p => p.currentHp > 0 && p.height <= 10);

                        if (tinyMembers.length === 0) {
                            log("目の前に精巧な作りの小さな家があるが、小さすぎて誰も入れなさそうだ。");
                            return;
                        }

                        const explorer = tinyMembers[Math.floor(Math.random() * tinyMembers.length)];
                        // 探索者の身長に応じてセリフセットを切り替える
                        const conversationKey = explorer.height === 1 ? 'dollhouse_explore_giant' : 'dollhouse_explore';
                        let conversationLine = "探検してみよう！"; // デフォルトのセリフ
                        const explorerConvos = conversations[explorer.name];
                        if (explorerConvos && explorerConvos[conversationKey] && explorerConvos[conversationKey].length > 0) {
                            const lines = explorerConvos[conversationKey];
                            conversationLine = lines[Math.floor(Math.random() * lines.length)];
                        }

                        log(`目の前に精巧な作りの家がある！ ${explorer.name}が中を調べてみるようだ。`);
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        log(`${explorer.name}「${conversationLine}」`);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        const foundItems = [];
                        const allItemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].special); // 特殊アイテムを除外
                        for (let i = 0; i < 2; i++) {
                            const foundItemId = allItemIds[Math.floor(Math.random() * allItemIds.length)];
                            addItemToInventory(foundItemId);
                            foundItems.push(itemBlueprints[foundItemId].name);
                        }
                        log(`${explorer.name}は家の中から ${foundItems.join('と')} を見つけてきた！`);
                    }

                    async function foundCrackedRock() {
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        const allTiny = aliveParty.length > 0 && aliveParty.every(p => p.height === 1);

                        if (allTiny) {
                            // 全員が1cmの場合の新しいシナリオ
                            const explorer = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                            let conversationLine = "この隙間、何かありそう！"; // デフォルト
                            const explorerConvos = conversations[explorer.name];
                            if (explorerConvos && explorerConvos.cracked_rock_tiny && explorerConvos.cracked_rock_tiny.length > 0) {
                                const lines = explorerConvos.cracked_rock_tiny;
                                conversationLine = lines[Math.floor(Math.random() * lines.length)];
                            }

                            log(`目の前に巨大な岩が道を塞いでいる！しかし、よく見ると小さな隙間がたくさん空いている…`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`${explorer.name}が隙間の中を調べてみるようだ。`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`${explorer.name}「${conversationLine}」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const foundItems = [];
                            const itemCount = Math.floor(Math.random() * 2) + 2; // 2〜3個のアイテム
                            const allItemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].special); // 特殊アイテムを除外
                            for (let i = 0; i < itemCount; i++) {
                                const foundItemId = allItemIds[Math.floor(Math.random() * allItemIds.length)];
                                addItemToInventory(foundItemId);
                                foundItems.push(itemBlueprints[foundItemId].name);
                            }
                            log(`${explorer.name}は岩の隙間から ${foundItems.join('と')} を見つけてきた！`);

                        } else {
                            // 従来のシナリオ
                            const giantMembers = aliveParty.filter(p => p.height >= 300);
                            if (giantMembers.length === 0) {
                                log("目の前にひび割れた巨岩があるが、誰も壊せそうにない。");
                                return;
                            }

                            const breaker = giantMembers[Math.floor(Math.random() * giantMembers.length)];
                            let conversationLine = "この岩、壊せそうだ！"; // デフォルト
                            const breakerConvos = conversations[breaker.name];
                            if (breakerConvos && breakerConvos.cracked_rock_break && breakerConvos.cracked_rock_break.length > 0) {
                                const lines = breakerConvos.cracked_rock_break;
                                conversationLine = lines[Math.floor(Math.random() * lines.length)];
                            }

                            log(`目の前に巨大な岩が道を塞いでいる！しかし、よく見ると大きなひびが入っている…`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`${breaker.name}がその巨体で岩を破壊するようだ！`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`${breaker.name}「${conversationLine}」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log(`ゴゴゴ…！ ${breaker.name}は巨岩を粉々に打ち砕いた！`);
                            levelUpCharacter(breaker, false); // UIは表示せずにレベルアップ
                        }
                    }

                    async function foundBeachLiberation() {
                        // 10%の確率で全員解放イベントに分岐
                        if (Math.random() < 0.1) {
                            celestiaEventTitle.textContent = "ビーチの熱狂";
                            celestiaEventText.textContent = "ライブの熱気は最高潮に達し、パーティ全体を巻き込もうとしている…！\n\n全員で、全てを解き放ちますか？";
                            celestiaEventButtons.innerHTML = `
                                <button id="liberation-all-accept" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">全員解放する</button>
                                <button id="liberation-all-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">理性を保つ</button>
                            `;
                            celestiaEventModal.classList.remove('hidden');

                            document.getElementById('liberation-all-accept').onclick = async() => {
                                celestiaEventModal.classList.add('hidden');
                                log("パーティ全員がビーチの熱気に身を任せ、解放状態になった！");
                                await new Promise(resolve => setTimeout(resolve, 2500));

                                // 追加の会話を再生
                                const partyConvos = conversations['summer_beach_all_liberated'];
                                const partyConvo = partyConvos[Math.floor(Math.random() * partyConvos.length)];
                                for (let i = 0; i < partyConvo.chars.length; i++) {
                                    log(`${partyConvo.chars[i]}「${partyConvo.lines[i]}」`);
                                    await new Promise(resolve => setTimeout(resolve, 2500));
                                }

                                gameState.party.forEach(p => { // ファイター, ソーサラー, ナイト, メディック
                                    if (p.currentHp > 0 && !p.statusEffects.stripped && !p.isLiberatedStripped) {
                                        p.statusEffects.stripped = {
                                            turns: 0
                                        };
                                        p.isLiberatedStripped = true;
                                    }
                                });
                                updatePartyStatus();
                            };
                            document.getElementById('liberation-all-decline').onclick = () => {
                                celestiaEventModal.classList.add('hidden');
                                log("一行はなんとか理性を保ち、熱狂を抑え込んだ。");
                            };
                            return; // 全員解放イベントを実行したらここで終了
                        }

                        const potentialTargets = gameState.party.filter(p => p.currentHp > 0 && !p.statusEffects.stripped && !p.isLiberatedStripped && (!p.liberationCooldown || p.liberationCooldown <= 0));
                        if (potentialTargets.length === 0) {
                            nothingHappened();
                            return;
                        }
                        const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
                        const promptLine = (conversations[target.name] && conversations[target.name].beach_liberation_prompt && conversations[target.name].beach_liberation_prompt[0]) || "なんだか、全部脱ぎ捨てたくなっちゃった！";

                        celestiaEventTitle.textContent = "ビーチの熱気";
                        celestiaEventText.textContent = `${target.name}「${promptLine}」\n\n${target.name}はライブの熱気にあてられ、大胆になっているようだ…！`;
                        celestiaEventButtons.innerHTML = `
                            <button id="liberation-accept" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">脱がせる</button>
                            <button id="liberation-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">止める</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('liberation-accept').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            target.statusEffects.stripped = {
                                turns: 0
                            };
                            target.isLiberatedStripped = true;
                            log(`${target.name}は自ら服を脱ぎ捨て、解放状態になった！`);
                            updatePartyStatus();
                        };
                        document.getElementById('liberation-decline').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            const stopLine = (conversations[target.name] && conversations[target.name].beach_liberation_stop && conversations[target.name].beach_liberation_stop[0]) || "ちぇっ、つまんないの。";
                            log(`${target.name}「${stopLine}」`);
                            target.liberationCooldown = 5; // 5フロアのクールダウンを設定
                        };
                    }

                    async function foundOnsenLiberation() {
                        // 10%の確率で全員解放イベントに分岐
                        if (Math.random() < 0.1) {
                            celestiaEventTitle.textContent = "温泉の狂騒";
                            celestiaEventText.textContent = "温泉の心地よさが極限に達し、パーティ全体に伝播していく…！\n\n全員で、身も心も解き放ちますか？";
                            celestiaEventButtons.innerHTML = `
                                <button id="liberation-all-accept" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">全員解放する</button>
                                <button id="liberation-all-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">自制心を保つ</button>
                            `;
                            celestiaEventModal.classList.remove('hidden');

                            document.getElementById('liberation-all-accept').onclick = async() => {
                                celestiaEventModal.classList.add('hidden');
                                log("パーティ全員が温泉の心地よさに身を委ね、解放状態になった！");
                                await new Promise(resolve => setTimeout(resolve, 2500));

                                // 追加の会話を再生
                                const partyConvos = conversations['summer_onsen_all_liberated'];
                                const partyConvo = partyConvos[Math.floor(Math.random() * partyConvos.length)];
                                for (let i = 0; i < partyConvo.chars.length; i++) {
                                    log(`${partyConvo.chars[i]}「${partyConvo.lines[i]}」`);
                                    await new Promise(resolve => setTimeout(resolve, 2500));
                                }

                                gameState.party.forEach(p => { // ファイター, ソーサラー, ナイト, メディック
                                    if (p.currentHp > 0 && !p.statusEffects.stripped && !p.isLiberatedStripped) {
                                        p.statusEffects.stripped = {
                                            turns: 0
                                        };
                                        p.isLiberatedStripped = true;
                                    }
                                });
                                updatePartyStatus();
                            };
                            document.getElementById('liberation-all-decline').onclick = () => {
                                celestiaEventModal.classList.add('hidden');
                                log("一行はなんとか自制心を保ち、のぼせるのを防いだ。");
                            };
                            return; // 全員解放イベントを実行したらここで終了
                        }

                        const potentialTargets = gameState.party.filter(p => p.currentHp > 0 && !p.statusEffects.stripped && !p.isLiberatedStripped && (!p.liberationCooldown || p.liberationCooldown <= 0));
                        if (potentialTargets.length === 0) {
                            nothingHappened();
                            return;
                        }
                        const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
                        const promptLine = (conversations[target.name] && conversations[target.name].onsen_liberation_prompt && conversations[target.name].onsen_liberation_prompt[0]) || "この心地よさ…もう何もかもどうでもよくなっちゃいそう。";

                        celestiaEventTitle.textContent = "温泉の誘惑";
                        celestiaEventText.textContent = `${target.name}「${promptLine}」\n\n${target.name}は温泉の心地よさに、身も心もとろけているようだ…！`;
                        celestiaEventButtons.innerHTML = `
                            <button id="liberation-accept" class="action-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">タオルを取る</button>
                            <button id="liberation-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">止める</button>
                        `;
                        celestiaEventModal.classList.remove('hidden');

                        document.getElementById('liberation-accept').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            target.statusEffects.stripped = {
                                turns: 0
                            };
                            target.isLiberatedStripped = true;
                            log(`${target.name}はタオルを外し、解放状態になった！`);
                            updatePartyStatus();
                        };
                        document.getElementById('liberation-decline').onclick = () => {
                            celestiaEventModal.classList.add('hidden');
                            const stopLine = (conversations[target.name] && conversations[target.name].onsen_liberation_stop && conversations[target.name].onsen_liberation_stop[0]) || "うん、わかった。もうちょっとだけこのままでいさせて。";
                            log(`${target.name}「${stopLine}」`);
                            target.liberationCooldown = 5; // 5フロアのクールダウンを設定
                            log(`（${target.name}はしばらくの間、大胆な気分にはならないだろう…）`);
                        };
                    }

                    function foundMagicCrystal() {
                        if (Math.random() < 0.5) {
                            addItemToInventory('holy_crystal');
                            log(`足元で輝く魔力の結晶を見つけた！「聖結晶」を手に入れた！`);
                        } else {
                            addItemToInventory('evil_crystal');
                            log(`足元で禍々しく光る魔力の結晶を見つけた！「邪結晶」を手に入れた！`);
                        }
                        flashCard(getRandomPartyMember(), 'yellow');
                    }

                    async function foundOnsenTowelTrouble() {
                        log("温泉の熱気にあてられて、少しのぼせてしまったようだ…");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        const immuneRoles = ['ナイト', 'サムライ', '聖女', 'アンドロイド'];
                        const potentialVictims = gameState.party.filter(p => p.currentHp > 0 && !immuneRoles.includes(p.role) && !p.statusEffects.stripped);

                        if (potentialVictims.length === 0) {
                            log("…が、特に何も起こらなかった。");
                            return;
                        }

                        const victim = potentialVictims[Math.floor(Math.random() * potentialVictims.length)];
                        log(`ふらついた拍子に、${victim.name}のタオルがはだけてしまった！`);
                        victim.statusEffects.stripped = {
                            turns: 0
                        };
                        flashCard(victim, 'red');
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        const line = conversations[victim.name].onsen_towel_trouble[0];
                        log(`${victim.name}「${line}」`);
                    }

                    // --- サマータイム・スペシャルライブ！専用イベント ---
                    async function foundWatermelonSmash() {
                        log("ビーチといえばスイカ割り！みんなで楽しむことにした。");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        const blindfolded = getRandomPartyMember();
                        log(`${blindfolded.name}が目隠しをして、スイカ割りに挑戦！`);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        if (Math.random() < 0.7) { // 70%で成功
                            log(`「そっちじゃない！もっと右！」「行き過ぎ！」「そこだー！」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log(`パッカーン！ 見事にスイカは命中！`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log("甘くて冷たいスイカを食べて、全員のHPが少し回復した！");
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.2), 'increase');
                            }
                        } else { // 30%で失敗
                            const victim = gameState.party.filter(p => p.currentHp > 0 && p !== blindfolded)[Math.floor(Math.random() * (gameState.party.length - 1))];
                            log(`「こっちだよー！」という${victim.name}の声の方へ、${blindfolded.name}は進んでいき…`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log(`ゴツン！ ${blindfolded.name}の振り下ろした棒が、${victim.name}の頭にクリーンヒット！`);
                            await dealDamage(victim, 10);
                        }
                    }

                    async function foundSandcastle() {
                        log("みんなで砂の城を作ることにした。");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("力を合わせて、立派な城を築き上げる！");
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        const quality = Math.random();
                        if (quality < 0.3) {
                            log("城は完成したが、波にさらわれてすぐに崩れてしまった…。");
                        } else if (quality < 0.8) {
                            log("立派な砂の城が完成した！達成感でパーティの士気が上がる！(3ターン攻撃力アップ)");
                            gameState.party.forEach(p => {
                                if (p.currentHp > 0) p.buffs.atk_up = 3;
                            });
                        } else {
                            log("あまりに完璧な城が完成し、砂の精霊が祝福を与えてくれた！");
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log("全員のHPとMPが完全に回復した！");
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                await animateStatChange(p, 'mp', p.maxMp, 'increase');
                            }
                        }
                    }

                    async function foundOnsenPingPong() {
                        log("温泉といえば卓球！トーナメント戦が始まった！");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        const winner = gameState.party.filter(p => p.currentHp > 0).sort((a, b) => getEffectiveStats(b).agi - getEffectiveStats(a).agi)[0];
                        log(`激しいラリーの末、最も素早い${winner.name}が優勝した！`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log(`${winner.name}は温泉卓球マスターの称号を得て、ステータスが永続的に上昇した！`);
                        winner.atk += 1;
                        winner.def += 1;
                        winner.agi += 1;
                        flashCard(winner, 'green');
                    }

                    async function foundHotSpringsSoak() {
                        log("一行は温泉にゆっくりと浸かり、冒険の疲れを癒した。");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log("全員のHPとMPが回復し、状態異常も治った。");
                        for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                            await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.5), 'increase');
                            await animateStatChange(p, 'mp', Math.ceil(p.maxMp * 0.5), 'increase');
                            p.statusEffects = {}; // 脱衣以外をリセット
                        }
                    }

                    async function foundHighMouseHole() {
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        const allTiny = aliveParty.length > 0 && aliveParty.every(p => p.height === 1);

                        if (allTiny) {
                            // 全員が1cmの場合の新しいシナリオ
                            log(`壁の高い位置に、小さなネズミ穴を見つけた！`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`しかし、全員小さすぎて、どうやっても届きそうにない…。`);
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const char1 = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                            const otherParty = aliveParty.filter(p => p !== char1);
                            const char2 = otherParty.length > 0 ? otherParty[Math.floor(Math.random() * otherParty.length)] : char1;

                            const getLine = (char) => {
                                const charConvos = conversations[char.name];
                                if (charConvos && charConvos.high_mouse_hole_all_tiny && charConvos.high_mouse_hole_all_tiny.length > 0) {
                                    const lines = charConvos.high_mouse_hole_all_tiny;
                                    return lines[Math.floor(Math.random() * lines.length)];
                                }
                                return "うーん、届かないね…";
                            };

                            log(`${char1.name}「${getLine(char1)}」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            if (char1 !== char2) {
                                log(`${char2.name}「${getLine(char2)}」`);
                            }
                        } else {
                            // 従来のシナリオ
                            const giantMembers = aliveParty.filter(p => p.height >= 200);
                            const tinyMembers = aliveParty.filter(p => p.height <= 10);

                            if (giantMembers.length === 0 || tinyMembers.length === 0) {
                                log("壁の高い位置にネズミ穴があるが、協力できそうな仲間がいなかった。");
                                return;
                            }

                            const giant = giantMembers[Math.floor(Math.random() * giantMembers.length)];
                            const tiny = tinyMembers[Math.floor(Math.random() * tinyMembers.length)];

                            log(`壁の高い位置に、小さなネズミ穴を見つけた！`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`これは一人では届かないし、小さすぎて入れない…。`);
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            log(`${giant.name}と${tiny.name}が協力して調べるようだ。`);
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const giantLine = getLineForHole(giant, 'high_mouse_hole_giant', tiny);
                            const tinyLine = getLineForHole(tiny, 'high_mouse_hole_tiny', giant);

                            log(`${giant.name}「${giantLine}」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            log(`${tiny.name}「${tinyLine}」`);
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                            const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                            addItemToInventory(foundItemId);
                            log(`${tiny.name}は穴の中から、とても珍しい「${itemBlueprints[foundItemId].name}」を見つけてきた！`);
                            flashCard(giant, 'yellow');
                            flashCard(tiny, 'yellow');
                        }
                    }

                    function foundProtectiveWall() {
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length === 0) {
                            nothingHappened();
                            return;
                        }
                        const target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                        const targetId = gameState.party.indexOf(target);

                        log("どこからか岩が集まり、防壁を形成した！");

                        // 耐久値は対象の最大HPの50%とする
                        const wallHp = Math.ceil(target.maxHp * 0.5);
                        gameState.walls.push({
                            targetId: targetId,
                            hp: wallHp,
                            maxHp: wallHp
                        });
                        log(`${target.name}の前に、耐久値${wallHp}の防壁が現れた！`);
                        flashCard(target, 'yellow');
                    }

                    function nothingHappened() {
                        log('なにも見つからなかった。');
                    }

                    function foundSuspiciousDevice() {
                        log("一行は研究室のような部屋で、人が二人入れる奇妙な装置を見つけた…");

                        // ボタンの表示状態をリセット
                        deviceRedButton.parentElement.classList.remove('hidden');
                        deviceBlueButton.parentElement.classList.remove('hidden');
                        deviceGreenButtonContainer.classList.add('hidden');
                        deviceWhiteButtonContainer.classList.add('hidden');

                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);

                        // 赤いボタンの条件チェック
                        const nonOneCmChars = aliveParty.filter(p => p.height !== 1 && !p.heightLocked);
                        if (nonOneCmChars.length < 2) {
                            deviceRedButton.parentElement.classList.add('hidden');
                            deviceGreenButtonContainer.classList.remove('hidden');
                        }

                        // 青いボタンの条件チェック
                        if (aliveParty.length >= 2) {
                            const heights = aliveParty.map(p => p.height);
                            const maxHeight = Math.max(...heights);
                            const minHeight = Math.min(...heights);
                            if (maxHeight - minHeight < 30 && Math.random() < 0.5) {
                                deviceBlueButton.parentElement.classList.add('hidden');
                                deviceWhiteButtonContainer.classList.remove('hidden');
                            }
                        }

                        deviceModal.classList.remove('hidden');

                        deviceRedButton.onclick = () => {
                            deviceModal.classList.add('hidden');
                            showTwoMemberSelectionModal("身長を吸収するキャラと、されるキャラを順に選んでください。", (char1, char2) => {
                                log(`装置に${char1.name}と${char2.name}が入り、赤いボタンを押した！`);
                                if (char1.heightLocked || char2.heightLocked) {
                                    log("しかし、装置はうんともすんとも言わない。不思議な力で守られているようだ。");
                                    return;
                                }
                                const growthAmount = char2.height - 1;
                                const shrinkAmount = 1 - char2.height;

                                animateStatChange(char1, 'height', growthAmount, 'increase');
                                animateStatChange(char2, 'height', shrinkAmount, 'decrease');
                                log(`眩い光の後、${char1.name}の身長は${growthAmount}cm伸び、${char2.name}の身長は1cmになった！`);
                                dungeonCommands.classList.remove('hidden');
                            });
                        };

                        deviceBlueButton.onclick = () => {
                            deviceModal.classList.add('hidden');
                            showTwoMemberSelectionModal("身長を平均化するキャラを2人選んでください。", (char1, char2) => {
                                log(`装置に${char1.name}と${char2.name}が入り、青いボタンを押した！`);
                                if (char1.heightLocked || char2.heightLocked) {
                                    log("しかし、装置はうんともすんとも言わない。不思議な力で守られているようだ。");
                                    return;
                                }
                                const totalHeight = char1.height + char2.height;
                                const newHeight = Math.floor(totalHeight / 2);

                                const change1 = newHeight - char1.height;
                                const change2 = newHeight - char2.height;

                                animateStatChange(char1, 'height', change1, change1 >= 0 ? 'increase' : 'decrease');
                                animateStatChange(char2, 'height', change2, change2 >= 0 ? 'increase' : 'decrease');
                                log(`装置が作動し、二人の身長は平均化され、共に${newHeight}cmになった！`);
                                dungeonCommands.classList.remove('hidden');
                            });
                        };

                        deviceGreenButton.onclick = () => {
                            deviceModal.classList.add('hidden');
                            showOneMemberSelectionModal(char => {
                                log(`${char.name}が装置に入り、緑のボタンを押した！`);
                                if (char.heightLocked) {
                                    log("しかし、装置はうんともすんとも言わない。不思議な力で守られているようだ。");
                                    return;
                                }
                                animateStatChange(char, 'height', 100, 'increase');
                                log(`装置から光が溢れ、${char.name}の身長が100cm伸びた！`);
                                dungeonCommands.classList.remove('hidden');
                            }, "身長を伸ばすキャラを1人選んでください。");
                        };

                        deviceWhiteButton.onclick = () => {
                            deviceModal.classList.add('hidden');
                            showOneMemberSelectionModal(char => {
                                log(`${char.name}が装置に入り、白いボタンを押した！`);
                                const stats = ['atk', 'def', 'maxHp'];
                                const statToUpgrade = stats[Math.floor(Math.random() * stats.length)];
                                let upgradeAmount = 0;
                                if (statToUpgrade === 'atk') upgradeAmount = 2;
                                else if (statToUpgrade === 'def') upgradeAmount = 2;
                                else if (statToUpgrade === 'maxHp') upgradeAmount = 10;

                                char[statToUpgrade] += upgradeAmount;
                                flashCard(char, 'green');
                                log(`装置が作動し、${char.name}の${statToUpgrade === 'maxHp' ? '最大HP' : statToUpgrade === 'atk' ? '攻撃力' : '防御力'}が永続的に${upgradeAmount}上昇した！`);
                                dungeonCommands.classList.remove('hidden');
                            }, "強化するキャラを1人選んでください。");
                        };

                        deviceIgnoreButton.onclick = () => {
                            deviceModal.classList.add('hidden');
                            log("一行は怪しい装置を無視して、先へ進んだ。");
                        };
                    }

                    async function foundLiberatedSenses() {
                        const liberatedMembers = gameState.party.filter(p => p.currentHp > 0 && p.isLiberatedStripped);
                        if (liberatedMembers.length === 0) {
                            nothingHappened(); // 念の為のフォールバック
                            return;
                        }
                        const explorer = liberatedMembers[Math.floor(Math.random() * liberatedMembers.length)];

                        log(`${explorer.name}は解放されたことで五感が研ぎ澄まされている…`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log(`「…！この先に、何かいいものの気配がする！」`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                        const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                        addItemToInventory(foundItemId);
                        log(`${explorer.name}は気配を頼りに、とても珍しい「${itemBlueprints[foundItemId].name}」を見つけ出した！`);
                        flashCard(explorer, 'green');
                    }

                    function foundDivineTrial() {
                        log("目の前に荘厳な祭壇が現れ、神々しい声が響き渡る…\n「汝らに試練と、祝福を与えん…」");

                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length === 0) {
                            log("しかし、誰もいなかったため声は消えていった。");
                            return;
                        }

                        const target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                        const specialBlessings = ['fairy_grace', 'dragon_god_grace', 'swelling_body', 'twisted_memory'];
                        const chosenBlessingId = specialBlessings[Math.floor(Math.random() * specialBlessings.length)];
                        const chosenBlessing = blessings[chosenBlessingId];

                        setTimeout(() => {
                            log(`声は${target.name}を選び、その身に大いなる力を注ぎ込んだ！`);
                            chosenBlessing.effect(target);
                            flashCard(target, 'green');
                            log(`${target.name}は祝福「${chosenBlessing.name}」を授かった！`);
                            dungeonCommands.classList.remove('hidden');
                        }, 2000);
                    }


                    function foundWishingStar() {
                        log("壁に空いた穴から、綺麗な光が差し込んでいる…\n「あなたの願い事、聞いてあげる」という声が響いた。");

                        wishingStarCharSelect.innerHTML = '';
                        wishingStarOptions.innerHTML = '';
                        wishingStarCharSelect.classList.remove('hidden');
                        wishingStarOptions.classList.add('hidden');
                        wishingStarModalPrompt.textContent = '願い事をする仲間を一人選んでください。';

                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);

                        aliveParty.forEach(char => {
                            const card = document.createElement('div');
                            card.className = 'p-4 border rounded-lg cursor-pointer hover:bg-cyan-100 hover:shadow-lg transition';
                            card.innerHTML = `<p class="font-bold text-lg text-${char.themeColor}-700">${char.name}</p><p class="text-sm text-gray-600">${char.role}</p>`;
                            card.onclick = () => presentWishingStarChoices(char);
                            wishingStarCharSelect.appendChild(card);
                        });

                        wishingStarModal.classList.remove('hidden');
                    }

                    function presentWishingStarChoices(char) {
                        wishingStarCharSelect.classList.add('hidden');
                        wishingStarOptions.classList.remove('hidden');
                        wishingStarModalPrompt.textContent = `${char.name}は何を願いますか？`;

                        const immuneToStripRoles = ['ナイト', 'サムライ', '聖女', 'アンドロイド'];

                        const wishPool = [{
                            id: 'level_up',
                            text: '強くなりたい',
                            description: 'レベルが1上がる。',
                            effect: (c) => {
                                levelUpCharacter(c, false);
                                log(`${c.name}は星に願った…「強くなりたい！」`);
                            },
                            condition: (c) => true
                        }, {
                            id: 'full_recover',
                            text: '元気になりたい',
                            description: '全員のHPとMPが全回復する。',
                            effect: async(c) => {
                                log(`${c.name}は星に願った…「みんなが元気になりますように！」`);
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) {
                                        await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                        await animateStatChange(p, 'mp', p.maxMp, 'increase');
                                    }
                                }
                            },
                            condition: (c) => true
                        }, {
                            id: 'permanent_stats',
                            text: '装備を整えたい',
                            description: '攻撃力と防御力が永続的に2ずつ上がる。',
                            effect: (c) => {
                                c.atk += 2;
                                c.def += 2;
                                log(`${c.name}は星に願った…「もっといい装備が欲しい！」\n星の光が${c.name}の体を包み、力がみなぎる！`);
                            },
                            condition: (c) => true
                        }, {
                            id: 'become_doll',
                            text: 'お人形さんになりたい',
                            description: '身長が20cmになる。(身長固定は解除)',
                            effect: async(c) => {
                                c.heightLocked = false;
                                await animateStatChange(c, 'height', 20 - c.height, 'decrease');
                                log(`${c.name}は星に願った…「お人形さんみたいになりたい！」\n体が小さくなり、身長が20cmになった！`);
                            },
                            condition: (c) => true
                        }, {
                            id: 'grow_big',
                            text: '大きくなりたい',
                            description: '身長が2倍になる。',
                            effect: async(c) => {
                                await animateStatChange(c, 'height', c.height, 'increase');
                                log(`${c.name}は星に願った…「大きくなりたい！」\n体がぐんぐん伸びて、身長が2倍になった！`);
                            },
                            condition: (c) => c.height > c.initialHeight / 2 && !c.heightLocked
                        }, {
                            id: 'grow_reset',
                            text: '大きくなりたい',
                            description: '身長が初期身長まで戻る。',
                            effect: async(c) => {
                                const growth = c.initialHeight - c.height;
                                await animateStatChange(c, 'height', growth, 'increase');
                                log(`${c.name}は星に願った…「元の大きさに戻りたい！」\n体がぐんぐん伸びて、元の身長に戻った！`);
                            },
                            condition: (c) => c.height <= c.initialHeight / 2 && !c.heightLocked
                        }, {
                            id: 'liberate',
                            text: 'すべてさらけ出したい',
                            description: '解放状態になり、今後、服発見イベントが発生しなくなる。',
                            effect: (c) => {
                                c.statusEffects.stripped = {
                                    turns: 0
                                };
                                c.isLiberatedStripped = true;
                                gameState.wishingStarNoClothes = true;
                                log(`${c.name}は星に願った…「すべてをさらけ出したい！」\n${c.name}は自ら服を脱ぎ捨て、解放状態になった！`);
                                dungeonCommands.classList.remove('hidden');
                            },
                            condition: (c) => !immuneToStripRoles.includes(c.role) && !c.isLiberatedStripped
                        }, {
                            id: 'all_tiny',
                            text: '違う世界が見たい',
                            description: '全員の身長が1cmになる。',
                            effect: async(c) => {
                                log(`${c.name}は星に願った…「違う世界が見たい！」\n星の光がパーティを包み、全員の身長が1cmになった！`);
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) await animateStatChange(p, 'height', 1 - p.height, 'decrease');
                                }
                                dungeonCommands.classList.remove('hidden');
                            },
                            condition: (c) => !gameState.party.some(p => p.heightLocked)
                        }, {
                            id: 'get_supplies',
                            text: '強敵に備えたい',
                            description: 'ポーションx3, マナポーションx3, リバイブハーブx2を入手。',
                            effect: (c) => {
                                addItemToInventory('potion', 3);
                                addItemToInventory('mana_potion', 3);
                                addItemToInventory('revive_herb', 2);
                                dungeonCommands.classList.remove('hidden');
                                log(`${c.name}は星に願った…「強敵に備えたい！」\n足元に便利なアイテムがたくさん現れた！`);
                            },
                            condition: (c) => true
                        }, {
                            id: 'get_ale',
                            text: 'エールで乾杯したい',
                            description: 'ギガンテスエールをパーティの人数分入手する。',
                            effect: (c) => {
                                const count = gameState.party.filter(p => p.currentHp > 0).length;
                                addItemToInventory('gigantes_ale', count);
                                log(`${c.name}は星に願った…「みんなでエールで乾杯したい！」\n人数分のギガンテスエールを手に入れた！`);
                                dungeonCommands.classList.remove('hidden');
                            },
                            condition: (c) => true
                        }, {
                            id: 'get_crystals',
                            text: '英雄と手合わせ願いたい',
                            description: '聖結晶と邪結晶を1個ずつ入手する。',
                            effect: (c) => {
                                addItemToInventory('holy_crystal', 1);
                                addItemToInventory('evil_crystal', 1);
                                log(`${c.name}は星に願った…「英雄と手合わせ願いたい！」\n聖と邪、二つの結晶が目の前に現れた！`);
                                dungeonCommands.classList.remove('hidden');
                            },
                            condition: (c) => gameState.gameMode === 'endless'
                        }, {
                            id: 'hp_to_mp',
                            text: '魔力と一体化したい',
                            description: '最大HPが半分になり、その分最大MPが上昇する。',
                            effect: (c) => {
                                const hpLoss = Math.floor(c.maxHp / 2);
                                c.maxHp -= hpLoss;
                                c.currentHp = Math.min(c.currentHp, c.maxHp);
                                c.maxMp += hpLoss;
                                dungeonCommands.classList.remove('hidden');
                                log(`${c.name}は星に願った…「魔力と一体になりたい！」\n${c.name}の生命力が魔力に変換された！`);
                            },
                            condition: (c) => c.maxHp > 1
                        }, {
                            id: 'mp_to_hp',
                            text: '強靭な肉体を手にしたい',
                            description: '最大MPが半分になり、その分最大HPが上昇する。',
                            effect: (c) => {
                                const mpLoss = Math.floor(c.maxMp / 2);
                                c.maxMp -= mpLoss;
                                c.currentMp = Math.min(c.currentMp, c.maxMp);
                                c.maxHp += mpLoss;
                                dungeonCommands.classList.remove('hidden');
                                log(`${c.name}は星に願った…「強靭な肉体が欲しい！」\n${c.name}の魔力が生命力に変換された！`);
                            },
                            condition: (c) => c.maxMp > 1
                        }, {
                            id: 'get_blessing',
                            text: '才能が欲しい',
                            description: 'ランダムな祝福を一つ授かる。',
                            effect: (c) => {
                                const available = Object.values(blessings).filter(b => !Object.values(c.blessings).some(owned => owned.name === b.name));
                                if (available.length > 0) {
                                    const chosenBlessing = available[Math.floor(Math.random() * available.length)];
                                    chosenBlessing.effect(c);
                                    log(`${c.name}は星に願った…「新しい才能が欲しい！」\n${c.name}は祝福「${chosenBlessing.name}」を授かった！`);
                                } else {
                                    log(`${c.name}は既に全ての祝福を授かっていた！代わりにレベルが上がった！`);
                                    levelUpCharacter(c, false);
                                    dungeonCommands.classList.remove('hidden');
                                }
                            },
                            condition: (c) => true
                        }, {
                            id: 'fight_observer',
                            text: 'あなたを超える',
                            description: 'そこにメリットはない。',
                            effect: (c) => {
                                log(`${c.name}は星に願った…「お前を超えてやる！」\n声の主は不敵に笑い、姿を現した！`);
                                startBattle(true, 'star_observer');
                            },
                            condition: (c) => true
                        }, {
                            id: 'average_all_height',
                            text: 'みんなと同じになりたい',
                            description: 'パーティ全員の身長が平均化される。',
                            effect: async(c) => {
                                const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                                const totalHeight = aliveParty.reduce((sum, p) => sum + p.height, 0);
                                const avgHeight = Math.floor(totalHeight / aliveParty.length);
                                log(`${c.name}は星に願った…「みんなと同じになりたい！」\n星の光がパーティを包み、全員の身長が${avgHeight}cmになった！`);
                                for (const p of aliveParty) {
                                    const change = avgHeight - p.height;
                                    if (change !== 0) {
                                        await animateStatChange(p, 'height', change, change >= 0 ? 'increase' : 'decrease');
                                    }
                                    dungeonCommands.classList.remove('hidden');
                                }
                            },
                            condition: (c) => {
                                const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                                return aliveParty.length >= 2 && !aliveParty.some(p => p.heightLocked) && !aliveParty.every(p => p.height === aliveParty[0].height);
                            }
                        }, ];

                        const choices = [];
                        const availableWishes = wishPool.filter(w => w.condition(char));

                        while (choices.length < 4 && availableWishes.length > 0) {
                            const randomIndex = Math.floor(Math.random() * availableWishes.length);
                            const chosenWish = availableWishes.splice(randomIndex, 1)[0];
                            choices.push(chosenWish);
                        }

                        choices.forEach(wish => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg text-left';
                            button.innerHTML = `<strong class="text-lg">${wish.text}</strong><span class="block text-sm text-cyan-100 mt-1">${wish.description}</span>`;
                            button.onclick = async() => {
                                wishingStarModal.classList.add('hidden');
                                await wish.effect(char);
                                updatePartyStatus();
                                // dungeonCommands.classList.remove('hidden'); // 各effect内で個別に対応
                                dungeonCommands.classList.remove('hidden');
                            };
                            wishingStarOptions.appendChild(button);
                        });
                    }

                    function showTwoMemberSelectionModal(prompt, callback) {
                        twoMemberSelectList.innerHTML = '';
                        let selectedChars = [];

                        document.getElementById('two-member-select-title').textContent = prompt;
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);

                        aliveParty.forEach(char => {
                            const card = document.createElement('div');
                            card.className = 'p-4 border-2 border-gray-200 rounded-lg cursor-pointer hover:bg-gray-100 transition';
                            card.innerHTML = `<p class="font-bold text-lg">${char.name}</p><p class="text-sm text-gray-600">${char.role}</p>`;

                            card.addEventListener('click', () => {
                                const index = selectedChars.indexOf(char);
                                if (index > -1) {
                                    selectedChars.splice(index, 1);
                                    card.classList.remove('border-indigo-500', 'bg-indigo-50');
                                } else if (selectedChars.length < 2) {
                                    selectedChars.push(char);
                                    card.classList.add('border-indigo-500', 'bg-indigo-50');
                                }

                                const isReady = selectedChars.length === 2;
                                twoMemberSelectConfirm.disabled = !isReady;
                                twoMemberSelectConfirm.classList.toggle('opacity-50', !isReady);
                                twoMemberSelectConfirm.classList.toggle('cursor-not-allowed', !isReady);
                            });
                            twoMemberSelectList.appendChild(card);
                        });

                        twoMemberSelectConfirm.onclick = () => {
                            if (selectedChars.length === 2) {
                                twoMemberSelectModal.classList.add('hidden');
                                callback(selectedChars[0], selectedChars[1]);
                            }
                        };

                        twoMemberSelectModal.classList.remove('hidden');
                    }

                    function foundBewilderingStatue() {
                        log("一行は、怪しいオーラを放つ石像を見つけた…");
                        statueModal.classList.remove('hidden');

                        statueTouchButton.onclick = () => {
                            statueModal.classList.add('hidden');
                            showOneMemberSelectionModal(char => {
                                log(`${char.name}は、おそるおそる石像に触れた…！`);

                                const effects = [{
                                        type: 'atk_up',
                                        weight: 30
                                    }, {
                                        type: 'def_up',
                                        weight: 30
                                    }, {
                                        type: 'regen',
                                        weight: 30
                                    }, {
                                        type: 'level_up',
                                        weight: 5
                                    }, // 当たり (低確率)
                                    {
                                        type: 'shrink_to_one',
                                        weight: 5
                                    }, // ハズレ (低確率)
                                    {
                                        type: 'average_height',
                                        weight: 20
                                    } // ハズレ (低確率)
                                ];

                                const totalWeight = effects.reduce((sum, e) => sum + e.weight, 0);
                                let random = Math.random() * totalWeight;
                                let chosenEffect = null;

                                for (const effect of effects) {
                                    random -= effect.weight;
                                    if (random <= 0) {
                                        chosenEffect = effect.type;
                                        break;
                                    }
                                }

                                switch (chosenEffect) {
                                    case 'atk_up':
                                        char.buffs.atk_up = 10;
                                        flashCard(char, 'yellow');
                                        log(`石像が輝き、${char.name}の体に力がみなぎる！(10ターン攻撃力アップ)`);
                                        break;
                                    case 'def_up':
                                        char.buffs.protect = 10;
                                        flashCard(char, 'yellow');
                                        log(`石像が輝き、${char.name}の体が硬質化していく！(10ターン防御力アップ)`);
                                        break;
                                    case 'regen':
                                        char.statusEffects.regeneration = {
                                            turns: 10
                                        };
                                        flashCard(char, 'green');
                                        log(`石像が輝き、${char.name}の傷が癒え始めた！(10ターン自動回復)`);
                                        break;
                                    case 'level_up':
                                        log(`石像から溢れ出た光が${char.name}を包み込む！ なんとレベルアップした！`);
                                        levelUpCharacter(char, false);
                                        break;
                                    case 'shrink_to_one':
                                        if (char.heightLocked) {
                                            log(`石像は禍々しい光を放ったが、${char.name}の体は変化を拒んだ！`);
                                        } else {
                                            log(`石像が禍々しい光を放ち、${char.name}の体がみるみる縮んでいく！`);
                                            animateStatChange(char, 'height', 1 - char.height, 'decrease');
                                        }
                                        break;
                                    case 'average_height':
                                        {
                                            const otherMembers = gameState.party.filter(p => p !== char && p.currentHp > 0);
                                            if (otherMembers.length > 0) {
                                                const totalHeight = otherMembers.reduce((sum, p) => sum + p.height, 0);
                                                const avgHeight = Math.floor(totalHeight / otherMembers.length);
                                                const change = avgHeight - char.height;
                                                log(`石像のオーラが${char.name}を包み込み、仲間たちの平均身長になった！`);
                                                animateStatChange(char, 'height', change, change >= 0 ? 'increase' : 'decrease');
                                            } else {
                                                // 他にメンバーがいない場合
                                                const change = char.initialHeight - char.height;
                                                log(`石像のオーラが${char.name}を包み込み、元の身長に戻った！`);
                                                if (change !== 0) {
                                                    animateStatChange(char, 'height', change, change >= 0 ? 'increase' : 'decrease');
                                                }
                                            }
                                            break;
                                        }
                                }
                            });
                        };

                        statueLeaveButton.onclick = () => {
                            statueModal.classList.add('hidden');
                            log("一行は不気味な石像を無視して、先へ進んだ。");
                        };
                    }

                    function showOneMemberSelectionModal(callback, prompt = "対象を1人選んでください") {
                        oneMemberSelectList.innerHTML = '';
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);

                        document.getElementById('one-member-select-title').textContent = prompt;
                        aliveParty.forEach(char => {
                            const card = document.createElement('div');
                            card.className = 'p-4 border-2 border-gray-200 rounded-lg cursor-pointer hover:bg-indigo-100 transition';
                            card.innerHTML = `<p class="font-bold text-lg">${char.name}</p><p class="text-sm text-gray-600">${char.role}</p>`;

                            card.addEventListener('click', () => {
                                oneMemberSelectModal.classList.add('hidden');
                                callback(char);
                            });
                            oneMemberSelectList.appendChild(card);
                        });

                        oneMemberSelectModal.classList.remove('hidden');
                    }

                    async function foundShamePillory() {
                        log("部屋の中央に、一枚の透明なガラス板が立っている…");
                        const strippedMembersCheck = gameState.party.filter(p => p.currentHp > 0 && p.statusEffects.stripped);
                        if (strippedMembersCheck.length === 0) {
                            // 対象がいない場合は別のイベントを再抽選
                            triggerRandomEvent();
                            return;
                        }

                        await new Promise(resolve => setTimeout(resolve, 1500));
                        const strippedMembers = gameState.party.filter(p => p.currentHp > 0 && p.statusEffects.stripped);
                        const victim = strippedMembers[Math.floor(Math.random() * strippedMembers.length)];

                        log(`突然、床から現れた無数の触手が、${victim.name}に絡みついた！`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        log(`${victim.name}は抵抗する間もなく、ガラス板に強く押し付けられてしまった！`);
                        flashCard(victim, 'red');
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        // ?. 演算子が使えない環境のための代替コード
                        let conversationLine = "いやっ…！離して…！"; // デフォルト値を先に設定
                        const victimConvos = conversations[victim.name];
                        if (victimConvos && victimConvos.shame_pillory && victimConvos.shame_pillory.length > 0) {
                            const lines = victimConvos.shame_pillory;
                            conversationLine = lines[Math.floor(Math.random() * lines.length)];
                        }

                        log(`${victim.name}「${conversationLine}」`);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        log(`${victim.name}は羞恥心から精神が乱れ、弱ってしまった…`);
                        victim.buffs.def_down = 3; // 3ターン防御力ダウン
                        const mpLoss = Math.ceil(victim.maxMp * 0.3);
                        dungeonCommands.classList.remove('hidden');
                        await animateStatChange(victim, 'mp', -mpLoss, 'decrease');

                        log(`(${victim.name}の防御力が下がり、MPが${mpLoss}減少した)`);
                    }

                    async function foundShrineOfPrayer() {
                        log("一行は、静かで神聖な空気が漂う小さなほこらを見つけた。");
                        await new Promise(resolve => setTimeout(resolve, 1500));

                        const prayer = getRandomPartyMember();
                        log(`${prayer.name}が代表して、静かに祈りを捧げた…`);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        let message = '';
                        switch (prayer.role) {
                            case 'ファイター':
                            case 'サムライ':
                            case 'モンク':
                                message = "戦いの神が応え、全員の体に力がみなぎる！(3ターン攻撃力アップ)";
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) p.buffs.atk_up = 3;
                                });
                                break;
                            case 'ナイト':
                            case 'ガーディアン':
                                message = "守護の神が応え、全員の体が硬質化していく！(3ターン防御力アップ)";
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) p.buffs.protect = 3;
                                });
                                break;
                            case 'ソーサラー':
                            case 'アルケミスト':
                            case 'ネクロマンサー':
                                message = "魔力の源が共鳴し、全員のMPが少し回復した！";
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) await animateStatChange(p, 'mp', Math.ceil(p.maxMp * 0.3), 'increase');
                                }
                                break;
                            case 'メディック':
                            case 'ドクター':
                                message = "癒やしの女神が微笑み、全員の傷が癒えた！";
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.3), 'increase');
                                }
                                break;
                            case 'ダンサー':
                            case 'ギャンブラー':
                                message = "幸運の女神が微笑み、全員の足取りが軽くなった！(3ターン素早さアップ)";
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) p.buffs.agi_up = 3;
                                });
                                break;
                            case 'リーパー':
                            case 'サモナー':
                                message = "精霊たちが集まり、贈り物を置いていった！";
                                addItemToInventory('potion', 2);
                                addItemToInventory('mana_potion', 1);
                                message += " (ポーションx2、マナポーションx1 を手に入れた)";
                                break;
                            case 'トラブルメーカー':
                                message = "コハルの祈りが天に通じたのか、なぜかレアなアイテムが見つかった！";
                                const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                                addItemToInventory(foundItemId);
                                message += ` (${itemBlueprints[foundItemId].name} を手に入れた)`;
                                break;
                            case 'シスター':
                                message = "慈愛の祈りが届き、全員に再生の祝福が与えられた！(3ターン自動回復)";
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) p.statusEffects.regeneration = {
                                        turns: 3
                                    };
                                });
                                break;
                            case '聖女':
                                message = "聖なる祈りがほこらを光で満たし、全員のHPとMPが完全に回復した！";
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) {
                                        await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                        await animateStatChange(p, 'mp', p.maxMp, 'increase');
                                    }
                                }
                                break;
                            case 'トレジャーハンター':
                            case 'サキュバス':
                            case 'フェアリー':
                            case 'アルラウネ':
                                message = "お宝探しの勘が働き、ほこらの隠し場所から珍しいアイテムを見つけた！";
                                let foundItemIdForHunter;
                                if (prayer.isTransformed) {
                                    if (prayer.role === 'サキュバス') {
                                        foundItemIdForHunter = 'gigantes_ale';
                                    } else if (prayer.role === 'フェアリー') {
                                        foundItemIdForHunter = 'mana_element';
                                    } else if (prayer.role === 'アルラウネ') {
                                        foundItemIdForHunter = 'heart_element';
                                    }
                                } else {
                                    // 変身していない場合はランダムなレアアイテム
                                    const rareItemIdsForHunter = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                    foundItemIdForHunter = rareItemIdsForHunter[Math.floor(Math.random() * rareItemIdsForHunter.length)];
                                }
                                addItemToInventory(foundItemIdForHunter);
                                message += ` (${itemBlueprints[foundItemIdForHunter].name} を手に入れた)`;
                                break;
                            case 'アンドロイド':
                                message = "アンドロイドの祈りが、ほこらのシステムに共鳴する！";
                                await new Promise(resolve => setTimeout(resolve, 1500));
                                message += " システムが最適化され、全員のMPが少し回復した！";
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) await animateStatChange(p, 'mp', Math.ceil(p.maxMp * 0.3), 'increase');
                                }
                                break;
                            case 'メイド':
                                message = "フローラの清らかな祈りに応え、ほこらの周りに可憐な花が咲き乱れた！";
                                await new Promise(resolve => setTimeout(resolve, 1500));
                                message += " 花々の癒やしの香りで、全員のHPが少し回復した！";
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.3), 'increase');
                                }
                                break;
                        }
                        log(message);
                        gameState.party.forEach(p => {
                            if (p.currentHp > 0) flashCard(p, 'green');
                        });
                    }

                    function getRandomPartyMember(aliveOnly = true) {
                        const available = aliveOnly ? gameState.party.filter(p => p.currentHp > 0) : gameState.party;
                        return available[Math.floor(Math.random() * available.length)];
                    }

                    function startBattle(isBoss = false, isEnhancedBoss = false, specialEnemyType = null, enemyCountOverride = null) {
                        log(isBoss ? "ボスの気配がする…！" : "敵が現れた！");
                        gameState.inBattle = true;
                        dungeonCommands.classList.add('hidden');
                        emergencyButton.classList.add('battle-active'); // 緊急ボタンを有効化
                        // 模倣の呪いチェック
                        if (gameState.nextBattleIsImitation) {
                            startImitationBattle();
                            gameState.nextBattleIsImitation = false; // フラグをリセット // ファイター, ソーサラー, ナイト, メディック
                            return;
                        } else if (isBoss && isEnhancedBoss === 'star_observer') {
                            startBattle(true, 'star_observer');
                            return;
                        }
                        floorDisplay.classList.add('hidden');
                        gameState.golem = null; // 戦闘開始時にゴーレムをリセット
                        battleCommands.classList.remove('hidden');

                        // 敵の数を計算（サマータイム・スペシャルライブ！では最大3体）
                        let maxEnemyCount = gameState.party.length + 2; // 味方の数 + 2 を上限とする
                        if (gameState.gameMode === 'summer_live') maxEnemyCount = 3;
                        const baseEnemyCount = Math.floor(Math.random() * 2) + 1 + Math.floor(gameState.floor / 10); // 敵の数を計算
                        let enemyCount = enemyCountOverride ? enemyCountOverride : (isBoss ? 1 : Math.min(baseEnemyCount, maxEnemyCount));
                        if (gameState.gameMode === 'secret_night') {
                            enemyCount = 1; // ヒミツの夜モードでは敵は常に1体
                        }

                        gameState.enemies = [];
                        if (isBoss && isEnhancedBoss === 'phantom_hero') {
                            gameState.enemies.push(createEnemy(true, 'phantom_hero'));
                        } else {
                            for (let i = 0; i < enemyCount; i++) gameState.enemies.push(createEnemy(isBoss, isEnhancedBoss, specialEnemyType));
                        }
                        updateEnemyStatus();

                        const combatants = [...gameState.party.filter(p => p.currentHp > 0), ...gameState.enemies];
                        gameState.turnOrder = combatants.sort((a, b) => {
                            const agiA = a.isEnemy ? a.agi : getEffectiveStats(a).agi;
                            const agiB = b.isEnemy ? b.agi : getEffectiveStats(b).agi;
                            return agiB - agiA;
                        });
                        gameState.currentTurnIndex = 0;

                        setTimeout(() => {
                            nextTurn();
                        }, 1000); // メッセージ表示のための待機
                    }

                    function startImitationBattle() {
                        log("不気味な気配と共に、見慣れた姿の敵が現れた！");
                        gameState.inBattle = true;
                        dungeonCommands.classList.add('hidden');
                        emergencyButton.classList.add('battle-active');
                        floorDisplay.classList.add('hidden');
                        gameState.golem = null;
                        battleCommands.classList.remove('hidden');

                        gameState.enemies = [createImitationEnemy()];
                        updateEnemyStatus();

                        const combatants = [...gameState.party.filter(p => p.currentHp > 0), ...gameState.enemies];
                        gameState.turnOrder = combatants.sort((a, b) => {
                            const agiA = a.isEnemy ? a.agi : getEffectiveStats(a).agi;
                            const agiB = b.isEnemy ? b.agi : getEffectiveStats(b).agi;
                            return agiB - agiA;
                        });
                        gameState.currentTurnIndex = 0;

                        setTimeout(() => {
                            nextTurn();
                        }, 1000);
                    }

                    function createImitationEnemy() {
                        const floor = gameState.floor;
                        const nonUnlockableRoles = ['聖女', 'トレジャーハンター', 'アンドロイド', 'メイド'];
                        const targetBlueprints = allCharacterBlueprints.filter(c => !nonUnlockableRoles.includes(c.role));
                        const blueprint = targetBlueprints[Math.floor(Math.random() * targetBlueprints.length)];

                        const imitation = {
                            name: `模倣体：${blueprint.name}`,
                            maxHp: 1000 + floor * 25,
                            currentHp: 1000 + floor * 25,
                            atk: 35 + Math.floor(floor * 1.5),
                            pDef: 20 + floor,
                            mDef: 20 + floor,
                            agi: 15 + Math.floor(floor / 2),
                            isEnemy: true,
                            isBoss: true, // ボス扱い
                            buffs: {},
                            statusEffects: {},
                            skills: blueprint.skills.map(s => ({...s,
                                originalType: s.type
                            })), // 元のスキル情報を保持
                            specialAIType: 'imitation',
                            originalBlueprint: blueprint, // AIで参照するために元のブループリントを保持
                        };
                        return imitation;
                    }

                    function createEnemy(isBoss, isEnhanced = false, specialEnemyType = null) {
                        let floor = gameState.floor;

                        // パーティ人数による敵ステータスの補正計算 (1人減るごとに10%低下)
                        // 終焉モードでは敵のステータス補正を2倍にする
                        if (gameState.gameMode === 'endgame_plus') {
                            floor *= 2;
                        }

                        const partySize = gameState.party.length;
                        const reductionFactor = Math.max(0, (4 - partySize) * 0.1);
                        let statMultiplier = 1 - reductionFactor;

                        // サマータイム・スペシャルライブ！モードでのフロア補正
                        if (gameState.gameMode === 'summer_live') {
                            // ボス階層の判定を正しく行うため、gameState.floorを直接参照する
                            // 通常敵の強さ調整は、この後の処理で行う
                            floor = gameState.floor;
                        }

                        // ヒミツの夜モードでの敵ステータス弱体化
                        if (gameState.gameMode === 'secret_night') {
                            statMultiplier *= 0.3;
                        }

                        if (isBoss && isEnhanced === 'phantom_hero') {
                            return {
                                name: '英雄の幻影', // ファイター, ソーサラー, ナイト, メディック
                                maxHp: 2000 + floor * 30,
                                currentHp: 2000 + floor * 30,
                                atk: 50 + Math.floor(floor * 1.8),
                                pDef: 25 + floor,
                                mDef: 25 + floor,
                                agi: 25 + Math.floor(floor / 2),
                                height: 180,
                                buffs: {},
                                isEnemy: true,
                                isBoss: true,
                                statusEffects: {},
                                skills: [{
                                    name: 'フォーカス',
                                    func: focusSkill
                                }, {
                                    name: 'チェインロック',
                                    func: chainLockSkill
                                }, {
                                    name: 'ヒロイックエンド',
                                    func: heroicEndSkill
                                }, ],
                                specialAIType: 'phantom_hero'
                            };
                        }
                        if (isBoss && isEnhanced === 'star_observer') {
                            return {
                                name: '星の観測者',
                                maxHp: 1500 + floor * 25,
                                currentHp: 1500 + floor * 25,
                                atk: 45 + Math.floor(floor * 1.6),
                                pDef: 22 + floor,
                                mDef: 22 + floor,
                                agi: 28 + Math.floor(floor / 2),
                                height: 500, // 巨大な存在
                                isEnemy: true,
                                isBoss: true,
                                buffs: {},
                                statusEffects: {},
                                specialAIType: 'star_observer',
                                turnCount: 0, // ターンカウントを追加
                                skills: [ // スキルを追加
                                    {
                                        name: '瞬き',
                                        func: blinkSkill
                                    }, {
                                        name: 'ブラックホール',
                                        func: blackholeSkill
                                    }
                                ]
                            };
                        }
                        if (isBoss && gameState.gameMode === 'endgame_plus' && gameState.floor === 90) {
                            return {
                                name: '終刻の魔王',
                                maxHp: 9999,
                                currentHp: 9999,
                                atk: 80 + Math.floor(floor * 2.0),
                                pDef: 50 + floor,
                                mDef: 50 + floor,
                                agi: 35 + Math.floor(floor / 2),
                                height: 9999, // 計測不能
                                buffs: {},
                                isEnemy: true,
                                isBoss: true,
                                statusEffects: {},
                                skills: [{
                                    name: '終末の宣告',
                                    func: finalBossSkill
                                }],
                                specialAIType: 'final_boss'
                            };
                        }

                        if (isBoss) {
                            if (isEnhanced) {
                                return {
                                    name: '【覚醒】ダンジョンマスター',
                                    maxHp: 1200 + floor * 20,
                                    currentHp: 1200 + floor * 20,
                                    atk: 40 + Math.floor(floor * 1.5),
                                    pDef: 30 + Math.floor(floor * 1.0),
                                    mDef: 20 + Math.floor(floor * 1.0),
                                    agi: 20,
                                    height: 250,
                                    isEnemy: true,
                                    buffs: {},
                                    statusEffects: {},
                                    skills: [{
                                        name: 'フォーカス',
                                        func: focusSkill
                                    }, {
                                        name: 'チェインロック',
                                        func: chainLockSkill
                                    }, {
                                        name: 'カタストロフィ',
                                        func: sweepAttack,
                                        type: 'physical'
                                    }, {
                                        name: '縮小ビーム',
                                        func: shrinkBeam,
                                        type: 'utility'
                                    }, ],
                                    usedFocus: false, // フォーカス使用フラグ
                                    usedHeroicEnd: false, // ヒロイックエンド使用フラグ
                                };
                            }
                            const bossBlueprints = [{
                                name: 'ダンジョンマスター',
                                maxHp: 750,
                                atk: 30,
                                pDef: 25,
                                mDef: 15,
                                agi: 15,
                                height: 200,
                                skills: [{
                                    name: '縮小ビーム',
                                    func: shrinkBeam,
                                    type: 'utility'
                                }, {
                                    name: 'なぎ払い',
                                    func: sweepAttack,
                                    type: 'physical'
                                }, ]
                            }, {
                                name: 'カオスゴーレム',
                                maxHp: 900,
                                atk: 35,
                                pDef: 35,
                                mDef: 5,
                                agi: 10,
                                height: 300,
                                skills: [{
                                    name: '状態異常攻撃',
                                    func: inflictStatusEffect,
                                    type: 'utility'
                                }, {
                                    name: 'なぎ払い',
                                    func: sweepAttack,
                                    type: 'physical'
                                }, ]
                            }, {
                                name: 'アークリッチ',
                                maxHp: 900, // HPを50%増加
                                atk: 25,
                                pDef: 10,
                                mDef: 30,
                                agi: 20,
                                height: 180,
                                skills: [{
                                    name: 'いたずら',
                                    type: 'utility'
                                }, ]
                            }];
                            const blueprint = bossBlueprints[Math.floor(Math.random() * bossBlueprints.length)];
                            const boss = {
                                ...blueprint,
                                isEnemy: true,
                                isBoss: true,
                                turnCount: 0, // ターンカウント用
                                buffs: {},
                                statusEffects: {},
                                regenUses: 0, // 自己再生の使用回数カウンター 
                            };

                            // ステータスに補正を適用
                            boss.maxHp = Math.ceil((boss.maxHp + floor * 15) * statMultiplier);
                            boss.currentHp = boss.maxHp;
                            boss.atk = Math.ceil((boss.atk + Math.ceil(floor * 1.2)) * statMultiplier);
                            boss.pDef = Math.ceil((boss.pDef + Math.ceil(floor * 0.8)) * statMultiplier);
                            boss.mDef = Math.ceil((boss.mDef + Math.ceil(floor * 0.8)) * statMultiplier);

                            // サマータイム・スペシャルライブ！モードでのボス弱体化
                            if (gameState.gameMode === 'summer_live') {
                                boss.maxHp = Math.ceil(boss.maxHp * 0.8); // HPを20%削減
                                // 通常敵の強さ調整と同様に、フロア補正をここで行う
                                const summerFloor = Math.floor(gameState.floor * 0.6);
                                boss.maxHp = Math.ceil((boss.maxHp + summerFloor * 15) * statMultiplier);
                                boss.atk = Math.ceil((boss.atk + Math.ceil(summerFloor * 1.2)) * statMultiplier);

                                boss.currentHp = boss.maxHp;
                                boss.atk = Math.ceil(boss.atk * 0.85); // 攻撃力を15%削減
                            }
                            // agiは補正対象外

                            // サマータイム・スペシャルライブ！の専用ボス
                            // ボスのサイズバリエーション
                            if (gameState.floor >= 16) {
                                const variantRoll = Math.random();
                                if (variantRoll < 0.1) { // 10%で巨大化
                                    boss.name = `【巨体の】${boss.name}`;
                                    boss.height = Math.ceil(boss.height * 1.5);
                                    boss.atk = Math.ceil(boss.atk * 1.2);
                                    boss.pDef = Math.ceil(boss.pDef * 1.2);
                                    boss.mDef = Math.ceil(boss.mDef * 1.2);
                                    boss.agi = Math.ceil(boss.agi * 0.8);
                                } else if (variantRoll < 0.2) { // 10%で縮小化
                                    boss.name = `【幼体】${boss.name}`;
                                    boss.height = Math.ceil(boss.height * 0.5);
                                    boss.atk = Math.ceil(boss.atk * 0.8);
                                    boss.pDef = Math.ceil(boss.pDef * 0.8);
                                    boss.mDef = Math.ceil(boss.mDef * 0.8);
                                    boss.agi = Math.ceil(boss.agi * 1.2);
                                }
                            }
                            if (gameState.gameMode === 'summer_live') {
                                if (floor === 30) {
                                    boss.name = 'ビーチシャーク';
                                    boss.maxHp = Math.ceil(800 * statMultiplier);
                                    boss.currentHp = boss.maxHp;
                                    boss.atk = Math.ceil(32 * statMultiplier);
                                    boss.pDef = Math.ceil((25 + Math.floor(floor * 0.6) * 0.8) * 3.0 * statMultiplier); // 物理防御が極端に高い
                                    boss.mDef = Math.ceil(Math.max(1, (15 + Math.floor(floor * 0.6) * 0.8) * 0.1) * statMultiplier); // 魔法防御が非常に低い
                                    boss.agi = 18;
                                    boss.height = 250,
                                        boss.skills = []; // スキルなし
                                } else if (floor === 60) {
                                    boss.name = 'アクアドラゴン';
                                    boss.maxHp = Math.ceil(1500 * statMultiplier);
                                    boss.currentHp = boss.maxHp;
                                    boss.atk = Math.ceil(45 * statMultiplier);
                                    boss.pDef = Math.ceil((30 + Math.floor(floor * 0.6) * 1.0) * 0.5 * statMultiplier); // 物理防御が低い
                                    boss.mDef = Math.ceil((20 + Math.floor(floor * 0.6) * 1.0) * 1.0 * statMultiplier);
                                    boss.agi = 22;
                                    boss.height = 800,
                                        boss.skills = [{
                                            name: 'ミニマムシャワー',
                                            func: minimumShower
                                        }];
                                    boss.specialAIType = 'aqua_dragon'; // 特殊AIタイプを設定
                                }
                            }

                            // 終焉モードの固定ボス
                            if (gameState.gameMode === 'endgame_plus') {
                                if (floor === 30) {
                                    return createEnemy(true, 'phantom_hero');
                                } else if (floor === 60) {
                                    return createEnemy(true, 'star_observer');
                                } else if (floor === 90) {
                                    // 終刻の魔王は上で定義済み
                                }
                            }

                            return boss;
                        }
                        const enemyBlueprints = [{
                                name: 'スライム',
                                pDefRatio: 0.8, // 物理に弱く、魔法に強い
                                mDefRatio: 1.2,
                                baseAgi: 14, // 普通
                                height: 50
                            }, // 物理に弱く、魔法に強い
                            {
                                name: 'ゴブリン',
                                pDefRatio: 1.2, // 物理に強く、魔法に弱い
                                mDefRatio: 0.8,
                                baseAgi: 8, // 遅い
                                height: 100
                            }, // 物理に強く、魔法に弱い
                            {
                                name: 'コウモリ',
                                pDefRatio: 1.0, // 平均的
                                mDefRatio: 1.0,
                                baseAgi: 20, // 速い
                                height: 30
                            }, // 平均的
                            {
                                name: 'スケルトン',
                                pDefRatio: 1.5, // 物理にとても強く、魔法にとても弱い
                                mDefRatio: 0.5,
                                baseAgi: 9, // 遅い
                                height: 170
                            }, // 物理にとても強く、魔法にとても弱い
                            {
                                name: 'ウィスプ',
                                pDefRatio: 0.7, // 状態異常を使う
                                mDefRatio: 1.5,
                                baseAgi: 22, // 速い
                                height: 40
                            }, // 状態異常を使う
                            {
                                name: 'リトルメイジ',
                                pDefRatio: 0.8,
                                mDefRatio: 1.2,
                                baseAgi: 15, // 普通
                                height: 120
                            }, {
                                name: 'インプ',
                                pDefRatio: 0.9,
                                mDefRatio: 1.1,
                                baseAgi: 18, // 速い
                                height: 80
                            }, {
                                name: 'リトルデーモン',
                                pDefRatio: 1.1,
                                mDefRatio: 1.1,
                                baseAgi: 16, // 少し速め
                                height: 60,
                                skills: [{
                                    name: 'ミニマムレイ',
                                    func: shrinkToOneSkill
                                }]
                            },
                        ];

                        let availableBlueprints = enemyBlueprints;
                        // 5階の戦闘ではスキルを持たない敵のみ出現させる
                        if (floor === 5) {
                            availableBlueprints = enemyBlueprints.filter(bp => bp.name !== 'ウィスプ' && bp.name !== 'リトルメイジ' && bp.name !== 'インプ');
                        }
                        const blueprint = availableBlueprints[Math.floor(Math.random() * availableBlueprints.length)];
                        const baseDef = 5 + floor * 0.8;
                        // 敵の素早さに揺らぎを追加
                        const agiFluctuation = Math.floor(Math.random() * 5) - 2; // -2から+2の揺らぎ
                        const finalAgi = Math.max(1, blueprint.baseAgi + agiFluctuation);

                        // ステータスに補正を適用
                        const finalMaxHp = Math.ceil((45 + Math.ceil(floor * 8)) * statMultiplier);
                        const finalAtk = Math.ceil((10 + Math.ceil(floor * 1.2)) * statMultiplier);
                        const finalPDef = Math.ceil(Math.max(1, Math.ceil(baseDef * blueprint.pDefRatio)) * statMultiplier);
                        const finalMDef = Math.ceil(Math.max(1, Math.ceil(baseDef * blueprint.mDefRatio)) * statMultiplier);

                        // サマータイム・スペシャルライブ！モードでの通常敵の強さ調整
                        if (gameState.gameMode === 'summer_live') {
                            floor = Math.floor(gameState.floor * 0.6);
                        }

                        const enemy = {
                            name: blueprint.name,
                            maxHp: finalMaxHp,
                            currentHp: finalMaxHp,
                            atk: finalAtk,
                            pDef: finalPDef,
                            mDef: finalMDef,
                            agi: finalAgi,
                            height: blueprint.height,
                            isEnemy: true,
                            buffs: {},
                            skills: (blueprint.name === 'ウィスプ') ? [{
                                    name: '状態異常攻撃',
                                    func: inflictStatusEffect
                                }] :
                                (blueprint.name === 'リトルメイジ') ? [{
                                    name: '縮小ビーム',
                                    func: shrinkBeam
                                }] :
                                (blueprint.name === 'インプ') ? [{
                                    name: 'いたずら' // funcはenemyTurnで直接処理
                                }] : [],
                            statusEffects: {},
                            // インプ専用フラグ
                            mischiefUsed: false,
                            focusedTargetId: null,
                        };

                        // 16階以降でサイズバリエーションを追加
                        if (gameState.floor >= 16) {
                            const variantRoll = Math.random() * 100; // 0-100の乱数
                            if (variantRoll < 5) { // 5%
                                enemy.name = `【狂暴な】${enemy.name}`;
                                enemy.atk = Math.ceil(enemy.atk * 1.5);
                                enemy.pDef = Math.ceil(enemy.pDef * 0.7);
                                enemy.mDef = Math.ceil(enemy.mDef * 0.7);
                            } else if (variantRoll < 10) { // 5%
                                enemy.name = `【堅牢な】${enemy.name}`;
                                enemy.pDef = Math.ceil(enemy.pDef * 1.5);
                                enemy.mDef = Math.ceil(enemy.mDef * 1.5);
                                enemy.agi = Math.ceil(enemy.agi * 0.7);
                            } else if (variantRoll < 15) { // 5%
                                enemy.name = `【俊敏な】${enemy.name}`;
                                enemy.agi = Math.ceil(enemy.agi * 1.5);
                                enemy.atk = Math.ceil(enemy.atk * 0.7);
                            } else if (variantRoll < 20) { // 5%
                                enemy.name = `【毒纏い】${enemy.name}`;
                                // 特殊能力は enemyTurn で処理
                            } else if (variantRoll < 25) { // 5%
                                enemy.name = `【痺れる】${enemy.name}`;
                                // 特殊能力は enemyTurn で処理
                            } else if (variantRoll < 30) { // 5%
                                enemy.name = `【輝く】${enemy.name}`;
                                enemy.atk = Math.ceil(enemy.atk * 1.1);
                                enemy.pDef = Math.ceil(enemy.pDef * 1.1);
                                enemy.mDef = Math.ceil(enemy.mDef * 1.1);
                                enemy.agi = Math.ceil(enemy.agi * 1.1);
                                enemy.maxHp = Math.ceil(enemy.maxHp * 0.7);
                                enemy.currentHp = enemy.maxHp;
                            } else if (variantRoll < 35) { // 5%
                                enemy.name = `【巨大な】${enemy.name}`;
                                enemy.height = Math.ceil(enemy.height * 1.5);
                                enemy.atk = Math.ceil(enemy.atk * 1.2);
                                enemy.pDef = Math.ceil(enemy.pDef * 1.2);
                                enemy.mDef = Math.ceil(enemy.mDef * 1.2);
                                enemy.agi = Math.ceil(enemy.agi * 0.8);
                            } else if (variantRoll < 40) { // 5%
                                enemy.name = `【小さな】${enemy.name}`;
                                enemy.height = Math.ceil(enemy.height * 0.5);
                                enemy.atk = Math.ceil(enemy.atk * 0.8);
                                enemy.pDef = Math.ceil(enemy.pDef * 0.8);
                                enemy.mDef = Math.ceil(enemy.mDef * 0.8);
                                enemy.agi = Math.ceil(enemy.agi * 1.2);
                            }
                        }
                        return enemy;
                    }

                    // createEnemy の直後に配置
                    function applyMicroModification(enemy) {
                        enemy.name = `【ミクロ】${enemy.name}`;
                        enemy.atk = Math.max(1, Math.ceil(enemy.atk * 0.1));
                        enemy.pDef = Math.max(1, Math.ceil(enemy.pDef * 0.1));
                        enemy.mDef = Math.max(1, Math.ceil(enemy.mDef * 0.1));
                        enemy.agi = Math.ceil(enemy.agi * 3);
                        enemy.height = 1;
                    }

                    function shrinkBeam(enemy) {
                        const target = findTarget(enemy);
                        let shrinkAmount = Math.ceil(Math.random() * 10) + 5;
                        // 挑発中の相手には効果半減
                        if (target.buffs && target.buffs.provoke) {
                            shrinkAmount = Math.ceil(shrinkAmount / 2);
                            log(`${target.name}は挑発でビームの威力を弱めた！`);
                        }
                        animateStatChange(target, 'height', -shrinkAmount, 'decrease');
                        flashCard(target, 'yellow', 'enemy');
                        log(`${enemy.name}は${target.name}に縮小ビームを放った！身長が${shrinkAmount}cm縮んだ！`);
                        updatePartyStatus();
                    }

                    function focusSkill(enemy) {
                        enemy.buffs = enemy.buffs || {};
                        enemy.buffs.atk_up = 3;
                        flashCard(enemy, 'yellow');
                        log(`${enemy.name}は${enemy.skills[0].name}で精神を集中！攻撃力が大幅に上昇！`);
                    }

                    async function chainLockSkill(enemy) {
                        // 龍神の加護チェック (全体)
                        if (gameState.party.every(p => p.blessings && p.blessings.dragon_god_grace && p.height > 1000)) {
                            log(`${enemy.name}はチェインロックを放ったが、龍神の加護によって全員が鎖を弾き返した！`);
                            return;
                        }

                        const target = findTarget(enemy);
                        if (target.isWall || target === gameState.golem) {
                            log(`${enemy.name}はチェインロックを放ったが、無機物には効果がなかった！`);
                            return;
                        }
                        log(`${enemy.name}は${enemy.skills[1].name}を放った！`);
                        for (const target of gameState.party.filter(p => p.currentHp > 0)) {
                            if (target.blessings && target.blessings.dragon_god_grace && target.height > 1000) {
                                log(`${target.name}は龍神の加護によって鎖を弾き返した！`);
                                continue;
                            }
                            if (Math.random() < 0.5) { // 50%の確率で鈍化
                                target.statusEffects.slow = {
                                    turns: 3
                                };
                                log(`${target.name}は鎖に捕らえられ、動きが鈍くなった！`);
                            }
                        }
                    }

                    async function inflictStripped(enemy, target) {
                        // 対象がナイト、サムライ、聖女、または防御中の場合、スキルは失敗
                        // 龍神の加護チェック
                        if (target.blessings && target.blessings.dragon_god_grace && target.height > 1000) {
                            log(`${enemy.name}は${target.name}にいたずらを仕掛けたが、龍神の加護によって防がれた！`);
                            return false;
                        }

                        const immuneRoles = ['ナイト', 'サムライ', '聖女', 'アンドロイド'];
                        if (immuneRoles.includes(target.role) || target.isDefending || target.isWall || target === gameState.golem) {
                            const targetDisplayName = target.isWall ? '防壁' : target.name;
                            log(`${enemy.name}は${targetDisplayName}にいたずらを仕掛けたが、効果がなかった！`);
                            return false; // 行動しなかったことを示す
                        }

                        // 成功率の計算 (小さいほど成功しやすい)
                        let successRate = 0.1; // 基本成功率10%
                        const heightDiff = target.initialHeight - target.height;
                        enemy.mischiefUsed = true; // スキル使用済みフラグを立てる

                        if (heightDiff > 0) {
                            // 初期身長からどれだけ小さいかの割合に応じて成功率アップ
                            successRate += (heightDiff / target.initialHeight) * 0.2;
                        }
                        successRate = Math.min(0.3, successRate); // 上限30%

                        if (Math.random() < successRate) {
                            // 成功
                            target.statusEffects.stripped = {
                                turns: 0
                            };
                            enemy.focusedTargetId = gameState.party.indexOf(target); // ターゲットを固定
                            flashCard(target, 'yellow');
                            log(`${enemy.name}のいたずらが成功！ ${target.name}は恥ずかしい格好になってしまった！`);
                            log(`${enemy.name}は${target.name}に執着し始めたようだ…`);
                        } else {
                            // 失敗
                            log(`${enemy.name}はいたずらを仕掛けたが、${target.name}には通用しなかった！`);
                        }
                        updatePartyStatus();
                        return true; // 行動したことを示す
                    }

                    async function inflictStrippedForArchlich(enemy, target) {
                        // 対象がナイト、サムライ、聖女、または防御中の場合、スキルは失敗
                        // 龍神の加護チェック
                        if (target.blessings && target.blessings.dragon_god_grace && target.height > 1000) {
                            log(`${enemy.name}は${target.name}にいたずらを仕掛けたが、龍神の加護によって防がれた！`);
                            return;
                        }

                        const immuneRoles = ['ナイト', 'サムライ', '聖女', 'アンドロイド'];
                        if (immuneRoles.includes(target.role) || target.isDefending || target.isWall || target === gameState.golem) {
                            const targetDisplayName = target.isWall ? '防壁' : target.name;
                            log(`${enemy.name}は${targetDisplayName}にいたずらを仕掛けたが、効果がなかった！`);
                            return; // 何もせずターン終了
                        }

                        // 成功率の計算 (小さいほど成功しやすい、最大50%)
                        let successRate = 0.2; // 基本成功率20%
                        const heightDiff = target.initialHeight - target.height;
                        if (heightDiff > 0) {
                            // 初期身長からどれだけ小さいかの割合に応じて成功率アップ
                            successRate += (heightDiff / target.initialHeight) * 0.3;
                        }
                        successRate = Math.min(0.5, successRate); // 上限50%

                        if (Math.random() < successRate) {
                            // 成功
                            target.statusEffects.stripped = {
                                turns: 0
                            };
                            flashCard(target, 'yellow');
                            log(`${enemy.name}の邪悪ないたずらが成功！ ${target.name}は恥ずかしい格好になってしまった！`);
                        } else {
                            // 失敗
                            log(`${enemy.name}はいたずらを仕掛けたが、${target.name}には通用しなかった！`);
                        }
                        updatePartyStatus();
                    }

                    async function shrinkToOneSkill(enemy, target) {
                        if (target.isWall || target === gameState.golem) {
                            log(`${enemy.name}は${target.name}にミニマムレイを放ったが、効果がなかった！`);
                            return;
                        }
                        if (target.heightLocked) {
                            log(`${enemy.name}は${target.name}にミニマムレイを放ったが、不思議な力で防がれた！`);
                            return;
                        }

                        log(`${enemy.name}は${target.name}にミニマムレイを放った！`);

                        // 戦闘中のみ有効な身長変更デバフを付与
                        target.statusEffects.shrunkToOne = true;

                        flashCard(target, 'yellow');
                        log(`${target.name}の体がみるみる縮んで、身長が1cmになってしまった！`);
                    }

                    async function minimumShower(enemy) {
                        log(`${enemy.name}はミニマムシャワーを放った！パーティ全員の体が縮んでしまった！`);
                        const shrinkAmount = 50;
                        for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                            if (p.heightLocked) {
                                log(`${p.name}は不思議な力で守られ、体の変化を防いだ！`);
                                continue;
                            }
                            await animateStatChange(p, 'height', -shrinkAmount, 'decrease', 'enemy');
                        }
                    }

                    function inflictStatusEffect(enemy, target) {
                        // 龍神の加護チェック
                        if (target.blessings && target.blessings.dragon_god_grace && target.height > 1000) {
                            log(`${target.name}は龍神の加護によって状態異常を弾いた！`);
                            return;
                        }

                        const effect = ['poison', 'paralysis', 'slow'][Math.floor(Math.random() * 3)];
                        let effectName = '',
                            duration = 0;
                        switch (effect) {
                            case 'poison':
                                effectName = '毒';
                                duration = 3;
                                target.statusEffects.poison = {
                                    turns: duration
                                };
                                break;
                            case 'paralysis':
                                effectName = '麻痺';
                                target.statusEffects.paralysis = true;
                                break;
                            case 'slow':
                                effectName = '鈍化';
                                duration = 3;
                                target.statusEffects.slow = {
                                    turns: duration
                                };
                                break;
                        }
                        flashCard(target, 'yellow');
                        log(`${enemy.name}の攻撃！ ${target.name}は${effectName}状態になった！`);
                    }

                    async function inflictRegeneration(enemy) {
                        // この関数はインプから削除されたため、他の敵が使う可能性を考慮して残す
                        if (enemy.regenUses < 3) {
                            enemy.regenUses++;
                            enemy.statusEffects.regeneration = {
                                turns: 3
                            };
                            flashCard(enemy, 'green');
                            log(`${enemy.name}は傷が再生し始めた！`);
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        } else {
                            log(`${enemy.name}は自己再生しようとしたが、力を使い果たしていた！`);
                        }
                    }

                    async function sweepAttack(enemy) {
                        log(`${enemy.name}のなぎ払い！`);
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        const damagePromises = [];
                        for (const member of aliveParty) {
                            const damage = calculateDamage(enemy, member, {
                                power: 1.0,
                                type: 'physical'
                            });
                            damagePromises.push(dealDamage(member, damage));
                        }
                        // 全員へのダメージ処理を並行して実行し、完了を待つ
                        await Promise.all(damagePromises);
                    }

                    async function nextTurn() {
                        let currentActor = gameState.turnOrder[gameState.currentTurnIndex];

                        // HPが0以下のキャラクターは行動できない
                        if (currentActor.currentHp <= 0) {
                            gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                            nextTurn();
                            return;
                        }

                        // 祝福「肥大する心身」「捻じ曲がった記憶」の効果
                        if (!currentActor.isEnemy && currentActor.currentHp > 0 && !currentActor.heightLocked) {
                            if (currentActor.blessings && currentActor.blessings.twisted_memory) {
                                const newHeight = Math.max(1, Math.floor(currentActor.height / 2));
                                const change = newHeight - currentActor.height;
                                if (change !== 0) {
                                    log(`${currentActor.name}の捻じ曲がった記憶が、その体を蝕む…！`);
                                    await animateStatChange(currentActor, 'height', change, 'decrease');
                                }
                            } else if (currentActor.blessings && currentActor.blessings.swelling_body) {
                                const change = currentActor.height;
                                // 上限2000cm
                                if (currentActor.height + change > 2000) {
                                    const cappedChange = 2000 - currentActor.height;
                                    if (cappedChange > 0) {
                                        log(`${currentActor.name}の心身が肥大し、成長の限界に達した！`);
                                        await animateStatChange(currentActor, 'height', cappedChange, 'increase');
                                    }
                                } else {
                                    log(`${currentActor.name}の心身が肥大し、体が膨れ上がっていく…！`);
                                    await animateStatChange(currentActor, 'height', change, 'increase');
                                }
                            }
                        }


                        // テンションアップのダメージ
                        if (currentActor.buffs && currentActor.buffs.tension_up && currentActor.currentHp > 0) {
                            const damage = Math.max(1, Math.floor(currentActor.maxHp * 0.05));
                            log(`${currentActor.name}はテンションが上がりすぎて、少しダメージを受けた！`);
                            await dealDamage(currentActor, damage);
                            if (currentActor.currentHp <= 0) return; // ダメージで倒れたらターン終了
                        }

                        // 聖女のターン開始時回復
                        if (!currentActor.isEnemy && currentActor.role === '聖女' && currentActor.currentHp > 0) {
                            const hpHeal = Math.max(1, Math.floor(currentActor.maxHp * 0.05));
                            const mpHeal = Math.max(1, Math.floor(currentActor.maxMp * 0.05));
                            animateStatChange(currentActor, 'hp', hpHeal, 'increase');
                            animateStatChange(currentActor, 'mp', mpHeal, 'increase');
                        }

                        // ターン開始時MP回復 (聖女と変身中のトレジャーハンターを除く)
                        if (!currentActor.isEnemy && currentActor.role !== '聖女' && !currentActor.isTransformed && currentActor.currentMp < currentActor.maxMp) {
                            animateStatChange(currentActor, 'mp', 1, 'increase');
                        }

                        // 祝福「願いの少女」「祈りの少女」の効果
                        if (!currentActor.isEnemy && currentActor.blessings) {
                            if (currentActor.blessings.wish_girl) {
                                log(`${currentActor.name}の肩に乗った願いの少女が、星に願いをかける！`);
                                await new Promise(resolve => setTimeout(resolve, 1000));
                                const power = Math.max(0.1, (currentActor.height / 150) * 0.5); // 身長150cmで威力0.5
                                const damagePromises = [];
                                for (const enemy of gameState.enemies.filter(e => e.currentHp > 0)) {
                                    const damage = calculateDamage(currentActor, enemy, {
                                        type: 'physical',
                                        power: power
                                    });
                                    damagePromises.push(dealDamage(enemy, damage));
                                }
                                await Promise.all(damagePromises);
                                log(`流星群が敵全体を襲った！`);
                                if (gameState.enemies.every(e => e.currentHp <= 0)) {
                                    endBattle(true);
                                    return;
                                }
                            } else if (currentActor.blessings.pray_girl) {
                                log(`${currentActor.name}の肩に乗った祈りの少女が、天に祈りを捧げる！`);
                                await new Promise(resolve => setTimeout(resolve, 1000));
                                const power = Math.max(0.1, (150 / Math.max(1, currentActor.height)) * 1.5); // 身長1cmで威力225相当
                                const damagePromises = [];
                                for (const enemy of gameState.enemies.filter(e => e.currentHp > 0)) {
                                    const damage = calculateDamage(currentActor, enemy, {
                                        type: 'magic',
                                        power: power
                                    });
                                    damagePromises.push(dealDamage(enemy, damage));
                                }
                                await Promise.all(damagePromises);
                                log(`聖なる光が敵全体を浄化した！`);
                                if (gameState.enemies.every(e => e.currentHp <= 0)) {
                                    endBattle(true);
                                    return;
                                }
                            }
                        }

                        // バフのターン経過
                        if (currentActor.buffs) {
                            Object.keys(currentActor.buffs).forEach(key => {
                                currentActor.buffs[key]--; // ファイター, ソーサラー, ナイト, メディック
                                // MP自動回復効果
                                if (key === 'mp_regen_once' && currentActor.buffs[key] <= 0) {
                                    animateStatChange(currentActor, 'mp', Math.ceil(currentActor.maxMp * 0.2), 'increase');
                                }
                                if (currentActor.buffs[key] <= 0) {
                                    delete currentActor.buffs[key];
                                    if (!currentActor.isEnemy) {
                                        let buffName = '';
                                        if (key === 'protect') buffName = '防御アップ';
                                        else if (key === 'atk_up') buffName = '攻撃アップ';
                                        else if (key === 'provoke') buffName = '挑発';
                                        if (buffName) {
                                            flashCard(currentActor, 'yellow');
                                            log(`${currentActor.name}の${buffName}効果が切れた。`);
                                        }
                                    }
                                }
                            });
                        }
                        // 状態異常のターン経過
                        if (currentActor.statusEffects) {
                            // 脱衣状態の経過ターンを増やす
                            if (currentActor.statusEffects.stripped && gameState.gameMode !== 'indecent' && !currentActor.isLiberatedStripped) {
                                const failChance = Math.max(0, 0.3 - (currentActor.statusEffects.stripped.turns * 0.05));
                                if (failChance > 0) {
                                    currentActor.statusEffects.stripped.turns++;
                                    log(`${currentActor.name}はだんだん恥ずかしさに慣れてきた…`);
                                }
                            }
                            ['poison', 'slow', 'regeneration'].forEach(effect => {
                                if (currentActor.statusEffects[effect]) {
                                    currentActor.statusEffects[effect].turns--;
                                    if (currentActor.statusEffects[effect].turns <= 0) {
                                        delete currentActor.statusEffects[effect];
                                        if (!currentActor.isEnemy) {
                                            const effectName = effect === 'poison' ? '毒' : '鈍化';
                                            flashCard(currentActor, 'yellow');
                                            log(`${currentActor.name}の${effectName}が治った。`);
                                        }
                                    }
                                }
                            });
                        }

                        if (currentActor.isDefending) currentActor.isDefending = false;

                        if (gameState.enemies.every(e => e.currentHp <= 0)) {
                            endBattle(true);
                            return;
                        }
                        if (gameState.party.every(p => p.currentHp <= 0)) {
                            endBattle(false);
                            return;
                        }

                        let actor = gameState.turnOrder[gameState.currentTurnIndex];

                        // 脱衣チェック (ナイト、サムライ、モンク、トレジャーハンターとその変身は対象外)
                        const immuneToShameRoles = ['ナイト', 'サムライ', 'モンク', 'トレジャーハンター', 'サキュバス', 'フェアリー', 'アルラウネ'];

                        if (actor.statusEffects && actor.statusEffects.stripped && !immuneToShameRoles.includes(actor.role) && !actor.isLiberatedStripped) {
                            let failChance = 0;
                            if (gameState.gameMode === 'indecent') {
                                failChance = 0.3; // 確率が減少しない
                            } else {
                                failChance = Math.max(0, 0.3 - (actor.statusEffects.stripped.turns * 0.05)); // ターン経過で確率低下
                            }

                            if (Math.random() < failChance) {
                                const messages = ["は、恥ずかしくて動けない…！", "こ、こんな格好じゃ集中できない…！", "だ、だめ、見ないで…！"];
                                log(`${actor.name}「${messages[Math.floor(Math.random() * messages.length)]}」`);
                                flashCard(actor, 'yellow');
                                setTimeout(() => {
                                    gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                    nextTurn();
                                }, 1000);
                                return;
                            }
                        }

                        // 麻痺チェック
                        if (currentActor.statusEffects && currentActor.statusEffects.paralysis) {
                            log(`${currentActor.name}は体が痺れて動けない！`);
                            delete currentActor.statusEffects.paralysis; // 麻痺は1回で解除
                            flashCard(currentActor, 'yellow');
                            updatePartyStatus();
                            setTimeout(() => {
                                gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                nextTurn();
                            }, 1000);
                            return;
                        }

                        // 変身中のMP消費と特殊効果
                        if (currentActor.isTransformed) {
                            // サマータイム・スペシャルライブ！モードではMP消費なし
                            const shouldConsumeMp = gameState.gameMode !== 'summer_live';

                            if (shouldConsumeMp) {
                                const mpCost = 15;
                                if (currentActor.currentMp < mpCost) {
                                    log(`${currentActor.name}はMPが尽き、変身が解けてしまった！`);
                                    await handleTransform(currentActor, {
                                        type: 'transform_revert'
                                    });
                                    // 変身解除後は即座にターン終了
                                    setTimeout(() => {
                                        gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                        nextTurn();
                                    }, 1000);
                                    return;
                                } else {
                                    animateStatChange(currentActor, 'mp', -mpCost, 'decrease');
                                }
                            }
                        }

                        // 毒ダメージ処理 (ターン終了時)
                        // nextTurnの最後に移動させるため、ここでは何もしない

                        // ターン実行
                        if (actor.isEnemy) {
                            // 敵の思考時間として少し待機
                            setTimeout(() => enemyTurn(actor), 1000);
                        } else {
                            playerTurn(actor); // ファイター, ソーサラー, ナイト, メディック
                        }

                        updatePartyStatus(); // ターン開始時に状態表示を更新
                    }

                    function playerTurn(character) {
                        commandMessage.textContent = `${character.name}のターン`;
                        actionButtons.innerHTML = '';
                        // コマンドコンテナのレイアウトを縦並びに変更
                        actionButtons.className = 'flex flex-col gap-2';

                        // 上段の基本コマンド用コンテナ
                        const topRow = document.createElement('div');
                        topRow.className = 'grid grid-cols-2 sm:grid-cols-4 gap-2';

                        // 下段のスキル用コンテナ
                        const skillRow = document.createElement('div');
                        skillRow.className = 'grid grid-cols-2 sm:grid-cols-4 gap-2';

                        const attackBtn = document.createElement('button');
                        attackBtn.textContent = 'たたかう';
                        attackBtn.className = 'action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded';
                        attackBtn.onclick = () => playerAction(character, {
                            type: 'attack'
                        });
                        topRow.appendChild(attackBtn);

                        const defendBtn = document.createElement('button');
                        defendBtn.textContent = 'ぼうぎょ';
                        defendBtn.className = 'action-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded';
                        defendBtn.onclick = () => playerAction(character, {
                            type: 'defend'
                        });
                        topRow.appendChild(defendBtn);

                        const itemBtn = document.createElement('button');
                        itemBtn.textContent = 'アイテム';
                        itemBtn.className = `action-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded ${gameState.inventory.length === 0 ? 'opacity-50 cursor-not-allowed' : ''}`;
                        itemBtn.disabled = gameState.inventory.length === 0;
                        itemBtn.onclick = () => showItemModal(character);
                        topRow.appendChild(itemBtn);

                        const scanBtn = document.createElement('button');
                        scanBtn.textContent = '調べる';
                        scanBtn.className = 'action-button bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-4 rounded';
                        scanBtn.onclick = () => playerAction(character, {
                            type: 'scan'
                        });
                        topRow.appendChild(scanBtn);

                        character.skills.forEach(skill => {
                            const isSlowed = character.statusEffects && character.statusEffects.slow;
                            const isHpCostSkill = skill.type && skill.type.includes('hp_cost');
                            const isHeightCostSkill = skill.type === 'special_heal'; // 献身スキル
                            const isDisabled = (isHpCostSkill ? character.currentHp <= skill.cost : character.currentMp < skill.cost) || isSlowed;
                            const skillBtn = document.createElement('button');

                            let costText = '';
                            if (isHeightCostSkill) {
                                costText = `(身長:20)`;
                            } else {
                                costText = `(${isHpCostSkill ? 'HP' : 'MP'}:${skill.cost})`;
                            }
                            skillBtn.textContent = `${skill.name} ${costText}`;
                            skillBtn.className = `action-button bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}`;
                            if (isSlowed) skillBtn.title = "鈍化状態でスキルが使えない！";
                            skillBtn.disabled = isDisabled;
                            skillBtn.onclick = () => playerAction(character, {
                                type: 'skill',
                                skill: skill
                            });
                            skillRow.appendChild(skillBtn);
                        });

                        actionButtons.appendChild(topRow);
                        if (skillRow.hasChildNodes()) {
                            actionButtons.appendChild(skillRow);
                        }
                    }

                    let pendingAction = null;

                    function cancelPlayerActionSelection(message = "対象が違います。") {
                        log(message);
                        pendingAction = null;
                        document.querySelectorAll('.enemy-card, .character-card').forEach(c => c.classList.remove('targeted'));
                        // 現在のキャラクターのターンに戻す
                        const currentActor = gameState.turnOrder[gameState.currentTurnIndex];
                        if (currentActor && !currentActor.isEnemy) {
                            playerTurn(currentActor);
                        }
                    }

                    function playerAction(character, action) {
                        pendingAction = {
                            character,
                            action
                        };

                        const targetType = action.type === 'attack' ? 'enemy' : (action.type === 'scan' ? 'any' : (action.skill ? action.skill.targetType : (action.item ? itemBlueprints[action.item.id].target : 'self')));

                        if (targetType === 'enemy') {
                            const aliveEnemies = gameState.enemies.filter(e => e.currentHp > 0);
                            if (aliveEnemies.length === 1 && pendingAction.action.type !== 'scan') {
                                pendingAction.target = aliveEnemies[0];
                                executePlayerAction();
                            } else {
                                commandMessage.textContent = '誰を狙う？';
                                gameState.enemies.forEach((enemy, index) => {
                                    if (enemy.currentHp > 0) document.getElementById(`enemy-card-${index}`).classList.add('targeted');
                                });
                            }
                        } else if (targetType === 'ally') {
                            commandMessage.textContent = '誰に使う？';
                            const isReviveSkill = action.skill && action.skill.type === 'revive_full';
                            gameState.party.forEach((char, index) => {
                                if ((isReviveSkill && char.currentHp <= 0) || (!isReviveSkill && char.currentHp > 0)) {
                                    document.getElementById(`party-card-${index}`).classList.add('targeted');
                                }
                            });
                        } else if (targetType === 'any') {
                            commandMessage.textContent = '調べる対象を選択してください。';
                            gameState.enemies.forEach((enemy, index) => {
                                if (enemy.currentHp > 0) document.getElementById(`enemy-card-${index}`).classList.add('targeted');
                            });
                            gameState.party.forEach((char, index) => {
                                if (char.currentHp > 0) document.getElementById(`party-card-${index}`).classList.add('targeted');
                            });
                        } else {
                            // 敵全体、自分自身が対象の場合
                            if (targetType === 'enemies') {
                                pendingAction.target = gameState.enemies.filter(e => e.currentHp > 0);
                            }
                            executePlayerAction();
                        }

                    }

                    function playerSelectTarget(targetIndex) {
                        if (!pendingAction || gameState.enemies[targetIndex].currentHp <= 0) return;

                        const action = pendingAction.action;
                        const targetType = action.type === 'attack' ? 'enemy' : (action.skill ? action.skill.targetType : (action.item ? itemBlueprints[action.item.id].target : null));

                        // 敵を対象とするアクションかチェック
                        if (targetType === 'enemy' || targetType === 'enemies' || targetType === 'any' || (targetType === 'random_enemies' && action.type === 'skill')) {
                            pendingAction.target = gameState.enemies[targetIndex];
                            executePlayerAction();
                        } else if (action.type === 'scan') {
                            showScanResult(gameState.enemies[targetIndex]);
                        } else {
                            cancelPlayerActionSelection("そのアクションは敵には使えません。");
                        }
                    }

                    function playerSelectAlly(targetIndex) {
                        if (!pendingAction) return;

                        const targetCharacter = gameState.party[targetIndex];
                        const action = pendingAction.action;
                        const targetType = action.skill ? action.skill.targetType : (action.item ? itemBlueprints[action.item.id].target : null);

                        // 味方を対象とするアクションかチェック
                        if (targetType === 'ally' || targetType === 'party' || targetType === 'self' || targetType === 'any') {
                            // 復活スキル/アイテムの場合
                            if ((action.skill && action.skill.type === 'revive_full') || (action.item && itemBlueprints[action.item.id].effect === 'revive')) {
                                if (targetCharacter.currentHp <= 0) {
                                    pendingAction.target = targetCharacter;
                                    executePlayerAction();
                                } else {
                                    cancelPlayerActionSelection(`${targetCharacter.name}は戦闘不能ではありません。`);
                                }
                            } else if (targetCharacter.currentHp > 0) { // 通常の味方対象アクション
                                pendingAction.target = targetCharacter;
                                executePlayerAction();
                            } else {
                                cancelPlayerActionSelection("戦闘不能の仲間には使えません。");
                            }
                        } else if (action.type === 'scan') {
                            showScanResult(targetCharacter);
                        } else {
                            cancelPlayerActionSelection("そのアクションは味方には使えません。");
                        }
                    }

                    async function executePlayerAction() {
                        const {
                            character,
                            action,
                            target
                        } = pendingAction;
                        document.querySelectorAll('.enemy-card, .character-card').forEach(c => c.classList.remove('targeted'));

                        pendingAction = null;
                        document.querySelectorAll('.enemy-card').forEach(c => c.classList.remove('targeted'));
                        actionButtons.innerHTML = '<p>コマンド実行中...</p>';
                        // トレジャーハンターの通常攻撃
                        if (action.type === 'attack' && character.role === 'トレジャーハンター' && !character.isTransformed) {
                            await handleTreasureHunterAttack(character, target);
                            // ターン終了処理
                            setTimeout(() => {
                                // ターン終了時の毒ダメージなどの処理
                                if (gameState.inBattle) {
                                    gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                    setTimeout(nextTurn, 0); // 即座に次のターンへ
                                }
                            }, 1000);
                            return;
                        }
                        switch (action.type) {
                            case 'attack': // Player attack
                                const aliveEnemies = gameState.enemies.filter(e => e.currentHp > 0);
                                // 身長が500cmを超えている場合、全体攻撃になる
                                // 敵が2体以上いる場合のみ全体攻撃
                                if (character.height > 500 && aliveEnemies.length > 1) {
                                    log(`${character.name}はその巨体で敵全体をなぎ払った！`);
                                    const damagePromises = [];
                                    for (const enemy of aliveEnemies) {
                                        // 全体攻撃なので威力を少し下げる (0.7倍)
                                        const damage = calculateDamage(character, enemy, {
                                            power: 0.7,
                                            type: 'physical'
                                        });
                                        damagePromises.push(dealDamage(enemy, damage));
                                    }
                                    await Promise.all(damagePromises);
                                } else {
                                    // 通常の単体攻撃
                                    let damage = calculateDamage(character, target);
                                    let logMessageText = `${character.name}の攻撃！ ${target.name}に${damage}のダメージ！`;

                                    const mpRecoveryRoles = ['ソーサラー', 'メディック', 'モンク', 'ギャンブラー', 'サモナー', 'アルケミスト', 'ダンサー', 'ネクロマンサー'];
                                    if (mpRecoveryRoles.includes(character.role)) {
                                        // MP回復ジョブの処理
                                        const mpRecovery = Math.floor(character.maxMp * 0.1);
                                        if (mpRecovery > 0) {
                                            await animateStatChange(character, 'mp', mpRecovery, 'increase');
                                            log(`${character.name}は攻撃から魔力を吸収した！(MP+${mpRecovery})`);
                                        }
                                    } else if (character.role === 'ドクター') {
                                        // ドクターの特殊攻撃
                                        if (target.statusEffects && (target.statusEffects.poison || target.statusEffects.slow)) {
                                            damage = Math.floor(damage * 1.5);
                                            logMessageText = `${character.name}は弱った${target.name}に追撃！ ${damage}のダメージ！`;
                                        }
                                        // MP回復効果も追加
                                        const mpRecovery = Math.floor(character.maxMp * 0.1);
                                        if (mpRecovery > 0) await animateStatChange(character, 'mp', mpRecovery, 'increase');
                                    } else {
                                        // クリティカルヒット判定ジョブの処理
                                        const criticalRoles = ['ファイター', 'ナイト', 'サムライ', 'ガーディアン', 'トラブルメーカー'];
                                        if (criticalRoles.includes(character.role) && Math.random() < 0.2) { // 20%の確率でクリティカル
                                            damage = Math.ceil(damage * (character.blessings && character.blessings.critical_master ? 2.0 : 1.5));
                                            logMessageText = `会心の一撃！ ${target.name}に${damage}の大ダメージ！`;
                                        }
                                        // アンドロイドの通常攻撃クリティカル
                                        if (character.role === 'アンドロイド' && Math.random() < 0.25) { // 25%の確率でクリティカル
                                            damage = Math.ceil(damage * (character.blessings && character.blessings.critical_master ? 2.0 : 1.5));
                                            logMessageText = `会心の一撃！ ${target.name}に${damage}の大ダメージ！`;
                                        }
                                    }
                                    // 祝福: 双撃
                                    if (character.blessings && character.blessings.double_attack && Math.random() < 0.75) {
                                        log(`${character.name}は双撃の祝福で追撃！`);
                                        await new Promise(resolve => setTimeout(resolve, 500));
                                        const secondDamage = calculateDamage(character, target, {
                                            power: 0.6
                                        }); // 2撃目は威力0.6倍
                                        await dealDamage(target, secondDamage);
                                        log(`${target.name}に${secondDamage}のダメージ！`);
                                    }
                                    // メイドのHP吸収
                                    if (character.buffs && character.buffs.hp_absorb) {
                                        const absorbAmount = Math.ceil(damage * 0.2);
                                        log(`${character.name}は攻撃から生命力を吸収した！`);
                                        await dealDamage(character, -absorbAmount, true); // isHealをtrueにしてdealDamageを呼び出す
                                    }

                                    await dealDamage(target, damage); // Await the damage animation
                                    log(logMessageText); // Log after animation
                                } // ファイター, ソーサラー, ナイト, メディック
                                break;
                            case 'skill': // ファイター, ソーサラー, ナイト, メディック
                                if (action.skill.type && action.skill.type.includes('hp_cost')) { // HPコスト
                                    await animateStatChange(character, 'hp', -action.skill.cost, 'decrease'); // HP消費
                                } else if (action.skill.cost > 0 && action.skill.type !== 'mp_burst_magic') { // MPコスト
                                    let mpCost = action.skill.cost;
                                    // 「ばっちりチェック」中に「ハプニングボックス」を使うと消費MP半減
                                    if (action.skill.name === 'ハプニングボックス' && character.buffs.trouble_check) {
                                        mpCost = Math.ceil(mpCost / 2); // ファイター, ソーサラー, ナイト, メディック
                                        log("ばっちりチェックの効果で、消費MPが半減した！");
                                    }
                                    await animateStatChange(character, 'mp', -mpCost, 'decrease'); // MP消費
                                }
                                flashCard(character, 'yellow'); // MP消費
                                await handleSkill(character, target, action.skill);
                                // 祝福: 魔力残響
                                if (character.blessings && character.blessings.spell_echo && action.skill.type.includes('magic') && !action.skill.type.includes('status') && Math.random() < 0.3) {
                                    log(`魔力残響が${action.skill.name}を反響させる！`);
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                    // MP消費なしで同じスキルを再実行
                                    const secondTarget = action.skill.targetType === 'enemy' ?
                                        gameState.enemies.filter(e => e.currentHp > 0)[Math.floor(Math.random() * gameState.enemies.filter(e => e.currentHp > 0).length)] :
                                        target;
                                    if (secondTarget) {
                                        await handleSkill(character, secondTarget, action.skill);
                                    }
                                }
                                break;
                            case 'item':
                                // handleItemがtrueを返した場合のみアイテムを消費
                                const itemUsed = await handleItem(character, target, action.item);
                                if (itemUsed) action.item.quantity--;
                                break;
                            case 'defend':
                                character.isDefending = true;
                                log(`${character.name}は防御の構えをとった。`);
                                break;
                            case 'scan':
                                // このケースは playerSelect... で直接処理されるため、ここでは何もしない
                                // ターンを消費しないように、nextTurnを呼ばずにplayerTurnに戻る
                                playerTurn(character);
                                return;
                        }

                        updatePartyStatus(); // Refresh all cards after animations
                        updateEnemyStatus(); // Enemy status doesn't have number animation, so it can be updated immediately

                        if (gameState.inBattle) {
                            setTimeout(() => {
                                // ターン終了時の毒ダメージと祝福処理
                                if (character.currentHp > 0 && character.statusEffects && character.statusEffects.poison) {
                                    const poisonDamage = Math.max(1, Math.ceil(character.maxHp * 0.05));
                                    log(`${character.name}は毒のダメージを受けている！`);
                                    // dealDamageはasyncだが、ここでは待たずに次のターンへ進む
                                    dealDamage(character, poisonDamage);
                                    updatePartyStatus();
                                }
                                // ターン終了時の自然治癒と祝福
                                if (character.currentHp > 0 && (character.statusEffects.regeneration || (character.blessings && (character.blessings.hp_regen || character.blessings.mp_regen)))) {
                                    let healAmount = Math.max(1, Math.ceil(character.maxHp * 0.08));
                                    // 祝福の処理
                                    if (character.blessings && character.blessings.hp_regen) {
                                        healAmount += Math.max(1, Math.ceil(character.maxHp * 0.05)); // 祝福による回復を追加
                                    }
                                    if (character.blessings && character.blessings.mp_regen) {
                                        const mpHeal = Math.max(1, Math.ceil(character.maxMp * 0.05));
                                        animateStatChange(character, 'mp', mpHeal, 'increase');
                                    }
                                    // 聖女の行進モードでは回復量が2倍
                                    if (gameState.gameMode === 'saint_march') {
                                        healAmount *= 2;
                                    } // ファイター, ソーサラー, ナイト, メディック
                                    if (character.statusEffects.regeneration) {
                                        log(`${character.name}は傷が自然に回復していく！`);
                                        animateStatChange(character, 'hp', healAmount, 'increase');
                                    } else if (character.blessings && character.blessings.hp_regen) {
                                        log(`${character.name}は祝福の力でHPが回復した！`);
                                        animateStatChange(character, 'hp', healAmount, 'increase');
                                    }
                                }


                                gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                nextTurn();
                            }, 1000);
                        }
                    }

                    async function handleSkill(caster, target, skill) {
                        switch (skill.type) {
                            case 'growth_physical':
                                {
                                    const skillDamage = calculateDamage(caster, target, skill);
                                    await dealDamage(target, skillDamage);
                                    log(`${caster.name}は${skill.name}を放った！ ${target.name}に${skillDamage}のダメージ！`);
                                    // 永続的な威力上昇
                                    skill.power = parseFloat((skill.power + 0.1).toFixed(2));
                                    log(`${caster.name}の「${skill.name}」が少し強くなった！`);
                                    break;
                                }
                            case 'physical':
                            case 'magic':
                                {
                                    if (Array.isArray(target) && target.every(t => t.isEnemy)) { // 敵全体への攻撃の場合
                                        let modifiedSkill = skill;
                                        // 解放状態でのホットウェーブ強化
                                        if (skill.name === 'ホットウェーブ' && caster.isLiberatedStripped) {
                                            log(`${caster.name}の解放された熱情が、波をさらに熱くする！`);
                                            await new Promise(resolve => setTimeout(resolve, 500));
                                            modifiedSkill = {...skill,
                                                power: skill.power * 1.2
                                            };
                                        }
                                        // 解放状態でのプチウンディーネ強化
                                        if (skill.name === 'プチウンディーネ' && caster.isLiberatedStripped) {
                                            log(`${caster.name}の解放された魔力が、水の精霊を荒ぶらせる！`);
                                            await new Promise(resolve => setTimeout(resolve, 500));
                                            modifiedSkill = {...skill,
                                                power: skill.power * 2.5
                                            };
                                        }
                                        log(`${caster.name}は${skill.name}を放った！`);
                                        const damagePromises = [];
                                        for (const t of target) {
                                            // dealDamageを直接awaitせず、Promiseを配列に格納
                                            damagePromises.push(dealDamage(t, calculateDamage(caster, t, modifiedSkill)));
                                        }
                                        // 全てのダメージ処理アニメーションを並行して実行
                                        await Promise.all(damagePromises);
                                    } else { // 単体攻撃の場合
                                        let modifiedSkill = skill;
                                        // サマータイム・スペシャルライブ！の温泉エリアでのプチサラマンダー強化
                                        if (skill.name === 'プチサラマンダー' && gameState.gameMode === 'summer_live' && gameState.floor > 30) {
                                            log("温泉の熱気がサラマンダーの力を増幅させる！");
                                            await new Promise(resolve => setTimeout(resolve, 500)); // メッセージ表示のための短い待機
                                            modifiedSkill = {...skill,
                                                power: skill.power * 2.5
                                            };
                                        }
                                        const skillDamage = calculateDamage(caster, target, modifiedSkill);
                                        await dealDamage(target, skillDamage);
                                        log(`${caster.name}は${skill.name}を放った！ ${target.name}に${skillDamage}のダメージ！`);
                                        // 天の裁きの副作用
                                        if (skill.name === '天の裁き') {
                                            await handleHeavensJudgmentSideEffect(caster);
                                        }

                                    }
                                    break;
                                }
                            case 'heal':
                                {
                                    const skillHealAmount = skill.power + Math.ceil(getEffectiveStats(caster).atk * 0.5); // Calculate amount first
                                    await animateStatChange(target, 'hp', skillHealAmount, 'increase'); // Await HP animation
                                    flashCard(target, 'green'); // Flash the card itself
                                    showDamagePopup(target, skillHealAmount, true);
                                    log(`${caster.name}は${target.name}に${skill.name}を唱えた！ HPが${skillHealAmount}回復した。`);
                                    // メディックの「ヒール」の場合、状態異常を解除
                                    if (skill.name === 'ヒール' && caster.role === 'メディック') {
                                        let curedEffects = [];
                                        if (target.statusEffects.poison) {
                                            delete target.statusEffects.poison;
                                            curedEffects.push('毒');
                                        }
                                        if (target.statusEffects.paralysis) {
                                            delete target.statusEffects.paralysis;
                                            curedEffects.push('麻痺');
                                        }
                                        if (target.statusEffects.slow) {
                                            delete target.statusEffects.slow;
                                            curedEffects.push('鈍化');
                                        }
                                        if (curedEffects.length > 0) log(`さらに、${target.name}の${curedEffects.join('、')}が治った！`);
                                    }
                                    break;
                                }
                            case 'buff':
                                {
                                    if (skill.effect === 'atk_up') {
                                        target.buffs.atk_up = 3; // 3ターン攻撃力アップ
                                        flashCard(target, 'yellow');
                                        log(`${caster.name}は${target.name}に${skill.name}を唱えた！ 攻撃力が上がった！`);
                                    } else if (skill.effect === 'protect') {
                                        target.buffs.protect = 3; // 3ターン防御力アップ
                                        flashCard(target, 'yellow');
                                        log(`${caster.name}は${target.name}に${skill.name}を唱えた！ 防御力が上がった！`);
                                    } else if (skill.effect === 'def_down') {
                                        target.buffs.def_down = 3; // 3ターン防御力ダウン
                                        flashCard(target, 'yellow');
                                        log(`${caster.name}は${target.name}に${skill.name}を唱えた！ 防御力が下がった！`);
                                    }
                                    break;
                                }
                            case 'utility':
                                {
                                    flashCard(caster, 'yellow');
                                    caster.buffs.provoke = 3; // 挑発は自分自身が対象
                                    log(`${caster.name}は${skill.name}で敵の注意を引いた！`);
                                    break;
                                }
                            case 'charge':
                                { // チャージ
                                    caster.chargeCount = (caster.chargeCount || 0) + 1;
                                    flashCard(caster, 'yellow');
                                    // 挑発状態の場合、挑発ターンを1増やす
                                    if (caster.buffs && caster.buffs.provoke > 0) {
                                        caster.buffs.provoke++;
                                        log(`${caster.name}は挑発を継続し、さらに力を溜める！ (${caster.chargeCount}回目)`);
                                    } else {
                                        log(`${caster.name}は${skill.name}！力を溜めている…！ (${caster.chargeCount}回目)`);
                                    }
                                    break;
                                }
                            case 'special_heal':
                                { // 献身
                                    if (caster.heightLocked) {
                                        log(`${caster.name}は献身を使おうとしたが、体が変化を拒んだ！`);
                                        caster.currentMp += skill.cost; // MPを消費しない
                                        break;
                                    }
                                    const costHeight = Math.min(20, caster.height - 1);
                                    if (costHeight < 1) {
                                        log(`${caster.name}は献身を使おうとしたが、身長が足りなかった！`);
                                        break; // 身長が1cmだと使えない
                                    }
                                    // 献身使用後に身長が1cm未満になる場合は使用不可
                                    if (caster.height - costHeight < 1) {
                                        log(`${caster.name}は献身を使おうとしたが、これ以上身長を捧げられなかった！`);
                                        caster.currentMp += skill.cost; // MPを消費しない
                                        break;
                                    }
                                    await animateStatChange(caster, 'height', -costHeight, 'decrease');
                                    log(`${caster.name}は身長を${costHeight}cm捧げて、味方を癒した！`);
                                    // 味方全体のHPを40%回復
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        const healAmount = Math.ceil(p.maxHp * 0.4);
                                        await animateStatChange(p, 'hp', healAmount, 'increase');
                                    }
                                    break;
                                }
                                // 新しいLv4スキル
                            case 'height_power_physical':
                                { // ボディドロップ
                                    let modifiedSkill = skill;
                                    if (caster.isLiberatedStripped) {
                                        log(`${caster.name}の解放された肉体が、一撃の重みを増す！`);
                                        await new Promise(resolve => setTimeout(resolve, 500));
                                        modifiedSkill = {...skill,
                                            power: skill.power * 1.2
                                        };
                                    }
                                    const heightBonus = Math.max(0, (caster.height - caster.initialHeight) * 0.1);
                                    const bodyDropDamage = calculateDamage(caster, target, {
                                        ...skill,
                                        power: skill.power + heightBonus
                                    });
                                    await dealDamage(target, bodyDropDamage);
                                    log(`${caster.name}の${skill.name}！ ${target.name}に${bodyDropDamage}の超特大ダメージ！`);
                                    break;
                                }
                            case 'multi_hit_physical':
                                { // 乱舞
                                    const hitCount = Math.ceil(Math.random() * 3) + 4; // 4〜6回
                                    log(`${caster.name}の${skill.name}！`);
                                    await new Promise(resolve => setTimeout(resolve, 500)); // メッセージ表示のための短い待機
                                    log(`${hitCount}回攻撃！`);
                                    for (let i = 0; i < hitCount; i++) {
                                        const randomTarget = gameState.enemies.filter(e => e.currentHp > 0)[Math.floor(Math.random() * gameState.enemies.filter(e => e.currentHp > 0).length)];
                                        if (randomTarget) {
                                            const damage = calculateDamage(caster, randomTarget, {
                                                ...skill,
                                                power: 0.6
                                            }); // 1ヒットあたりの威力は調整
                                            // 連続攻撃なので、一体ずつ待機してダメージを与える
                                            await dealDamage(randomTarget, damage);
                                        }
                                    } // ファイター, ソーサラー, ナイト, メディック
                                    break;
                                }
                            case 'mp_burst_magic':
                                { // マジックバースト
                                    const damage = caster.currentMp * 4;
                                    await animateStatChange(caster, 'mp', -caster.currentMp, 'decrease');
                                    log(`${caster.name}は${skill.name}を放った！`);
                                    await dealDamage(target, damage);
                                    log(`${target.name}に${damage}の特大ダメージ！`);
                                    break;
                                }
                            case 'self_buff_special':
                                { // 堅守の構え
                                    log(`${caster.name}は${skill.name}をとった！`);
                                    caster.buffs.provoke = 3;
                                    caster.statusEffects.regeneration = {
                                        turns: 3
                                    };
                                    flashCard(caster, 'yellow');
                                    log(`${caster.name}は敵の注意を引きつけ、傷が再生し始めた！`);
                                    break;
                                }
                            case 'party_restore_growth':
                                { // サンクチュアリ
                                    log(`${caster.name}は${skill.name}を唱えた！聖なる光がパーティを包み込む！`);
                                    if (caster.heightLocked) {
                                        log(`しかし、${caster.name}の体は聖なる力による成長を受け付けなかった！`);
                                    }

                                    for (const p of gameState.party) {
                                        if (p.currentHp > 0) {
                                            await animateStatChange(p, 'hp', p.maxHp, 'increase'); // 全回復
                                            p.statusEffects = {}; // 状態異常回復
                                            if (p !== caster) await animateStatChange(p, 'height', skill.growth, 'increase'); // 身長アップ
                                        }
                                    }
                                    break;
                                }
                                // 新キャラクタースキル
                            case 'transform_succubus':
                            case 'transform_fairy':
                            case 'transform_alraune':
                                await handleTransform(caster, skill);
                                break;
                            case 'transform_revert':
                                await handleTransform(caster, skill);
                                break;
                            case 'treasure_hunter_attack':
                                { // ジュエルショット
                                    const jewelDamage = calculateDamage(caster, target, {
                                        ...skill,
                                        power: 1.5
                                    });
                                    await dealDamage(target, jewelDamage);
                                    log(`${caster.name}は${skill.name}を放った！ ${target.name}に${jewelDamage}のダメージ！`);
                                    if (Math.random() < 0.5) {
                                        caster.buffs.atk_up = 3;
                                        log(`${caster.name}の攻撃力が上がった！`);
                                    } else {
                                        const mpHeal = Math.ceil(caster.maxMp * 0.3);
                                        await animateStatChange(caster, 'mp', mpHeal, 'increase');
                                        log(`${caster.name}のMPが${mpHeal}回復した！`);
                                    }
                                    break;
                                }
                            case 'status_magic':
                                { // ポイズンミスト
                                    if (skill.effect === 'poison' && Array.isArray(target)) { // 敵全体
                                        log(`${caster.name}の${skill.name}！ 毒の霧が敵全体を包み込む！`);
                                        target.forEach(t => {
                                            t.statusEffects.poison = {
                                                turns: 3
                                            };
                                            flashCard(t, 'yellow');
                                        });
                                    } else if (skill.effect === 'poison') { // 敵単体 (念のため残す)
                                        target.statusEffects.poison = {
                                            turns: 3
                                        };
                                        flashCard(target, 'yellow');
                                        log(`${caster.name}の${skill.name}！ ${target.name}は毒状態になった！`);
                                    }
                                    break;
                                }
                            case 'evade_provoke':
                                { // スポットライト
                                    caster.buffs.provoke = 3;
                                    caster.buffs.evade_up = 3;
                                    flashCard(caster, 'yellow');
                                    log(`${caster.name}は${skill.name}を浴びて、敵の注目と視線を集めた！`);
                                    break;
                                }
                            case 'hp_cost_physical':
                                { // 居合, 無明の一閃
                                    const samuraiDamage = calculateDamage(caster, target, skill);
                                    await dealDamage(target, samuraiDamage);
                                    log(`${caster.name}は${skill.name}を放った！ ${target.name}に${samuraiDamage}のダメージ！`);
                                    break;
                                }
                            case 'drain_physical':
                                { // ハートドレイン
                                    const drainDamage = calculateDamage(caster, target, skill);
                                    const targetOriginalHp = target.currentHp;
                                    if (drainDamage === 'evaded') {
                                        log(`${target.name}は攻撃をかわした！`);
                                        showDamagePopup(target, '回避');
                                    } else {
                                        const drainHeal = Math.ceil(drainDamage * 0.5);
                                        await dealDamage(target, drainDamage);
                                        const isDefeated = target.currentHp <= 0;
                                        if (isDefeated) {
                                            const overkill = drainDamage - targetOriginalHp;
                                            const heightGain = Math.max(0, Math.floor(overkill / 2));
                                            if (heightGain > 0) {
                                                await animateStatChange(caster, 'height', heightGain, 'increase');
                                                log(`${caster.name}は過剰な生命力を吸収し、身長が${heightGain}cm伸びた！`);
                                            }
                                        }
                                        await animateStatChange(caster, 'hp', drainHeal, 'increase');
                                        log(`${caster.name}は${skill.name}で${target.name}に${drainDamage}のダメージを与え、HPを${drainHeal}回復した！`);
                                    }
                                    break;
                                }
                            case 'self_buff_samurai':
                                { // 明鏡止水
                                    caster.buffs.atk_up = 3;
                                    log(`${caster.name}は${skill.name}の構え。精神を研ぎ澄まし、攻撃力が上がった！`);
                                    break;
                                }
                            case 'def_ignore_physical':
                                { // 破砕拳
                                    const monkDamage = calculateDamage(caster, target, skill);
                                    await dealDamage(target, monkDamage);
                                    log(`${caster.name}の${skill.name}！ ${target.name}に${monkDamage}の防御無視ダメージ！`);
                                    break;
                                }
                            case 'growth_ally':
                                { // 成長促進剤
                                    if (target.heightLocked) {
                                        log(`${caster.name}は${target.name}に薬を投与したが、体が変化を拒んだ！`);
                                        caster.currentMp += skill.cost; // MPを消費しない
                                        break;
                                    }
                                    await animateStatChange(target, 'height', skill.power, 'increase');
                                    flashCard(target, 'yellow');
                                    log(`${caster.name}は${target.name}に${skill.name}を投与した！ ${target.name}の体が巨大化した！(身長+${skill.power}cm)`);
                                    break;
                                }
                            case 'shrink_ally':
                                { // 縮小薬
                                    if (target.heightLocked) {
                                        log(`${caster.name}は${target.name}に薬を投与したが、体が変化を拒んだ！`);
                                        caster.currentMp += skill.cost; // MPを消費しない
                                        break;
                                    }
                                    await animateStatChange(target, 'height', -skill.power, 'decrease');
                                    flashCard(target, 'yellow');
                                    log(`${caster.name}は${target.name}に${skill.name}を投与した！ 身長が${skill.power}cm縮んだ！`);
                                    break;
                                }
                            case 'status_ailment_multi':
                                { // パンデミック
                                    log(`${caster.name}は${skill.name}を散布した！`);
                                    const ailmentTargets = Array.isArray(target) ? target : [target];
                                    for (const t of ailmentTargets) {
                                        const effect = skill.effects[Math.floor(Math.random() * skill.effects.length)];
                                        let effectName = ''; // ファイター, ソーサラー, ナイト, メディック
                                        if (effect === 'poison') {
                                            t.statusEffects.poison = {
                                                turns: 3
                                            };
                                            effectName = '毒';
                                        } else if (effect === 'paralysis') {
                                            t.statusEffects.paralysis = true;
                                            effectName = '麻痺';
                                        } else if (effect === 'slow') {
                                            t.statusEffects.slow = {
                                                turns: 3
                                            };
                                            effectName = '鈍化';
                                        }
                                        flashCard(t, 'yellow');
                                        log(`${t.name}は${effectName}状態になった！`);
                                    }
                                    break;
                                }
                            case 'gambling_damage':
                                { // ダーツショット
                                    const roll = Math.random();
                                    let damageMultiplier = 1.0;
                                    let message = "";
                                    if (roll < 0.1) { // 10%でミス
                                        damageMultiplier = 0;
                                        message = "しかし、ダーツは大きく外れてしまった！"; // ファイター, ソーサラー, ナイト, メディック
                                    } else if (roll < 0.5) { // 40%で通常ヒット
                                        damageMultiplier = 1.5;
                                        message = `${target.name}にヒット！`;
                                    } else if (roll < 0.9) { // 40%でクリティカル // ファイター, ソーサラー, ナイト, メディック
                                        damageMultiplier = 3.0;
                                        message = `クリティカルヒット！ ${target.name}に大ダメージ！`;
                                    } else { // 10%でミラクルヒット
                                        damageMultiplier = 5.0;
                                        message = `ミラクルヒット！ ${target.name}に超特大ダメージ！`;
                                    }
                                    const gamblingDamage = calculateDamage(caster, target, {
                                        ...skill,
                                        power: damageMultiplier
                                    });
                                    log(`${caster.name}の${skill.name}！ ${message}`);
                                    if (gamblingDamage > 0) await dealDamage(target, gamblingDamage);
                                    break;
                                }
                            case 'gambling_support':
                                { // ラッキースター
                                    const supportRoll = Math.random();
                                    log(`${caster.name}は${target.name}に${skill.name}を祈った！`);
                                    const effects = [{
                                        name: 'HP回復',
                                        func: async() => {
                                            const healAmount = Math.ceil(target.maxHp * 0.5);
                                            await animateStatChange(target, 'hp', healAmount, 'increase');
                                            log(`${target.name}のHPが${healAmount}回復！`);
                                        }
                                    }, {
                                        name: 'MP回復',
                                        func: async() => {
                                            const mpAmount = Math.ceil(target.maxMp * 0.5);
                                            await animateStatChange(target, 'mp', mpAmount, 'increase');
                                            log(`${target.name}のMPが${mpAmount}回復！`);
                                        }
                                    }, {
                                        name: '攻撃力アップ',
                                        func: () => {
                                            target.buffs.atk_up = 3;
                                            log(`${target.name}の攻撃力がアップ！`);
                                        }
                                    }, {
                                        name: '防御力アップ',
                                        func: () => {
                                            target.buffs.protect = 3;
                                            log(`${target.name}の防御力がアップ！`);
                                        }
                                    }, {
                                        name: '状態異常回復',
                                        func: () => {
                                            target.statusEffects = {};
                                            log(`${target.name}の状態異常が回復！`);
                                        }
                                    }, ];
                                    // シャッフルして3つ選ぶ
                                    for (let i = effects.length - 1; i > 0; i--) {
                                        const j = Math.floor(Math.random() * (i + 1));
                                        [effects[i], effects[j]] = [effects[j], effects[i]];
                                    }
                                    const selectedEffects = effects.slice(0, 3);
                                    log(`幸運の星が輝き、${selectedEffects.map(e => e.name).join('、')}の効果が発動！`);
                                    for (const effect of selectedEffects) {
                                        await effect.func();
                                    }
                                    flashCard(target, 'yellow');
                                    break;
                                }
                            case 'gambling_all_in':
                                { // オールイン
                                    const allInRoll = Math.random();
                                    log(`${caster.name}は${skill.name}！全てを賭けた！`);
                                    if (allInRoll < 0.4) { // 40% 敵全体にダメージ
                                        log("賭けは成功！敵全体にダメージ！");
                                        for (const t of target) {
                                            const damage = calculateDamage(caster, t, {
                                                ...skill,
                                                power: 1.8
                                            });
                                            await dealDamage(t, damage);
                                        }
                                    } else if (allInRoll < 0.6) { // 20% 味方全体を小回復
                                        log("悪くない！味方全体が少し回復した！");
                                        for (const p of gameState.party) {
                                            if (p.currentHp > 0) await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.2), 'increase');
                                        }
                                    } else if (allInRoll < 0.9) { // 30% 何も起こらない
                                        log("…しかし、何も起こらなかった。");
                                    } else { // 10% 自分がダメージ
                                        log("賭けに負けた！術者にダメージ！");
                                        await dealDamage(caster, Math.ceil(caster.maxHp * 0.25));
                                    }
                                    break;
                                }
                            case 'gambling_jackpot':
                                { // ジャックポット
                                    log(`${caster.name}は${skill.name}を狙う！`);
                                    if (Math.random() < 0.2) { // 20%で成功
                                        log("大当たり！ジャックポット！パーティが完全に回復し、強化された！");
                                        for (const p of gameState.party) {
                                            if (p.currentHp > 0) {
                                                await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                                await animateStatChange(p, 'mp', p.maxMp, 'increase');
                                                p.buffs.atk_up = 3;
                                                p.buffs.protect = 3;
                                                flashCard(p, 'green');
                                            }
                                        }
                                    } else {
                                        log("…しかし、何も起こらなかった。MPだけが無駄になった！");
                                    }
                                    break;
                                }
                            case 'reaper_instant_death':
                                { // 魂狩り
                                    log(`${caster.name}は${skill.name}を唱えた…！`); // ファイター, ソーサラー, ナイト, メディック
                                    if (target.isBoss && Math.random() < 0.15) {
                                        log(`鎌がボスの魂に深く突き刺さった！`);
                                        const bossDamage = Math.ceil(target.maxHp * 0.5);
                                        await dealDamage(target, bossDamage);
                                    } else if (!target.isBoss && Math.random() < 0.15) { // 15%で即死
                                        log(`鎌が${target.name}の魂を捉えた！`);
                                        await dealDamage(target, target.currentHp);
                                    } else {
                                        log("…しかし、魂を狩るには至らなかった！");
                                        const failDamage = calculateDamage(caster, target, skill);
                                        await dealDamage(target, failDamage);
                                    }
                                    break;
                                }
                            case 'reaper_height_scaling':
                                { // 影の一撃
                                    const heightDiff = Math.max(0, caster.initialHeight - caster.height);
                                    const bonusDamageFromSelf = Math.ceil(heightDiff * 2); // 自身の身長によるボーナス
                                    let bonusDamageFromEnemy = 0;
                                    // 敵の身長が自分より大きい場合、追加ボーナス
                                    if (target.isEnemy && target.height > caster.height) {
                                        const enemyHeightDiff = target.height - caster.height;
                                        bonusDamageFromEnemy = Math.floor(enemyHeightDiff * 0.1); // 身長差1cmあたり0.1ダメージ追加
                                    }
                                    const baseDamage = calculateDamage(caster, target, skill);
                                    const totalDamage = baseDamage + bonusDamageFromSelf + bonusDamageFromEnemy;
                                    log(`${caster.name}の${skill.name}！`);
                                    await dealDamage(target, totalDamage);
                                    log(`${target.name}に${totalDamage}のダメージ！`);
                                    break;
                                }
                            case 'reaper_soul_exchange':
                                { // 魂の交換
                                    const hpCost = Math.ceil(caster.currentHp / 2);
                                    await dealDamage(caster, hpCost, false, true); // isHeal=false, isSelfDamage=true
                                    const soulHealAmount = Math.ceil(hpCost * 1.5); // 削ったHPの1.5倍回復
                                    const mpAmount = Math.ceil(hpCost * 1.0); // 削ったHPと同じだけMP回復
                                    log(`${caster.name}は${skill.name}で自らの魂を分け与えた！`);
                                    await animateStatChange(target, 'hp', soulHealAmount, 'increase');
                                    await animateStatChange(target, 'mp', mpAmount, 'increase');
                                    log(`${target.name}のHPとMPが回復した！`);
                                    break;
                                }
                            case 'reaper_height_scaling_multi':
                                { // 冥府の鎌
                                    log(`${caster.name}は${skill.name}を振るった！`);
                                    const heightDiffMulti = Math.max(0, caster.initialHeight - caster.height);
                                    const bonusDamageMulti = Math.ceil(heightDiffMulti * 1); // 全体攻撃なのでボーナスは少し控えめ
                                    const damagePromisesReaper = [];
                                    for (const t of target) {
                                        let bonusDamageFromEnemyMulti = 0;
                                        // 敵の身長が自分より大きい場合、追加ボーナス
                                        if (t.isEnemy && t.height > caster.height) {
                                            const enemyHeightDiff = t.height - caster.height;
                                            bonusDamageFromEnemyMulti = Math.floor(enemyHeightDiff * 0.05); // 全体攻撃なのでボーナスはさらに控えめ
                                        }
                                        const totalDamageMulti = calculateDamage(caster, t, skill) + bonusDamageMulti + bonusDamageFromEnemyMulti;
                                        damagePromisesReaper.push(dealDamage(t, totalDamageMulti));
                                    }
                                    await Promise.all(damagePromisesReaper);
                                    break;
                                }
                            case 'summon_golem':
                                { // ゴーレム召喚
                                    let golemHp = Math.ceil(caster.maxHp * skill.power);
                                    let golemMaxHp = golemHp;

                                    // 術者にウォールがあるかチェック
                                    const casterIndex = gameState.party.indexOf(caster);
                                    const wallIndex = gameState.walls.findIndex(w => w.targetId === casterIndex);
                                    if (wallIndex !== -1) {
                                        const wall = gameState.walls[wallIndex];
                                        log(`${caster.name}は自らの防壁を破壊し、ゴーレムの素材にした！`);
                                        golemHp += wall.hp;
                                        golemMaxHp += wall.maxHp;
                                        // ウォールを削除
                                        gameState.walls.splice(wallIndex, 1);
                                    }

                                    gameState.golem = {
                                        name: 'ゴーレム',
                                        hp: golemHp,
                                        maxHp: golemMaxHp
                                    };
                                    log(`${caster.name}は${skill.name}を唱えた！パーティの前にゴーレムが現れた！`);
                                    updatePartyStatus();
                                    flashCard(caster, 'yellow');
                                    break;
                                }
                                // ネクロマンサー
                            case 'necro_magic':
                                {
                                    const killBonus = Math.ceil(gameState.killCount / 2); // 2体倒すごとに威力アップ
                                    const necroSkill = {
                                        ...skill,
                                        power: skill.power + killBonus * 0.2
                                    };
                                    if (Array.isArray(target)) { // 全体攻撃
                                        const damagePromisesNecro = [];
                                        log(`${caster.name}は${skill.name}を放った！`);
                                        for (const t of target) {
                                            damagePromisesNecro.push(dealDamage(t, calculateDamage(caster, t, necroSkill)));
                                        }
                                        await Promise.all(damagePromisesNecro);
                                    } else { // 単体攻撃
                                        const damage = calculateDamage(caster, target, necroSkill);
                                        await dealDamage(target, damage);
                                        log(`${caster.name}は${skill.name}を放った！ ${target.name}に${damage}のダメージ！`);
                                    }
                                    break;
                                }
                            case 'revive_full':
                                { // リザレクション
                                    if (target.currentHp > 0) {
                                        log(`しかし、${target.name}は戦闘不能ではなかった！`);
                                        caster.currentMp += skill.cost; // MPを消費しない
                                        break;
                                    }
                                    log(`${caster.name}は${skill.name}を唱えた！`);
                                    await animateStatChange(target, 'hp', target.maxHp, 'increase');
                                    flashCard(target, 'green');
                                    log(`${target.name}は完全な状態で戦線に復帰した！`);
                                    break;
                                }
                                // ネクロマンサー MPドレイン
                            case 'mp_drain':
                                {
                                    const drainDamage = Math.ceil(calculateDamage(caster, target, skill));
                                    await dealDamage(target, drainDamage);
                                    const mpDrainAmount = Math.max(1, Math.ceil(drainDamage * 0.2));
                                    await animateStatChange(caster, 'mp', mpDrainAmount, 'increase');
                                    log(`${caster.name}は${skill.name}で${target.name}に${drainDamage}のダメージを与え、MPを${mpDrainAmount}吸収した！`);
                                    break;
                                }
                                // ガーディアン
                            case 'guardian_wall':
                                {
                                    const wallHp = Math.ceil(caster.maxHp * (caster.buffs.guardian_high ? skill.power * 1.5 : skill.power));
                                    // 対象がゴーレム持ちのサモナーかチェック
                                    if (target.role === 'サモナー' && gameState.golem && gameState.golem.hp > 0) {
                                        gameState.golem.hp += wallHp;
                                        gameState.golem.maxHp += wallHp;
                                        log(`${caster.name}は${target.name}のゴーレムに防壁の力を注ぎ込んだ！ ゴーレムのHPが強化された！`);
                                    } else {
                                        gameState.walls.push({
                                            targetId: gameState.party.indexOf(target),
                                            hp: wallHp,
                                            maxHp: wallHp
                                        });
                                        log(`${caster.name}は${target.name}の前に${skill.name}を展開した！`);
                                    }
                                    if (caster.buffs.guardian_high) delete caster.buffs.guardian_high;
                                    break;
                                }
                            case 'guardian_wall_party':
                                {
                                    log(`${caster.name}は${skill.name}を展開した！`);
                                    gameState.party.forEach((p, index) => {
                                        if (p.currentHp > 0) {
                                            const wallHp = Math.ceil(caster.maxHp * skill.power);
                                            // 対象がゴーレム持ちのサモナーかチェック
                                            if (p.role === 'サモナー' && gameState.golem && gameState.golem.hp > 0) {
                                                gameState.golem.hp += wallHp;
                                                gameState.golem.maxHp += wallHp;
                                                log(`${p.name}のゴーレムが防壁の力を吸収し、強化された！`);
                                            } else {
                                                gameState.walls.push({
                                                    targetId: index,
                                                    hp: wallHp,
                                                    maxHp: wallHp
                                                });
                                            }
                                        }
                                    });
                                    break;
                                }
                            case 'self_buff_guardian':
                                {
                                    caster.buffs.protect = 3;
                                    caster.buffs.guardian_high = true;
                                    log(`${caster.name}は${skill.name}を発動！防御力が上がり、次のウォールが強化される！`);
                                    break;
                                }
                                // トラブルメーカー
                            case 'trouble_maker_box':
                                {
                                    // 実装は handleTroubleMakerBox に集約
                                    await handleTroubleMakerBox(caster);
                                    break;
                                }
                            case 'trouble_maker_debuff':
                                {
                                    const debuffDamage = calculateDamage(caster, target, skill);
                                    await dealDamage(target, debuffDamage);
                                    log(`${caster.name}は${skill.name}で${target.name}に${debuffDamage}のダメージを与えた！`);
                                    if (Math.random() < 0.4) { // 40%の確率でデバフ発動
                                        if (Math.random() < 0.5) {
                                            target.buffs.atk_down = 3;
                                            log(`さらに${target.name}の攻撃力が下がった！`);
                                        } else {
                                            target.buffs.def_down = 3;
                                            log(`さらに${target.name}の防御力が下がった！`);
                                        }
                                        flashCard(target, 'yellow');
                                    }
                                    break;
                                }
                            case 'self_buff_trouble':
                                {
                                    caster.buffs.trouble_check = true;
                                    log(`${caster.name}は${skill.name}を開始！次のハプニングボックスはきっとうまくいく！`);
                                    break;
                                }
                            case 'trouble_maker_miracle':
                                {
                                    handleTroubleMakerMiracle(caster);
                                    break;
                                }
                                // シスター
                            case 'special_magic':
                                { // ワンダーカーニバル, ソーンウィップ
                                    if (skill.name === 'ワンダーカーニバル') {
                                        const heightDiff = Math.max(0, caster.initialHeight - caster.height);
                                        const powerBonus = heightDiff * 0.05; // 身長が低いほど威力ボーナス
                                        log(`${caster.name}は${skill.name}を放った！`);
                                        for (const t of target) {
                                            const attackerStats = getEffectiveStats(caster);
                                            const defenderStats = getEffectiveStats(t);
                                            const baseDamage = attackerStats.atk * (skill.power + powerBonus);
                                            const damage = Math.max(1, Math.ceil((baseDamage - Math.min(defenderStats.pDef, defenderStats.mDef)) * (Math.random() * 0.2 + 0.9)));
                                            await dealDamage(t, damage);
                                            if (Math.random() < 0.3) {
                                                t.statusEffects.poison = {
                                                    turns: 3
                                                };
                                                log(`${t.name}は毒状態になった！`);
                                            }
                                        }
                                    } else if (skill.name === 'ソーンウィップ') {
                                        caster.thornWhipUses = (caster.thornWhipUses || 0) + 1;
                                        const powerBonus = Math.pow(caster.thornWhipUses, 2) * 0.5; // 使用回数の2乗でボーナス増加
                                        log(`${caster.name}は${skill.name}を放った！`);
                                        for (const t of target) {
                                            const damage = calculateDamage(caster, t, { // ファイター, ソーサラー, ナイト, メディック
                                                ...skill,
                                                power: skill.power + powerBonus
                                            });
                                            await dealDamage(t, damage);
                                        }
                                    }
                                    break;
                                }
                            case 'special_heal_alraune':
                                { // グロウヒール
                                    log(`${caster.name}は${skill.name}を唱えた！`);
                                    await animateStatChange(target, 'hp', target.maxHp, 'increase');
                                    target.buffs.protect = 3;
                                    log(`${target.name}のHPが全回復し、防御力が上がった！`);
                                    if (target === caster) {
                                        addItemToInventory('potion', 1);
                                        log(`さらに、${caster.name}はポーションを1つ手に入れた！`);
                                    }
                                    break;
                                }
                            case 'regeneration_ally':
                            case 'regeneration_party':
                                { // ファイター, ソーサラー, ナイト, メディック
                                    log(`${caster.name}は${skill.name}を唱えた！`);
                                    const regenTargets = skill.targetType === 'party' ? gameState.party.filter(p => p.currentHp > 0) : [target];

                                    for (const t of regenTargets) {
                                        t.statusEffects.regeneration = {
                                            turns: 3
                                        };
                                        flashCard(t, 'green');
                                        log(`${t.name}は聖なる光に包まれ、傷が再生し始めた！`);
                                    }
                                    // 「祈りの円環」の場合、追加でMP回復効果
                                    if (skill.name === '祈りの円環') {
                                        log("円環の光が、味方全体の魔力を満たしていく！");
                                        regenTargets.forEach(t => t.buffs.mp_regen_once = 2); // 1ターン後(次の自分のターン開始時)に発動
                                    }
                                    break;
                                }
                            case 'dancer_buff_pair':
                                { // ラブステップ
                                    log(`${caster.name}は${target.name}と${skill.name}を踊った！`);
                                    [caster, target].forEach(p => {
                                        p.buffs.agi_up = {
                                            turns: 3,
                                            power: 1.5
                                        };
                                        p.buffs.evade_up = {
                                            turns: 3,
                                            fromLoveStep: true
                                        }; // ラブステップ由来の回避バフ
                                        flashCard(p, 'yellow');
                                    });
                                    log(`${caster.name}と${target.name}の素早さと回避率が上がった！`);

                                    // 身長300cm以上で全体攻撃を追加
                                    if (caster.height > 300 || target.height > 300) {
                                        const shaker = caster.height > 300 ? caster : target;
                                        log(`${shaker.name}は巨大な体でステップを踏み、地面を揺らした！`);
                                        await new Promise(resolve => setTimeout(resolve, 1000)); // メッセージ表示のための待機

                                        const aliveEnemies = gameState.enemies.filter(e => e.currentHp > 0);
                                        const damagePromises = [];
                                        for (const enemy of aliveEnemies) {
                                            // 術者（リリカ）の攻撃力に基づく物理ダメージ
                                            const damage = calculateDamage(caster, enemy, {
                                                power: 0.5,
                                                type: 'physical'
                                            });
                                            damagePromises.push(dealDamage(enemy, damage));
                                        }
                                        await Promise.all(damagePromises);
                                        log(`敵全体に衝撃が走った！`);
                                    }
                                    break;
                                }
                            case 'dancer_party_buff_height':
                                { // キューティチアー
                                    let power = 1.5;
                                    if (caster.height <= 10) {
                                        power = 3.0;
                                    } else if (caster.height < caster.initialHeight) {
                                        const heightRatio = caster.height / caster.initialHeight; // 1未満
                                        power += (1 - heightRatio) * 1.5; // 1.5から3.0の間で線形に増加
                                    }
                                    power = parseFloat(power.toFixed(2));

                                    log(`${caster.name}の${skill.name}！ 味方全体の攻撃力が${power}倍になった！`);
                                    gameState.party.forEach(p => {
                                        if (p.currentHp > 0) {
                                            p.buffs.atk_up = {
                                                turns: 3,
                                                power: power
                                            };
                                            flashCard(p, 'yellow');
                                        }
                                    });
                                    break;
                                }
                            case 'dancer_tension_up':
                                { // センターオブステージ
                                    log(`${caster.name}は${skill.name}に立った！ パーティのテンションが最高潮に！`);
                                    gameState.party.forEach(p => {
                                        if (p.currentHp > 0) p.buffs.tension_up = true; // 永続バフ
                                    });
                                    break;
                                }
                            case 'alchemist_craft':
                                { // マジッククラフト
                                    // レベル4ごとに最大作成数が1増える (Lv1-3: 1-2個, Lv4-7: 1-3個, ...)
                                    const maxQuantity = 2 + Math.floor((caster.level - 1) / 4);
                                    const quantity = Math.floor(Math.random() * maxQuantity) + 1;
                                    const itemToCraft = Math.random() < 0.5 ? 'glass_blade' : 'crazy_bomb';
                                    const itemName = itemBlueprints[itemToCraft].name;

                                    addItemToInventory(itemToCraft, quantity);

                                    log(`${caster.name}は${skill.name}でアイテムを錬成した！`);
                                    await new Promise(resolve => setTimeout(resolve, 1000));
                                    log(`「${itemName}」を${quantity}個手に入れた！`);
                                    flashCard(caster, 'yellow');
                                    break;
                                }
                            case 'samurai_counter_stance':
                                { // 後の先
                                    caster.buffs.go_no_sen = 2; // 次の自分のターンが来るまで有効
                                    caster.buffs.provoke = 2;
                                    flashCard(caster, 'yellow');
                                    log(`${caster.name}は${skill.name}の構えをとった！敵の攻撃を待ち受ける！`);
                                    break;
                                }
                            case 'doctor_debuff':
                                { // 衰弱ガス
                                    log(`${caster.name}は${skill.name}を散布した！`);
                                    target.statusEffects.poison = {
                                        turns: 3
                                    };
                                    target.buffs.atk_down = 3;
                                    target.buffs.def_down = 3;
                                    flashCard(target, 'yellow');
                                    log(`${target.name}は毒におかされ、攻撃力と防御力が低下した！`);
                                    break;
                                }
                            case 'saint_wall':
                                { // セイクリッドウォール
                                    caster.buffs.protect = 3;
                                    const wallHp = Math.ceil(caster.maxHp * 0.1);
                                    // 既存のウォールがあれば耐久値を加算、なければ新規作成
                                    const casterIndex = gameState.party.indexOf(caster);
                                    const existingWall = gameState.walls.find(w => w.targetId === casterIndex);
                                    if (existingWall) {
                                        existingWall.hp += wallHp;
                                        existingWall.maxHp += wallHp;
                                        log(`${caster.name}の防壁がさらに強化された！`);
                                    } else {
                                        gameState.walls.push({
                                            targetId: casterIndex,
                                            hp: wallHp,
                                            maxHp: wallHp
                                        });
                                        log(`${caster.name}は聖なる障壁を展開した！`);
                                    }
                                    flashCard(caster, 'yellow');
                                    break;
                                }
                            case 'divine_light':
                                {
                                    // 敵の最大HPに対する割合ダメージ
                                    const damage = Math.ceil(target.maxHp * skill.power);
                                    log(`${caster.name}は${skill.name}を放った！ ${target.name}に聖なる光が降り注ぐ！`);
                                    // dealDamageは固定ダメージを直接与える
                                    await dealDamage(target, damage);
                                    log(`${target.name}に${damage}の神聖なダメージ！`);
                                    break;
                                }
                            case 'cure_strip_party':
                                { // ビーチエール
                                    log(`${caster.name}は${skill.name}でみんなを元気づけた！`);
                                    let cured = false;
                                    // 解放状態も解除する
                                    gameState.party.forEach(p => {
                                        if (p.isLiberatedStripped) delete p.isLiberatedStripped;
                                    });

                                    gameState.party.forEach(p => {
                                        if (p.statusEffects.stripped) {
                                            delete p.statusEffects.stripped;
                                            cured = true;
                                        }
                                    });
                                    if (cured) log("全員の脱衣状態が治った！");
                                    else log("しかし、誰も脱衣状態ではなかった。");
                                    break;
                                }
                            case 'guardian_stomp':
                                { // タイタンスタンプ
                                    const casterIndex = gameState.party.indexOf(caster);
                                    const wall = gameState.walls.find(w => w.targetId === casterIndex);
                                    if (wall) {
                                        const damage = wall.hp * 2; // 防壁の残りHPの2倍のダメージ
                                        log(`${caster.name}は防壁を砕き、${skill.name}を放った！`);
                                        await dealDamage(target, damage);
                                        // 防壁を削除
                                        gameState.walls = gameState.walls.filter(w => w.targetId !== casterIndex);
                                    } else {
                                        // 防壁がない場合、身長に応じてダメージを計算
                                        const attackerStats = getEffectiveStats(caster);
                                        // (基本攻撃力 + 身長ボーナス) * 揺らぎ でダメージを計算
                                        const damage = Math.max(1, Math.ceil((attackerStats.atk + caster.height * 0.5) * (Math.random() * 0.2 + 0.9)));
                                        log(`${caster.name}はその巨体で${skill.name}を放った！`);
                                        await dealDamage(target, damage);
                                    }
                                    break;
                                }
                            case 'self_wall':
                                { // リラックスタイム
                                    const wallHp = Math.ceil(caster.maxHp * 1.0);
                                    const casterIndex = gameState.party.indexOf(caster);
                                    gameState.walls.push({
                                        targetId: casterIndex,
                                        hp: wallHp,
                                        maxHp: wallHp
                                    });
                                    log(`${caster.name}は${skill.name}でくつろぎ、強力な防壁を展開した！`);
                                    break;
                                }
                            case 'party_mp_regen_special':
                                { // マジックオーラ
                                    log(`${caster.name}は${skill.name}を放ち、味方全体の魔力を活性化させた！`);
                                    gameState.party.forEach(p => {
                                        if (p.currentHp > 0) {
                                            p.buffs.mp_regen_once = 3; // 2ターン後まで効果持続
                                        }
                                    });

                                    if (caster.statusEffects.stripped) {
                                        caster.statusEffects.slow = {
                                            turns: 2
                                        };
                                        log(`しかし、${caster.name}はのぼせてしまい、動きが鈍くなった！`);
                                    } else {
                                        caster.statusEffects.stripped = {
                                            turns: 0
                                        };
                                        log(`しかし、${caster.name}は熱気にあてられ、タオルがはだけてしまった！`);
                                    }
                                    break;
                                }
                            case 'party_heal':
                                { // パッションハート
                                    log(`${caster.name}は${skill.name}で味方を癒した！`);
                                    let healRatio = 0.3;
                                    if (caster.isLiberatedStripped) {
                                        log(`${caster.name}の解放された心が、癒やしの力を増幅させる！`);
                                        await new Promise(resolve => setTimeout(resolve, 500));
                                        healRatio = 0.5; // 解放状態なら50%回復
                                    }
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        const healAmount = Math.ceil(p.maxHp * healRatio);
                                        await animateStatChange(p, 'hp', healAmount, 'increase');
                                    }
                                    break;
                                }
                            case 'self_heal_and_paralyze':
                                { // メンテナンス
                                    log(`${caster.name}は${skill.name}を開始した！`);
                                    await animateStatChange(caster, 'hp', caster.maxHp, 'increase');
                                    await animateStatChange(caster, 'mp', caster.maxMp, 'increase');
                                    caster.statusEffects.paralysis = {
                                        turns: 2
                                    }; // 1ターン麻痺(次のターンは動けない)
                                    log(`${caster.name}のHPとMPが全回復したが、システムがオーバーヒートし麻痺してしまった！`);
                                    break;
                                }
                            case 'hp_cost_growth':
                                { // バンプアップ
                                    if (caster.heightLocked) {
                                        log(`${caster.name}は${skill.name}を使おうとしたが、体が変化を拒んだ！`);
                                        // HPコストは消費される仕様のままにする
                                        break;
                                    }
                                    let growthAmount = skill.power;
                                    if (caster.height < caster.initialHeight) {
                                        log(`${caster.name}はまず初期身長に戻った！`);
                                        const resetAmount = caster.initialHeight - caster.height;
                                        await animateStatChange(caster, 'height', resetAmount, 'increase');
                                        await new Promise(resolve => setTimeout(resolve, 500)); // ログ表示のための短い待機
                                    }
                                    log(`${caster.name}は${skill.name}で自らのボディを強化！`);
                                    await animateStatChange(caster, 'height', growthAmount, 'increase');
                                    log(`${caster.name}の身長がさらに${growthAmount}cm伸びた！`);
                                    break;
                                }
                            case 'mp_burst_height_scaling':
                                { // オーバーブースト
                                    if (caster.currentMp < skill.cost) {
                                        log("MPが足りない！");
                                        break;
                                    }
                                    const heightBonus = Math.max(0, (caster.height - caster.initialHeight) * 0.1);
                                    const boostSkill = {...skill,
                                        power: skill.power + heightBonus
                                    };
                                    log(`${caster.name}は${skill.name}を放った！`);
                                    const damagePromises = [];
                                    for (const t of target) {
                                        damagePromises.push(dealDamage(t, calculateDamage(caster, t, boostSkill)));
                                    }
                                    await Promise.all(damagePromises);
                                    await animateStatChange(caster, 'mp', -caster.currentMp, 'decrease');
                                    break;
                                }
                            case 'party_buff_and_heal':
                                { // フラワーアレンジ
                                    log(`${caster.name}は${skill.name}で場を和ませた！`);
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        p.buffs.atk_up = 3;
                                        await animateStatChange(p, 'hp', 20, 'increase');
                                    }
                                    log("味方全体の攻撃力が上がり、HPが少し回復した！");
                                    break;
                                }
                            case 'height_transfer':
                                { // ロイヤルティ
                                    await handleRoyaltySkill(caster, target);
                                    break;
                                }
                            case 'party_cure_all':
                                { // ティータイム
                                    await handleTeaTimeSkill(caster);
                                    break;
                                }
                            case 'maid_special_buff':
                                { // マジカルエナジー
                                    await handleMagicalEnergySkill(caster);
                                    break;
                                }
                        }
                    }

                    async function handleItem(caster, target, item, isInternalCall = false) {
                        const itemInfo = itemBlueprints[item.id];
                        log(`${caster.name}は${itemInfo.name}を使った！`);

                        switch (itemInfo.effect) {
                            case 'shrink': // リトルスープの特殊処理
                                if (target && !target.isEnemy && target.heightLocked) {
                                    log(`${target.name}は不思議な力で守られており、スープを飲んでも変化がなかった！`);
                                    return false; // アイテム消費しない
                                }
                                if (target && target.isEnemy) {
                                    // 敵に使った場合
                                    target.buffs = target.buffs || {};
                                    target.buffs.atk_down = 3;
                                    target.buffs.def_down = 3;
                                    flashCard(target, 'yellow');
                                    log(`${target.name}は小さくなって弱々しくなった！攻撃力と防御力が低下！`);
                                } else {
                                    // 味方に使った場合
                                    await animateStatChange(target, 'height', -itemInfo.power, 'decrease');
                                    log(`${target.name}の身長が${itemInfo.power}cm縮んだ！`);
                                }
                                break;
                            case 'heal_percent':
                                if (itemInfo.target === 'party') {
                                    log(`味方全員のHPが回復した！`);
                                    for (const p of gameState.party) {
                                        if (p.currentHp > 0) {
                                            const partyHealAmount = Math.ceil(p.maxHp * itemInfo.power);
                                            await animateStatChange(p, 'hp', partyHealAmount, 'increase');
                                            flashCard(p, 'green');
                                            showDamagePopup(p, partyHealAmount, true);
                                        }
                                    }
                                } else {
                                    const itemHealAmount = Math.ceil(target.maxHp * itemInfo.power);
                                    await animateStatChange(target, 'hp', itemHealAmount, 'increase');
                                    flashCard(target, 'green');
                                    showDamagePopup(target, itemHealAmount, true);
                                    log(`${target.name}のHPが${itemHealAmount}回復した！`);
                                }
                                break;
                            case 'reset_height':
                                if (target.heightLocked) {
                                    log(`${target.name}は不思議な力で守られており、ミルクを飲んでも変化がなかった！`);
                                    return false; // アイテム消費しない
                                }
                                const resetDiff = target.initialHeight - target.height;
                                await animateStatChange(target, 'height', resetDiff, 'increase');
                                flashCard(target, 'yellow');
                                log(`${target.name}の身長が元に戻った！`);
                                break;
                            case 'set_height':
                                if (target.heightLocked) {
                                    log(`${target.name}は不思議な力で守られており、ギフトを受け取っても変化がなかった！`);
                                    return false; // アイテム消費しない
                                }
                                const setDiff = itemInfo.power - target.height;
                                const type = setDiff < 0 ? 'decrease' : 'increase';
                                await animateStatChange(target, 'height', setDiff, type); // Await height animation
                                flashCard(target, 'yellow'); // Flash the card itself
                                log(`${target.name}の身長が${itemInfo.power}cmになった！`);
                                break;
                            case 'damage':
                                {
                                    let baseDamage = itemInfo.power;
                                    let floorBonus = 0;
                                    if (item.id === 'glass_blade') {
                                        floorBonus = gameState.floor * 5;
                                    } else if (item.id === 'crazy_bomb') {
                                        floorBonus = gameState.floor * 3;
                                    }
                                    const finalDamage = baseDamage + floorBonus;

                                    if (itemInfo.target === 'enemies') {
                                        const damagePromisesItem = [];
                                        for (const t of target) {
                                            damagePromisesItem.push(dealDamage(t, finalDamage));
                                        }
                                        log(`敵全体に${finalDamage}のダメージ！`);
                                        await Promise.all(damagePromisesItem);
                                    } else {
                                        await dealDamage(target, finalDamage); // Await damage
                                        log(`${target.name}に${finalDamage}の特大ダメージ！`);
                                    }
                                    break;
                                }
                            case 'restore_mp_full':
                                const mpToRestore = target.maxMp - target.currentMp;
                                await animateStatChange(target, 'mp', mpToRestore, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}のMPが全回復した！`);
                                break;
                            case 'increase_max_hp':
                                target.maxHp += itemInfo.power;
                                await animateStatChange(target, 'hp', itemInfo.power, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}の最大HPが${itemInfo.power}上がった！`);
                                break;
                            case 'increase_max_mp':
                                target.maxMp += itemInfo.power;
                                await animateStatChange(target, 'mp', itemInfo.power, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}の最大MPが${itemInfo.power}上がった！`);
                                break;
                            case 'increase_height_and_initial':
                                if (target.heightLocked) {
                                    log(`${target.name}は不思議な力で守られており、エールを飲んでも変化がなかった！`);
                                    return false; // アイテム消費しない
                                }
                                let growthAmount = itemInfo.power;
                                if (target.height < target.initialHeight) {
                                    // 初期値より低い場合、まず初期値に戻す分の増加量を加える
                                    growthAmount += (target.initialHeight - target.height);
                                }
                                await animateStatChange(target, 'height', growthAmount, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}の体が大きく成長した！(身長+${growthAmount}cm)`);
                                break;
                            case 'revive':
                                if (target.currentHp > 0) {
                                    log(`しかし、${target.name}は戦闘不能ではなかった！`);
                                    return false; // アイテム使用失敗
                                }
                                const reviveHealAmount = Math.ceil(target.maxHp * itemInfo.power);
                                target.currentHp = 0; // HPを0にリセットしてから回復アニメーション
                                await animateStatChange(target, 'hp', reviveHealAmount, 'increase');
                                flashCard(target, 'green');
                                showDamagePopup(target, reviveHealAmount, true);
                                log(`${target.name}は意識を取り戻した！`);
                                break;
                            case 'shrink_party_and_debuff_enemies':
                                let anyShrunk = false;
                                log(`シュリンクアロマの香りが戦場に広がる！`);
                                // 味方全員の身長を縮める
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) {
                                        if (p.heightLocked) {
                                            log(`${p.name}は体の変化を拒んだ！`);
                                            continue;
                                        }
                                        anyShrunk = true;
                                        await animateStatChange(p, 'height', -itemInfo.power, 'decrease');
                                    }
                                }
                                if (anyShrunk) {
                                    for (const p of gameState.party) {
                                        if (p.currentHp > 0 && !p.heightLocked) await animateStatChange(p, 'height', -itemInfo.power, 'decrease');
                                    }
                                }
                                // 敵全員にデバフを付与
                                for (const e of gameState.enemies) {
                                    if (e.currentHp > 0) {
                                        e.statusEffects.stat_down = true;
                                    }
                                }
                                log(`敵が大幅に弱体化した！`);
                                break;
                            case 'lock_height_to_one':
                                if (target.heightLocked) {
                                    log(`${target.name}の体はすでに固定されているため、何も起こらなかった。`);
                                    return false; // アイテム消費しない
                                }
                                await animateStatChange(target, 'height', 1 - target.height, 'decrease');
                                target.heightLocked = true;
                                log(`${target.name}の体が妖精のように小さくなり、その姿で固定された！`);
                                break;
                            case 'increase_height_party':
                                log(`パーティ全員に${itemInfo.name}の効果！`);
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) {
                                        if (p.heightLocked) {
                                            log(`${p.name}は体の変化を拒んだ！`);
                                        } else {
                                            await animateStatChange(p, 'height', itemInfo.power, 'increase');
                                        }
                                    }
                                }
                                log(`全員の身長が${itemInfo.power}cm伸びた！`);
                                break;
                            case 'cure_all_and_restore':
                                await animateStatChange(target, 'hp', target.maxHp, 'increase');
                                await animateStatChange(target, 'mp', target.maxMp, 'increase');
                                target.statusEffects = {}; // 脱衣も治す
                                flashCard(target, 'green');
                                log(`${target.name}は完全に回復した！`);
                                break;
                            case 'lock_height_current':
                                await confirmAndLockHeight(target, target.height);
                                return true; // アイテム消費は確認後
                            case 'increase_height_party_30':
                                log(`パーティ全員に${itemInfo.name}の効果！`);
                                for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                    if (p.heightLocked) log(`${p.name}は体の変化を拒んだ！`);
                                    else await animateStatChange(p, 'height', 30, 'increase');
                                }
                                log(`全員の身長が30cm伸びた！`);
                                break;
                        }
                        // 献身の内部呼び出しではUIを更新しない
                        if (isInternalCall) {
                            return;
                        }
                        updatePartyStatus(); // Refresh all cards after animations
                        updateEnemyStatus(); // Enemy status doesn't have number animation, so it can be updated immediately
                        return true; // アイテム使用成功
                    }

                    function confirmAndLockHeight(target, height) {
                        return new Promise((resolve) => {
                            const modal = document.getElementById('height-lock-confirm-modal');
                            const text = document.getElementById('height-lock-confirm-text');
                            const confirmBtn = document.getElementById('height-lock-confirm-button');
                            const cancelBtn = document.getElementById('height-lock-cancel-button');

                            text.textContent = `${target.name}の身長を${height}cmで固定しますか？この冒険中、この効果は解除できません。`;
                            modal.classList.remove('hidden');

                            confirmBtn.onclick = () => {
                                modal.classList.add('hidden');
                                target.heightLocked = true;
                                animateStatChange(target, 'height', height - target.height, height >= target.height ? 'increase' : 'decrease');
                                log(`${target.name}の身長が${height}cmで固定された！`);
                                resolve(true); // アイテム使用成功
                            };

                            cancelBtn.onclick = () => {
                                modal.classList.add('hidden');
                                log("アイテムの使用をやめた。");
                                resolve(false); // アイテム使用失敗
                            };
                        });
                    }

                    function foundAlchemyEvent() {
                        const recipes = [{
                            name: 'エリクサー',
                            itemId: 'elixir',
                            ingredients: {
                                'potion': 1,
                                'mana_potion': 1,
                                'milk': 1
                            },
                            description: 'HP/MP/状態異常を全回復 (ポーション+マナポーション+ミルク)'
                        }, {
                            name: 'ギガントシロップ',
                            itemId: 'gigant_syrup',
                            ingredients: {
                                'pixie_gift': 1,
                                'fairy_syrup': 1,
                                'gigantes_ale': 1
                            },
                            description: '現在の身長で固定 (ピクシーギフト+フェアリーシロップ+ギガンテスエール)'
                        }, {
                            name: 'オーラスフィア',
                            itemId: 'aura_sphere',
                            ingredients: {
                                'cure_mist': 1,
                                'shrink_aroma': 1,
                                'crazy_bomb': 1
                            },
                            description: '全員の身長+30cm (キュアミスト+シュリンクアロマ+クレイジーボム)'
                        }];

                        const checkIngredients = (ingredients) => {
                            return Object.entries(ingredients).every(([itemId, requiredQty]) => {
                                const itemInInventory = gameState.inventory.find(i => i.id === itemId);
                                return itemInInventory && itemInInventory.quantity >= requiredQty;
                            });
                        };

                        const craftableRecipes = recipes.filter(r => checkIngredients(r.ingredients));

                        if (craftableRecipes.length === 0) {
                            log("調合を試みたが、材料が足りず何も作れなかった…。");
                            return;
                        }

                        alchemyOptions.innerHTML = '';
                        craftableRecipes.forEach(recipe => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg text-left';
                            button.innerHTML = `<strong class="text-lg">${recipe.name}</strong><span class="block text-sm text-purple-100 mt-1">${recipe.description}</span>`;
                            button.onclick = () => {
                                // 材料を消費
                                Object.entries(recipe.ingredients).forEach(([itemId, requiredQty]) => {
                                    const itemInInventory = gameState.inventory.find(i => i.id === itemId);
                                    itemInInventory.quantity -= requiredQty;
                                });
                                // 完成品を追加
                                addItemToInventory(recipe.itemId, 1);
                                log(`調合に成功し、「${recipe.name}」を1個手に入れた！`);
                                flashCard(gameState.party[0], 'yellow');
                                alchemyModal.classList.add('hidden');
                                dungeonCommands.classList.remove('hidden');
                            };
                            alchemyOptions.appendChild(button);
                        });

                        alchemyModal.classList.remove('hidden');
                        dungeonCommands.classList.add('hidden');
                    }

                    alchemyCancelButton.onclick = () => {
                        alchemyModal.classList.add('hidden');
                        log("調合をやめて、探索を続けることにした。");
                        dungeonCommands.classList.remove('hidden');
                    };


                    async function handleTreasureHunterAttack(character, target) {
                        log(`${character.name}は${target.name}からアイテムを盗もうとした！`);

                        if (target.stolen) {
                            log(`しかし、${target.name}からはもう何も盗めない！`);
                            if (Math.random() < 0.5) {
                                target.buffs = target.buffs || {};
                                target.buffs.atk_down = 3;
                                log(`${target.name}の攻撃力が下がった！`);
                            } else {
                                target.buffs = target.buffs || {};
                                target.buffs.def_down = 3;
                                log(`${target.name}の防御力が下がった！`);
                            }
                            const mpHeal = Math.ceil(character.maxMp * 0.15);
                            await animateStatChange(character, 'mp', mpHeal, 'increase');
                            log(`${character.name}はMPを${mpHeal}回復した！`);
                            return;
                        }

                        const successRate = 0.5 + (getEffectiveStats(character).agi - getEffectiveStats(target).agi) * 0.02;
                        if (Math.random() < successRate) {
                            const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].rare && !itemBlueprints[id].special);
                            const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                            addItemToInventory(foundItemId);
                            log(`盗みに成功！「${itemBlueprints[foundItemId].name}」を手に入れた！`);
                            target.stolen = true; // 盗み済みフラグ
                            flashCard(character, 'yellow');
                        } else {
                            log("しかし、盗みは失敗した！");
                            flashCard(character, 'red');
                        }
                    }

                    async function handleTransform(character, skill) {
                        if (skill.type === 'transform_revert') {
                            // 変身解除
                            if (character.originalState) {
                                log(`${character.name}は変身を解き、元の姿に戻った！`);
                                character.role = character.originalState.role;
                                character.skills = character.originalState.skills;
                                character.bgClass = character.originalState.bgClass;
                                // 身長は維持するため、originalState.height には戻さない
                                delete character.originalState;
                                delete character.isTransformed;
                                delete character.thornWhipUses;
                            }
                        } else {
                            // 変身処理
                            const transformType = skill.type.split('_')[1]; // 'succubus', 'fairy', 'alraune'
                            const blueprint = allCharacterBlueprints.find(c => c.name === 'リリィ');
                            const transformData = blueprint.transforms[transformType];

                            if (!transformData) return;

                            // 元の状態を保存
                            character.originalState = {
                                role: character.role,
                                skills: character.skills,
                                bgClass: character.bgClass,
                                height: character.height
                            };

                            log(`${character.name}は${transformData.role}に変身した！`);

                            // ステータス、スキル、見た目を変更
                            character.role = transformData.role;
                            character.skills = transformData.skills;
                            character.bgClass = transformData.bgClass;
                            character.isTransformed = true;

                            // 変身時の特殊効果
                            switch (transformType) {
                                case 'succubus':
                                    await animateStatChange(character, 'height', 30, 'increase');
                                    break;
                                case 'fairy':
                                    await animateStatChange(character, 'height', -30, 'decrease');
                                    break;
                                case 'alraune':
                                    await animateStatChange(character, 'hp', character.maxHp, 'increase');
                                    break;
                            }
                        }
                        updatePartyStatus();
                    }
                    async function handleRoyaltySkill(caster, target) {
                        log(`${caster.name}は${target.name}に${caster.skills.find(s => s.type === 'height_transfer').name}を発動！`);
                        if (target.heightLocked) {
                            log(`しかし、${target.name}の体は不思議な力で守られており、変化しなかった！`);
                            caster.currentMp += 20; // MP消費をキャンセル
                            return;
                        }

                        let totalHeightToTransfer = 0;
                        const otherMembers = gameState.party.filter(p => p !== target && p.currentHp > 0);

                        for (const member of otherMembers) {
                            if (member.heightLocked) {
                                log(`${member.name}の体は変化を拒んだ！`);
                                continue;
                            }
                            const heightToGive = member.height - 1;
                            if (heightToGive > 0) {
                                totalHeightToTransfer += heightToGive;
                                await animateStatChange(member, 'height', -heightToGive, 'decrease');
                            }
                        }

                        if (totalHeightToTransfer > 0) {
                            await animateStatChange(target, 'height', totalHeightToTransfer, 'increase');
                            log(`${target.name}に仲間たちの身長が集約され、他のメンバーは1cmになった！`);
                        } else {
                            log("しかし、誰も身長を分け与えることができなかった…。");
                        }
                    }

                    async function handleTeaTimeSkill(caster) {
                        log(`${caster.name}は優雅に${caster.skills.find(s => s.type === 'party_cure_all').name}の準備をした！`);
                        let curedAny = false;
                        gameState.party.forEach(p => {
                            if (p.currentHp > 0) {
                                const effects = Object.keys(p.statusEffects);
                                if (effects.length > 0) {
                                    curedAny = true;
                                    p.statusEffects = {};
                                    log(`${p.name}の状態異常がすべて治った！`);
                                    flashCard(p, 'green');
                                }
                            }
                        });
                        if (!curedAny) {
                            log("…が、誰も状態異常ではなかったようだ。");
                        }
                    }

                    async function handleMagicalEnergySkill(caster) {
                        log(`${caster.name}は${caster.skills.find(s => s.type === 'maid_special_buff').name}を発動！`);
                        caster.buffs.provoke = 3;
                        caster.buffs.atk_up = 3;
                        caster.buffs.protect = 3;
                        caster.buffs.hp_absorb = true; // 永続
                        caster.buffs.heal_spread = true; // 永続
                        if (caster.height < caster.initialHeight) {
                            await animateStatChange(caster, 'height', caster.initialHeight - caster.height, 'increase');
                        }
                        log(`${caster.name}は不思議な力に包まれ、大幅に強化された！`);
                        flashCard(caster, 'yellow');
                    }


                    async function handleTroubleMakerBox(caster) {
                        log(`${caster.name}は${caster.skills[0].name}を開けた！`);
                        const isChecked = caster.buffs.trouble_check;
                        const successRate = isChecked ? 0.9 : 0.6; // ばっちりチェックで成功率90%
                        if (isChecked) delete caster.buffs.trouble_check;

                        if (Math.random() < successRate) {
                            // 成功

                            // 大あたり抽選 (ばっちりチェック中のみ)
                            if (isChecked && Math.random() < 0.1) { // 10%の確率で大あたり
                                log("箱から眩い光が！これは…大当たりだ！");
                                const isBossBattle = gameState.enemies.some(e => e.isBoss); // ファイター, ソーサラー, ナイト, メディック
                                if (isBossBattle) {
                                    const boss = gameState.enemies.find(e => e.isBoss);
                                    const damage = Math.floor(boss.maxHp * 0.5);
                                    log(`ボスの体に亀裂が走る！`);
                                    await dealDamage(boss, damage);
                                } else {
                                    log("敵が一瞬で塵と化した！");
                                    const damagePromises = [];
                                    for (const enemy of gameState.enemies.filter(e => e.currentHp > 0)) {
                                        damagePromises.push(dealDamage(enemy, enemy.currentHp));
                                    }
                                    await Promise.all(damagePromises);
                                }
                                return; // 大あたりの場合はここで処理終了
                            }

                            // 通常の成功効果
                            const goodEffects = [
                                async() => {
                                    log("箱から光が溢れ、敵全体に大ダメージ！");
                                    const damagePromisesBox = gameState.enemies.filter(e => e.currentHp > 0).map(enemy => dealDamage(enemy, 150 + caster.atk * 2));
                                    await Promise.all(damagePromisesBox);
                                },
                                async() => {
                                    log("箱からお菓子が飛び出し、味方全体が回復した！"); // 回復は1人ずつアニメーション
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        await animateStatChange(p, 'hp', Math.ceil(p.maxHp * 0.5), 'increase');
                                    }
                                }, {
                                    name: "あたり",
                                    func: () => {
                                        log("箱から虹色のオーラが！味方全体が強化され、傷が癒えていく！");
                                        gameState.party.forEach(p => {
                                            if (p.currentHp > 0) {
                                                p.buffs.atk_up = 3;
                                                p.statusEffects.regeneration = {
                                                    turns: 3
                                                };
                                                flashCard(p, 'yellow');
                                            }
                                        });
                                    }
                                },
                                () => {
                                    log("箱から怪しいガスが！敵全体が弱体化した！");
                                    gameState.enemies.forEach(e => {
                                        if (e.currentHp > 0) e.statusEffects.stat_down = true;
                                    });
                                }
                            ];
                            const chosenGoodEffect = goodEffects[Math.floor(Math.random() * goodEffects.length)];
                            await (typeof chosenGoodEffect === 'function' ? chosenGoodEffect() : chosenGoodEffect.func());
                        } else {
                            // 失敗
                            const badEffects = [{
                                name: "shrink",
                                func: async() => {
                                    log("箱から黒い煙が！味方全体が縮んでしまった！");
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        await animateStatChange(p, 'height', -30, 'decrease');
                                    }
                                }
                            }, {
                                name: "tiny_damage",
                                func: async() => {
                                    const randomEnemy = gameState.enemies.filter(e => e.currentHp > 0)[Math.floor(Math.random() * gameState.enemies.filter(e => e.currentHp > 0).length)];
                                    if (randomEnemy) {
                                        log("箱からかわいい小動物が飛び出して、敵にかみついた！");
                                        await dealDamage(randomEnemy, 1);
                                    } else {
                                        log("箱からかわいい小動物が飛び出したが、何事もなかった。");
                                    }
                                }
                            }, {
                                name: "strip_all",
                                func: () => {
                                    log("箱から妖しい光が！ なんと味方全員が脱衣状態になってしまった！");
                                    gameState.party.forEach(p => { // ファイター, ソーサラー, ナイト, メディック
                                        if (p.currentHp > 0 && p.role !== 'ナイト' && p.role !== 'サムライ' && p.role !== '聖女') {
                                            p.statusEffects.stripped = {
                                                turns: 0
                                            };
                                        }
                                    });
                                }
                            }, ];
                            const chosenEffect = badEffects[Math.floor(Math.random() * badEffects.length)];
                            await chosenEffect.func();
                        }
                    }

                    async function handleTroubleMakerMiracle(caster) {
                        const isChecked = caster.buffs.trouble_check;
                        log(`${caster.name}は${caster.skills.find(s => s.type === 'trouble_maker_miracle').name}を使った！`);
                        if (isChecked) {
                            delete caster.buffs.trouble_check;
                            log("ばっちりチェックの効果で、奇跡は確実に起こる！");
                        }

                        // ばっちりチェック中ではない場合、5%で失敗
                        if (!isChecked && Math.random() < 0.05) {
                            log("…しかし、何も起こらなかった！");
                        } else {
                            log("奇跡の光がパーティを包む！");
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                await animateStatChange(p, 'mp', p.maxMp, 'increase');
                                p.buffs.atk_up = 3;
                                p.buffs.protect = 3;
                                flashCard(p, 'green');
                            }
                            log("味方全体が全回復し、強化された！");
                        }
                    }


                    async function enemyTurn(enemy) {
                        log(`${enemy.name}のターン`);
                        enemy.turnCount = (enemy.turnCount || 0) + 1; // ターン数をカウント

                        // アークリッチの特殊AI (1ターン目に必ず「いたずら」)
                        if (enemy.name === 'アークリッチ' && enemy.turnCount === 1) { // ファイター, ソーサラー, ナイト, メディック
                            const archlichTarget = findTarget(enemy);
                            await inflictStrippedForArchlich(enemy, archlichTarget);
                            endEnemyTurn(enemy); // ターン終了
                            return;
                        }

                        const target = findTarget(enemy);

                        // 星の観測者の特殊AI
                        if (enemy.specialAIType === 'star_observer') {
                            if (enemy.buffs && enemy.buffs.omen) {
                                // 奥義準備中の行動
                                if (enemy.buffs.omen === 1) {
                                    // 最終ターンにブラックホール
                                    await blackholeSkill(enemy, target);
                                } else {
                                    // それ以外の準備ターン
                                    const roll = Math.random();
                                    if (roll < 0.4) { // 40%で全体縮小
                                        log(`${enemy.name}は星屑のシャワーを降らせた！`);
                                        for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                            if (!p.heightLocked) await animateStatChange(p, 'height', -20, 'decrease');
                                        }
                                    } else if (roll < 0.7) { // 30%で単体ステータス吸収
                                        log(`${enemy.name}は${target.name}の才能を盗み見た！`);
                                        const statToSteal = ['atk', 'def', 'agi'][Math.floor(Math.random() * 3)];
                                        target.buffs[`${statToSteal}_down`] = 3;
                                        enemy.buffs[`${statToSteal}_up`] = 3;
                                        log(`${target.name}の${statToSteal === 'atk' ? '攻撃力' : statToSteal === 'def' ? '防御力' : '素早さ'}が下がり、${enemy.name}の能力が上がった！`);
                                    } else { // 30%で通常攻撃
                                        await defaultEnemyAttack(enemy, target);
                                    }
                                }
                            } else {
                                // 1ターン目は必ず「瞬き」
                                await blinkSkill(enemy);
                            }
                            endEnemyTurn(enemy);
                            return;
                        }

                        // 模倣体の特殊AI
                        if (enemy.specialAIType === 'imitation') {
                            // 50%の確率でスキルを使用
                            if (enemy.skills.length > 0 && Math.random() < 0.5) {
                                // 使用させたくないスキルタイプを除外
                                const unusableSkillTypes = ['utility', 'samurai_counter_stance', 'summon_golem', 'guardian_wall'];
                                const usableSkills = enemy.skills.filter(s => !unusableSkillTypes.includes(s.originalType));

                                if (usableSkills.length > 0) {
                                    const originalSkill = usableSkills[Math.floor(Math.random() * usableSkills.length)];
                                    log(`${enemy.name}は「${originalSkill.name}」を模倣した！`);
                                    await new Promise(resolve => setTimeout(resolve, 1000));

                                    // 模倣スキルの効果を簡略化
                                    if (originalSkill.targetType === 'enemy') {
                                        // 単体攻撃スキル
                                        const isMagic = originalSkill.originalType.includes('magic');
                                        const damage = calculateDamage(enemy, target, {
                                            type: isMagic ? 'magic' : 'physical',
                                            power: 2.0
                                        });
                                        await dealDamage(target, damage);
                                        log(`${enemy.name}の強力な一撃！ ${target.name}に${damage}のダメージ！`);
                                    } else if (originalSkill.targetType === 'enemies') {
                                        // 全体攻撃スキル
                                        const isMagic = originalSkill.originalType.includes('magic');
                                        log(`${enemy.name}は全体攻撃を放った！`);
                                        const damagePromises = [];
                                        for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                            const damage = calculateDamage(enemy, p, {
                                                type: isMagic ? 'magic' : 'physical',
                                                power: 1.2
                                            });
                                            damagePromises.push(dealDamage(p, damage));
                                        }
                                        await Promise.all(damagePromises);
                                    } else {
                                        // 自己強化・回復スキル
                                        if (Math.random() < 0.5) {
                                            enemy.buffs.atk_up = 3;
                                            log(`${enemy.name}は自身の攻撃力を上げた！`);
                                        } else {
                                            const healAmount = Math.ceil(enemy.maxHp * 0.2);
                                            await dealDamage(enemy, -healAmount, true);
                                            log(`${enemy.name}は自身のHPを${healAmount}回復した！`);
                                        }
                                    }
                                    endEnemyTurn(enemy);
                                    return;
                                }
                            }
                            // スキルを使わない、または使えるスキルがない場合は通常攻撃
                            await defaultEnemyAttack(enemy, findTarget(enemy));
                            endEnemyTurn(enemy);
                            return; // 模倣体のターンを終了
                        } // ファイター, ソーサラー, ナイト, メディック

                        // ターゲットがゴーレムやウォールの場合、特殊行動はせず通常攻撃
                        const isDefensiveTarget = target.isWall || target === gameState.golem;


                        // 敵のバフ・デバフターン経過処理
                        if (enemy.buffs) {
                            Object.keys(enemy.buffs).forEach(key => {
                                enemy.buffs[key]--;
                                if (enemy.buffs[key] <= 0) {
                                    delete enemy.buffs[key];
                                    let buffName = '';
                                    if (key === 'atk_down') buffName = '攻撃力低下';
                                    else if (key === 'def_down') buffName = '防御力低下';
                                    if (buffName) {
                                        log(`${enemy.name}の${buffName}効果が切れた。`);
                                    }
                                }
                            });
                        }

                        let actionTaken = false;

                        if (enemy.specialAIType === 'phantom_hero') {
                            if (enemy.turnCount === 1) {
                                await chainLockSkill(enemy);
                                actionTaken = true;
                            } else if (enemy.currentHp / enemy.maxHp < 0.5 && !enemy.usedFocus) {
                                await focusSkill(enemy);
                                enemy.usedFocus = true;
                                actionTaken = true;
                            } else if (enemy.currentHp / enemy.maxHp < 0.15 && !enemy.usedHeroicEnd) {
                                await heroicEndSkill(enemy, target);
                                enemy.usedHeroicEnd = true;
                                actionTaken = true;
                            } else if (enemy.specialAIType === 'aqua_dragon' && enemy.turnCount === 1) {
                                // アクアドラゴンの初手行動
                                const skill = enemy.skills.find(s => s.name === 'ミニマムシャワー');
                                if (skill && skill.func) {
                                    await skill.func(enemy);
                                }
                            }
                        } else if (enemy.name === 'インプ' && !enemy.mischiefUsed && !isDefensiveTarget && Math.random() < 0.25) {
                            actionTaken = await inflictStripped(enemy, target);
                        } else if (enemy.name === 'アークリッチ' && enemy.turnCount === 1) {
                            await inflictStrippedForArchlich(enemy, target);
                            actionTaken = true;
                        } else if (enemy.skills && enemy.skills.length > 0 && !isDefensiveTarget && Math.random() < 0.5) {
                            const skill = enemy.skills[Math.floor(Math.random() * enemy.skills.length)];
                            if (skill.name === '状態異常攻撃') {
                                inflictStatusEffect(enemy, target);
                                actionTaken = true;
                            } else if (skill.func) {
                                await skill.func(enemy, target);
                                actionTaken = true;
                            }
                        }

                        // どの特殊行動も実行されなかった場合、通常攻撃を行う
                        if (!actionTaken) {
                            await defaultEnemyAttack(enemy, target);
                        }

                        // 旧ロジックを削除
                        /*
                        ...
                        } else {
                            // 通常攻撃
                            await defaultEnemyAttack(enemy, target);
                        }*/

                        endEnemyTurn(enemy);
                    }

                    async function endEnemyTurn(enemy) {
                        updatePartyStatus(); // Refresh all cards after animations
                        updateEnemyStatus();

                        // ターン終了時の反撃処理
                        if (enemy.counterTarget) {
                            const {
                                counterAttacker,
                                damage, // ファイター, ソーサラー, ナイト, メディック
                                isHpAbsorb
                            } = enemy.counterTarget;
                            await counterAttack(counterAttacker, enemy, damage, isHpAbsorb);
                            delete enemy.counterTarget; // 反撃処理後にクリア
                        }

                        // ターン終了時の毒ダメージ
                        if (enemy.statusEffects && enemy.statusEffects.poison) {
                            const poisonDamage = Math.max(1, Math.ceil(enemy.maxHp * 0.05));
                            log(`${enemy.name}は毒のダメージを受けている！`);
                            await dealDamage(enemy, poisonDamage);
                            updateEnemyStatus();
                        }

                        // ターン終了時の自然治癒
                        if (enemy.statusEffects && enemy.statusEffects.regeneration) {
                            let healAmount = Math.max(1, Math.ceil(enemy.maxHp * 0.08));
                            // 祝福の処理
                            if (character.blessings && character.blessings.hp_regen) {
                                healAmount += Math.max(1, Math.ceil(character.maxHp * 0.05));
                            }
                            if (character.blessings && character.blessings.mp_regen) {
                                const mpHeal = Math.max(1, Math.ceil(character.maxMp * 0.05));
                                animateStatChange(character, 'mp', mpHeal, 'increase');
                            }
                            log(`${enemy.name}の傷が再生していく！`); // 敵の回復ログ
                            await dealDamage(enemy, -healAmount, true);
                            updateEnemyStatus();
                        }

                        setTimeout(() => {
                            gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                            nextTurn();
                        }, 1000);
                    }

                    async function defaultEnemyAttack(enemy, target, power = 1.0) {
                        const damage = calculateDamage(enemy, target);
                        if (damage === 'evaded' && target.role === 'ダンサー' && target.buffs && target.buffs.provoke) {
                            // ダンサーの回避時反撃
                            let counterMessage = `${target.name}は攻撃を華麗にかわし、反撃の体勢に入った！`;
                            let counterPowerMultiplier = 1.0;
                            if (target.isLiberatedStripped) {
                                counterMessage = `${target.name}の解放された肉体が、反撃の威力を増大させる！`;
                                counterPowerMultiplier = 2.0;
                            }
                            log(counterMessage);
                            // ダンサー(target)が敵(enemy)に反撃する
                            const counterDamage = calculateDamage(target, enemy, null, true);
                            enemy.counterTarget = {
                                counterAttacker: target,
                                damage: counterDamage * counterPowerMultiplier
                            };
                        } else if (damage === 'evaded') {
                            log(`${target.name}は攻撃をかわした！`);
                            showDamagePopup(target, '回避');
                            flashCard(target, 'yellow');
                        } else {
                            // サムライ「後の先」の反撃
                            if (target.buffs && target.buffs.go_no_sen) {
                                log(`${target.name}は後の先で反撃！`);
                                enemy.counterTarget = {
                                    counterAttacker: target,
                                    damage: getEffectiveStats(target).atk * 2 // 攻撃力を倍にして反撃
                                };
                            } else if (target.role === 'ナイト' && target.buffs && target.buffs.provoke && Math.random() < 0.5) {
                                // ナイトの被弾時反撃
                                enemy.counterTarget = { // ファイター, ソーサラー, ナイト, メディック
                                    counterAttacker: target,
                                    damage: getEffectiveStats(target).atk
                                };
                            }
                            // 祝福: 反撃
                            if (target.blessings && target.blessings.counter_attack && Math.random() < 0.3) {
                                log(`${target.name}は祝福の力で反撃の構えをとった！`);
                                enemy.counterTarget = {
                                    counterAttacker: target,
                                    damage: getEffectiveStats(target).atk
                                };
                            }
                            // メイドのHP吸収
                            if (target.buffs && target.buffs.hp_absorb) {
                                enemy.counterTarget = {
                                    counterAttacker: target,
                                    damage: getEffectiveStats(target).atk,
                                    isHpAbsorb: true // HP吸収フラグを追加
                                }; // ファイター, ソーサラー, ナイト, メディック
                            }

                            // 通常のダメージ処理
                            // 反撃の祝福
                            if (target.blessings && target.blessings.counter_attack && Math.random() < 0.3) {
                                enemy.counterTarget = {
                                    counterAttacker: target,
                                    damage: getEffectiveStats(target).atk
                                };
                            }
                            await dealDamage(target, damage);
                            if (target.isWall) {
                                log(`${enemy.name}の攻撃！ 防壁に${damage}のダメージ！`);
                            } else {
                                log(`${enemy.name}の攻撃！ ${target.name}に${damage}のダメージ！`);
                            }
                        }

                        // 接頭辞による追加効果
                        if (enemy.name.startsWith('【毒纏い】') && !target.isWall && target !== gameState.golem && Math.random() < 0.2) {
                            log(`${enemy.name}の攻撃から毒が放たれた！`);
                            target.statusEffects.poison = {
                                turns: 3
                            };
                            flashCard(target, 'yellow');
                            log(`${target.name}は毒状態になった！`);
                        }

                        if (enemy.name.startsWith('【痺れる】') && !target.isWall && target !== gameState.golem && Math.random() < 0.2) {
                            log(`${enemy.name}の攻撃から電撃が走った！`);
                            target.statusEffects.paralysis = true;
                            flashCard(target, 'yellow');
                            log(`${target.name}は麻痺してしまった！`);
                        }

                        updatePartyStatus();

                    }

                    async function counterAttack(counterAttacker, originalAttacker, damage, isHpAbsorb = false) {
                        log(`${counterAttacker.name}の反撃！`);
                        const counterDamage = Math.max(1, damage); // 保存しておいたダメージをそのまま使う
                        await dealDamage(originalAttacker, counterDamage);
                        log(`${originalAttacker.name}に${counterDamage}のダメージ！`);

                        // HP吸収効果の処理
                        if (isHpAbsorb) {
                            const absorbAmount = Math.ceil(counterDamage * 0.2);
                            log(`${counterAttacker.name}は反撃から生命力を吸収した！`);
                            await dealDamage(counterAttacker, -absorbAmount, true); // isHealをtrueにしてdealDamageを呼び出す
                        }
                    }

                    async function heroicEndSkill(enemy, target) {
                        log(`${enemy.name}は${enemy.skills[2].name}を放つ！`);
                        const damage = calculateDamage(enemy, target, {
                            power: 3.5
                        }); // 高威力
                        await dealDamage(target, damage);
                        log(`${enemy.name}の${enemy.skills[2].name}！ ${target.name}に${damage}の特大ダメージ！`);
                    }


                    function findTarget(enemy, forCounterDamageCalc = false) {
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);

                        // インプが集中攻撃対象を持っている場合
                        if (enemy.name === 'インプ' && enemy.focusedTargetId !== null) {
                            const focused = gameState.party[enemy.focusedTargetId];
                            if (focused && focused.currentHp > 0) return focused;
                        }

                        // ガーディアンのウォール判定
                        const wallsOnParty = gameState.walls.map((wall, index) => ({...wall,
                            wallIndex: index
                        })).filter(wall => aliveParty.some(p => gameState.party.indexOf(p) === wall.targetId));

                        if (wallsOnParty.length > 0) {
                            // 複数のウォールがある場合、ランダムで1つをターゲットにする
                            const randomWall = wallsOnParty[Math.floor(Math.random() * wallsOnParty.length)];
                            return {...randomWall,
                                isWall: true
                            };
                        }

                        // 「英雄の幻影」の特殊AI
                        if (enemy.specialAIType === 'phantom_hero') {
                            const provokingChar = aliveParty.find(p => p.buffs && (p.buffs.provoke || p.buffs.cover));
                            const golemActive = gameState.golem && gameState.golem.hp > 0;
                            const wallActive = gameState.walls.length > 0;

                            if (provokingChar) {
                                return provokingChar;
                            }
                            if (golemActive) {
                                return gameState.golem;
                            }
                            if (wallActive) {
                                const randomWall = gameState.walls[Math.floor(Math.random() * gameState.walls.length)];
                                return {...randomWall,
                                    isWall: true,
                                    wallIndex: gameState.walls.indexOf(randomWall)
                                };
                            }
                        }

                        // ゴーレムが召喚されていれば最優先でターゲットにする
                        if (gameState.golem && gameState.golem.hp > 0) {
                            return gameState.golem;
                        }

                        // 「かばう」状態のキャラがいれば最優先
                        const coveringMember = aliveParty.find(p => p.buffs && p.buffs.cover);
                        if (coveringMember) {
                            return coveringMember;
                        }

                        updateHate();
                        const totalHate = aliveParty.reduce((sum, char) => sum + char.hate, 0);
                        let random = Math.random() * totalHate;
                        for (const char of aliveParty) {
                            random -= char.hate;
                            if (random <= 0) return char;
                        }
                        return aliveParty[0];
                    }

                    function calculateDamage(attacker, defender, skill = null, isCounter = false) {
                        const attackerStats = getEffectiveStats(attacker);
                        let skillPowerMultiplier = 1.0;
                        let baseAtk;

                        // 魔法攻撃の場合、身長補正を無視し、バフのみを適用した攻撃力を計算
                        if (skill && (skill.type === 'magic' || skill.type.includes('magic'))) {
                            baseAtk = attacker.atk; // 素の攻撃力
                            if (attacker.buffs && attacker.buffs.atk_up) {
                                baseAtk *= 1.5; // 攻撃力アップバフは適用
                            }
                            // リーパーの脱衣デバフも適用
                            if (attacker.statusEffects && attacker.statusEffects.stripped && attacker.role === 'リーパー') {
                                baseAtk *= 0.5;
                            }
                        } else if (isCounter) {
                            // ダンサーの反撃ダメージ計算時: 敵の素の攻撃力を参照
                            baseAtk = attacker.atk;
                        } else {
                            // 物理攻撃や通常攻撃の場合は、身長補正を含む攻撃力を使用
                            baseAtk = attackerStats.atk;
                        }

                        // インプが脱衣状態の相手を攻撃する場合、ダメージを減少させる
                        if (attacker.name === 'インプ' && defender.statusEffects && defender.statusEffects.stripped) {
                            baseAtk *= 0.7; // ダメージを30%減少
                        }


                        // 渾身斬りのクリティカル判定
                        if (skill && skill.name === '渾身斬り' && Math.random() < 0.3) {
                            log('会心の一撃！');
                            skillPowerMultiplier = 3; // ダメージ計算用の倍率を変更 // ファイター, ソーサラー, ナイト, メディック
                        }

                        let baseDamage = skill ? baseAtk * ((skill && skill.power) || 1.0) * skillPowerMultiplier : baseAtk;
                        let effectiveDefense = 0;

                        // 防御側の防御力を決定
                        if (defender.isWall) {
                            // ウォールの場合、防御力は0とする
                            effectiveDefense = 0;
                        } else if (defender === gameState.golem) {
                            // ゴーレムの場合、防御力は0とする
                            effectiveDefense = 0;
                        } else if (defender.isEnemy) {
                            // 敵の場合、攻撃タイプに応じて物理防御力か魔法防御力を適用
                            let attackType = 'physical';
                            if (skill && skill.type === 'magic') {
                                attackType = 'magic'; // スキルが魔法なら魔法攻撃
                            } else if (!skill && attacker.buffs && attacker.buffs.atk_up) {
                                // エンチャント(atk_up)中の通常攻撃は魔法攻撃扱い
                                attackType = 'magic';
                            }
                            // 祝福: 巨人殺し
                            if (attacker.blessings && attacker.blessings.giant_slayer && attacker.height < defender.height) {
                                baseDamage *= 1.5;
                            }
                            // 祝福: 巨人の力
                            if (attacker.blessings && attacker.blessings.height_power) {
                                const heightBonus = Math.max(0, (attacker.height - 150) / 150); // 150cmを基準に、150cmごとに100%ボーナス
                                baseDamage *= (1 + heightBonus);
                            }
                            // 祝福: 妖精の加護
                            if (attacker.blessings && attacker.blessings.fairy_grace && attacker.height === 1 && skill) {
                                log(`${attacker.name}の妖精の加護がスキルを強化する！`);
                                baseDamage *= 3;
                            }
                            // 祝福: 絶対零度
                            if (attacker.blessings && attacker.blessings.absolute_zero && Math.random() < 0.1) {
                                defender.statusEffects = defender.statusEffects || {};
                                defender.statusEffects.paralysis = true; // 1ターン麻痺
                                log(`${attacker.name}の一撃が${defender.name}を凍てつかせた！`);
                            }
                            const defenderStats = getEffectiveStats(defender);
                            effectiveDefense = (attackType === 'magic') ? defenderStats.mDef : defenderStats.pDef;

                            // 祝福: 巨躯の地ならし
                            if (attacker.blessings && attacker.blessings.giant_grounding && !skill) { // 通常攻撃時のみ
                                if (attacker.height > defender.height) {
                                    log(`${attacker.name}の巨躯の地ならし！${defender.name}の防御力を無視する！`);
                                    effectiveDefense = 0;
                                }
                            }
                        } else {
                            // 味方の場合、getEffectiveStatsで計算された防御力を使用し、防御状態を考慮
                            const defenderStats = getEffectiveStats(defender);
                            effectiveDefense = defenderStats.def;
                            if (defender.isDefending) {
                                effectiveDefense *= 2;
                            }
                        }

                        // 祝福: 物理/魔法シールド
                        if (defender.blessings && defender.blessings.physical_shield && (!skill || skill.type === 'physical' || skill.type.includes('physical'))) {
                            baseDamage *= 0.7;
                        }
                        // フェアリーのワンダーカーニバル
                        if (skill && skill.name === 'ワンダーカーニバル') {
                            const defenderStats = getEffectiveStats(defender);
                            effectiveDefense = Math.min(defenderStats.pDef, defenderStats.mDef);
                            baseDamage = attackerStats.atk * skill.power; // 攻撃力ベースで計算
                        }
                        if (defender.blessings && defender.blessings.magic_shield && skill && (skill.type === 'magic' || skill.type.includes('magic'))) {
                            baseDamage *= 0.7;
                        }

                        // モンクの破砕拳は防御無視
                        if (skill && skill.type === 'def_ignore_physical') {
                            effectiveDefense = 0;
                        }

                        // 溜め攻撃の処理 (物理攻撃のみ)
                        if (attacker.chargeCount > 0 && (!skill || skill.type === 'physical' || skill.type === 'growth_physical' || skill.type === 'hp_cost_physical')) {
                            const chargeMultiplier = 1 + (1.5 * attacker.chargeCount);
                            baseDamage *= chargeMultiplier;
                            attacker.chargeCount = 0;
                        }

                        // ダメージから防御力を減算
                        baseDamage -= effectiveDefense;

                        // ダンサーの回避判定 (スポットライト効果中)
                        if (defender.buffs && defender.buffs.evade_up) {
                            let evadeRate = 0.7; // 基本回避率70%
                            const heightDiff = defender.initialHeight - defender.height;

                            // 身長が初期値より低い場合、回避率にボーナス
                            if (heightDiff > 0) { // ファイター, ソーサラー, ナイト, メディック
                                // 1cm低くなるごとに0.15%回避率が上昇
                                // ラブステップ中のボーナス
                                if (defender.buffs.evade_up.fromLoveStep) {
                                    evadeRate += 0.1;
                                }

                                const bonusEvadeRate = heightDiff * 0.0015;
                                evadeRate += bonusEvadeRate;
                            }
                            // フェアリー変身中の素早さボーナス
                            if (attacker.role === 'フェアリー') {
                                const heightDiff = attacker.initialHeight - attacker.height;
                                const agiBonus = Math.floor(attacker.agi * (heightDiff / attacker.initialHeight * -1.5));
                                agi += agiBonus; // 通常の2倍のボーナス
                            }
                            // 祝福: 小人の俊敏
                            if (defender.blessings && defender.blessings.low_height_evade) {
                                const heightDiffBonus = Math.max(0, defender.initialHeight - defender.height);
                                evadeRate += (heightDiffBonus * 0.002); // 1cmあたり0.2%回避率上昇
                            }

                            // 回避率の上限を95%に設定
                            const finalEvadeRate = Math.min(0.95, evadeRate);

                            if (Math.random() < finalEvadeRate) {
                                log(`${defender.name}は華麗に攻撃をかわした！`);
                                return 'evaded'; // 回避したことを示す特別な値を返す
                            }
                        }
                        // ダメージに±10%の揺らぎを追加
                        const finalDamage = Math.max(1, Math.ceil(baseDamage * (Math.random() * 0.2 + 0.9)));
                        return finalDamage;
                    }
                    async function dealDamage(target, amount, isHeal = false) {
                        // ターゲットがウォールの場合
                        if (target && target.isWall) {
                            const wall = gameState.walls[target.wallIndex];
                            wall.hp = Math.max(0, wall.hp - amount);
                            log(`防壁が攻撃を受け止めた！ (防壁の残り耐久値: ${wall.hp})`);
                            if (wall && wall.hp <= 0) {
                                flashCard(gameState.party[wall.targetId], 'red');
                                log("防壁は砕け散った！");
                                gameState.walls.splice(target.wallIndex, 1);
                            }
                            return;
                        }
                        if (amount === 0) return; // 回避などでダメージ0の場合は何もしない
                        if (amount === 'evaded') return; // 回避の場合は何もしない
                        if (isHeal) {
                            // 回復の場合
                            if (target && !target.isEnemy) await animateStatChange(target, 'hp', -amount, 'increase');
                            else if (target) target.currentHp = Math.min(target.maxHp, target.currentHp - amount);
                            flashCard(target, 'green');
                            if (target) showDamagePopup(target, Math.abs(amount), true);
                            return;
                        }
                        // ターゲットがゴーレムの場合
                        if (target === gameState.golem) {
                            gameState.golem.hp = Math.max(0, gameState.golem.hp - amount);
                            showDamagePopup(target, amount, false);
                            flashCard(target, 'red');
                            updatePartyStatus();
                            if (gameState.golem.hp <= 0) log('ゴーレムは砕け散った！');
                        } else if (target && !target.isEnemy) { // ターゲットが味方の場合 (敵からの攻撃、自傷など)
                            await animateStatChange(target, 'hp', -amount, 'decrease');
                        } else if (target) { // ターゲットが敵の場合
                            target.currentHp = Math.max(0, target.currentHp - amount);
                            updateEnemyStatus(); // 敵のHPバーを更新
                        }
                        flashCard(target, 'red');
                        if (target) showDamagePopup(target, amount, false);
                        if (target.currentHp <= 0 && target !== gameState.golem) {
                            if (!target.isEnemy && gameState.gameMode === 'enjoy') {
                                log(`${target.name}は倒れた...しかし、不思議な力ですぐに立ち上がった！`);
                                // HPを即座に全回復させる
                                target.currentHp = target.maxHp; // ファイター, ソーサラー, ナイト, メディック
                                flashCard(target, 'green');
                                updatePartyStatus(); // UIを更新 // ファイター, ソーサラー, ナイト, メディック
                            } else if (!target.isEnemy && target.blessings && target.blessings.last_stand) {
                                // 祝福: 不屈の魂
                                target.currentHp = 1;
                                delete target.blessings.last_stand; // 一度だけ発動
                                log(`${target.name}は不屈の魂で踏みとどまった！`);
                                flashCard(target, 'yellow');
                                updatePartyStatus();
                            } else {
                                log(`${target.name}は倒れた...`);
                                if (target.isEnemy) {
                                    const card = document.getElementById(`enemy-card-${gameState.enemies.indexOf(target)}`);
                                    // 祝福: 魂喰らい
                                    const killer = gameState.turnOrder[gameState.currentTurnIndex];
                                    if (killer && !killer.isEnemy && killer.blessings && killer.blessings.kill_heal) {
                                        const healAmount = Math.ceil(killer.maxHp * 0.15);
                                        const mpAmount = Math.ceil(killer.maxMp * 0.15);
                                        animateStatChange(killer, 'hp', healAmount, 'increase');
                                        animateStatChange(killer, 'mp', mpAmount, 'increase');
                                        log(`${killer.name}は倒した敵から魂を吸収し、HPとMPが回復した！`);
                                    }
                                    if (card) card.classList.add('fade-out-down');
                                    setTimeout(() => {
                                        if (card) card.remove();
                                    }, 1000); // アニメーション後に要素を削除
                                }
                            }
                        }
                        // 祝福: 過剰治癒 // ファイター, ソーサラー, ナイト, メディック
                        if (target && !target.isEnemy && target.blessings && target.blessings.over_heal && isHeal && target.currentHp === target.maxHp) {
                            const overHealAmount = (target.currentHp + amount) - target.maxHp;
                            if (target.buffs && target.buffs.heal_spread) {
                                const spreadHeal = Math.ceil(amount / (gameState.party.filter(p => p.currentHp > 0).length - 1));
                                gameState.party.forEach(p => {
                                    if (p !== target && p.currentHp > 0) animateStatChange(p, 'hp', spreadHeal, 'increase');
                                });
                            }
                            if (overHealAmount > 0) {
                                const wallHp = Math.ceil(overHealAmount);
                                gameState.walls.push({
                                    targetId: gameState.party.indexOf(target),
                                    hp: wallHp,
                                    maxHp: wallHp
                                });
                                log(`${target.name}の超過した回復力が、耐久値${wallHp}の防壁に変換された！`);
                            }
                        }
                        // メイドの回復拡散
                        if (target && !target.isEnemy && target.buffs && target.buffs.heal_spread && isHeal) {
                            const aliveAllies = gameState.party.filter(p => p !== target && p.currentHp > 0);
                            if (aliveAllies.length > 0) {
                                const spreadHeal = Math.ceil(amount / aliveAllies.length);
                                log(`${target.name}から癒しの力が拡散し、仲間たちのHPが${spreadHeal}回復した！`);
                                aliveAllies.forEach(p => animateStatChange(p, 'hp', spreadHeal, 'increase'));
                            }
                        }

                    } // ファイター, ソーサラー, ナイト, メディック

                    function triggerLiberationEvent() {
                        liberationModal.classList.remove('hidden');
                        liberationAcceptButton.onclick = () => {
                            liberationModal.classList.add('hidden');
                            log("結晶が砕け散り、空間が歪む…！");
                            // アイテムを1つずつ消費
                            gameState.inventory.find(item => item.id === 'holy_crystal').quantity--;
                            gameState.inventory.find(item => item.id === 'evil_crystal').quantity--;
                            startBattle(true, 'phantom_hero');
                        };
                        liberationDeclineButton.onclick = () => {
                            liberationModal.classList.add('hidden');
                            log("一行は危険を察知し、その場を後にした。");
                        };
                    }

                    async function blinkSkill(enemy) {
                        log(`${enemy.name}は瞬きをした。空間が歪み、奥義の気配が満ちる！`);
                        enemy.buffs.omen = 4; // 自身と次の3ターン、計4ターン持続
                        flashCard(enemy, 'yellow');
                    }

                    async function blackholeSkill(enemy, target) {
                        log(`${enemy.name}は${target.name}にブラックホールを放った！`);
                        const damage = 9999; // 耐えられないダメージ
                        log(`${target.name}は闇に飲み込まれてしまった…！`);
                        await dealDamage(target, damage); // ログ表示の後にダメージ処理
                    }

                    async function finalBossSkill(enemy, target) {
                        const roll = Math.random();
                        if (roll < 0.3) {
                            log(`${enemy.name}は終末の宣告を放った！`);
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                p.statusEffects.stat_down = true;
                                log(`${p.name}は絶望し、全ての能力が低下した！`);
                            }
                        } else if (roll < 0.6) {
                            log(`${enemy.name}は虚無の波動を放った！`);
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                await animateStatChange(p, 'mp', -Math.ceil(p.maxMp * 0.5), 'decrease');
                            }
                        } else {
                            await defaultEnemyAttack(enemy, target);
                        }
                    }

                    function showDamagePopup(target, amount, isHeal = false) {
                        const targetCard = target.isEnemy ?
                            document.getElementById(`enemy-card-${gameState.enemies.indexOf(target)}`) :
                            partyContainer.children[gameState.party.indexOf(target)];
                        if (!targetCard) return;
                        if (target === gameState.golem) {
                            const summonerCard = Array.from(partyContainer.children).find(card => card.querySelector('.golem-card-inner'));
                            if (summonerCard) targetCard = summonerCard.querySelector('.golem-card-inner');
                        }

                        const popup = document.createElement('div');
                        popup.textContent = amount;
                        popup.className = `damage-popup ${isHeal ? 'heal-popup' : ''}`; // 回避ポップアップのスタイル調整
                        if (amount === '回避') {
                            popup.style.color = '#3b82f6'; // 青色
                            popup.style.fontSize = '1.25rem'; // 少し小さく
                        }
                        targetCard.appendChild(popup);
                        setTimeout(() => popup.remove(), 1500);
                    }

                    async function endBattle(isVictory) {
                        gameState.inBattle = false;
                        emergencyButton.classList.remove('battle-active'); // 緊急ボタンを無効化

                        // ゴーレムが残っている場合の処理
                        if (gameState.golem && gameState.golem.hp > 0) {
                            const summoner = gameState.party.find(p => p.role === 'サモナー' && p.currentHp > 0);
                            if (summoner) {
                                const mpRecovery = Math.ceil(gameState.golem.hp / 5);
                                if (mpRecovery > 0) {
                                    log("ゴーレムは役目を終えて帰還した。");
                                    animateStatChange(summoner, 'mp', mpRecovery, 'increase');
                                    log(`${summoner.name}のMPが${mpRecovery}回復した！`);
                                }
                            }
                            gameState.golem = null;
                        }

                        // 防壁が残っている場合の処理
                        if (gameState.walls.length > 0) {
                            log("戦闘が終わり、残っていた防壁の魔力が少し失われた。");
                            gameState.walls.forEach(wall => {
                                wall.hp = Math.ceil(wall.hp / 2);
                                wall.maxHp = Math.ceil(wall.maxHp / 2); // 最大耐久値も半減
                            });
                            // 耐久値が0になった防壁を削除
                            gameState.walls = gameState.walls.filter(wall => wall.hp > 0);
                        }

                        dungeonCommands.classList.remove('hidden');
                        updateFloorDisplay();
                        battleCommands.classList.add('hidden');
                        // 戦闘終了時に身長を元に戻す処理
                        gameState.party.forEach(p => {
                            if (p.statusEffects.shrunkToOne) delete p.statusEffects.shrunkToOne;
                        });

                        gameState.party.forEach(p => {
                            p.buffs = {};
                            p.isDefending = false;
                            // 脱衣状態のみ持続させる
                            const wasStripped = p.statusEffects.stripped;
                            p.statusEffects = {}; // ファイター, ソーサラー, ナイト, メディック
                            if (wasStripped) p.statusEffects.stripped = wasStripped; // ターン数も引き継ぐ
                        });

                        if (isVictory) {
                            // 「英雄の幻影」撃破ボーナス
                            if (gameState.enemies.some(e => e.name === '英雄の幻影')) {
                                log("英雄の幻影を打ち破った！パーティ全員の魂が共鳴し、限界を超えて成長する！"); // ファイター, ソーサラー, ナイト, メディック
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) {
                                        p.maxHp += 5;
                                        p.maxMp += 5;
                                        p.atk += 1;
                                        p.def += 1;
                                        flashCard(p, 'green');
                                    }
                                });
                                updatePartyStatus();
                            }

                            gameState.killCount += gameState.enemies.length; // 倒した敵の数を加算

                            // 新モード「流転の体躯」の処理
                            if (gameState.gameMode === 'unstable_bodies') {
                                log("勝利の余韻に浸る間もなく、パーティの体が不安定に変化する…！");
                                await new Promise(resolve => setTimeout(resolve, 1500)); // メッセージ表示のための待機
                                const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                                if (aliveParty.every(p => p.heightLocked)) {
                                    log("…しかし、全員の体が変化を拒んだ！");
                                    await new Promise(resolve => setTimeout(resolve, 1500)); // ファイター, ソーサラー, ナイト, メディック
                                } // ファイター, ソーサラー, ナイト, メディック
                                for (const char of aliveParty) {
                                    const change = Math.ceil(Math.random() * 101) - 50; // -50 から +50
                                    const type = change >= 0 ? 'increase' : 'decrease';
                                    await animateStatChange(char, 'height', change, type);
                                    log(`${char.name}の身長が${change > 0 ? '+' : ''}${change}cm変化した！`);
                                    await new Promise(resolve => setTimeout(resolve, 500)); // 各キャラのログ表示のための短い待機
                                }
                            }

                            if (gameState.gameMode === 'monster_march') {
                                if (gameState.floor === 50) {
                                    showModal("完全踏破", "絶え間ない戦いの果てに、あなたはついにダンジョンの最奥に到達し、元凶を打ち破りました。その行軍は、伝説として語り継がれるでしょう。");
                                    gameState.gameOver = true;
                                    return; // ファイター, ソーサラー, ナイト, メディック
                                }
                                log('敵を倒した！パーティ全員がレベルアップ！');
                                gameState.party.forEach(char => {
                                    if (char.currentHp > 0) levelUpCharacter(char, false); // UIは表示しない
                                });

                                const foundItems = [];
                                const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].battleOnly && !itemBlueprints[id].rare);
                                for (let i = 0; i < 3; i++) {
                                    const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                                    addItemToInventory(foundItemId);
                                    foundItems.push(itemBlueprints[foundItemId].name);
                                }
                                log(`さらに、 ${foundItems.join('、')} を手に入れた！`);
                            } else if (gameState.gameMode === 'endless') {
                                // 無限モードのボス撃破後
                                const isBossFloor = gameState.floor > 0 && gameState.floor % 30 === 0;
                                if (isBossFloor) {
                                    showEndlessCurseModal(); // 呪い選択モーダルを表示
                                } else {
                                    showLevelUpModal(true); // 通常のボーナス選択モーダルを表示
                                }
                            } else if (gameState.gameMode === 'summer_live' && gameState.floor === 30) {
                                log("ビーチステージのボスを撃破！打ち上げの温泉に向けて、冒険は続く！");
                                showLevelUpModal(false); // レベルアップ選択画面へ
                            } else if (gameState.gameMode === 'endgame' && gameState.floor === 1) {
                                showModal("ゲームクリア？", "あなたはダンジョンの入り口で待ち構えていたボスを打ち破りました！…これでよかったのでしょうか？");
                                gameState.gameOver = true;
                            } else if ((gameState.floor === 30 && gameState.gameMode !== 'endless' && gameState.gameMode !== 'monster_march') || (gameState.gameMode === 'endgame_plus' && gameState.floor === 90)) {
                                let title = "ゲームクリア！";
                                let text = "おめでとう！あなたはダンジョンの最深部に到達し、ボスを打ち破りました！";
                                switch (gameState.gameMode) {
                                    case 'normal':
                                    case 'trial':
                                        text += "\nもしもの物語では、異なる結末があなたを待っているかもしれません。";
                                        break;
                                    case 'endgame_plus':
                                        title = "真の終焉";
                                        text = "終刻の魔王を打ち破り、世界に真の静寂が訪れた。しかし、それは新たな始まりに過ぎないのかもしれない…。\n\nこの偉業を成し遂げた者たちの魂は、星の観測者たちに記憶され、永遠に語り継がれるだろう。";
                                        break;
                                    case 'veterans':
                                        title = "歴戦の証";
                                        text = "歴戦の勇者たちは、その実力を見せつけ、ダンジョンを容易く踏破しました。しかし、彼女たちの本当の戦いは、まだ始まったばかりなのかもしれません。";
                                        break;
                                    case 'dwarves':
                                        title = "小さな英雄譚";
                                        text = "小さな体で、大きな困難を乗り越えた一行。彼女たちの勇気は、どんな巨人よりも雄大でした。";
                                        break;
                                    case 'brawl':
                                        title = "武闘の果てに";
                                        text = "戦い、戦い、そしてまた戦い…。武闘の宴の果てに、彼女たちは最強の称号を手にしました。その拳に宿るは、数多の強敵との記憶。";
                                        break;
                                    case 'solo':
                                        title = "孤独な覇者";
                                        text = `たった一人で、${gameState.party[0].name}はダンジョンを制覇しました。その強さは伝説となり、後世まで語り継がれるでしょう。\n\nこの経験は彼女の魂に刻まれ、「孤高の魂」として今後の冒険で力となります。`;
                                        // ソロクリアしたキャラクターを保存
                                        const soloClearFlags = JSON.parse(localStorage.getItem('sizeDungeonSoloClearFlags') || '{}');
                                        const clearedCharName = gameState.party[0].name;
                                        soloClearFlags[clearedCharName] = true;
                                        localStorage.setItem('sizeDungeonSoloClearFlags', JSON.stringify(soloClearFlags));
                                        break;
                                    case 'saint_march':
                                        title = "聖女の使命";
                                        text = "セレスティアはダンジョンの最深部に巣食う元凶を浄化しました。しかし、世界のどこかで穢れが生まれる限り、彼女の行進は終わりません。";
                                        // 聖女クリアフラグを保存
                                        const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                                        clearFlags.saintMarchCleared = true;
                                        localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(clearFlags));
                                        break;
                                    case 'treasure_map':
                                        title = "秘宝の在り処";
                                        text = "リリィはついにダンジョンの最奥に眠る秘宝を手に入れました。しかし、世界にはまだ見ぬお宝がたくさん眠っています。彼女の冒険は、まだ始まったばかりです。";
                                        // トレジャーハンタークリアフラグを保存
                                        const clearFlagsTreasure = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                                        clearFlagsTreasure.treasureMapCleared = true;
                                        localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(clearFlagsTreasure));
                                        break;
                                    case 'indecent':
                                        title = "恥辱の先の勝利";
                                        text = "数々の羞恥を乗り越え、彼女たちはついにボスを打ち破りました。この冒険のことは、きっと誰にも話せないでしょう…。";
                                        break;
                                    case 'fixed_path':
                                        title = "運命の踏破";
                                        text = "定められた道を乗り越え、一行はついに最深部に到達しました。これは運命だったのか、それとも自ら選び取った未来だったのか…。";
                                        break;
                                    case 'enjoy':
                                        title = "楽しい冒険の終わり";
                                        text = "どんな困難も笑顔で乗り越え、パーティはついにダンジョンを制覇しました！最高の冒険でしたね！";
                                        break;
                                    case 'brawling_belles':
                                        title = "闘争の果てに";
                                        text = "ノエルとフローラは、数々の強敵を打ち破り、ついにダンジョンを踏破しました。彼女たちの絆は、誰にも壊せないでしょう。";
                                        const bellesFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                                        bellesFlags.brawlingBellesCleared = true;
                                        localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(bellesFlags));
                                        break;
                                    case 'unstable_bodies':
                                        text = "絶え間なく変化する肉体を乗りこなし、あなたは見事ボスを打ち破りました！その精神力は、もはや何物にも揺るがないでしょう。";
                                        break;
                                    case 'random_party':
                                        title = "運命の勝利";
                                        text = "偶然出会った仲間たちと共に、あなたはついにダンジョンを制覇しました。この出会いは運命だったのかもしれません。彼女たちとの絆は、これからも続いていくでしょう。";
                                        break;
                                    case 'secret_night':
                                        title = "ヒミツの夜明け";
                                        const charName = gameState.party[0].name;
                                        if (charName === 'リリカ') {
                                            text = "リリカは、ドキドキの夜の冒険を終えた。誰にも言えないヒミツのステージは、彼女を少しだけ大人にしたのかもしれない。";
                                        } else if (charName === 'ユイ') {
                                            text = "ユイは、恥ずかしくてドキドキの冒険を終えた。このヒミツの経験は、彼女の心に小さな勇気の種を植え付けた。";
                                        } else if (charName === 'ミコ') {
                                            text = "ミコは、モコと一緒に夜の冒険を終えた。いつもと違うダンジョンは、彼女の冒険心をさらに掻き立てたようだ。";
                                        } else if (charName === 'リリィ') {
                                            text = "リリィは、静かな夜のダンジョン探索を終えた。お宝は見つからなかったが、スリリングな一夜は彼女を満足させた。";
                                        } else if (charName === 'フローラ') {
                                            text = "フローラは、背徳感に満ちた夜の冒険を終えた。このヒミツは、彼女の心に甘い棘となって残り続けるだろう。";
                                        } else {
                                            text = "ヒミツの夜は明けた。この冒険のことは、あなたと彼女だけのヒミツだ。";
                                        }
                                        break;
                                }
                                showModal(title, text);
                                gameState.gameOver = true;
                            } else if (gameState.enemies.some(e => e.name === '星の観測者')) {
                                // 星の観測者撃破時の特殊エンディング
                                showModal("観測者の終焉", "星の観測者を打ち破ったあなた達の前に、空間の裂け目が現れる。\n\n「…我を超えし者よ。世界の真の終焉を、見る覚悟があるか…？」\n\nその声と共に、新たな道が開かれた。\n\n（もしもの物語に「終焉の呼び声」が追加されました）");

                                // クリアフラグと実績を保存
                                const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                                clearFlags.endgameCleared = true;
                                localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(clearFlags));

                                const starObserverClearers = JSON.parse(localStorage.getItem('sizeDungeonStarObserverClearers') || '{}');
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) {
                                        starObserverClearers[p.name] = true;
                                    }
                                });
                                localStorage.setItem('sizeDungeonStarObserverClearers', JSON.stringify(starObserverClearers));

                                // デバッグボタンを更新
                                updateDebugButtons();

                                gameState.gameOver = true;
                            } else {
                                showLevelUpModal(false);
                            }
                        } else {
                            if (gameState.party.length === 1) {
                                const characterName = gameState.party[0].name;
                                showModal("ゲームオーバー", `${characterName}は力尽きてしまった...`);
                            } else {
                                showModal("ゲームオーバー", "パーティは全滅してしまった...");
                            }
                            gameState.gameOver = true;
                        }
                    }

                    function showBlessingModal() {

                        blessingCharSelectList.innerHTML = '';
                        blessingOptionsList.innerHTML = '';
                        blessingCharSelectList.classList.remove('hidden');
                        blessingOptionsList.classList.add('hidden');
                        blessingModalPrompt.textContent = '祝福を授ける仲間を一人選んでください。';

                        gameState.party.forEach((char) => {
                            if (char.currentHp <= 0) return;

                            const card = document.createElement('div');
                            card.className = 'p-4 border rounded-lg cursor-pointer hover:bg-amber-100 hover:shadow-lg transition';
                            card.innerHTML = `
                                <p class="font-bold text-lg text-${char.themeColor}-700">${char.name}</p>
                                <p class="text-sm text-gray-600">${char.role}</p>
                            `;
                            card.onclick = () => presentBlessingChoices(char);
                            blessingCharSelectList.appendChild(card);
                        });

                        blessingModal.classList.remove('hidden');
                    }

                    function presentBlessingChoices(char) {
                        blessingCharSelectList.classList.add('hidden');
                        blessingOptionsList.classList.remove('hidden');
                        blessingModalPrompt.textContent = `${char.name}に授ける祝福を選んでください。`;
                        blessingOptionsList.innerHTML = '';

                        const blessingPool = Object.values(blessings);
                        const available = blessingPool.filter(b => !Object.values(char.blessings).some(owned => owned.name === b.name));
                        const choices = [];
                        while (choices.length < 3 && available.length > 0) {
                            const randomIndex = Math.floor(Math.random() * available.length);
                            choices.push(available.splice(randomIndex, 1)[0]);
                        }

                        choices.forEach(blessing => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-amber-500 hover:bg-amber-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg text-left';
                            button.innerHTML = `<strong class="text-lg">${blessing.name}</strong><span class="block text-sm text-amber-100 mt-1">${blessing.description}</span>`;
                            button.onclick = () => {
                                blessing.effect(char);
                                log(`${char.name}は神々の祝福「${blessing.name}」を授かった！`);
                                blessingModal.classList.add('hidden');
                                dungeonCommands.classList.remove('hidden');
                            };
                            blessingOptionsList.appendChild(button);
                        });
                    }

                    function showModal(title, text) {
                        modalTitle.textContent = title;
                        modalText.textContent = text;
                        modal.classList.remove('hidden');
                    }

                    function showLevelUpModal(isEndless = false) {
                        log('敵を倒した！');
                        enemyContainer.innerHTML = '';
                        dungeonCommands.classList.add('hidden'); // 選択中はコマンドを隠す

                        levelUpPartyList.innerHTML = '';
                        // パーティが1人の場合は選択肢を出さずに即時レベルアップ
                        if (gameState.party.length === 1 && gameState.party[0].currentHp > 0) {
                            // UI表示フラグをtrueにして、レベルアップ処理を呼び出す
                            // isEndlessフラグも正しく渡す
                            levelUpCharacter(gameState.party[0], true, isEndless);
                            return; // ファイター, ソーサラー, ナイト, メディック
                        }


                        gameState.party.forEach((char, index) => {
                            if (char.currentHp <= 0) return; // 戦闘不能のキャラは選択不可

                            const card = document.createElement('div');
                            card.className = 'p-4 border rounded-lg cursor-pointer hover:bg-yellow-100 hover:shadow-lg transition';
                            card.innerHTML = `
                        <p class="font-bold text-lg text-${char.themeColor}-700">${char.name}</p>
                        <p class="text-sm text-gray-600">Lv.${char.level} ${char.role}</p>
                    `;
                            card.onclick = () => {
                                if (isEndless) {
                                    levelUpCharacter(char, true, true);
                                } else {
                                    levelUpCharacter(char);
                                }
                            };
                            levelUpPartyList.appendChild(card);
                        });

                        if (gameState.gameMode === 'summer_live' && gameState.floor === 60) {
                            showModal("ライブ大成功！", "おめでとう！あなたはビーチと温泉でのスペシャルライブを大成功させ、ダンジョンを制覇しました！彼女たちの夏の思い出は、最高の形で幕を閉じました。");
                            // クリアフラグを保存
                            const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                            clearFlags.summerLiveCleared = true;
                            localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(clearFlags));
                            gameState.gameOver = true;
                            return;
                        }
                        levelUpModal.classList.remove('hidden');
                    }

                    function levelUpCharacter(character, showUI = true, isEndless = false) {
                        // ステータスアップ
                        character.maxHp += 5;
                        character.maxMp += 3;
                        character.atk += 1;
                        character.def += 1;
                        character.agi += 1;
                        character.level += 1; // ファイター, ソーサラー, ナイト, メディック
                        // HP/MPを全回復
                        character.currentHp = character.maxHp;
                        character.currentMp = character.maxMp; // ファイター, ソーサラー, ナイト, メディック

                        character.skills.forEach(skill => {
                            if (skill.power) skill.power = parseFloat((skill.power * 1.05).toFixed(2)); // 威力を5%上昇
                        });
                        // 新スキル習得
                        if (character.level === 2 && character.unlockableSkill) {
                            character.skills.push(character.unlockableSkill);
                            log(`${character.name}は強くなった！ さらに、新しいスキル「${character.unlockableSkill.name}」を覚えた！`);
                        } else if (character.level === 4 && character.unlockableSkillLv4) {
                            character.skills.push(character.unlockableSkillLv4);
                            log(`${character.name}は大きく成長した！ 奥義「${character.unlockableSkillLv4.name}」を習得！`);
                        } else {
                            log(`${character.name}は強くなった！`);
                        }
                        if (showUI) {
                            levelUpModal.classList.add('hidden');
                            updatePartyStatus();
                            if (isEndless) {
                                showEndlessBonusModal();
                            } else {
                                dungeonCommands.classList.remove('hidden');
                            }
                        }
                    }

                    function showEndlessBonusModal() {
                        endlessBonusButtons.innerHTML = '';
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length === 0) {
                            endBattle(false); // 全滅している場合はゲームオーバー
                            return;
                        }

                        const bonusPool = [{
                            id: 'maxHpUp',
                            text: (target) => `${target.name}の最大HPが永続上昇`,
                            effect: (target) => {
                                target.maxHp += 20;
                                log(`${target.name}の最大HPが20上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'maxMpUp',
                            text: (target) => `${target.name}の最大MPが永続上昇`,
                            effect: (target) => {
                                target.maxMp += 10;
                                log(`${target.name}の最大MPが10上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'atkUp',
                            text: (target) => `${target.name}の攻撃力が永続上昇`,
                            effect: (target) => {
                                target.atk += 3;
                                log(`${target.name}の攻撃力が3上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'defUp',
                            text: (target) => `${target.name}の防御力が永続上昇`,
                            effect: (target) => {
                                target.def += 2;
                                log(`${target.name}の防御力が2上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'cureStrip',
                            text: () => '全員の脱衣状態を治す',
                            effect: () => {
                                gameState.party.forEach(p => delete p.statusEffects.stripped);
                                log('全員が服を着て、元の状態に戻った！');
                            },
                            weight: 15,
                            condition: () => gameState.party.some(p => p.statusEffects.stripped)
                        }, {
                            id: 'allLevelUp',
                            text: () => '全員がさらにレベルアップ',
                            effect: () => {
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) levelUpCharacter(p, false);
                                });
                                log('パーティ全員がさらにレベルアップした！');
                            },
                            weight: 3
                        }, {
                            id: 'getItems',
                            text: () => 'アイテムを5個獲得',
                            effect: () => {
                                const foundItems = [];
                                const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].battleOnly && !itemBlueprints[id].rare && !itemBlueprints[id].special);
                                for (let i = 0; i < 5; i++) {
                                    const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                                    addItemToInventory(foundItemId);
                                    foundItems.push(itemBlueprints[foundItemId].name);
                                }
                                log(`アイテムを5個手に入れた！ (${foundItems.join('、')})`);
                            },
                            weight: 12
                        }, {
                            id: 'getRareItem',
                            text: () => 'レアアイテムを1個獲得',
                            effect: () => {
                                const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                                addItemToInventory(foundItemId);
                                log(`なんと、とても珍しい「${itemBlueprints[foundItemId].name}」を見つけた！`);
                            },
                            weight: 2
                        }, {
                            id: 'becomeCute',
                            text: (target) => `${target.name}がかわいくなる`,
                            effect: async(target) => {
                                log(`突然の光に包まれ、${target.name}は…`);
                                await new Promise(resolve => setTimeout(resolve, 1500));

                                let outcomes = ['shrink', 'strip', 'glow', 'dress', 'full_recover'];
                                // 身長が固定されている場合のみ、「いつもの姿が一番」を候補に追加
                                if (target.heightLocked) {
                                    outcomes.push('reset_height');
                                }

                                const outcome = outcomes[Math.floor(Math.random() * outcomes.length)];

                                switch (outcome) {
                                    case 'full_recover':
                                        await animateStatChange(target, 'hp', target.maxHp, 'increase');
                                        await animateStatChange(target, 'mp', target.maxMp, 'increase');
                                        target.statusEffects = {};
                                        log(`…「かわいいは元気から！」HPとMPが全回復し、状態異常も治った！`);
                                        break;
                                    case 'reset_height':
                                        target.heightLocked = false;
                                        const resetAmount = target.initialHeight - target.height;
                                        await animateStatChange(target, 'height', resetAmount, resetAmount >= 0 ? 'increase' : 'decrease');
                                        log(`…「いつもの姿が一番！」身長の固定が解除され、元の身長に戻った！`);
                                        break;
                                    case 'shrink':
                                        if (target.heightLocked) {
                                            log(`…しかし、${target.name}の体は変化を拒んだ！`);
                                            return;
                                        }
                                        const diff = 1 - target.height;
                                        await animateStatChange(target, 'height', diff, 'decrease');
                                        log(`…なんと、身長が1cmになってしまった！`);
                                        break;
                                    case 'strip':
                                        const immuneRoles = ['ナイト', 'サムライ', '聖女']; // ファイター, ソーサラー, ナイト, メディック
                                        if (immuneRoles.includes(target.role)) {
                                            log(`…しかし、${target.name}は恥じらいを覚えず、何も起こらなかった。`); // ファイター, ソーサラー, ナイト, メディック
                                        } else {
                                            target.statusEffects.stripped = {
                                                turns: 0
                                            };
                                            log(`…なんと、恥ずかしい格好になってしまった！`);
                                        }
                                        break;
                                    case 'glow':
                                        log(`…肌がつやつやになり、いつもより魅力的に見える！(特に効果はない)`);
                                        break;
                                    case 'dress':
                                        if (target.statusEffects.stripped) {
                                            delete target.statusEffects.stripped;
                                            log(`…服がかわいらしいドレスに変化し、脱衣状態が治った！`);
                                        } else {
                                            log(`…服がかわいらしいドレスに変化した！(特に効果はない)`);
                                        }
                                        break;
                                }
                            },
                            weight: 1,
                            needsTarget: true
                        }, {
                            id: 'getBlessing',
                            text: (target) => `${target.name}に神々の祝福を授ける`,
                            effect: (target) => {
                                const blessingPool = Object.values(blessings);
                                const available = blessingPool.filter(b => !Object.values(target.blessings).some(owned => owned.name === b.name));

                                if (available.length === 0) {
                                    log(`${target.name}は既に全ての祝福を授かっている！`);
                                    // 代わりにランダムなアイテムを獲得
                                    const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].battleOnly && !itemBlueprints[id].rare && !itemBlueprints[id].special);
                                    const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                                    addItemToInventory(foundItemId);
                                    log(`代わりに「${itemBlueprints[foundItemId].name}」を手に入れた！`);
                                } else {
                                    const chosenBlessing = available[Math.floor(Math.random() * available.length)];
                                    chosenBlessing.effect(target);
                                    log(`${target.name}は神々の祝福「${chosenBlessing.name}」を授かった！`);
                                }
                            },
                            weight: 5,
                            needsTarget: true
                        }, ];

                        let selectedBonuses = []; // ファイター, ソーサラー, ナイト, メディック
                        let availableBonuses = [...bonusPool];

                        while (selectedBonuses.length < 4 && availableBonuses.length > 0) {
                            // 条件を満たすボーナスのみをフィルタリング
                            const filteredBonuses = availableBonuses.filter(b => !b.condition || b.condition());
                            if (filteredBonuses.length === 0) break;

                            // 重み付け抽選
                            const totalWeight = filteredBonuses.reduce((sum, b) => sum + b.weight, 0);
                            let random = Math.random() * totalWeight;
                            let chosenBonus = null;
                            for (const bonus of filteredBonuses) {
                                random -= bonus.weight;
                                if (random <= 0) {
                                    chosenBonus = bonus;
                                    break;
                                }
                            }
                            if (!chosenBonus) chosenBonus = filteredBonuses[filteredBonuses.length - 1];

                            // ターゲットが必要な場合は抽選
                            let target = null;
                            if (chosenBonus.needsTarget) {
                                target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                            }

                            selectedBonuses.push({...chosenBonus,
                                target
                            });

                            // 同じIDのボーナスは再度選ばれないようにする
                            availableBonuses = availableBonuses.filter(b => b.id !== chosenBonus.id);
                        }

                        // 選択肢ボタンを生成
                        selectedBonuses.forEach(bonus => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-4 rounded-lg shadow-lg text-left';

                            let buttonText = bonus.text(bonus.target);
                            let description = '';
                            if (bonus.id === 'becomeCute') description = '（効果は不明）';

                            button.innerHTML = `
                                ${buttonText}
                                <span class="block text-xs text-blue-200">${description}</span>
                            `;

                            button.onclick = () => {
                                endlessBonusModal.classList.add('hidden');
                                bonus.effect(bonus.target);
                                // 選択後、少し待ってからUIを更新し、次のフロアへ
                                setTimeout(() => {
                                    updatePartyStatus();
                                    dungeonCommands.classList.remove('hidden');
                                }, 1000);
                            };
                            endlessBonusButtons.appendChild(button);
                        });

                        dungeonCommands.classList.add('hidden');
                        endlessBonusModal.classList.remove('hidden');
                    }

                    function showEndlessCurseModal() {
                        endlessCurseButtons.innerHTML = '';
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length === 0) {
                            endBattle(false); // 全滅している場合はゲームオーバー
                            return;
                        }

                        // 呪いの選択肢プール
                        const cursePool = [{
                            id: 'hp_half',
                            text: '血の代償',
                            description: '生存者全員の現在HPが半減する。',
                            effect: () => {
                                log("呪いが発動し、全員の生命力が吸い取られた！");
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) { // ファイター, ソーサラー, ナイト, メディック
                                        const damage = Math.ceil(p.currentHp / 2); // ファイター, ソーサラー, ナイト, メディック
                                        animateStatChange(p, 'hp', -damage, 'decrease');
                                    }
                                });
                            },
                            weight: 10
                        }, {
                            id: 'lose_items',
                            text: '忘却の呪い',
                            description: '所持アイテムをランダムに3つ失う。',
                            effect: () => {
                                const lostItems = []; // ファイター, ソーサラー, ナイト, メディック
                                for (let i = 0; i < 3; i++) {
                                    const availableItems = gameState.inventory.filter(item => item.quantity > 0);
                                    if (availableItems.length > 0) {
                                        const itemToLose = availableItems[Math.floor(Math.random() * availableItems.length)];
                                        itemToLose.quantity--;
                                        lostItems.push(itemBlueprints[itemToLose.id].name);
                                    }
                                }
                                if (lostItems.length > 0) {
                                    log(`呪いによって ${lostItems.join('、')} を失ってしまった！`);
                                } else {
                                    log("呪いが発動したが、失うアイテムがなかった。");
                                }
                            },
                            weight: 10,
                            condition: () => gameState.inventory.some(item => item.quantity > 0)
                        }, {
                            id: 'random_height',
                            text: '不安定な肉体',
                            description: '生存者全員の身長が-100cm～+100cmの範囲でランダムに変動する。',
                            effect: async() => {
                                log("呪いがパーティの肉体を蝕む！");
                                for (const p of aliveParty) {
                                    if (p.heightLocked) {
                                        log(`${p.name}は体の変化を拒んだ！`);
                                        continue;
                                    } // ファイター, ソーサラー, ナイト, メディック
                                    const change = Math.ceil(Math.random() * 201) - 100;
                                    await animateStatChange(p, 'height', change, change >= 0 ? 'increase' : 'decrease');
                                    log(`${p.name}の身長が${change > 0 ? '+' : ''}${change}cm変化した！`);
                                }
                            },
                            weight: 8
                        }, {
                            id: 'stat_down_or_lock',
                            text: '個人の犠牲',
                            description: 'ランダムな仲間一人に過酷な運命が降りかかる。',
                            effect: (target) => {
                                if (Math.random() < 0.5) {
                                    target.atk -= 1;
                                    log(`呪いによって${target.name}の魂が少し削られ、攻撃力が永続的に1減少した…。`);
                                } else {
                                    if (target.heightLocked) {
                                        log(`呪いは${target.name}の体を固定しようとしたが、既に固定されていたため何も起こらなかった。`);
                                    } else {
                                        animateStatChange(target, 'height', 1 - target.height, 'decrease');
                                        target.heightLocked = true;
                                        log(`呪いによって${target.name}の体が1cmに固定されてしまった！`);
                                    }
                                }
                            },
                            weight: 7,
                            needsTarget: true
                        }, {
                            id: 'lose_blessing',
                            text: '祝福の喪失',
                            description: 'ランダムな仲間一人の祝福が一つ失われる。',
                            effect: (target) => {
                                const blessings = target.blessings ? Object.keys(target.blessings) : [];
                                if (blessings.length > 0) {
                                    const blessingToLoseKey = blessings[Math.floor(Math.random() * blessings.length)];
                                    const blessingToLoseName = window.blessings[blessingToLoseKey].name;
                                    delete target.blessings[blessingToLoseKey];
                                    log(`呪いによって${target.name}は祝福「${blessingToLoseName}」を失ってしまった…。`);
                                } else {
                                    log(`${target.name}は祝福を授かっていなかったため、呪いの影響を受けなかった。`);
                                }
                            },
                            weight: 7,
                            needsTarget: true,
                            condition: () => gameState.party.some(p => p.blessings && Object.keys(p.blessings).length > 0)
                        }, {
                            id: 'swap_height',
                            text: '天秤の悪戯',
                            description: '最も身長が高いキャラと最も低いキャラの身長が入れ替わる。',
                            effect: async() => {
                                const aliveParty = gameState.party.filter(p => p.currentHp > 0 && !p.heightLocked);
                                if (aliveParty.length < 2) {
                                    log("呪いは発動したが、対象がいなかったため何も起こらなかった。");
                                    return;
                                }
                                aliveParty.sort((a, b) => a.height - b.height);
                                const smallest = aliveParty[0];
                                const tallest = aliveParty[aliveParty.length - 1];

                                if (smallest === tallest) {
                                    log("呪いは発動したが、全員の身長が同じだったため何も起こらなかった。");
                                    return;
                                }

                                const smallestHeight = smallest.height;
                                const tallestHeight = tallest.height;

                                log(`呪いによって、${tallest.name}と${smallest.name}の身長が入れ替わってしまった！`);
                                await animateStatChange(smallest, 'height', tallestHeight - smallest.height, 'increase');
                                await animateStatChange(tallest, 'height', smallestHeight - tallest.height, 'decrease');
                            },
                            weight: 6,
                            condition: () => gameState.party.filter(p => p.currentHp > 0 && !p.heightLocked).length >= 2
                        }, {
                            id: 'imitation_curse',
                            text: '模倣の呪い',
                            description: '次のフロアで、あなたの仲間を模倣した強敵が出現する。',
                            effect: () => {
                                gameState.nextBattleIsImitation = true;
                                log("次の戦いで、言い知れぬ恐怖と対峙することになるだろう…");
                            },
                            weight: 6,
                            // 次のフロアがボスフロアの場合は出現しない
                            condition: () => (gameState.floor + 1) % 30 !== 0
                        }, ]; // ファイター, ソーサラー, ナイト, メディック

                        // 4つの異なる呪いを選択
                        let selectedCurses = [];
                        let availableCurses = [...cursePool];
                        while (selectedCurses.length < 4 && availableCurses.length > 0) {
                            const filtered = availableCurses.filter(c => !c.condition || c.condition());
                            if (filtered.length === 0) break;
                            const index = Math.floor(Math.random() * filtered.length);
                            const curse = filtered[index];
                            // 「なにも起こらない」を追加
                            const allCurses = [...cursePool, {
                                id: 'nothing',
                                text: '空虚な刻',
                                description: '幸運にも、呪いはあなたを素通りしていった。',
                                effect: () => {
                                    log("呪いの気配が霧散し、何も起こらなかった。");
                                },
                                weight: 5
                            }];
                            if (curse.needsTarget) curse.target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                            selectedCurses.push(curse);
                            availableCurses.splice(availableCurses.findIndex(c => c.id === curse.id), 1);
                        }

                        // 選択肢ボタンを生成
                        selectedCurses.forEach(curse => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-purple-700 hover:bg-purple-800 text-white font-bold py-4 px-4 rounded-lg shadow-lg text-left';
                            const targetName = curse.target ? ` (${curse.target.name})` : '';
                            button.innerHTML = `
                                <strong class="text-lg">${curse.text}${targetName}</strong>
                                <span class="block text-sm text-purple-200 mt-1">${curse.description}</span>
                            `;
                            button.onclick = async() => {
                                endlessCurseModal.classList.add('hidden');
                                await curse.effect(curse.target);
                                setTimeout(() => {
                                    updatePartyStatus();
                                    dungeonCommands.classList.remove('hidden');
                                }, 1000);
                            };
                            endlessCurseButtons.appendChild(button);
                        });

                        dungeonCommands.classList.add('hidden');
                        endlessCurseModal.classList.remove('hidden');
                    }

                    function flashCard(target, type) {
                        const card = target.isEnemy ?
                            document.getElementById(`enemy-card-${gameState.enemies.indexOf(target)}`) :
                            document.getElementById(`party-card-${gameState.party.indexOf(target)}`);

                        if (card) {
                            const className = `flash-${type}`;
                            card.classList.add(className);
                            // 敵のカードの場合、z-indexを一時的に上げてフラッシュが手前に表示されるようにする
                            if (target.isEnemy) {
                                card.style.zIndex = '10';
                            }
                            setTimeout(() => {
                                card.classList.remove(className); // ファイター, ソーサラー, ナイト, メディック
                                if (target.isEnemy) {
                                    card.style.zIndex = 'auto';
                                }
                            }, 500); // アニメーション時間と合わせる
                        }
                    }

                    // Renamed and extended flashStat to handle both visual flash and number animation
                    async function animateStatChange(target, statName, changeAmount, type, source = 'player') {
                        if (target.isEnemy) return; // 敵のステータスは表示されていないので何もしない
                        // 身長固定フラグをチェック
                        if (statName === 'height' && target.heightLocked) {
                            // ログは呼び出し元で出すのでここでは不要
                            return;
                        }

                        const card = document.getElementById(`party-card-${gameState.party.indexOf(target)}`);
                        if (!card) return;

                        const statElement = card.querySelector(`.stat-${statName}`);
                        if (!statElement) return;

                        const statSpan = statElement.querySelector('.font-semibold');
                        if (!statSpan) {
                            // If there's no specific number span (e.g., for 'atk' if it were displayed)
                            // Just do the background flash and return
                            const className = `stat-flash-${type}`;
                            statElement.classList.add(className);
                            setTimeout(() => statElement.classList.remove(className), 800);
                            return;
                        }

                        const duration = 500; // Animation duration for number change
                        const flashDuration = 800; // Animation duration for background flash

                        // Apply background flash // ファイター, ソーサラー, ナイト, メディック
                        const flashClassName = `stat-flash-${type}`;
                        statElement.classList.add(flashClassName);
                        setTimeout(() => statElement.classList.remove(flashClassName), flashDuration);

                        // Get current displayed value (before gameState update)
                        if (!statSpan) return animationPromise; // statSpanがない場合はアニメーションをスキップ
                        let startValue;
                        if (statName === 'height') startValue = parseInt(statSpan.textContent.replace('cm', ''));
                        else startValue = parseInt(statSpan.textContent);

                        // Update the actual game state value
                        if (statName === 'hp') target.currentHp += changeAmount;
                        else if (statName === 'mp') target.currentMp += changeAmount;
                        else if (statName === 'height' && target.blessings && target.blessings.size_master && source === 'enemy') {
                            const buffAmount = Math.ceil(Math.abs(changeAmount) / 10);
                            target.buffs.atk_up = (target.buffs.atk_up || 0) + buffAmount;
                            target.buffs.protect = (target.buffs.protect || 0) + buffAmount;
                            target.buffs.agi_up = (target.buffs.agi_up || 0) + buffAmount;
                            log(`${target.name}は変幻自在の力で一時的に強化された！`);
                        } else if (statName === 'height') {
                            let newHeight = target.height + changeAmount;

                            // 「小人族の戦い」モードでの身長上限チェック
                            if (gameState.gameMode === 'dwarves' && newHeight > 10) {
                                if (target.height < 10) {
                                    log(`${target.name}はこれ以上大きくはなれないようだ！`);
                                }
                                changeAmount = 10 - target.height; // 10cmまでの変化量に修正
                                newHeight = 10;
                            }
                            // 「リトルパニック！」モードでの身長上限チェック
                            if (gameState.gameMode === 'little_panic' && ['ソーサラー', 'ドクター', 'トラブルメーカー'].includes(target.role)) {
                                if (newHeight > target.initialHeight) {
                                    changeAmount = target.initialHeight - target.height;
                                    newHeight = target.initialHeight;
                                }
                            }
                            if (newHeight > 2000) {
                                if (target.height < 2000) {
                                    // 上限に達した瞬間にメッセージを表示
                                    const showSpecialMessage = async() => {
                                        log(`${target.name}は成長の限界に達した！これ以上大きくはなれない！`);
                                        await new Promise(resolve => setTimeout(resolve, 1500));
                                        const charConvos = conversations[target.name];
                                        const maxLines = charConvos ? charConvos.grown_max : null;
                                        if (maxLines && maxLines.length > 0) {
                                            log(`${target.name}「${maxLines[Math.floor(Math.random() * maxLines.length)]}」`);
                                        }
                                    };
                                    showSpecialMessage();
                                }
                                changeAmount = 2000 - target.height; // 実際に変化する量に修正
                                target.height = 2000; // 上限値に設定
                            } else {
                                target.height += changeAmount;
                            }
                        }
                        const heightLimit = gameState.gameMode === 'endgame_plus' ? 1000 : 2000;
                        // Clamp values to min/max
                        target.currentHp = Math.min(target.maxHp, Math.max(0, target.currentHp));
                        target.currentMp = Math.min(target.maxMp, Math.max(0, target.currentMp));
                        target.height = Math.min(heightLimit, Math.max(1, Math.ceil(target.height))); // 整数にして1cmと上限値でクランプ

                        const endValue = (statName === 'hp') ? target.currentHp :
                            (statName === 'mp') ? target.currentMp :
                            (statName === 'height') ? target.height : startValue; // Fallback

                        const startTime = performance.now();
                        let resolveAnimation; // アニメーション完了を通知するためのPromise
                        const animationPromise = new Promise(resolve => {
                            resolveAnimation = resolve;
                        });

                        function updateNumber(currentTime) {
                            const elapsedTime = currentTime - startTime;
                            const progress = Math.min(1, elapsedTime / duration);
                            const currentValue = Math.ceil(startValue + (endValue - startValue) * progress);

                            // Update the displayed number and bar // ファイター, ソーサラー, ナイト, メディック
                            if (statName === 'hp') {
                                statSpan.textContent = currentValue;
                                const hpBarInner = card.querySelector('.hp-bar-inner');
                                if (hpBarInner) hpBarInner.style.width = `${Math.max(0, currentValue / target.maxHp * 100)}%`;
                            } else if (statName === 'mp') {
                                statSpan.textContent = currentValue;
                                const mpBarInner = card.querySelector('.mp-bar-inner');
                                if (mpBarInner) mpBarInner.style.width = `${Math.max(0, currentValue / target.maxMp * 100)}%`;
                            } else if (statName === 'height') {
                                statSpan.textContent = `${currentValue}cm`;
                                const heightDiffElement = card.querySelector('.stat-height');
                                if (heightDiffElement) {
                                    const diff = currentValue - target.initialHeight;
                                    heightDiffElement.innerHTML = `身長: <span class="font-semibold">${currentValue}cm</span> (${diff >= 0 ? '+' : ''}${diff})`;
                                }
                            }

                            if (progress < 1) {
                                requestAnimationFrame(updateNumber);
                            } else {
                                // Ensure final value is set after animation // ファイター, ソーサラー, ナイト, メディック
                                if (statName === 'hp') {
                                    statSpan.textContent = endValue;
                                    const hpBarInner = card.querySelector('.hp-bar-inner');
                                    if (hpBarInner) hpBarInner.style.width = `${Math.max(0, endValue / target.maxHp * 100)}%`;
                                } else if (statName === 'mp') {
                                    statSpan.textContent = endValue;
                                    const mpBarInner = card.querySelector('.mp-bar-inner');
                                    if (mpBarInner) mpBarInner.style.width = `${Math.max(0, endValue / target.maxMp * 100)}%`;
                                } else if (statName === 'height') {
                                    statSpan.textContent = `${endValue}cm`;
                                    const heightDiffElement = card.querySelector('.stat-height');
                                    if (heightDiffElement) {
                                        const diff = endValue - target.initialHeight;
                                        heightDiffElement.innerHTML = `身長: <span class="font-semibold">${endValue}cm</span> (${diff >= 0 ? '+' : ''}${diff})`;
                                    }
                                }
                                resolveAnimation();
                            }
                        }
                        requestAnimationFrame(updateNumber);
                        return animationPromise;
                    }

                    function getStatusAndBuffsHtml(target) { // ファイター, ソーサラー, ナイト, メディック
                        let html = '<div class="mt-3 pt-3 border-t border-gray-300 space-y-1">';
                        let hasEffect = false;

                        const effectMap = {
                            // buffs
                            'atk_up': {
                                name: '攻撃力アップ', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-red-600'
                            },
                            'tension_up': {
                                name: 'テンションアップ',
                                color: 'text-orange-500'
                            },

                            'protect': {
                                name: '防御力アップ', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-blue-600'
                            },
                            'agi_up': {
                                name: '素早さアップ', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-green-600'
                            },
                            'provoke': {
                                name: '挑発', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-orange-600'
                            },
                            'cover': {
                                name: 'かばう',
                                color: 'text-amber-600'
                            },
                            'evade_up': {
                                name: '回避アップ',
                                color: 'text-cyan-600'
                            },
                            'guardian_high': {
                                name: 'ガーディアンズハイ',
                                color: 'text-stone-600'
                            },
                            'trouble_check': {
                                name: 'ばっちりチェック',
                                color: 'text-rose-600'
                            },
                            // statusEffects (good)
                            'regeneration': {
                                name: 'HP自動回復', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-green-700'
                            },
                            // statusEffects (bad)
                            'poison': {
                                name: '毒', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-purple-600'
                            },
                            'paralysis': {
                                name: '麻痺',
                                color: 'text-yellow-600'
                            },
                            'slow': {
                                name: '鈍化',
                                color: 'text-gray-600'
                            },
                            'stripped': {
                                name: '脱衣', // ファイター, ソーサラー, ナイト, メディック
                                color: 'text-pink-600'
                            },
                            'stat_down': {
                                name: '能力低下',
                                color: 'text-gray-600'
                            },
                        };

                        const allEffects = {...target.buffs,
                            ...target.statusEffects
                        };

                        for (const key in allEffects) {
                            if (effectMap[key]) {
                                hasEffect = true;
                                const effect = effectMap[key];
                                const turns = (typeof allEffects[key] === 'object' && allEffects[key].turns !== undefined) ? allEffects[key].turns : (typeof allEffects[key] === 'number' && allEffects[key] > 0 ? allEffects[key] : null);
                                html += `<p class="${effect.color} font-semibold">${effect.name} ${turns !== null ? `(残り ${turns} ターン)` : ''}</p>`;
                            }
                    }

                if (!hasEffect) return ''; // 効果がなければ何も返さない
                return html + '</div>';
            }

            function showScanResult(target) {
                const scanModalTitle = document.getElementById('scan-modal-title');
                const scanModalContent = document.getElementById('scan-modal-content');
                const scanModalTextContainer = document.getElementById('scan-modal-text-content');
                const scanModalImageContainer = document.getElementById('scan-modal-image-container');
                scanModalContent.innerHTML = ''; // コンテンツをクリア
                scanModalImageContainer.innerHTML = ''; // 画像コンテナもクリア

                if (target.isEnemy) {
                    scanModalTitle.textContent = `${target.name} の調査結果`;

                    let weakness = '物理・魔法ともに同程度有効。';
                    if (target.pDef < target.mDef * 0.8) {
                        weakness = '<strong class="text-red-600">物理攻撃が有効。</strong> 魔法攻撃は効きにくい。';
                    } else if (target.mDef < target.pDef * 0.8) {
                        weakness = '<strong class="text-blue-600">魔法攻撃が有効。</strong> 物理攻撃は効きにくい。';
                    }

                    let skillInfo = '特別なスキルは使用しない。';
                    if (target.skills && target.skills.length > 0) {
                        skillInfo = '使用スキル: ' + target.skills.map(s => s.name).join('、');
                    }

                    scanModalContent.innerHTML = `
                        <p>HP: ${target.currentHp} / ${target.maxHp}</p>
                        <p>弱点: ${weakness}</p>
                        <p>${skillInfo}</p> 
                        ${getStatusAndBuffsHtml(target)}
                    `;
                    // 敵の場合は立ち絵を隠し、テキストエリアを全幅にする
                    scanModalImageContainer.classList.add('hidden');
                    scanModalTextContainer.classList.remove('md:w-1/2');
                    scanModalTextContainer.classList.add('w-full');

                } else { // 味方の場合
                    scanModalTitle.textContent = `${target.name} の情報`;
                    // 変身状態を考慮してブループリントを一度だけ取得する
                    const blueprint = allCharacterBlueprints.find(c => c.name === (target.isTransformed ? 'リリィ' : target.name));
                    let skillHtml = target.skills.map(skill => {
                        return `<div class="p-2 bg-gray-100 rounded-md">
                                   <p class="font-bold">${skill.name} <span class="text-sm font-normal text-gray-600">(${skill.type && skill.type.includes('hp_cost') ? 'HP' : 'MP'}:${skill.cost})</span></p>
                                   <p class="text-sm">${skill.description}</p>
                               </div>`;
                    }).join('');

                    let blessingHtml = '';
                    if (target.blessings && Object.keys(target.blessings).length > 0) {
                        blessingHtml += '<div class="mt-3 pt-3 border-t border-gray-300 space-y-1">';
                        blessingHtml += '<p class="font-bold text-amber-700">授かった祝福</p>';
                        Object.keys(target.blessings).forEach(blessingKey => {
                            const blessingInfo = blessings[blessingKey];
                            if (blessingInfo) {
                                blessingHtml += `<div class="p-2 bg-amber-50 rounded-md"><p class="font-semibold text-amber-800">${blessingInfo.name}</p><p class="text-sm text-amber-700">${blessingInfo.description}</p></div>`;
                            }
                        });
                        blessingHtml += '</div>';
                    }

                    // 先天性能力の表示
                    const innateCriticalRoles = ['ファイター', 'ナイト', 'サムライ', 'ガーディアン', 'トラブルメーカー', 'アンドロイド'];
                    const innateMpRecoveryRoles = ['ソーサラー', 'メディック', 'モンク', 'ギャンブラー', 'サモナー', 'アルケミスト', 'ダンサー', 'ネクロマンサー', 'ドクター'];

                    let innateHtml = '';
                    if (innateCriticalRoles.includes(target.role)) {
                        innateHtml += `<div class="p-2 bg-gray-100 rounded-md"><p class="font-semibold text-gray-800">先天性：クリティカル</p><p class="text-sm text-gray-700">通常攻撃時、確率で会心の一撃になる。</p></div>`;
                    }
                    if (innateMpRecoveryRoles.includes(target.role)) {
                        innateHtml += `<div class="p-2 bg-gray-100 rounded-md"><p class="font-semibold text-gray-800">先天性：MP回復</p><p class="text-sm text-gray-700">通常攻撃時、自身のMPが少し回復する。</p></div>`;
                    }

                    if (innateHtml) {
                        // 祝福欄が既にあればその中に追加、なければ新しく作る
                        if (blessingHtml) {
                            // 閉じタグの直前に挿入
                            blessingHtml = blessingHtml.slice(0, -6) + innateHtml + '</div>';
                        } else {
                            blessingHtml = '<div class="mt-3 pt-3 border-t border-gray-300 space-y-1">' +
                                '<p class="font-bold text-amber-700">授かった祝福</p>' + innateHtml + '</div>';
                        }
                    }

                    scanModalContent.innerHTML = `
                        <p class="italic">"${blueprint.description}"</p>
                        <div class="space-y-2 mt-2">${skillHtml}</div>
                        ${getStatusAndBuffsHtml(target)}
                        ${blessingHtml}
                    `;
                    // 味方の場合は立ち絵を表示し、テキストエリアを半分の幅にする
                    scanModalImageContainer.classList.remove('hidden');
                    scanModalTextContainer.classList.remove('w-full');
                    scanModalTextContainer.classList.add('md:w-1/2');

                    // 立ち絵の表示
                    const imgDiv = document.createElement('div');
                    const bgClass = target.bgClass || blueprint.bgClass;
                    imgDiv.className = `absolute inset-0 bg-no-repeat ${bgClass}`;
                    imgDiv.style.backgroundSize = 'contain';
                    imgDiv.style.backgroundPosition = 'center';
                    scanModalImageContainer.appendChild(imgDiv);
                }

                scanModal.classList.remove('hidden');
                pendingAction = null; // アクションをクリア
                document.querySelectorAll('.enemy-card, .character-card').forEach(c => c.classList.remove('targeted'));
            }

            function showAmountChoiceModal(title, text, choices, callback) {
                amountChoiceTitle.textContent = title;
                amountChoiceText.textContent = text;
                amountChoiceButtons.innerHTML = '';

                choices.forEach(choice => {
                    const button = document.createElement('button');
                    button.className = 'action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg';
                    button.textContent = choice.text;
                    button.onclick = () => {
                        amountChoiceModal.classList.add('hidden');
                        callback(choice.value);
                    };
                    amountChoiceButtons.appendChild(button);
                });

                amountChoiceModal.classList.remove('hidden');
            }

            function cancelScanMode() {
                // 探索中の「調べる」モードをキャンセルする
                if (!gameState.inBattle) {
                    log('探索を続けます。');
                    dungeonCommands.classList.remove('hidden');
                    updatePartyStatus(); // クリックイベントとカードのスタイルを元に戻す
                }
            }

            function showScanTargetSelection() {
                log('誰を調べますか？');
                dungeonCommands.classList.add('hidden'); // コマンドを隠す
                gameState.party.forEach((char, index) => {
                    const card = document.getElementById(`party-card-${index}`);
                    if (card) {
                        card.classList.add('targeted');
                        // 探索中のクリックイベントを一時的に上書き
                        card.onclick = () => {
                            showScanResult(char);
                        };
                    }
                });
            }

            function showItemModal(character = null) {
                itemList.innerHTML = '';
                const availableItems = gameState.inventory.filter(item => item.quantity > 0);

                if (availableItems.length === 0) {
                    itemList.innerHTML = '<p class="text-gray-500">使えるアイテムがありません。</p>';
                } else {
                    availableItems.forEach(item => {
                        const itemInfo = itemBlueprints[item.id];
                        let canUse = gameState.inBattle || !itemInfo.battleOnly;

                        // 復活アイテムは戦闘中で、かつ戦闘不能の味方がいる場合のみ使用可能
                        if (itemInfo.effect === 'revive') {
                            const hasFallenAlly = gameState.party.some(p => p.currentHp <= 0);
                            canUse = gameState.inBattle && hasFallenAlly;
                        }

                        const itemDiv = document.createElement('div');
                        let itemClasses = 'p-2 border-b flex justify-between items-center';
                        if (!canUse) {
                            itemClasses += ' opacity-50';
                        }
                        itemDiv.className = itemClasses;

                        itemDiv.innerHTML = `
                            <div>
                                <p class="font-bold">${itemInfo.name} (x${item.quantity})</p>
                                <p class="text-sm text-gray-600">${itemInfo.description}</p>
                            </div>
                            <button 
                                class="use-item-btn action-button text-white text-sm py-1 px-3 rounded ${canUse ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-400 cursor-not-allowed'}"
                                ${!canUse ? 'disabled' : ''}
                            >つかう</button>
                        `;
                        itemDiv.querySelector('.use-item-btn').onclick = () => {
                            useItem(character, item);
                        };
                        itemList.appendChild(itemDiv);
                    });
                }
                itemModal.classList.remove('hidden');
            }

            function useItem(character, item) {
                itemModal.classList.add('hidden');
                const itemInfo = itemBlueprints[item.id];

                if (!gameState.inBattle && itemInfo.battleOnly) {
                    log("そのアイテムはバトル中にしか使えません。");
                    return;
                }

                if (gameState.inBattle) {
                    playerAction(character, {
                        type: 'item',
                        item: item
                    });
                } else {
                    // 探索中のアイテム使用
                    pendingAction = {
                        character: getRandomPartyMember(),
                        action: {
                            type: 'item',
                            item: item
                        },
                        target: null // ターゲットは後で選択
                    };
                    if (itemInfo.target === 'ally' || itemInfo.target === 'any') {
                        log('誰に使いますか？');
                        // 復活アイテムの場合、戦闘不能の味方をターゲット可能にする
                        if (itemInfo.effect === 'revive') {
                            gameState.party.forEach((char, index) => {
                                // 戦闘不能のキャラのみ光らせる
                                if (char.currentHp <= 0) {
                                    document.getElementById(`party-card-${index}`).classList.add('targeted');
                                }
                            });
                            return; // ここで処理を中断し、ユーザーの選択を待つ
                        }
                        gameState.party.forEach((char, index) => {
                            if (char.currentHp > 0) document.getElementById(`party-card-${index}`).classList.add('targeted');
                        });
                    } else if (itemInfo.target === 'party') {
                        // 全体対象や対象不要のアイテム
                        handleItem(pendingAction.character, gameState.party, pendingAction.action.item);
                    } else {
                        // 全体対象や対象不要のアイテム
                        executePlayerAction();
                    }
                }
            }

            function startGame(mode = 'normal', selectedMembers = null, fromSave = false) {
                gameState.gameMode = mode;

                // 新しいモード「運命の出会い」の処理
                if (mode === 'random_party') {
                    const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                    let characterPool = allCharacterBlueprints.map(c => c.name);

                    // 聖女の行進をクリアしていない場合、聖女を抽選対象から除外
                    if (!clearFlags.saintMarchCleared) {
                        characterPool = characterPool.filter(name => name !== 'セレスティア');
                    }

                    // Fisher-Yates shuffleで配列をシャッフル
                    for (let i = characterPool.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [characterPool[i], characterPool[j]] = [characterPool[j], characterPool[i]];
                    }

                    selectedMembers = characterPool.slice(0, 4); // シャッフルされたリストから先頭4人を選ぶ
                }

                if (mode === 'treasure_map') {
                    selectedMembers = ['リリィ'];
                }
                if (mode === 'brawling_belles') {
                    selectedMembers = ['ノエル', 'フローラ'];
                }

                // メンバー選択が必要なモードで、まだメンバーが選ばれていない場合 (聖女の行進は除く)
                const toggleSelectTeam = document.getElementById('toggle-select-team');
                const fixedPartyModes = ['normal', 'saint_march', 'treasure_map', 'summer_live', 'random_party', 'little_panic', 'brawling_belles'];
                const teamSelectionRequired = toggleSelectTeam.checked && !fixedPartyModes.includes(mode);

                if ((mode === 'solo' || mode === 'indecent' || mode === 'secret_night' || teamSelectionRequired) && !selectedMembers) {
                    whatIfModal.classList.add('hidden');
                    showSelectTeamModal(mode); // モードを引き継いで選択画面へ
                    return;
                }

                // パーティ表示をクリア
                partyContainer.innerHTML = '';

                titleScreen.classList.add('hidden');
                whatIfModal.classList.add('hidden');
                selectTeamModal.classList.add('hidden');
                dungeonView.classList.remove('hidden');
                hud.classList.remove('hidden');
                commandContainer.classList.remove('hidden');

                if (mode === 'saint_march') {
                    selectedMembers = ['セレスティア'];
                }

                // サマータイム・スペシャルライブ！モードの初期設定
                if (mode === 'summer_live') {
                    selectedMembers = ['リリカ', 'ユイ', 'ミコ', 'リリィ'];
                } else if (mode === 'little_panic') {
                    selectedMembers = ['ヒカリ', 'ベアトリス', 'コハル', 'オリビア'];
                }

                initGame(selectedMembers, fromSave);

                // initGame の後にモード別の特殊設定を適用
                let backgroundSet = false;
                if (!fromSave) {
                    if (mode === 'little_panic') {
                        gameState.party.forEach(char => {
                            switch (char.role) {
                                case 'シスター':
                                    // レベル10に設定
                                    applyLevelUp(char, 9);
                                    // スキル変更
                                    char.skills = char.skills.map(skill => {
                                        if (skill.name === 'ホーリーライト') {
                                            return littlePanicSkills.holySphere;
                                        }
                                        if (skill.name === '祈りの円環') {
                                            return littlePanicSkills.heavensJudgment;
                                        }
                                        return skill;
                                    });
                                    // 立ち絵変更
                                    char.bgClass = 'bg-char-olivia-a';
                                    break;
                                case 'ソーサラー': // ドクターからアルケミストに変更
                                case 'アルケミスト':
                                case 'トラブルメーカー':
                                    // 身長と初期身長を-30
                                    char.height -= 30;
                                    char.initialHeight -= 30;
                                    // 立ち絵変更
                                    if (char.role === 'ソーサラー') char.bgClass = 'bg-char-hikari-a';
                                    if (char.role === 'アルケミスト') char.bgClass = 'bg-char-beatrice-a';
                                    if (char.role === 'トラブルメーカー') char.bgClass = 'bg-char-koharu-a';
                                    break;
                            }
                        });
                        log("幼くなった仲間を守るため、シスターが本気を出す！");
                    }
                    if (mode === 'summer_live') {
                        backgroundSet = true;
                        gameState.dungeonBackground = SUMMER_BEACH_BG;
                        // 開始レベルを2にする
                        gameState.party.forEach(char => {
                            applyLevelUp(char, 1); // Lv1 -> Lv2
                            // レベルアップ後にHP/MPを全快させる
                            char.currentHp = char.maxHp;
                            char.currentMp = char.maxMp;
                        });

                        // 立ち絵を水着に変更
                        gameState.party.forEach(char => {
                            if (char.name === 'リリカ') char.bgClass = 'bg-char-ririka-a';
                            if (char.name === 'ユイ') char.bgClass = 'bg-char-yui-a';
                            if (char.name === 'ミコ') char.bgClass = 'bg-char-miko-a';
                        });

                        // リリィをフェアリー化＆スキル変更
                        const lily = gameState.party.find(p => p.name === 'リリィ');
                        if (lily) {
                            const blueprint = allCharacterBlueprints.find(c => c.name === 'リリィ');
                            const transformData = blueprint.transforms['fairy'];
                            lily.originalState = { role: lily.role, skills: lily.skills, bgClass: lily.bgClass, height: lily.height };
                            // 開始時の身長を30cmにする
                            lily.height = 30;
                            lily.role = transformData.role;
                            lily.skills = transformData.skills.map(s => {
                                if (s.type === 'transform_revert') {
                                    return { name: 'ビーチエール', cost: 10, type: 'cure_strip_party', targetType: 'party', description: '味方全員の脱衣状態を解除する。' };
                                }
                                return s;
                            });
                            lily.bgClass = 'bg-char-lily-fairy-a'; // 水着フェアリー
                            lily.isTransformed = true;
                        }

                        // ユイのスキル変更
                        const yui = gameState.party.find(p => p.name === 'ユイ');
                        if (yui) {
                            const devotionIndex = yui.skills.findIndex(s => s.name === '献身');
                            if (devotionIndex !== -1) {
                                yui.skills[devotionIndex] = { name: 'パッションハート', cost: 15, type: 'party_heal', targetType: 'party', description: '味方全体のHPを30%回復する。' };
                            }
                        }
                    }
                }
                // 通常モードの背景設定
                if (!backgroundSet) {
                    gameState.dungeonBackground = DEFAULT_DUNGEON_BG;
                }
                dungeonView.style.backgroundImage = gameState.dungeonBackground;

                setupDungeonUI();
                        // ログキューを初期化
                        logQueue = [];
                        isProcessingLog = false;
                        logMessage.textContent = '';

                dungeonCommands.classList.remove('hidden');
                battleCommands.classList.add('hidden');
                enemyContainer.innerHTML = '';
                updatePartyStatus();
            }

                    let logQueue = [];
                    let isProcessingLog = false;

                    function processLogQueue() {
                        if (logQueue.length === 0) {
                            isProcessingLog = false;
                            return;
                        }
                        isProcessingLog = true;
                        const message = logQueue.shift();
                        addLogToHistory(message); // ログを履歴に追加
                        logMessage.textContent = message;

                        // メッセージ表示後に次のメッセージを表示するまでの遅延
                        const delay = 700; // 0.7秒
                        setTimeout(processLogQueue, delay);
                    }

            nextFloorButton.addEventListener('click', () => {
                if (!gameState.inBattle && !gameState.gameOver) advanceFloor();
            });
            talkButton.addEventListener('click', () => {
                cancelScanMode(); // 会話する前に調べるモードを終了
                generateConversation();
            });
            modalButton.addEventListener('click', () => {
                returnToTitle();
            });
            itemModalClose.addEventListener('click', () => {
                itemModal.classList.add('hidden');
                document.querySelectorAll('.character-card').forEach(c => c.classList.remove('targeted'));
            });
            loadButton.addEventListener('click', () => {
                const savedData = localStorage.getItem('sizeDungeonSaveData');
                if (savedData) {
                    try {
                        const loadedState = JSON.parse(savedData);
                        // セーブデータをgameStateに復元
                        gameState = loadedState;
                        // ゲーム画面を直接セットアップ
                        // 背景画像を復元
                        dungeonView.style.backgroundImage = gameState.dungeonBackground || DEFAULT_DUNGEON_BG;
                        titleScreen.classList.add('hidden');
                        dungeonView.classList.remove('hidden');
                        hud.classList.remove('hidden');
                        commandContainer.classList.remove('hidden');
                        setupDungeonUI();
                        updatePartyStatus();
                        log("セーブデータをロードしました。");
                    } catch (e) {
                        console.error("セーブデータの読み込みに失敗しました:", e);
                        alert("セーブデータの形式が正しくありません。");
                    }
                }
            });
            startButton.addEventListener('click', () => startGame('normal'));
            ruleButton.addEventListener('click', () => ruleModal.classList.remove('hidden'));
            ruleModalClose.addEventListener('click', () => ruleModal.classList.add('hidden'));
            whatIfButton.addEventListener('click', () => whatIfModal.classList.remove('hidden'));
            whatIfModalClose.addEventListener('click', () => whatIfModal.classList.add('hidden'));
            selectTeamBackButton.addEventListener('click', () => {
                // 選択状態をリセット
                pendingAction = null;
                selectTeamModal.classList.add('hidden');
                whatIfModal.classList.remove('hidden');
            });

            // 「もしもの物語」のタブ切り替え処理
            const whatIfTabs = document.querySelectorAll('.what-if-tab');
            const whatIfContents = document.querySelectorAll('.what-if-content');

            whatIfTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // すべてのタブとコンテンツを非アクティブ/非表示にする
                    whatIfTabs.forEach(t => t.classList.remove('active-tab'));
                    whatIfContents.forEach(c => c.classList.add('hidden'));

                    // クリックされたタブと対応するコンテンツをアクティブ/表示にする
                    tab.classList.add('active-tab');
                    const tabName = tab.dataset.tab;
                    document.getElementById(`what-if-content-${tabName}`).classList.remove('hidden');
                });
            });

            // 各モード選択ボタンにイベントリスナーを設定
            document.querySelectorAll('.what-if-content button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const mode = e.currentTarget.dataset.mode;
                    whatIfModal.classList.add('hidden'); // モーダルを閉じる処理を追加
                    // startGameを呼び出す。メンバー選択が必要なら中で処理される
                    startGame(mode);
                });
            });

            // リトルパニックモードのスキル定義
            const littlePanicSkills = {
                holySphere: {
                    name: 'ホーリースフィア', // ファイター, ソーサラー, ナイト, メディック
                    cost: 30,
                    power: 3.5,
                    type: 'magic',
                    targetType: 'enemies',
                    description: '敵全体に高威力の聖なる魔法ダメージを与える。'
                },
                heavensJudgment: {
                    name: '天の裁き',
                    cost: 50,
                    power: 999,
                    type: 'magic',
                    targetType: 'enemy',
                    description: '敵ひとりをほぼ確実に倒す魔法攻撃。低確率で味方ひとりが大ダメージを受ける。'
                }
            };

            // 天の裁きの副作用処理
            async function handleHeavensJudgmentSideEffect(caster) {
                if (Math.random() < 0.15) { // 15%の確率で副作用
                    const aliveAllies = gameState.party.filter(p => p.currentHp > 0 && p !== caster);
                    if (aliveAllies.length > 0) {
                        const victim = aliveAllies[Math.floor(Math.random() * aliveAllies.length)];
                        const damage = Math.ceil(victim.currentHp * 0.7);
                        log(`天罰が下り、${victim.name}が巻き添えを食らった！`);
                        await dealDamage(victim, damage);
                        return true;
                    }
                }
                return false;
            }




            scanModalClose.addEventListener('click', () => {
                scanModal.classList.add('hidden');
                // 「調べる」をキャンセルした場合、元のキャラクターのターンに戻す
                if (gameState.inBattle && !pendingAction) {
                    playerTurn(gameState.turnOrder[gameState.currentTurnIndex]);
                } else if (!gameState.inBattle) {
                    // 探索中の場合は調べるモードをキャンセルするだけ
                    cancelScanMode();
                }
            });

            menuButton.addEventListener('click', () => {
                if (!gameState.inBattle) { // 戦闘中でなければメニューを開ける
                    menuModal.classList.remove('hidden');
                } else {
                    log("戦闘中はメニューを開けません。");
                }
            });
            menuModalClose.addEventListener('click', () => menuModal.classList.add('hidden'));
            saveButton.addEventListener('click', () => {
                try {
                    localStorage.setItem('sizeDungeonSaveData', JSON.stringify(gameState));
                    log("ゲームの状態をセーブしました。");
                    menuModal.classList.add('hidden');
                    checkSaveData(); // セーブ後に「つづきから」ボタンの状態を更新
                } catch (e) {
                    console.error("セーブに失敗しました:", e);
                    log("セーブに失敗しました。ブラウザのストレージ容量が不足している可能性があります。");
                }
            });
            menuReturnTitleButton.addEventListener('click', () => {
                menuModal.classList.add('hidden');
                returnToTitle();
            });

            emergencyButton.addEventListener('click', () => {
                if (!gameState.inBattle) return; // 戦闘中のみ有効

                log("【緊急処理】現在のターンを強制的にスキップします。");

                // 保留中のアクションをクリア
                pendingAction = null;
                document.querySelectorAll('.enemy-card, .character-card').forEach(c => c.classList.remove('targeted'));

                // コマンドUIをリセット
                actionButtons.innerHTML = '';
                commandMessage.textContent = '';

                // ターンを進める
                gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                nextTurn();
            });

            function showSelectTeamModal(mode) {
                teamSelectionList.innerHTML = '';
                let selectedNames = [];
                const isSolo = mode === 'solo';
                const isIndecent = mode === 'indecent';
                const isTrial = mode === 'trial' || mode === 'enjoy' || mode === 'uninhibited_souls';
                const isSecretNight = mode === 'secret_night';


                // モードに応じてプロンプトと選択上限を変更 (enjoy, uninhibited_souls も trial と同じ扱い)
                if (isSolo) {
                    selectionPrompt.textContent = '共に冒険する仲間を1人選んでください。';
                } else if (isIndecent) {
                    selectionPrompt.textContent = '共に冒険する仲間を2～4人選んでください。(ナイト、サムライは選択不可)';
                } else if (isTrial) {
                    selectionPrompt.textContent = '共に冒険する仲間を2～4人選んでください。(このモードはチーム選択が可能です)';
                } else if (isSecretNight) {
                    selectionPrompt.textContent = 'ヒミツの夜を過ごす仲間を1人選んでください。';
                } else {
                    selectionPrompt.textContent = '共に冒険する仲間を2～4人選んでください。';
                }

                // 表示するキャラクターリストを準備
                const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                let availableBlueprints = allCharacterBlueprints.filter(char => {
                    if (char.role === '聖女' && !clearFlags.saintMarchCleared) return false;
                    if (char.role === 'トレジャーハンター' && !clearFlags.treasureMapCleared) return false;
                    if (char.role === 'アンドロイド' && !clearFlags.brawlingBellesCleared) return false;
                    if (isSecretNight) {
                        const secretNightChars = ['リリカ', 'ユイ', 'ミコ', 'リリィ', 'フローラ'];
                        return secretNightChars.includes(char.name);
                    }
                    if (char.role === 'メイド' && !clearFlags.brawlingBellesCleared) return false;
                    return true; // ファイター, ソーサラー, ナイト, メディック
                }); // ファイター, ソーサラー, ナイト, メディック
                
                // 終焉の呼び声モードの参加資格チェック
                const soloClearFlags = JSON.parse(localStorage.getItem('sizeDungeonSoloClearFlags') || '{}');
                const starObserverClearers = JSON.parse(localStorage.getItem('sizeDungeonStarObserverClearers') || '{}');
                const isEndgamePlus = mode === 'endgame_plus';

                availableBlueprints.forEach(char => {
                    if (isIndecent && (char.role === 'ナイト' || char.role === 'サムライ' || char.role === '聖女')) {
                        return; // 痴態騒ぎモードではナイト、サムライ、聖女をスキップ
                    }
                    // 終焉の呼び声モードの参加資格チェック
                    if (isEndgamePlus && !soloClearFlags[char.name] && !starObserverClearers[char.name]) {
                        return; // 資格がなければスキップ
                    }


                    const specialRoles = ['聖女', 'トレジャーハンター', 'アンドロイド', 'メイド'];
                    const isSpecialChar = specialRoles.includes(char.role);

                    const card = document.createElement('div');
                    let cardClasses = 'p-4 border-2 border-gray-200 rounded-lg cursor-pointer hover:bg-gray-100 transition';

                    // 特別なキャラクターの背景色を少し変える
                    if (isSpecialChar) {
                        // TailwindのJITコンパイラが動的にクラスを生成できるよう、完全なクラス名を記述します。
                        if (char.themeColor === 'yellow') cardClasses += ' bg-gradient-to-br from-yellow-50 to-yellow-100';
                        else if (char.themeColor === 'lime') cardClasses += ' bg-gradient-to-br from-lime-50 to-lime-100';
                        else if (char.themeColor === 'rose') cardClasses += ' bg-gradient-to-br from-rose-50 to-rose-100';
                        else if (char.themeColor === 'emerald') cardClasses += ' bg-gradient-to-br from-emerald-50 to-emerald-100';
                    }
                    card.className = cardClasses;
                    card.dataset.name = char.name;
                    card.innerHTML = `
                        <p class="font-bold text-lg text-${char.themeColor}-700">${char.name}</p>
                        <p class="text-sm text-gray-600">${char.role}</p>
                    `;
                    card.addEventListener('click', () => {
                        if (selectedNames.includes(char.name)) {
                            selectedNames = selectedNames.filter(name => name !== char.name);
                            card.classList.remove('border-indigo-500', 'bg-indigo-50');
                        } else if ((isSolo || isSecretNight) && selectedNames.length < 1) {
                            selectedNames.push(char.name);
                            card.classList.add('border-indigo-500', 'bg-indigo-50');
                        } else if (!isSolo && !isSecretNight && selectedNames.length < 4) {
                            selectedNames.push(char.name);
                            card.classList.add('border-indigo-500', 'bg-indigo-50');
                        }
                        updateSelectionUI();
                    });
                    teamSelectionList.appendChild(card);
                });

                function updateSelectionUI() {
                    let isValid;
                    if (isSolo || isSecretNight) { // 1人選択モード
                        selectionCounter.textContent = `${selectedNames.length} / 1 人選択中`;
                        isValid = selectedNames.length === 1;
                    } else { // 2〜4人選択モード
                        selectionCounter.textContent = `${selectedNames.length} 人選択中`;
                        isValid = selectedNames.length >= 2 && selectedNames.length <= 4;
                    }
                    startSelectionButton.disabled = !isValid;
                    startSelectionButton.classList.toggle('opacity-50', !isValid);
                    startSelectionButton.classList.toggle('cursor-not-allowed', !isValid);
                }

                startSelectionButton.onclick = () => {
                    const count = selectedNames.length;
                    const validSolo = isSolo && count === 1; // soloモードは1人
                    const validSecretNight = isSecretNight && count === 1; // secret_nightモードは1人
                    const validTrial = isTrial && count >= 2 && count <= 4; // trial, enjoy, uninhibited_soulsモードは2-4人
                    const validIndecent = isIndecent && count >= 2 && count <= 4; // indecentモードは2-4人
                    // 上記以外のモード（endgame_plusなど）でチーム選択が有効な場合
                    const validTeam = !isSolo && !isSecretNight && !isIndecent && !isTrial && count >= 2 && count <= 4;

                    if (validSolo || validSecretNight || validIndecent || validTrial || validTeam) startGame(mode, selectedNames);
                };

                selectTeamModal.classList.remove('hidden');
            }

            randomSelectButton.addEventListener('click', () => {
                const teamListContainer = document.getElementById('team-selection-list');
                const allCharacterCards = Array.from(teamListContainer.children);
                const availableCharacters = allCharacterCards.map(card => card.dataset.name);

                // Fisher-Yates shuffle algorithm
                for (let i = availableCharacters.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availableCharacters[i], availableCharacters[j]] = [availableCharacters[j], availableCharacters[i]];
                }

                const isSolo = gameState.gameMode === 'solo';
                const selectionCount = isSolo ? 1 : 4;
                const randomSelection = availableCharacters.slice(0, selectionCount);

                // Simulate clicks on the character cards
                allCharacterCards.forEach(card => {
                    const shouldBeSelected = randomSelection.includes(card.dataset.name);
                    const isCurrentlySelected = card.classList.contains('border-indigo-500');
                    if (shouldBeSelected !== isCurrentlySelected) card.click();
                });
            });

            function returnToTitle() {
                modal.classList.add('hidden');
                titleScreen.classList.remove('hidden');
                dungeonView.classList.add('hidden');
                hud.classList.add('hidden');
                commandContainer.classList.add('hidden');
                // 背景をデフォルトに戻す
                dungeonView.style.backgroundImage = DEFAULT_DUNGEON_BG;
                checkSaveData(); // タイトルに戻るたびにセーブデータの有無をチェック
            }

            // --- デバッグ用クリアフラグ操作 ---
            const debugSaintButton = document.getElementById('debug-saint-button');
            const debugTreasureButton = document.getElementById('debug-treasure-button');
            const debugSummerButton = document.getElementById('debug-summer-button');
            const debugBellesButton = document.getElementById('debug-belles-button');
            const debugEndgameButton = document.createElement('button'); // 終焉モード用

            // ボタンの表示状態を更新する関数
            function updateDebugButtons() {
                const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');

                // 終焉の呼び声ボタンの表示制御
                if (clearFlags.endgameCleared) endgamePlusButton.classList.remove('hidden');
                else endgamePlusButton.classList.add('hidden');

                // 聖女
                if (clearFlags.saintMarchCleared) {
                    debugSaintButton.textContent = '聖女クリア済';
                    debugSaintButton.className = 'text-white p-1 rounded bg-green-600 hover:bg-green-700';
                } else {
                    debugSaintButton.textContent = '聖女未クリア';
                    debugSaintButton.className = 'text-white p-1 rounded bg-red-600 hover:bg-red-700';
                }

                // 秘宝
                if (clearFlags.treasureMapCleared) {
                    debugTreasureButton.textContent = '秘宝クリア済';
                    debugTreasureButton.className = 'text-white p-1 rounded bg-green-600 hover:bg-green-700';
                } else {
                    debugTreasureButton.textContent = '秘宝未クリア';
                    debugTreasureButton.className = 'text-white p-1 rounded bg-red-600 hover:bg-red-700';
                }

                // サマー
                if (clearFlags.summerLiveCleared) {
                    debugSummerButton.textContent = 'サマークリア済';
                    debugSummerButton.className = 'text-white p-1 rounded bg-green-600 hover:bg-green-700';
                } else {
                    debugSummerButton.textContent = 'サマー未クリア';
                    debugSummerButton.className = 'text-white p-1 rounded bg-red-600 hover:bg-red-700';
                }

                // 闘争令嬢
                if (clearFlags.brawlingBellesCleared) {
                    debugBellesButton.textContent = '令嬢クリア済';
                    debugBellesButton.className = 'text-white p-1 rounded bg-green-600 hover:bg-green-700';
                } else {
                    debugBellesButton.textContent = '令嬢未クリア';
                    debugBellesButton.className = 'text-white p-1 rounded bg-red-600 hover:bg-red-700';
                }

                // 終焉
                if (clearFlags.endgameCleared) {
                    debugEndgameButton.textContent = '終焉クリア済';
                    debugEndgameButton.className = 'text-white p-1 rounded bg-green-600 hover:bg-green-700';
                } else {
                    debugEndgameButton.textContent = '終焉未クリア';
                    debugEndgameButton.className = 'text-white p-1 rounded bg-red-600 hover:bg-red-700';
                }
            }

            // クリアフラグをトグルする関数
            function toggleClearFlag(flagName) {
                const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                const isClearing = !clearFlags[flagName]; // これからクリア済みにするかどうか
                clearFlags[flagName] = isClearing;
                localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(clearFlags));

                // 「終焉の呼び声」のデバッグ操作時に、参加資格も同時に操作する
                if (flagName === 'endgameCleared') {
                    if (isClearing) { // 終焉をクリア済みにする場合
                        const soloClearFlags = {};
                        allCharacterBlueprints.forEach(char => {
                            soloClearFlags[char.name] = true;
                        });
                        localStorage.setItem('sizeDungeonSoloClearFlags', JSON.stringify(soloClearFlags));
                    } else { // 未クリアに戻す場合
                        localStorage.removeItem('sizeDungeonSoloClearFlags');
                    }
                }

                updateDebugButtons();
            }

            // デバッグボタンのイベントリスナーを設定する関数
            function setupDebugControls() {
                debugEndgameButton.id = 'debug-endgame-button';
                document.getElementById('debug-controls').appendChild(debugEndgameButton);
                debugSaintButton.addEventListener('click', () => toggleClearFlag('saintMarchCleared'));
                debugTreasureButton.addEventListener('click', () => toggleClearFlag('treasureMapCleared'));
                debugSummerButton.addEventListener('click', () => toggleClearFlag('summerLiveCleared'));
                debugBellesButton.addEventListener('click', () => toggleClearFlag('brawlingBellesCleared'));
                debugEndgameButton.addEventListener('click', () => toggleClearFlag('endgameCleared'));
            }
            // ログ履歴表示のイベントリスナー
            logContainer.addEventListener('mouseenter', () => {
                if (logHistory.length > 0) {
                    const recentLogs = logHistory.slice(-5).reverse(); // 最新5件を新しい順に取得
                    logTooltip.innerHTML = recentLogs.map((log, index) => 
                        `<p class="${index === 0 ? 'font-bold' : 'text-gray-300'}">${log}</p>`
                    ).join('');
                    logTooltip.classList.remove('hidden');
                }
            });

            logContainer.addEventListener('mouseleave', () => {
                logTooltip.classList.add('hidden');
            });

            // ツールチップ自体にマウスが入った時も表示を維持
            logTooltip.addEventListener('mouseenter', () => {
                logTooltip.classList.remove('hidden');
            });
            logTooltip.addEventListener('mouseleave', () => {
                logTooltip.classList.add('hidden');
            });

            // --- 初期化処理 ---
            // セーブデータの有無をチェックし、「つづきから」ボタンの表示を制御
            function checkSaveData() {
                if (localStorage.getItem('sizeDungeonSaveData')) {
                    loadButton.classList.remove('hidden');
                } else {
                    loadButton.classList.add('hidden');
                }
            }
            checkSaveData(); // セーブデータチェックを実行
            setupDebugControls(); // デバッグ関連のセットアップを実行
            updateDebugButtons(); // デバッグボタンの初期表示を更新
        });
    </script>
</body>

</html>