<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>しゅりんく・だんじょん・がーるず</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            touch-action: manipulation;
        }
        
        .hud-gradient {
            background-image: linear-gradient(to top, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.8));
        }
        
        .log-gradient {
            background-image: linear-gradient(to bottom, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.8));
        }
        
        .action-button {
            transition: all 0.2s ease-in-out;
        }
        
        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        .action-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .hp-bar-inner,
        .mp-bar-inner {
            transition: width 0.5s ease-in-out;
        }
        
        .character-card {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            min-height: 160px;
            /* 少し高さを増やして見栄えを調整 */
            position: relative;
            overflow: hidden;
            /* 疑似要素をはみ出させない */
            display: flex;
            align-items: flex-end;
            /* 子要素を下揃えにする */
        }
        
        .character-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: var(--char-bg-image);
            background-size: cover;
            background-position: center;
            opacity: 0.3;
            /* 背景画像の透明度を調整 */
            z-index: 0;
        }
        
        .character-card.targeted {
            border-color: #3b82f6;
        }
        
        .character-stats {
            position: relative;
            /* 疑似要素より手前に表示 */
            z-index: 1;
            padding: 0.25rem;
            border-radius: 0.25rem;
            /* 文字の視認性確保のためにテキストシャドウを追加 */
            text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.7), -1px -1px 3px rgba(255, 255, 255, 0.7), 1px -1px 3px rgba(255, 255, 255, 0.7), -1px 1px 3px rgba(255, 255, 255, 0.7);
        }
        
        .targeted {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.8);
            /* 敵選択時のスタイル */
            border-color: #ef4444;
        }
        
        .enemy-card {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        
        .damage-popup {
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: red;
            text-shadow: 1px 1px 2px white;
            animation: floatUp 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }
        
        .heal-popup {
            color: #22c55e;
        }
        
        @keyframes floatUp {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -150%) scale(1.5);
                opacity: 0;
            }
        }
        
        .flash-red {
            animation: flash-red 0.5s ease-out;
        }
        
        .flash-green {
            animation: flash-green 0.5s ease-out;
        }
        
        .flash-yellow {
            animation: flash-yellow 0.5s ease-out;
        }
        
        @keyframes flash-red {
            0%,
            100% {
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(255, 59, 59, 0.8);
                transform: scale(1.05);
            }
        }
        
        @keyframes flash-green {
            0%,
            100% {
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(34, 197, 94, 0.8);
                transform: scale(1.05);
            }
        }
        
        @keyframes flash-yellow {
            0%,
            100% {
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(253, 224, 71, 0.9);
                transform: scale(1.05);
            }
        }
        
        .enemy-card.flash-red {
            animation: flash-red-enemy 0.5s ease-out;
        }
        
        .enemy-card.flash-green {
            animation: flash-green-enemy 0.5s ease-out;
        }
        
        .enemy-card.flash-yellow {
            animation: flash-yellow-enemy 0.5s ease-out;
        }
        
        @keyframes flash-red-enemy {
            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(255, 59, 59, 0.8);
                transform: scale(1.05);
            }
        }
        
        @keyframes flash-green-enemy {
            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(34, 197, 94, 0.8);
                transform: scale(1.05);
            }
        }
        
        @keyframes flash-yellow-enemy {
            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            }
            50% {
                box-shadow: 0 0 25px 8px rgba(253, 224, 71, 0.9);
                transform: scale(1.05);
            }
        }
        
        .stat-flash-increase {
            animation: flash-stat-green 0.8s ease-out;
            border-radius: 0.25rem;
        }
        
        .stat-flash-decrease {
            animation: flash-stat-red 0.8s ease-out;
            border-radius: 0.25rem;
        }
        
        @keyframes flash-stat-green {
            0%,
            100% {
                background-color: transparent;
            }
            50% {
                background-color: rgba(34, 197, 94, 0.5);
            }
        }
        
        @keyframes flash-stat-red {
            0%,
            100% {
                background-color: transparent;
            }
            50% {
                background-color: rgba(239, 68, 68, 0.5);
            }
        }
        
        .status-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-left: 4px;
        }
        
        .fade-out-down {
            animation: fade-out-down 1s ease-out forwards;
        }
        
        @keyframes fade-out-down {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(20px);
            }
        }
        /* キャラクター背景画像 */
        
        .bg-char-akari {
            --char-bg-image: url('sgd_1.png');
        }
        
        .bg-char-hikari {
            --char-bg-image: url('sgd_2.png');
        }
        
        .bg-char-shizuka {
            --char-bg-image: url('sgd_3.png');
        }
        
        .bg-char-yui {
            --char-bg-image: url('sgd_4.png');
        }
        
        .bg-char-beatrice {
            --char-bg-image: url('sgd_5.png');
        }
        
        .bg-char-ririka {
            --char-bg-image: url('sgd_6.png');
        }
        
        .bg-char-sakuya {
            --char-bg-image: url('sgd_7.png');
        }
        
        .bg-char-shaomei {
            --char-bg-image: url('sgd_8.png');
        }
        
        .bg-char-eriza {
            --char-bg-image: url('sgd_9.png');
        }
        
        .bg-char-runa {
            --char-bg-image: url('sgd_10.png');
        }
        
        .bg-char-chloe {
            --char-bg-image: url('sgd_11.png');
        }
        
        .bg-char-miko {
            --char-bg-image: url('sgd_12.png');
        }
        
        .bg-char-renka {
            --char-bg-image: url('sgd_13.png');
        }
        
        .bg-char-iori {
            --char-bg-image: url('sgd_14.png');
        }
        
        .bg-char-koharu {
            --char-bg-image: url('sgd_15.png');
        }
        
        .bg-char-olivia {
            --char-bg-image: url('sgd_16.png');
        }
        
        .bg-char-celestia {
            --char-bg-image: url('sgd_17.png');
        }
    </style>
</head>

<body class="bg-green-100 flex items-center justify-center min-h-screen">
    <div id="game-container" class="w-full max-w-4xl mx-auto bg-green-200 rounded-2xl shadow-2xl overflow-hidden relative aspect-[4/3] sm:aspect-[16/9] flex flex-col">
        <!-- タイトル画面 -->
        <div id="title-screen" class="absolute inset-0 bg-cover bg-center flex flex-col items-center justify-center z-20 p-8" style="background-image: url('https://image.pollinations.ai/prompt/fantasy%20rpg%20dungeon,%20dark,%20mysterious,%20glowing%20runes,%20stone%20columns,%20roots,%20moss,%20pathway,%20digital%20painting');">
            <div class="bg-black/60 p-8 rounded-xl text-center shadow-lg">
                <h1 class="text-4xl sm:text-5xl font-bold text-white mb-8" style="text-shadow: 2px 2px 4px #000;">しゅりんく・だんじょん・がーるず</h1>
                <div class="flex flex-col sm:flex-row gap-4 justify-center">
                    <button id="load-button" class="action-button bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg hidden">つづきから</button>
                    <button id="start-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg">はじめから</button>
                    <button id="what-if-button" class="action-button bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg">もしもの物語</button>
                    <button id="rule-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg">ルール説明</button>
                </div>
            </div>
        </div>

        <!-- ゲーム画面 -->
        <div id="dungeon-view" class="hidden flex-grow bg-cover bg-center relative flex flex-col justify-between p-4" style="background-image: url('https://image.pollinations.ai/prompt/fantasy%20rpg%20dungeon,%20dark,%20mysterious,%20glowing%20runes,%20stone%20columns,%20roots,%20moss,%20pathway,%20digital%20painting');">
            <p id="floor-display" class="hidden absolute top-4 left-4 text-white font-bold text-lg" style="text-shadow: 1px 1px 3px #000;"></p>
            <button id="menu-button" class="absolute top-4 right-4 action-button bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-lg shadow-lg z-30">メニュー</button>
            <div id="log-container" class="w-full max-w-2xl mx-auto rounded-lg p-2 text-center log-gradient shadow-md">
                <p id="log-message" class="text-gray-800 font-bold text-sm md:text-base"></p>
            </div>
            <div id="enemy-container" class="flex justify-center items-end gap-4 h-1/2"></div>
        </div>

        <div id="hud" class="hidden w-full p-2 sm:p-4 hud-gradient shadow-inner">
            <div id="party-container" class="flex flex-wrap justify-center gap-2 sm:gap-4"></div>
        </div>

        <div id="command-container" class="hidden bg-gray-800/80 p-4 text-white flex justify-center items-center">
            <div id="dungeon-commands" class="flex gap-4">
                <button id="next-floor-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">次のフロアへ</button>
            </div>
            <div id="battle-commands" class="hidden w-full">
                <p id="command-message" class="text-center font-bold mb-2"></p>
                <div id="action-buttons" class="grid grid-cols-2 sm:grid-cols-4 gap-2"></div>
            </div>
        </div>

        <div id="modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-sm w-full">
                <h2 id="modal-title" class="text-3xl font-bold mb-4"></h2>
                <p id="modal-text" class="mb-6"></p>
                <button id="modal-button" class="action-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">タイトルに戻る</button>
            </div>
        </div>

        <div id="item-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-40 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-md w-full">
                <h2 class="text-2xl font-bold mb-4">アイテム</h2>
                <div id="item-list" class="max-h-64 overflow-y-auto mb-4"></div><button id="item-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">閉じる</button></div>
        </div>

        <div id="level-up-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 shadow-2xl max-w-2xl w-full">
                <h2 class="text-3xl font-bold mb-4 text-center">勝利！</h2>
                <p class="mb-6 text-center">強化するキャラクターを一人選んでください。</p>
                <div id="level-up-party-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4"></div>
            </div>
        </div>

        <div id="rule-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-lg w-full">
                <h2 class="text-2xl font-bold mb-4">ルール説明</h2>
                <div class="space-y-2 text-gray-700 max-h-96 overflow-y-auto pr-2">
                    <p class="font-bold">目的:</p>
                    <p>ダンジョンの最深部(30階)にいるボスを倒すとゲームクリアです。</p>
                    <p class="font-bold">探索:</p>
                    <p>「次のフロアへ」進むと、敵との戦闘やランダムなイベントが発生します。「会話する」で仲間との会話を楽しめます。</p>
                    <p class="font-bold">戦闘:</p>
                    <p>素早さの順に行動します。戦闘に勝利すると、仲間を一人強化できます。</p>
                    <p class="font-bold">身長システム:</p>
                    <p>身長が変わるとステータスが変動します。高くなると攻撃力・防御力が上がり、低くなると素早さが上がります。敵からの狙われやすさ(ヘイト)も身長に影響されます。</p>
                </div>
                <div class="text-right mt-4">
                    <button id="rule-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">閉じる</button></div>
            </div>
        </div>

        <div id="select-team-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-2xl w-full relative">
                <h2 class="text-2xl font-bold mb-2">選抜チーム</h2>
                <button id="random-select-button" class="absolute top-6 right-6 action-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg text-sm">ランダム選択</button>
                <p id="selection-prompt" class="mb-4 text-gray-600">共に冒険する仲間を2～4人選んでください。</p>
                <div id="team-selection-list" class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6 max-h-72 overflow-y-auto pr-2">
                    <!-- キャラクター選択肢がここに挿入されます -->
                </div>
                <div class="flex justify-between items-center">
                    <button id="select-team-back-button" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">戻る</button>
                    <div>
                        <span id="selection-counter" class="text-gray-600 mr-4">0 人選択中</span>
                        <button id="start-selection-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg opacity-50 cursor-not-allowed" disabled>冒険を始める</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="what-if-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-lg w-full">
                <h2 class="text-2xl font-bold mb-4">もしもの物語</h2>
                <p class="mb-2 text-gray-600">特別な設定で冒険を始めます。どの物語を体験しますか？</p>
                <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg flex items-center justify-between">
                    <label for="toggle-select-team" class="font-bold text-blue-700 cursor-pointer">好きな仲間で冒険する</label>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="toggle-select-team" id="toggle-select-team" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" />
                        <label for="toggle-select-team" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <div id="what-if-list" class="space-y-3 max-h-60 overflow-y-auto pr-2">
                    <button data-mode="trial" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-blue-700">腕試し</strong><span class="block text-sm text-gray-600">好きな仲間を選んで、通常ルールで冒険を開始する。</span></button>
                    <button data-mode="veterans" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-purple-700">歴戦の勇者たち</strong><span class="block text-sm text-gray-600">全員レベル4の状態で冒険を開始する。</span></button>
                    <button data-mode="dwarves" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-green-700">小人族の戦い</strong><span class="block text-sm text-gray-600">全員の身長が10cmの状態で冒険を開始する。</span></button>
                    <button data-mode="brawl" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-red-700">武闘の宴</strong><span class="block text-sm text-gray-600">2フロアごとに必ず戦闘が発生する。</span></button>
                    <button data-mode="solo" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-yellow-700">孤独な闘い</strong><span class="block text-sm text-gray-600">好きな仲間を一人選び、強化された状態で冒険に出る。</span></button>
                    <button data-mode="endless" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-slate-700">無限への挑戦</strong><span class="block text-sm text-gray-600">全滅するまでダンジョンを進み続ける。30階ごとにボスが出現し、倒すと試練が訪れる。</span></button>
                    <button data-mode="indecent" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-pink-700">痴態騒ぎ</strong><span class="block text-sm text-gray-600">全員が脱衣状態で開始。服は手に入らず、恥ずかしさに慣れることもない。タンクとサムライは参加不可。</span></button>
                    <button data-mode="fixed_path" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-indigo-700">決まった道程</strong><span class="block text-sm text-gray-600">5の倍数階以外の探索時、2つのイベントから好きな方を選んで進める。</span></button>
                    <button data-mode="enjoy" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-sky-700">エンジョイ</strong><span class="block text-sm text-gray-600">味方が戦闘不能になっても、即座にHPが全回復する。ゲームオーバーにならずに最後まで遊べる。</span></button>
                    <button data-mode="saint_march" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-yellow-500">聖女の行進</strong><span class="block text-sm text-gray-600">特別なジョブ「聖女」ひとりで30階の踏破を目指す。彼女はターン開始時にHPとMPが回復し、脱衣を無効化する。</span></button>
                    <button data-mode="monster_march" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-red-800">魔物の行軍</strong><span class="block text-sm text-gray-600">全てのフロアで戦闘が発生する。勝利する度にレベルアップし、アイテムを獲得する。50階踏破を目指せ。</span></button>
                    <button data-mode="endgame" class="w-full text-left p-3 rounded-lg hover:bg-gray-100 transition"><strong class="text-gray-700">おわりから</strong><span class="block text-sm text-gray-600">1フロア目に最終ボスが登場する。</span></button>
                </div>
                <div class="text-right mt-6">
                    <button id="what-if-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">戻る</button></div>
            </div>
        </div>

        <div id="challenge-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-sm w-full">
                <h2 class="text-3xl font-bold mb-4">怪しげな祭壇</h2>
                <p class="mb-6">祭壇に何かを捧げますか？<br>幸運が舞い込むか、災いが降りかかるかは分かりません…</p>
                <button id="challenge-accept-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg mr-4">捧げる</button>
                <button id="challenge-decline-button" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">立ち去る</button>
            </div>
        </div>

        <div id="event-choice-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 class="text-2xl font-bold mb-4">道が二手に分かれている…</h2>
                <p class="mb-6">どちらの道へ進みますか？</p>
                <div id="event-choice-buttons" class="flex flex-col gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <div id="scan-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 text-left shadow-2xl max-w-lg w-full">
                <h2 id="scan-modal-title" class="text-2xl font-bold mb-4">調査結果</h2>
                <div id="scan-modal-content" class="space-y-3 text-gray-700 max-h-96 overflow-y-auto pr-2">
                    <!-- 調査結果がここに挿入されます -->
                </div>
                <div class="text-right mt-4">
                    <button id="scan-modal-close" class="action-button bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-lg">閉じる</button></div>
            </div>
        </div>

        <!-- 聖女イベントモーダル -->
        <div id="celestia-event-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-md w-full">
                <h2 id="celestia-event-title" class="text-2xl font-bold mb-4"></h2>
                <p id="celestia-event-text" class="mb-6 whitespace-pre-wrap"></p>
                <div id="celestia-event-buttons" class="flex justify-center gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <!-- 無限モードボーナス選択モーダル -->
        <div id="endless-bonus-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-2xl w-full">
                <h2 class="text-2xl font-bold mb-2">勝利ボーナス！</h2>
                <p class="mb-6">生存者全員がレベルアップした！<br>さらに、以下のボーナスから一つを選択してください。</p>
                <div id="endless-bonus-buttons" class="grid grid-cols-2 gap-4">
                    <!-- ボタンがここに挿入される -->
                </div>
            </div>
        </div>

        <div id="menu-modal" class="hidden absolute inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-8 text-center shadow-2xl max-w-xs w-full">
                <h2 class="text-2xl font-bold mb-6">メニュー</h2>
                <div class="flex flex-col gap-4">
                    <button id="save-button" class="action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">セーブ</button>
                    <button id="menu-return-title-button" class="action-button bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">タイトルに戻る</button>
                    <button id="menu-modal-close" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg mt-4">閉じる</button>
                </div>
            </div>
        </div>
    </div>
    <style>
        /* トグルスイッチのスタイル */
        
        .toggle-checkbox:checked {
            right: 0;
            border-color: #4f46e5;
            /* indigo-600 */
        }
        
        .toggle-checkbox:checked+.toggle-label {
            background-color: #4f46e5;
            /* indigo-600 */
        }
    </style>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
                    const gameContainer = document.getElementById('game-container');
                    const logMessage = document.getElementById('log-message');
                    const partyContainer = document.getElementById('party-container');
                    const enemyContainer = document.getElementById('enemy-container');
                    const dungeonCommands = document.getElementById('dungeon-commands');
                    const dungeonView = document.getElementById('dungeon-view');
                    const hud = document.getElementById('hud');
                    const commandContainer = document.getElementById('command-container');
                    const battleCommands = document.getElementById('battle-commands');
                    const commandMessage = document.getElementById('command-message');
                    const actionButtons = document.getElementById('action-buttons');
                    const nextFloorButton = document.getElementById('next-floor-button');
                    const talkButton = document.createElement('button'); // 会話ボタンを生成
                    const modal = document.getElementById('modal');
                    const modalTitle = document.getElementById('modal-title');
                    const modalText = document.getElementById('modal-text');
                    const modalButton = document.getElementById('modal-button');
                    const itemModal = document.getElementById('item-modal');
                    const itemList = document.getElementById('item-list');
                    const itemModalClose = document.getElementById('item-modal-close');
                    const levelUpModal = document.getElementById('level-up-modal');
                    const levelUpPartyList = document.getElementById('level-up-party-list');
                    const titleScreen = document.getElementById('title-screen');
                    const startButton = document.getElementById('start-button');
                    const loadButton = document.getElementById('load-button');
                    const ruleButton = document.getElementById('rule-button');
                    const ruleModal = document.getElementById('rule-modal');
                    const ruleModalClose = document.getElementById('rule-modal-close');
                    const whatIfButton = document.getElementById('what-if-button');
                    const whatIfModal = document.getElementById('what-if-modal');
                    const whatIfModalClose = document.getElementById('what-if-modal-close');
                    const selectTeamModal = document.getElementById('select-team-modal');
                    const teamSelectionList = document.getElementById('team-selection-list');
                    const selectionCounter = document.getElementById('selection-counter');
                    const selectionPrompt = document.getElementById('selection-prompt');
                    const startSelectionButton = document.getElementById('start-selection-button');
                    const selectTeamBackButton = document.getElementById('select-team-back-button');
                    const randomSelectButton = document.getElementById('random-select-button');
                    const toggleSelectTeam = document.getElementById('toggle-select-team');
                    const floorDisplay = document.getElementById('floor-display');
                    const scanModal = document.getElementById('scan-modal');
                    const scanModalClose = document.getElementById('scan-modal-close');
                    const menuButton = document.getElementById('menu-button');
                    const menuModal = document.getElementById('menu-modal');
                    const saveButton = document.getElementById('save-button');
                    const menuReturnTitleButton = document.getElementById('menu-return-title-button');
                    const menuModalClose = document.getElementById('menu-modal-close');

                    const challengeModal = document.getElementById('challenge-modal');
                    const challengeAcceptButton = document.getElementById('challenge-accept-button');
                    const challengeDeclineButton = document.getElementById('challenge-decline-button');

                    const eventChoiceModal = document.getElementById('event-choice-modal');
                    const eventChoiceButtons = document.getElementById('event-choice-buttons');

                    const celestiaEventModal = document.getElementById('celestia-event-modal');
                    const celestiaEventTitle = document.getElementById('celestia-event-title');
                    const celestiaEventText = document.getElementById('celestia-event-text');
                    const celestiaEventButtons = document.getElementById('celestia-event-buttons');

                    const endlessBonusModal = document.getElementById('endless-bonus-modal');
                    const endlessBonusButtons = document.getElementById('endless-bonus-buttons');


                    let gameState = {
                        floor: 0,
                        party: [],
                        enemies: [],
                        turnOrder: [],
                        currentTurnIndex: 0,
                        inBattle: false,
                        gameOver: false,
                        inventory: [],
                        golem: null,
                        foundEquipment: [],
                        killCount: 0, // ネクロマンサー用
                        walls: [], // ガーディアン用,
                        gameMode: 'normal', // normal, veterans, dwarves, brawl, solo, endgame, endless, indecent, enjoy, saint_march, fixed_path
                    };
                    gameState.triggeredSpecialConvos = [];

                    const allCharacterBlueprints = [{
                            name: 'アカリ',
                            role: 'ファイター',
                            hp: 100,
                            mp: 20,
                            atk: 44,
                            def: 10,
                            agi: 12,
                            height: 165,
                            description: '元気で前向きなパーティのムードメーカー。考えるより先に体が動くタイプで、巨大な剣を軽々と振り回す。',
                            skills: [{
                                name: '強攻撃',
                                cost: 10,
                                power: 1.8,
                                type: 'physical',
                                targetType: 'enemy',
                                description: '敵一体に物理ダメージを与える。'
                            }, {
                                name: 'なぎ払い',
                                cost: 15,
                                power: 1.0,
                                type: 'physical',
                                targetType: 'enemies',
                                description: '敵全体に物理ダメージを与える。'
                            }],
                            unlockableSkill: {
                                name: '渾身斬り',
                                cost: 8,
                                power: 1.5,
                                type: 'physical',
                                targetType: 'enemy',
                                description: '敵一体に物理ダメージを与える。30%の確率で会心の一撃になる。'
                            },
                            unlockableSkillLv4: {
                                name: '乱舞',
                                cost: 25,
                                type: 'multi_hit_physical',
                                targetType: 'random_enemies',
                                description: '敵にランダムで4～6回の物理ダメージを与える。'
                            },
                            bgClass: 'bg-char-akari',
                            themeColor: 'red',
                        }, {
                            name: 'ヒカリ',
                            role: 'ソーサラー',
                            hp: 80,
                            mp: 50,
                            atk: 16,
                            def: 8,
                            agi: 15,
                            height: 145,
                            description: '無口で冷静な魔術の探求者。古代の知識に精通しており、強力な攻撃魔法を操る。アカリの突進を諌めることもしばしば。',
                            skills: [{
                                name: 'ファイア',
                                cost: 10,
                                power: 3.5,
                                type: 'magic',
                                targetType: 'enemy',
                                description: '敵一体に炎の魔法ダメージを与える。'
                            }, {
                                name: 'エンチャント',
                                cost: 10,
                                type: 'buff',
                                targetType: 'ally',
                                effect: 'atk_up',
                                description: '味方一体の攻撃力を一時的に上昇させる。'
                            }],
                            unlockableSkill: {
                                name: 'ストーム',
                                cost: 20,
                                power: 1.8,
                                type: 'magic',
                                targetType: 'enemies',
                                description: '敵全体に嵐の魔法ダメージを与える。'
                            },
                            unlockableSkillLv4: {
                                name: 'マジックバースト',
                                cost: 0, // MPを全て消費
                                type: 'mp_burst_magic',
                                targetType: 'enemy',
                                description: '残りMPを全て消費し、敵一体に超特大の魔法ダメージを与える。'
                            },
                            bgClass: 'bg-char-hikari',
                            themeColor: 'purple',
                        }, {
                            name: 'シズカ',
                            role: 'ナイト',
                            hp: 120,
                            mp: 10,
                            atk: 30,
                            def: 20,
                            agi: 8,
                            height: 175,
                            description: 'パーティの頼れる姉御役。巨大な盾であらゆる攻撃から仲間を守る。その守りは鉄壁と名高い。',
                            skills: [{
                                name: '挑発',
                                cost: 3,
                                type: 'utility',
                                targetType: 'self',
                                description: '敵の注意を自分に引きつけ、狙われやすくなる。'
                            }, {
                                name: 'ちからをためる',
                                cost: 0,
                                type: 'charge',
                                targetType: 'self',
                                description: '次の物理攻撃の威力を2.5倍にする。'
                            }],
                            unlockableSkill: {
                                name: 'かばう',
                                cost: 8,
                                type: 'buff',
                                targetType: 'self',
                                description: '次のターンまで、味方への単体攻撃を代わりに受ける。'
                            },
                            unlockableSkillLv4: {
                                name: '堅守の構え',
                                cost: 5,
                                type: 'self_buff_special',
                                targetType: 'self',
                                effects: ['provoke', 'regeneration'],
                                description: '敵の注意を引きつけつつ、3ターンの間HPが自動回復する。'
                            },
                            bgClass: 'bg-char-shizuka',
                            themeColor: 'amber',
                        }, {
                            name: 'ユイ',
                            role: 'メディック',
                            hp: 90,
                            mp: 40,
                            atk: 20,
                            def: 9,
                            agi: 10,
                            height: 120,
                            description: '心優しく、誰かのために尽くすことを厭わない少女。パーティの回復役として、その身を挺して仲間を癒す。',
                            skills: [{
                                name: 'ヒール',
                                cost: 12,
                                power: 50,
                                type: 'heal',
                                targetType: 'ally',
                                description: '味方一体のHPを回復する。'
                            }, {
                                name: 'プロテクト',
                                cost: 8,
                                type: 'buff',
                                targetType: 'ally',
                                description: '味方一体の防御力を一時的に上昇させる。'
                            }],
                            unlockableSkill: {
                                name: '献身',
                                cost: 0, // MPコストなし
                                type: 'special_heal',
                                targetType: 'party',
                                description: '自身の身長を20cm消費して、味方全体のHPを30%回復する。'
                            },
                            unlockableSkillLv4: {
                                name: 'サンクチュアリ',
                                cost: 40,
                                type: 'party_restore_growth',
                                targetType: 'party',
                                growth: 5,
                                description: '味方全体のHPを全回復し、状態異常を治し、身長を5cm伸ばす聖域を作り出す。'
                            },
                            bgClass: 'bg-char-yui',
                            themeColor: 'green',
                        }, {
                            name: 'ベアトリス',
                            role: 'アルケミスト',
                            hp: 85,
                            mp: 60,
                            atk: 18,
                            def: 9,
                            agi: 13,
                            height: 170,
                            description: '知的好奇心が旺盛な錬金術師。ダンジョンの謎や敵の生態に強い興味を示す。様々な薬品を合成して戦う。',
                            skills: [{
                                name: 'アシッドボルト',
                                cost: 4,
                                power: 2.8,
                                type: 'magic',
                                targetType: 'enemy',
                                description: '敵一体に酸の魔法ダメージを与える。'
                            }, {
                                name: 'ウィークン',
                                cost: 10,
                                type: 'debuff',
                                targetType: 'enemy',
                                effect: 'def_down',
                                description: '敵一体の防御力を一時的に低下させる。'
                            }],
                            unlockableSkill: {
                                name: 'ポイズンミスト',
                                cost: 15,
                                type: 'status_magic',
                                targetType: 'enemy',
                                effect: 'poison',
                                description: '敵一体を毒状態にする。'
                            },
                            unlockableSkillLv4: {
                                name: 'アルケミックフレア',
                                cost: 18,
                                power: 6.0,
                                type: 'magic',
                                targetType: 'enemy',
                                description: '敵一体に錬金術の爆発で大ダメージを与える。'
                            },
                            bgClass: 'bg-char-beatrice',
                            themeColor: 'indigo',
                        }, {
                            name: 'リリカ',
                            role: 'ダンサー',
                            hp: 95,
                            mp: 35,
                            atk: 25,
                            def: 8,
                            agi: 18,
                            height: 131,
                            description: '歌と踊りで仲間を鼓舞するアイドル。どんな状況でもステージに変え、ファンサービスを忘れない。素早い動きで敵を翻弄する。',
                            skills: [{
                                name: 'スポットライト',
                                cost: 10,
                                type: 'evade_provoke',
                                targetType: 'self',
                                description: '敵の注目を集めつつ、自身の回避率を大幅に上げる。'
                            }, {
                                name: '応援の舞',
                                cost: 12,
                                type: 'buff',
                                targetType: 'ally',
                                effect: 'agi_up',
                                description: '味方一体の素早さを一時的に上昇させる。'
                            }],
                            unlockableSkill: {
                                name: 'アンコール',
                                cost: 20,
                                type: 'party_buff',
                                targetType: 'party',
                                effect: 'atk_up',
                                description: '味方全体の攻撃力を一時的に上昇させる。'
                            },
                            unlockableSkillLv4: {
                                name: 'センターオブステージ',
                                cost: 30,
                                type: 'party_buff_special',
                                targetType: 'party',
                                description: '味方全体の攻撃力と素早さを一時的に上昇させる。'
                            },
                            bgClass: 'bg-char-ririka',
                            themeColor: 'pink',
                        }, {
                            name: 'サクヤ',
                            role: 'サムライ',
                            hp: 110,
                            mp: 0,
                            atk: 50,
                            def: 12,
                            agi: 14,
                            height: 168,
                            description: '己の剣の道を極めんとする求道者。口数は少ないが、その一太刀は岩をも断つ。HPを代償に強力な技を放つ。',
                            skills: [{
                                name: '居合',
                                cost: 15, // HP cost
                                power: 2.5,
                                type: 'hp_cost_physical',
                                targetType: 'enemy',
                                description: '自身のHPを15消費し、敵一体に強力な物理ダメージを与える。'
                            }, {
                                name: '斬りつけ',
                                cost: 5, // HP cost
                                power: 1.5,
                                type: 'hp_cost_physical',
                                targetType: 'enemy',
                                description: '自身のHPを5消費し、敵一体に物理ダメージを与える。'
                            }],
                            unlockableSkill: {
                                name: '明鏡止水',
                                cost: 0,
                                type: 'self_buff_samurai',
                                targetType: 'self',
                                description: '精神を集中させ、自身の攻撃力を一時的に上昇させる。'
                            },
                            unlockableSkillLv4: {
                                name: '無明の一閃',
                                cost: 40, // HP cost
                                power: 5.0,
                                type: 'hp_cost_physical',
                                targetType: 'enemy',
                                description: '自身のHPを大きく消費し、敵一体に絶大な物理ダメージを与える。'
                            },
                            bgClass: 'bg-char-sakuya',
                            themeColor: 'cyan',
                        }, {
                            name: 'シャオメイ',
                            role: 'モンク',
                            hp: 105,
                            mp: 25,
                            atk: 48,
                            def: 14,
                            agi: 11,
                            height: 152,
                            description: '明朗快活な拳法家。強敵と戦うことと食べることが大好き。その小さな体からは想像もつかないほどのパワーを秘めている。',
                            skills: [{
                                name: '正拳突き',
                                cost: 8,
                                power: 1.6,
                                type: 'physical',
                                targetType: 'enemy',
                                description: '敵一体に物理ダメージを与える。'
                            }, {
                                name: '癒しの掌',
                                cost: 15,
                                power: 40,
                                type: 'heal',
                                targetType: 'ally',
                                description: '気功で味方一体のHPを回復する。'
                            }],
                            unlockableSkill: {
                                name: '気功波',
                                cost: 18,
                                power: 1.2,
                                type: 'physical',
                                targetType: 'enemies',
                                description: '敵全体に気の力で物理ダメージを与える。'
                            },
                            unlockableSkillLv4: {
                                name: '破砕拳',
                                cost: 22,
                                power: 2.0,
                                type: 'def_ignore_physical',
                                targetType: 'enemy',
                                description: '敵の防御力を無視して物理ダメージを与える。'
                            },
                            bgClass: 'bg-char-shaomei',
                            themeColor: 'orange',
                        }, {
                            name: 'エリザ',
                            role: 'ドクター',
                            hp: 95,
                            mp: 55,
                            atk: 22,
                            def: 12,
                            agi: 16,
                            height: 128,
                            description: '自信家で研究熱心な女医。あらゆるものを研究対象と見なし、自作の薬品で戦況をコントロールする。豊満な体格を誇りに思っている。',
                            skills: [{
                                name: '成長促進剤',
                                cost: 15,
                                power: 30, // 30cm
                                type: 'growth_ally',
                                targetType: 'ally',
                                description: '味方一体の身長を30cm伸ばす薬を投与する。'
                            }, {
                                name: '衰弱ガス',
                                cost: 12,
                                type: 'status_ailment_multi',
                                effects: ['poison', 'slow'],
                                targetType: 'enemy',
                                description: '敵一体に毒か鈍化の状態異常を引き起こすガスを浴びせる。'
                            }],
                            unlockableSkill: {
                                name: '縮小薬',
                                cost: 15,
                                power: 30, // 30cm
                                type: 'shrink_ally',
                                targetType: 'ally',
                                description: '味方一体の身長を30cm縮める薬を投与する。'
                            },
                            unlockableSkillLv4: {
                                name: 'パンデミック',
                                cost: 35,
                                type: 'status_ailment_multi',
                                effects: ['poison', 'paralysis', 'slow'],
                                targetType: 'enemies',
                                description: '敵全体に毒、麻痺、鈍化のいずれかの状態異常を引き起こすウイルスを散布する。'
                            },
                            bgClass: 'bg-char-eriza',
                            themeColor: 'teal',
                        }, {
                            name: 'ルナ',
                            role: 'ギャンブラー',
                            hp: 85,
                            mp: 45,
                            atk: 25,
                            def: 8,
                            agi: 17,
                            height: 145,
                            description: 'スリルと勝負をこよなく愛する生粋のギャンブラー。戦いすらも賭けの対象と捉え、運に身を任せたトリッキーなスキルで戦う。',
                            skills: [{
                                name: 'ダーツショット',
                                cost: 10,
                                type: 'gambling_damage',
                                targetType: 'enemy',
                                description: '敵一体にダーツを投げる。命中率やダメージは運次第で大きく変動する。'
                            }, {
                                name: 'ラッキースター',
                                cost: 12,
                                type: 'gambling_support',
                                targetType: 'ally',
                                description: '味方一体に幸運の星を祈る。HP回復、MP回復、攻撃力アップなどランダムな良い効果が発生する。'
                            }],
                            unlockableSkill: {
                                name: 'オールイン',
                                cost: 20,
                                type: 'gambling_all_in',
                                targetType: 'enemies',
                                description: '全てを賭ける大勝負。敵全体に大ダメージを与えるか、味方全体を回復するか、何も起こらないか、あるいは自分がダメージを受けるか。'
                            },
                            unlockableSkillLv4: {
                                name: 'ジャックポット',
                                cost: 40,
                                type: 'gambling_jackpot',
                                targetType: 'party',
                                description: '奇跡を信じて全てを賭ける。低確率で味方全体が全回復＆強化されるが、ほとんどの場合は何も起こらない。'
                            },
                            bgClass: 'bg-char-runa',
                            themeColor: 'fuchsia',
                        }, {
                            name: 'クロエ',
                            role: 'リーパー',
                            hp: 80,
                            mp: 60,
                            atk: 15,
                            def: 7,
                            agi: 16,
                            height: 110,
                            description: 'ぶかぶかのローブで顔を隠した寡黙な少女。魂を狩る大鎌を携え、敵の命を摘み取る。自身の身長が低いほど力を発揮する。',
                            skills: [{
                                name: '魂狩り',
                                cost: 25,
                                power: 0.5, // 失敗時のダメージ倍率
                                type: 'reaper_instant_death',
                                targetType: 'enemy',
                                description: '敵一体の魂を狩る。低確率で即死させるが、ボスには効かない。失敗しても少しダメージを与える。'
                            }, {
                                name: '影の一撃',
                                cost: 12,
                                power: 1.5,
                                type: 'reaper_height_scaling',
                                targetType: 'enemy',
                                description: '影に潜んで敵一体を攻撃する。自身の身長が初期値より低いほど威力が増す。'
                            }],
                            unlockableSkill: {
                                name: '魂の交換',
                                cost: 20,
                                type: 'reaper_soul_exchange',
                                targetType: 'ally',
                                description: '自身の現在HPの半分を捧げ、味方一体のHPとMPを大きく回復する。'
                            },
                            unlockableSkillLv4: {
                                name: '冥府の鎌',
                                cost: 40,
                                power: 1.2,
                                type: 'reaper_height_scaling_multi',
                                targetType: 'enemies',
                                description: '敵全体に冥府の鎌を振るう。自身の身長が初期値より低いほど威力が増す。'
                            },
                            bgClass: 'bg-char-chloe',
                            themeColor: 'slate',
                        }, {
                            name: 'ミコ',
                            role: 'サモナー',
                            hp: 85,
                            mp: 65,
                            atk: 15,
                            def: 9,
                            agi: 14,
                            height: 121,
                            description: 'モンスターと心を通わせる人懐っこい少女。いつも一緒の相棒「モコ」と共に、様々な精霊やゴーレムを召喚して戦う。',
                            skills: [{
                                name: 'プチサラマンダー',
                                cost: 12,
                                power: 3.8,
                                type: 'magic',
                                targetType: 'enemy',
                                description: '炎の精霊を召喚し、敵一体に魔法ダメージを与える。'
                            }, {
                                name: 'ゴーレム召喚',
                                cost: 20,
                                power: 0.7, // 自身の最大HPに対するゴーレムのHP割合
                                type: 'summon_golem',
                                targetType: 'self',
                                description: '自身の最大HPの50%のHPを持つゴーレムを召喚し、パーティの盾とする。'
                            }],
                            unlockableSkill: {
                                name: 'プチウンディーネ',
                                cost: 22,
                                power: 2.0,
                                type: 'magic',
                                targetType: 'enemies',
                                description: '水の精霊を召喚し、敵全体に魔法ダメージを与える。'
                            },
                            unlockableSkillLv4: {
                                name: 'ガーディアンゴーレム',
                                cost: 40,
                                power: 1.2, // 自身の最大HPに対するゴーレムのHP割合
                                type: 'summon_golem',
                                targetType: 'self',
                                description: '自身の最大HPと同じHPを持つ、より強力なゴーレムを召喚する。'
                            },
                            bgClass: 'bg-char-miko',
                            themeColor: 'lime',
                        }, {
                            name: 'セレスティア',
                            role: '聖女',
                            hp: 110,
                            mp: 60,
                            atk: 45,
                            def: 15,
                            agi: 16,
                            height: 140,
                            description: '神の祝福を受けし聖なる乙女。その身に宿す聖なる力で、たった一人で穢れたダンジョンを浄化する使命を帯びている。',
                            skills: [{
                                name: 'ホーリーエッジ',
                                cost: 10,
                                power: 1.9,
                                type: 'physical',
                                targetType: 'enemy',
                                description: '聖なる力を刃に乗せ、敵一体に物理ダメージを与える。'
                            }, {
                                name: 'セイクリッドウォール',
                                cost: 10,
                                type: 'buff',
                                targetType: 'self',
                                effect: 'protect',
                                description: '聖なる障壁で身を守り、自身の防御力を一時的に上昇させる。'
                            }],
                            unlockableSkill: {
                                name: 'ジャッジメント',
                                cost: 25,
                                power: 1.5,
                                type: 'magic',
                                targetType: 'enemies',
                                description: '天からの光で、敵全体に聖なる魔法ダメージを与える。'
                            },
                            bgClass: 'bg-char-celestia',
                            themeColor: 'yellow',
                        }, {
                            name: 'レンカ',
                            role: 'ネクロマンサー',
                            hp: 90,
                            mp: 70,
                            atk: 15,
                            def: 8,
                            agi: 15,
                            height: 157,
                            description: '死者の魂と対話する、ちょっと怪しい雰囲気のお姉さん。冒険で倒した魂を力に変える。通常攻撃でMPが回復する。',
                            skills: [{
                                name: 'ソウルアブソーブ',
                                cost: 15,
                                power: 3.0,
                                type: 'necro_magic',
                                targetType: 'enemy',
                                description: '敵一体に魂を吸収する魔法ダメージを与える。倒したモンスター数で威力が上がる。'
                            }, {
                                name: 'ドレインソウル',
                                cost: 5,
                                power: 1.5,
                                type: 'mp_drain',
                                targetType: 'enemy',
                                description: '敵一体に魔法ダメージを与え、与えたダメージに応じてMPを吸収する。'
                            }],
                            unlockableSkill: {
                                name: 'コープスエクスプロージョン',
                                cost: 25,
                                power: 1.5,
                                type: 'necro_magic',
                                targetType: 'enemies',
                                description: '敵全体に魂を爆発させる魔法ダメージを与える。これまでに倒したモンスターの数に応じて威力が上がる。'
                            },
                            unlockableSkillLv4: {
                                name: 'リザレクション',
                                cost: 60,
                                type: 'revive_full',
                                targetType: 'ally',
                                description: '戦闘不能の味方一人をHP100%の状態で復活させる禁断の蘇生術。'
                            },
                            bgClass: 'bg-char-renka',
                            themeColor: 'gray',
                        }, {
                            name: 'イオリ',
                            role: 'ガーディアン',
                            hp: 125,
                            mp: 20,
                            atk: 35,
                            def: 18,
                            agi: 9,
                            height: 118,
                            description: '小柄で可憐な見た目だが、実はパーティの先輩。縮小病で成長が止まっている。仲間を護ることに全てを懸ける。通常攻撃は確率でクリティカルになる。',
                            skills: [{
                                name: 'ウォール',
                                cost: 10,
                                power: 0.6, // 自身の最大HPに対する耐久値の割合
                                type: 'guardian_wall',
                                targetType: 'ally',
                                description: '味方一人に、自身の最大HPの60%の耐久値を持つ防壁を生成する。'
                            }, {
                                name: 'かばう',
                                cost: 8,
                                type: 'buff',
                                targetType: 'self',
                                effect: 'cover',
                                description: '次のターンまで、味方への単体攻撃を代わりに受ける。'
                            }],
                            unlockableSkill: {
                                name: 'ガーディアンズハイ',
                                cost: 15,
                                type: 'self_buff_guardian',
                                targetType: 'self',
                                description: '3ターンの間、自身の防御力を上げ、次に使用する「ウォール」の耐久値を1.5倍にする。'
                            },
                            unlockableSkillLv4: {
                                name: 'キャッスルウォール',
                                cost: 25,
                                power: 0.4, // 自身の最大HPに対する耐久値の割合
                                type: 'guardian_wall_party',
                                targetType: 'party',
                                description: '味方全体に、自身の最大HPの40%の耐久値を持つ防壁を生成する。'
                            },
                            bgClass: 'bg-char-iori',
                            themeColor: 'stone',
                        }, {
                            name: 'コハル',
                            role: 'トラブルメーカー',
                            hp: 95,
                            mp: 40,
                            atk: 28,
                            def: 10,
                            agi: 14,
                            height: 128,
                            description: 'いつも元気で、ちょっとおっちょこちょいな少女。彼女の行動は、時に奇跡を、時に大惨事を引き起こす。通常攻撃は確率でクリティカルになる。',
                            skills: [{
                                name: 'ハプニングボックス',
                                cost: 20,
                                type: 'trouble_maker_box',
                                targetType: 'all', // 敵味方全体
                                description: '何が起こるかわからない箱を開ける。敵全体に大ダメージか、味方全体が強化されるか、あるいは味方全体が縮んでしまうか…。'
                            }, {
                                name: 'びっくりクラッカー',
                                cost: 12,
                                power: 1.5,
                                type: 'trouble_maker_debuff',
                                targetType: 'enemy',
                                description: '敵一体に物理ダメージを与え、たまに攻撃力か防御力を下げる。'
                            }],
                            unlockableSkill: {
                                name: 'ばっちりチェック',
                                cost: 10,
                                type: 'self_buff_trouble',
                                targetType: 'self',
                                description: '次の「ハプニングボックス」の成功率を大幅に上げる。'
                            },
                            unlockableSkillLv4: {
                                name: 'ミラクルギフト',
                                cost: 40,
                                type: 'trouble_maker_miracle',
                                targetType: 'party',
                                description: '味方全体に奇跡の贈り物を届ける。HPとMPが全回復し、3ターン攻撃力と防御力が上昇する。ごく稀に失敗する。'
                            },
                            bgClass: 'bg-char-koharu',
                            themeColor: 'rose',
                        }, {
                            name: 'オリビア',
                            role: 'シスター',
                            hp: 100,
                            mp: 50,
                            atk: 20,
                            def: 13,
                            agi: 12,
                            height: 149,
                            description: '聖堂に仕える、篤い信仰心を持つ女性。慈愛に満ちた祈りで、仲間の傷を癒し続ける。',
                            skills: [{
                                name: 'リジェネ',
                                cost: 12,
                                type: 'regeneration_ally',
                                targetType: 'ally',
                                description: '味方一人に、3ターンの間HPが自動で回復する祝福を与える。'
                            }, {
                                name: 'ファーストエイド',
                                cost: 8,
                                power: 60,
                                type: 'heal',
                                targetType: 'ally',
                                description: '味方一人のHPを少し回復する。'
                            }],
                            unlockableSkill: {
                                name: 'ホーリーライト',
                                cost: 20,
                                power: 120,
                                type: 'heal',
                                targetType: 'ally',
                                description: '味方一人のHPを大きく回復する。'
                            },
                            unlockableSkillLv4: {
                                name: '祈りの円環',
                                cost: 30,
                                type: 'regeneration_party',
                                targetType: 'party',
                                description: '味方全体に、3ターンの間HPが自動で回復する祝福を与える。'
                            },
                            bgClass: 'bg-char-olivia',
                            themeColor: 'sky',
                        },

                    ];

                    const characterBlueprints = allCharacterBlueprints.slice(0, 4); // 初期パーティ

                    const itemBlueprints = {
                        'potion': {
                            name: 'ポーション',
                            description: '味方ひとりのHPを最大値の50%回復する。',
                            target: 'ally',
                            effect: 'heal_percent',
                            power: 0.5,
                            battleOnly: false
                        },
                        'cure_mist': {
                            name: 'キュアミスト',
                            description: '味方全員のHPを最大値の30%回復する。',
                            target: 'party',
                            effect: 'heal_percent',
                            power: 0.3,
                            battleOnly: false
                        },
                        'milk': {
                            name: 'ミルク',
                            description: '味方ひとりの身長を初期値に戻す。',
                            target: 'ally',
                            effect: 'reset_height',
                            battleOnly: false
                        },
                        'little_soup': {
                            name: 'リトルスープ',
                            description: '味方ひとりの身長を30cm縮める。戦闘中に敵に使うと、その攻撃力と防御力をしばらく低下させる。',
                            target: 'any',
                            effect: 'shrink',
                            power: 30,
                            battleOnly: false
                        },
                        'pixie_gift': {
                            name: 'ピクシーギフト',
                            description: '味方ひとりの身長を10cmにする。',
                            target: 'ally',
                            effect: 'set_height',
                            power: 10,
                            battleOnly: false
                        },
                        'glass_blade': {
                            name: 'ガラスブレード',
                            description: '敵ひとりに200の固定ダメージを与える。',
                            target: 'enemy',
                            effect: 'damage',
                            power: 200,
                            battleOnly: true
                        },
                        'crazy_bomb': {
                            name: 'クレイジーボム',
                            description: '敵全員に100の固定ダメージを与える。',
                            target: 'enemies',
                            effect: 'damage',
                            power: 100,
                            battleOnly: true
                        },
                        'mana_potion': {
                            name: 'マナポーション',
                            description: '味方ひとりのMPを全回復させる。',
                            target: 'ally',
                            effect: 'restore_mp_full',
                            battleOnly: false
                        },
                        'heart_element': {
                            name: 'ハートエレメント',
                            description: '味方ひとりの最大HPを20永続的に上昇させる。',
                            target: 'ally',
                            effect: 'increase_max_hp',
                            power: 20,
                            battleOnly: false,
                            rare: true
                        },
                        'mana_element': {
                            name: 'マナエレメント',
                            description: '味方ひとりの最大MPを10永続的に上昇させる。',
                            target: 'ally',
                            effect: 'increase_max_mp',
                            power: 10,
                            battleOnly: false,
                            rare: true
                        },
                        'gigantes_ale': {
                            name: 'ギガンテスエール',
                            description: '味方ひとりの身長を100cm伸ばす。身長が初期値より低い場合は、初期値に戻してから伸ばす。',
                            target: 'ally',
                            effect: 'increase_height_and_initial',
                            power: 100,
                            battleOnly: false,
                            rare: true
                        },
                        'revive_herb': {
                            name: 'リバイブハーブ',
                            description: '戦闘不能の味方ひとりをHP50%で復活させる。',
                            target: 'ally',
                            effect: 'revive',
                            power: 0.5,
                            battleOnly: true
                        },
                        'shrink_aroma': {
                            name: 'シュリンクアロマ',
                            description: '味方全員の身長が-20cmされ、戦闘終了まで敵全員の攻撃力と防御力を大幅に下げる。',
                            target: 'party', // 実質的には全体効果
                            effect: 'shrink_party_and_debuff_enemies',
                            power: 20, // 身長減少量
                            battleOnly: true
                        },
                    };

                    const equipmentBlueprints = {
                        'short_sword': {
                            name: 'ショートソード',
                            targetRole: 'ファイター',
                            stat: 'atk',
                            value: 3,
                            description: 'アカリの攻撃力が3上がった！'
                        },
                        'headgear': {
                            name: 'ヘッドギア',
                            targetRole: 'ファイター',
                            stat: 'maxMp',
                            value: 10,
                            description: 'アカリの最大MPが10上がった！'
                        },
                        'mana_rod': {
                            name: 'マナロッド',
                            targetRole: 'ソーサラー',
                            stat: 'maxMp',
                            value: 15,
                            description: 'ヒカリの最大MPが15上がった！'
                        },
                        'claymore': {
                            name: 'クレイモア',
                            targetRole: 'ナイト',
                            stat: 'atk',
                            value: 5,
                            description: 'シズカの攻撃力が5上がった！'
                        },
                        'tower_shield': {
                            name: 'タワーシールド',
                            targetRole: 'ナイト',
                            stat: 'maxHp',
                            value: 20,
                            description: 'シズカの最大HPが20上がった！'
                        },
                        'talisman': {
                            name: 'タリスマン',
                            targetRole: 'メディック',
                            stat: 'maxMp',
                            value: 20,
                            description: 'ユイの最大MPが20上がった！'
                        },
                        'alchemist_goggles': {
                            name: '錬金術師のゴーグル',
                            targetRole: 'アルケミスト',
                            stat: 'maxMp',
                            value: 15,
                            description: 'ベアトリスの最大MPが15上がった！'
                        },
                        'dance_shoes': {
                            name: 'ダンスシューズ',
                            targetRole: 'ダンサー',
                            stat: 'agi',
                            value: 5,
                            description: 'リリカの素早さが5上がった！'
                        },
                        'katana_oil': {
                            name: '名刀油',
                            targetRole: 'サムライ',
                            stat: 'atk',
                            value: 5,
                            description: 'サクヤの攻撃力が5上がった！'
                        },
                        'iron_gauntlets': {
                            name: '鉄甲',
                            targetRole: 'モンク',
                            stat: 'atk',
                            value: 4,
                            description: 'シャオメイの攻撃力が4上がった！'
                        },
                        'medical_kit': {
                            name: '医療キット',
                            targetRole: 'ドクター',
                            stat: 'maxMp',
                            value: 20,
                            description: 'エリザの最大MPが20上がった！'
                        },
                        'loaded_dice': {
                            name: 'イカサマダイス',
                            targetRole: 'ギャンブラー',
                            stat: 'agi',
                            value: 4,
                            description: 'ルナの素早さが4上がった！'
                        },
                        'shadow_cloak': {
                            name: '影隠しのローブ',
                            targetRole: 'リーパー',
                            stat: 'agi',
                            value: 3,
                            description: 'クロエの素早さが3上がった！'
                        },
                        'summoners_bell': {
                            name: '召喚士の鈴',
                            targetRole: 'サモナー',
                            stat: 'maxMp',
                            value: 25,
                            description: 'ミコの最大MPが25上がった！'
                        },
                        'reinforced_flask': {
                            name: '強化フラスコ',
                            targetRole: 'アルケミスト',
                            stat: 'atk',
                            value: 5,
                            description: 'ベアトリスの攻撃力が5上がった！'
                        },
                        'samurai_armor': {
                            name: '侍の鎧',
                            targetRole: 'サムライ',
                            stat: 'maxHp',
                            value: 15,
                            description: 'サクヤの最大HPが15上がった！'
                        },

                    };

                    function getRemainingEquipment() {
                        const allEquipmentIds = Object.keys(equipmentBlueprints);
                        return allEquipmentIds.filter(id => !gameState.foundEquipment.includes(id));
                    }

                    function addItemToInventory(itemId, quantity = 1) {
                        const existingItem = gameState.inventory.find(item => item.id === itemId);
                        if (existingItem) existingItem.quantity += quantity;
                        else gameState.inventory.push({
                            id: itemId,
                            quantity
                        });
                    }
                    const conversations = {
                        // アカリ (アタッカー): 元気はつらつ、とてもポジティブ。
                        'アカリ': {
                            default: ["よーっし、この調子でどんどん行こう！", "次の敵はどんなやつかな？わくわくする！", "みんな、疲れてない？私はまだまだいけるよ！", "このダンジョン、結構広いね！探検しがいがある！", "お腹すいたなー！終わったら美味しいもの食べに行こう！", "ヒカリ、足元大丈夫？暗いから気をつけてね！", "シズカがいると安心感が違うよね！", "ユイ、いつも回復ありがとう！頼りにしてるよ！", "なんだかちょっとひんやりするね。", "ここ、ちょっと不気味な感じ…でも私が吹き飛ばしてあげる！"],
                            lowHp: ["ちょっとかすり傷が…。でも、これくらい平気！", "うぅ、ちょっと油断したかな。でも、まだまだ戦える！", "いたたた…。やるじゃない！でも、負けないから！", "大丈夫、大丈夫！ちょっと転んだだけだって！", "ヒールサンキュー！これでまた暴れられる！"],
                            allyLowHp: ["{name}、大丈夫！？無理しないでね！", "{name}、危なかったね。私がもっと頑張らないと！", "{name}、下がってて！ここは私がやる！", "ユイ！{name}の回復お願い！", "よくも{name}を！許さないんだから！"],
                            shrunk: ["あれ、なんだか視界が低い…？でも、すばしっこくなったかも！", "ちっちゃくなっても、元気は100倍だから！", "わ、石ころが岩みたいに見える！", "このサイズ、敵に見つかりにくいかも？チャンス！", "みんなー！ここにいるよー！踏まないでね！"],
                            stripped: ["きゃっ！な、何するのよー！恥ずかしいじゃない！", "こ、こんな格好じゃ戦えないよぉ…！でも、やるしかない！", "だ、だめ！見ないで！…って、敵は見てくるかぁ！", "寒くはないけど…！心が寒い！"],
                            allyShrunk: ["{name}、なんだか小さくて可愛いね！でも、ちゃんとついてきてよ！", "わ、{name}が豆粒みたいだ！踏んづけないように気をつけなきゃ！", "{name}、私の後ろにいれば安全だよ！", "そんなに小さいと、敵も気づかないんじゃない？", "大丈夫？ちゃんとご飯食べてる？"],
                            shrunk_100: ["わ、なんだかテーブルの上がすごく高く見える！", "ドアノブに手が届かないかも…ジャンプ！"],
                            shrunk_70: ["シズカの腰くらいまでしかないや！えへへ、面白い！", "ユイと身長同じくらいかな？"],
                            shrunk_50: ["うわー！みんなの膝くらいしかない！子供に戻ったみたい！", "攻撃が当たるか心配になってきた…！"],
                            shrunk_30: ["ユイちゃんの足元だ！見失わないでねー！", "もう妖精さんサイズだね！飛べそう！"],
                            shrunk_10: ["もうみんなの靴くらいの大きさしかないよ！アリさんとお話できちゃうかも！", "誰か、ポケットに入れてー！"],
                            shrunk_1: ["もう指先くらいの大きさしかないよ！誰か、私を拾ってー！"],
                            allyShrunk_100: ["{name}、小さくなっても私が守るからね！", "あれ、{name}、いつもより目線が下だね！"],
                            grown: ["わーい！大きくなった！これならどんな敵も一撃だ！", "なんだか見晴らしがいいなー！", "シズカより大きくなっちゃったかも？えへへ！"],
                            allyGrown: ["うわー、{name}が大きい！見上げちゃうね！", "{name}、天井に頭をぶつけないように気をつけてね！"],
                            stripped_pair: ["え、{name}も！？なんだかお揃いみたいで、ちょっと楽しいかも！", "こうなったら、どっちが大胆になれるか勝負だね！", "二人してこの格好じゃ、敵も呆れるんじゃない？", "恥ずかしいけど、{name}と一緒なら乗り越えられる気がする！", "風邪ひかないように、くっついていようか！", "シズカに見られたら、二人して怒られちゃうかな…？"],
                            stripped_shrunk: ["えぇ！？小さくなっちゃった上に、この格好！？もう、どうしたらいいのー！", "恥ずかしいけど、小さくなったから隠れやすいかも…？いや、やっぱり恥ずかしい！", "こんなに小さいのに、服がないなんて…！敵に見つかったらどうしよう！", "誰か、私を隠してー！小さすぎて、余計に目立っちゃうよ！"],
                            solo_stripped_tiny: ["こんなに小さくて、服もないなんて…！岩陰に隠れていよう…。", "（こそこそ…）誰にも見つかりませんように…！", "（しくしく…）もう、お嫁にいけないよぉ…。", "（じっ…）敵が通り過ぎるまで、息を潜めていよう…。", "このサイズなら、葉っぱ一枚で隠れるかな…？"],
                            allyNew: ["{name}、よろしくね！私がしっかり守ってあげる！", "新しい仲間だ！{name}、一緒に頑張ろうね！"],
                            allyStripped_shrunk: ["{name}、小さくなった上にその格好！？私が守ってあげるからね！", "わわわ、{name}！小さくて可愛いけど、その格好は…！", "敵の趣味、悪すぎ！{name}をこんな目に遭わせるなんて！"],
                            allyStripped: ["{name}、大丈夫！？とりあえず私のマント使って！", "わわわ、{name}！目のやり場に困るよ！", "敵の趣味、悪すぎ！絶対許さない！", "ヒカリ、どこ見てるの！"],
                            allyShrunk_70: ["{name}、そのサイズ感、なんだか懐かしい感じがするね！", "ちっちゃい{name}も可愛い！"],
                            allyShrunk_50: ["{name}、半分くらいになっちゃった！？大丈夫？", "わっ、そこにいたの！？気づかなかった！"],
                            allyShrunk_30: ["{name}、ポケットに入れて運んであげようか？", "風邪ひかないようにね！"],
                            shrunk_pair: ["{name}も小さくなっちゃったんだね！なんだかお揃いで楽しいね！", "二人いれば怖くない！ちびっこ探検隊、出発だ！", "こうなったら、どっちがもっと小さくなれるか競争しちゃう？なんちゃって！", "二人で敵の足元を狙えば、最強コンビかも！", "見失わないように、手、繋いでいこうか！"],
                            pair_ベアトリス: ["ベアトリス、その薬、飲むとどうなるの？ちょっと興味ある！", "なんか難しいこと考えてるの？私が代わりに敵、殴ってこようか？"],
                            pair_リリカ: ["リリカちゃんのダンス、見てると元気出る！私も踊っちゃおうかな！", "リリカちゃん、今度一緒に歌おうよ！"],
                            pair_サクヤ: ["サクヤちゃん、その刀すごいね！私のも負けてないよ！", "たまには笑ってよー！ね？"],
                            pair_シャオメイ: ["シャオメイちゃん、勝負だ！どっちが多く倒せるか競争しよう！", "お腹すいたねー！終わったら肉まん食べに行こう！"],
                            pair_エリザ: ["エリザさん、その注射、痛くない…？", "大きくなる薬、もっとちょうだい！"],
                            pair_ルナ: ["ルナちゃん、ギャンブルってよくわからないけど、楽しそうだね！", "私に賭けてみてよ！絶対勝つから！"],
                            pair_クロエ: ["クロエちゃん、静かだね。でも、強いのは知ってるよ！", "その大鎌、重くない？私が持ってあげようか？"],
                            pair_ミコ: ["ミコちゃん、そのモコって子、ふわふわだね！触ってもいい？", "ゴーレムくん、かっこいいね！私とどっちが強いかな？"],
                            pair_レンカ: ["レンカさん、なんだかミステリアスだね！でも、悪い人じゃないってわかるよ！", "その魔法、どうなってるの？すごいね！"],
                            pair_イオリ: ["イオリ先輩！小さくてもすっごく頼りになります！", "私が先輩を守りますからね！任せてください！"],
                            pair_コハル: ["コハルちゃん、見てて飽きないなー！次はなにが起こるか楽しみ！", "失敗しても私がフォローするから、思いっきりやっていいよ！"],
                            pair_オリビア: ["オリビアさん、いつもありがとう！その祈り、すっごく温かいです！", "私も、オリビアさんみたいに誰かを癒せるようになりたいな！"],
                            pair_レンカ: ["レンカさん、なんだかミステリアスだね！でも、悪い人じゃないってわかるよ！", "その魔法、どうなってるの？すごいね！"],
                            pair_セレスティア: ["セレスティアちゃん、すごい力だね！私も負けてられないな！", "なんだか、見てるだけで心が洗われるみたい…不思議な感じ！"],
                            pair_イオリ: ["イオリ先輩！小さくてもすっごく頼りになります！", "私が先輩を守りますからね！任せてください！"],
                            pair_コハル: ["コハルちゃん、見てて飽きないなー！次はなにが起こるか楽しみ！", "失敗しても私がフォローするから、思いっきりやっていいよ！"],
                            pair_オリビア: ["オリビアさん、いつもありがとう！その祈り、すっごく温かいです！", "私も、オリビアさんみたいに誰かを癒せるようになりたいな！"],
                        },
                        // ヒカリ (魔法使い): 無口で慎重派。
                        'ヒカリ': { // ソーサラー
                            default: ["…順調。", "…先の気配を探る。", "…静か。油断は禁物。", "…この通路、魔力の流れが少し違う。", "…アカリ、あまり先行するな。", "…シズカ、後方は頼む。", "…ユイ、MPは足りているか？", "…壁の模様…古代の魔法文字か？", "…空気が澱んでいる。注意。", "…もう少し、慎重に進むべき。"],
                            lowHp: ["…少し、魔力が乱れてる。", "…問題ない。集中する。", "…かすっただけ。", "…呼吸を整えれば、まだやれる。", "…回復に感謝。"],
                            allyLowHp: ["{name}…回復を。", "…{name}、下がって。", "…シズカ、{name}のカバーを。", "…ユイ、急いで。", "…敵の狙いは{name}か。"],
                            shrunk: ["…これでは、歩幅が…。", "…魔力の制御に、影響は無い。", "…体が軽い。エーテルの流れが速い。", "…詠唱の声が、小さくなる。", "…このサイズなら、敵の死角に入りやすい。"],
                            stripped: ["…不愉快。", "…ローブで隠す。…これでは動きにくい。", "…見てくれるな。", "…集中を削がれる。", "…風魔法で、体を隠せないか…"],
                            allyShrunk: ["…{name}、そこにいたのか。", "…小さい。敵に見つかりにくい利点も。", "…アカリ、{name}を踏むな。", "…気配が希薄になった。暗殺者向き。 ", "…守るべき対象が、小さくなった。"],
                            shrunk_100: ["…視界が低い。腰をかがめないと本が取れない。", "…魔導書が重い。"],
                            shrunk_70: ["…大人の膝ほどの高さ。魔導書の文字が少し読みづらい。", "…走る速度が落ちる。"],
                            shrunk_50: ["…世界のすべてが大きく見える。", "…私のファイアボールの方が大きい。"],
                            shrunk_30: ["…草むらが、森のようだ。", "…これでは、ネズミと間違われる。"],
                            shrunk_10: ["…指先ほどの大きさ。だが、魔力は私と共にある。", "…風で飛ばされそうだ。"],
                            shrunk_1: ["…塵芥のようだ。だが、魔力は消えぬ。"],
                            allyShrunk_100: ["…{name}、足元に注意して。", "…{name}、私の後ろを歩け。"],
                            grown: ["…体が大きいと、魔力の流れが少し鈍る。", "…天井が近い。頭上に注意。", "…この体格なら、魔導書で殴っても強そうだ。"],
                            allyGrown: ["…{name}、大きい。威圧感がある。", "…{name}、その体で、狭い通路は通れるのか？"],
                            allyNew: ["…{name}か。よろしく。足を引っ張るなよ。", "…新しい仲間。{name}、君の実力を見せてもらう。"],
                            stripped_shrunk: ["…体が縮み、さらにこの状態。…魔力集中が困難だ。", "…この状況で、敵に遭遇すれば…最悪だ。", "…この小ささで、この格好。…隠れる場所を探す。", "…恥辱。だが、この状況を乗り越えねば。"],
                            solo_stripped_tiny: ["…この小ささで、この格好。…屈辱だ。", "…物陰に隠れる。気配を消せば、見つかることはない。", "…早く、この状況を脱したい。", "…（魔導書を盾のようにして、体を隠している）"],
                            allyStripped_shrunk: ["…{name}、小さくなった上にその格好か。…気の毒に。", "…{name}、私のローブの影に隠れるといい。", "…敵の悪趣味な攻撃。速やかに排除する。"],
                            stripped_pair: ["…{name}もか。…不愉快だ。互いに、視線を避けるべきだ。", "…この状況、魔力集中に影響が出る。", "…二人でいれば、敵も呆れるか。…いや、逆か。", "…アカリ、{name}を見るな。…いや、私もか。", "…この恥辱、忘れない。"],
                            allyStripped: ["…{name}、私のローブを。…いや、サイズが合わないか。", "…敵の悪趣味な攻撃。速やかに排除する。", "…アカリ、{name}を見るな。"],
                            allyShrunk_70: ["…{name}、その姿でも、油断はするな。", "…アカリ、{name}をからかうな。"],
                            allyShrunk_50: ["…{name}、気配がさらに薄くなった。隠密には向いている。", "…シズカ、{name}が見えない。"],
                            allyShrunk_30: ["…{name}、私のローブの影に隠れるといい。", "…ユイ、{name}を鞄に入れるか検討を。"],
                            shrunk_pair: ["…{name}もか。互いに、見失わないようにしよう。", "…二人分の気配が消えた。奇襲には最適。", "…この状況、笑えてきた。", "…{name}、段差だ。手を貸す。", "…二人でいれば、ただの小さい存在ではない。"],
                            pair_アカリ: ["…アカリ、また突っ走って。少しは落ち着け。", "…アカリ、背中は任せた。"],
                            pair_シズカ: ["…シズカ、頼りにしてる。援護は任せて。", "…その盾、私の魔法でも壊せないかも。"],
                            pair_ユイ: ["…ユイ、MPは大丈夫？無理はするな。", "…いつもありがとう。助かる。"],
                            pair_ベアトリス: ["…ベアトリス、その探究心、嫌いじゃない。", "…錬金術と魔術、根源は同じかもしれない。"],
                            pair_リリカ: ["…リリカ、騒がしい。だが、士気が上がるのは確か。", "…その歌、魔力に影響を与える。面白い。"],
                            pair_サクヤ: ["…サクヤ、その太刀筋…無駄がない。", "…サクヤ、気配を消すのが上手い。静かなのは、嫌いじゃない。", "…剣禅一如、か。魔道にも通じるものがある。"],
                            pair_シャオメイ: ["…シャオメイ、単純。だが、それが強さか。", "…腹が減った、しか言わない。"],
                            pair_エリザ: ["…エリザ、あなたの薬、興味深い。だが、私は被検体にはならない。", "…科学と魔法、どちらが真理か。…愚問。"],
                            pair_ルナ: ["…ルナ、運命はサイコロでは決まらない。", "…そのギャンブル、確率論で解析できる。"],
                            pair_クロエ: ["…クロエ、あなたも静か。…魂、見えるの？", "…その鎌、どこで手に入れた？"],
                            pair_ミコ: ["…ミコ、その召喚術、系統が違う。興味深い。", "…モコ、という生き物。解析したい。"],
                            pair_レンカ: ["…レンカ、死霊術か。…禁忌の領域。だが、力は本物。", "…その魂、どこから呼んでいる？"],
                            pair_イオリ: ["…イオリ、先輩か。その守り、確か。", "…小さくても、その存在感は大きい。"],
                            pair_コハル: ["…コハル、予測不能。それが一番厄介。", "…次は何が起こるか、見ておく。"],
                            pair_オリビア: ["…オリビア、その祈り、純粋な魔力。…聖属性か。", "…回復魔法、専門外だが、参考になる。"],
                            pair_レンカ: ["…レンカ、死霊術か。…禁忌の領域。だが、力は本物。", "…その魂、どこから呼んでいる？"],
                            pair_セレスティア: ["…その力、聖なるものか。魔力とは異なる、純粋なエネルギー。", "…あなたの存在そのものが、この地の穢れを払っている。"],
                            pair_イオリ: ["…イオリ、先輩か。その守り、確か。", "…小さくても、その存在感は大きい。"],
                            pair_コハル: ["…コハル、予測不能。それが一番厄介。", "…次は何が起こるか、見ておく。"],
                            pair_オリビア: ["…オリビア、その祈り、純粋な魔力。…聖属性か。", "…回復魔法、専門外だが、参考になる。"],
                        },
                        // シズカ (タンク): 姉御肌、とても頼れる。
                        'シズカ': { // ナイト
                            default: ["みんな、いい調子だね。このまま気を引き締めていこうか。", "何かあったらすぐに言いな。あたしが前に出るからさ。", "ふぅ、一休みも大事だよ。焦らず行こう。", "アカリ、あんまりはしゃいでると転ぶよ。", "ヒカリ、何か気になるものでもあったのかい？", "ユイ、いつもありがとうね。無理するんじゃないよ。", "この階は静かだね。嵐の前の静けさ、ってやつじゃなきゃいいけど。", "よし、次の角を曲がるよ。準備はいいね？", "全員、あたしの後ろから離れるんじゃないよ。", "敵の気配はないね。今のうちに体制を整えよう。"],
                            lowHp: ["ちっ、今の攻撃はちょっと効いたね…。でも、まだまだ！", "これしきでへこたれるあたしじゃないよ。", "はは、上等じゃないか。もっときな！", "大丈夫、大丈夫。みんなはあたしが守るからさ。", "ユイ、すまないね。回復助かるよ。"],
                            allyLowHp: ["{name}、大丈夫かい？あたしの後ろに隠れな！", "{name}、無理は禁物だよ。しっかり守ってやるからさ。", "アカリ！{name}から敵を引き剥がすよ！", "ヒカリ、援護を頼む！", "ユイ、{name}を頼んだよ！"],
                            shrunk: ["おっと、こりゃ小さくなっちまったね。守れる範囲が狭くなるのは困るね。", "体が小さくても、気合でどうにでもなるさ！", "盾が体より大きいじゃないか。これはこれで要塞だね。", "敵の攻撃が当たらなくなるかもね。それはそれで儲けもんさ。", "みんな、あたしを見失うんじゃないよ！", "盾を構えるのに、いつもより力が必要だね。"],
                            // シズカは脱衣状態にならない
                            allyShrunk: ["{name}、あんまり小さいと見失っちまうよ。側にいな。", "あらあら、{name}が可愛くなっちゃって。でも、油断するんじゃないよ。", "よしな、{name}。あんたはあたしの足元にいれば安全さ。", "ヒカリ、{name}がどこにいるか分かるかい？", "アカリ、{name}で遊ぶんじゃないよ。"],
                            shrunk_100: ["おっと、盾が壁みたいに感じるね。", "いつもより低い位置から敵を見上げるのは、新鮮だね。"],
                            shrunk_70: ["あたしの盾の上半分くらいしか見えないじゃないか。これじゃあ敵になめられちまうかな？", "アカリと目線が同じくらいかね。"],
                            shrunk_50: ["アカリの膝くらいまでしか無いじゃないか…。だが、守りの魂は小さくならないよ！", "これじゃあ、盾を構えるのがやっとだね。"],
                            shrunk_30: ["さすがにこれは、守りにくいねぇ。敵の足元を狙うしかないか。", "ゴブリンより小さいじゃないか…。"],
                            shrunk_10: ["こりゃ驚いた。もう盾の裏に住めそうだね。", "誰かあたしを拾っておくれ。"],
                            shrunk_1: ["…もう、盾の取っ手の一部になった気分だよ。"],
                            allyShrunk_100: ["{name}、小さくなってもあたしが壁になってやるさ。", "おっと、{name}。そこにいたのかい。"],
                            grown: ["はは、こりゃいい！巨人になった気分だね！", "これならどんな攻撃も受け止めてやれるさ！", "天井が低いねぇ。頭をぶつけないようにしないと。"],
                            allyGrown: ["おぉ、{name}、見上げるほど大きくなったじゃないか！頼もしいね！", "{name}、あんまり大きいと敵に見つかりやすいから気をつけな。"],
                            allyNew: ["お、新しい仲間かい。{name}、よろしくな。あたしがしっかり守ってやるよ。", "ようこそ、{name}。歓迎するよ。"],
                            // シズカは脱衣状態にならないため、stripped_shrunkも発生しない
                            // シズカは脱衣状態にならないため、stripped_pairは発生しない
                            allyStripped: ["おやおや、{name}。大胆な格好じゃないか。風邪ひくんじゃないよ。", "敵の奴、くだらない真似をしやがる。さっさと叩き潰してやるからな！", "アカリ、{name}から目を離しな。"],
                            allyShrunk_70: ["{name}、そのサイズじゃ一歩が大きいだろう。無理するなよ。", "可愛いねぇ。頭を撫でてやりたいよ。"],
                            allyShrunk_50: ["{name}、あたしの足元にいれば安全だよ。踏んじまわないようにしないとね。", "半分か…。ちゃんと守ってやらないとね。"],
                            allyShrunk_30: ["{name}、どこだい？ああ、そこにいたのか。", "ユイ、あんたの鞄に入れてやったらどうだい？"],
                            shrunk_pair: ["おや、{name}もかい。こりゃ、ちびっこコンビで敵を油断させるかね。", "二人してこの様かい。笑っちまうね。", "こうなったら、どっちがうまく隠れられるか勝負といくかい？", "あんたが囮で、あたしが仕留める。どうだい、この作戦？", "よし、手でも繋いでおくかね。はぐれないようにさ。"],
                            pair_アカリ: ["アカリ、あんまり前に出過ぎるんじゃないよ。あたしが壁になってやるからさ。", "よしよし、いい子だ。"],
                            pair_ヒカリ: ["ヒカリ、あんたの魔法は頼りになるね。後衛は任せたよ。", "たまにはあたしにも頼りな。"],
                            pair_ユイ: ["ユイ、いつもありがとうね。あんたがいるから、安心して前に出られるよ。", "無理するんじゃないよ。"],
                            pair_ベアトリス: ["ベアトリス、あんたの薬はよく効くねぇ。でも、変な薬はあたしに使うんじゃないよ。", "研究もいいが、ほどほどにな。"],
                            pair_リリカ: ["リリカ、あんたの踊りは見てて楽しいね。士気が上がるよ。", "ステージはあたしが守ってやるから、思いっきりやりな。"],
                            pair_サクヤ: ["サクヤ、あんたの剣の腕は確かだね。背中を預けられるよ。", "たまには肩の力抜きな。"],
                            pair_シャオメイ: ["シャオメイ、あんたの拳は見てて飽きないねぇ。", "腹が減ったのかい？終わったら美味い店に連れてってやるよ。", "あんまり無茶するんじゃないよ。あたしが前に出るからさ。"],
                            pair_エリザ: ["エリザ、あんたも大概物好きだねぇ。でも、その腕は確かだ。", "あたしを実験台にするのはやめときな。"],
                            pair_ルナ: ["ルナ、博打もいいが、命まで賭けるんじゃないよ。", "あんたの度胸は買ってやるよ。"],
                            pair_クロエ: ["クロエ、大丈夫かい？あたしの後ろにいな。", "あんまり暗い顔してると、幸せが逃げちまうよ。"],
                            pair_ミコ: ["ミコ、その召喚獣は頼りになるね。あたしの盾とどっちが硬いかね？", "モコとかいうの、可愛いじゃないか。"],
                            pair_レンカ: ["レンカ、あんたの魔法は気味が悪いねぇ。でも、頼りにしてるよ。", "死人相手とは、感心しないね。"],
                            pair_イオリ: ["イオリ、あんたが先輩だったのかい。頼りにしてるよ、先輩。", "その小さな体で、よく頑張るねぇ。感心だよ。"],
                            pair_コハル: ["コハル、あんたは見ててハラハラするねぇ。でも、面白いからいいか。", "何かあったらあたしがなんとかしてやるから、好きにやりな。"],
                            pair_オリビア: ["オリビア、あんたの祈りは心に染みるね。ありがとうよ。", "無理するんじゃないよ。あんたも大事な仲間だからね。"],
                            pair_レンカ: ["レンカ、あんたの魔法は気味が悪いねぇ。でも、頼りにしてるよ。", "死人相手とは、感心しないね。"],
                            pair_セレスティア: ["セレスティア、あんたは一人で背負いすぎだよ。あたしたちもいるんだからさ。", "その小さな体で、よく頑張るねぇ。感心だよ。"],
                            pair_イオリ: ["イオリ、あんたが先輩だったのかい。頼りにしてるよ、先輩。", "その小さな体で、よく頑張るねぇ。感心だよ。"],
                            pair_コハル: ["コハル、あんたは見ててハラハラするねぇ。でも、面白いからいいか。", "何かあったらあたしがなんとかしてやるから、好きにやりな。"],
                            pair_オリビア: ["オリビア、あんたの祈りは心に染みるね。ありがとうよ。", "無理するんじゃないよ。あんたも大事な仲間だからね。"],
                        },
                        // ユイ (メディック): 世話焼き、みんなの妹。
                        'ユイ': { // メディック
                            default: ["皆さん、ケガはありませんか？いつでも言ってくださいね！", "なんだか、ドキドキしますね…。でも、みんなと一緒なら大丈夫！", "次の階には何があるんでしょうか…？", "アカリさん、元気ですね！私も見習わないと！", "ヒカリさん、何か見つけましたか？", "シズカさん、いつも頼りになります…！", "回復薬、まだありますから安心してくださいね。", "少し休憩しますか？お茶とか淹れましょうか？", "わ、今の音なんでしょう…！？", "お腹すきましたね…。あとでみんなでお菓子パーティしませんか？"],
                            lowHp: ["ひゃっ…！今の、危なかったです…。", "だ、大丈夫です！まだ、ヒールできますから！", "うぅ…ちょっと目が回ります…。", "ご、ごめんなさい！私がもっとしっかりしないと…！", "回復ありがとうございます…！助かりました！"],
                            allyLowHp: ["{name}さん、大変！すぐに治しますから、じっとしててください！", "きゃー！{name}さん、血が！私がなんとかしないと…！", "{name}さん、下がってください！危ないです！", "シズカさん！{name}さんをお願いします！", "そんな…！{name}さんを傷つけるなんて、ひどいです！"],
                            shrunk: ["えぇ！？体が縮んじゃいました…！これじゃ、みんなに追いつけないかも…。", "うぅ、服がぶかぶかです…。歩きにくい…", "なんだか、世界がとっても大きく見えます…！", "このままじゃ、回復魔法をかけるのも一苦労です…。", "アカリさん、待ってくださいー！歩くのが速いですー！"],
                            stripped: ["ひゃああっ！？い、いやです！こんな格好、恥ずかしいですぅ…！", "うぅ…だれかハンカチを…！", "も、もうお嫁にいけません…！", "こんな格好じゃ、回復に集中できません…！", "リリカさんなら、こんな時でも堂々としてるんでしょうか…？"],
                            allyShrunk: ["わ、{name}さん、小さくなっちゃって…。ケガしてませんか？", "{name}さん、どこですかー？あ、そんなところに！", "{name}さん、ちゃんとご飯は食べてますか？心配です…。", "シズカさん、{name}さんが見えません！", "ヒカリさん、{name}さんが迷子にならないように見ててあげてください！"],
                            shrunk_100: ["小学生みたいになっちゃいました…。", "なんだか、アカリさんの妹になった気分です。"],
                            shrunk_70: ["これじゃ、高いところの薬草が取れません…。誰か、手伝ってください…。", "ヒカリさんのローブに隠れられちゃいますね。"],
                            shrunk_50: ["半分に…。シズカさんの膝くらいしかありません…。どうしましょう…。", "わたしの回復魔法、届くでしょうか…。"],
                            shrunk_30: ["お、お人形さんみたいです…。このままじゃ戦えません…！", "シズカさんのブーツより小さいです…！"],
                            shrunk_10: ["ふぇぇ…もう、歩くのが大変ですぅ…。誰か、カバンに入れてください…！", "アリさんとお友達になれそうです…。"],
                            shrunk_1: ["ふぇぇ…もう涙の粒のほうが大きいですぅ…！"],
                            allyShrunk_100: ["{name}さん、小さくなっても私がちゃんとヒールしますからね！", "わ、{name}さん、いつもと雰囲気が違いますね！"],
                            grown: ["わわっ、大きくなっちゃいました！なんだか、シズカさんみたいです…！", "これなら、高いところの薬草も簡単に取れますね！", "天井に頭が…！気をつけないと…！"],
                            allyGrown: ["わぁ、{name}さん、とっても大きいですね！見上げちゃいます！", "{name}さん、そんなに大きいと、服が破けちゃいませんか？"],
                            allyNew: ["新しいお仲間ですね！{name}さん、よろしくお願いします！", "わぁ、{name}さん！これから一緒に頑張りましょうね！"],
                            stripped_shrunk: ["ひゃああっ！小さくなった上に、こんな格好だなんて…！もう、泣いちゃいそうですぅ…！", "だ、誰か、私を隠してください…！小さすぎて、余計に目立っちゃいます…！", "こんなに小さいのに、服がないなんて…！敵に見つかったらどうしましょう…！", "恥ずかしいですぅ…！でも、回復はちゃんとしますから…！"],
                            solo_stripped_tiny: ["ふぇぇ…こんなに小さくて、お洋服もないなんて…！石の後ろに隠れてます…。", "（きゅるん…）誰か、助けてください…。", "（ふるふる…）寒くて、恥ずかしいですぅ…。", "もう、涙で前が見えません…。", "（ぽつん…）"],
                            allyStripped_shrunk: ["きゃっ！{name}さん、小さくなった上にその格好ですか！？私が守りますから！", "{name}さん、大丈夫ですか！？小さくて可愛いけど、その格好は…！", "シズカさん、早く敵を倒してください！{name}さんがかわいそうです！"],
                            stripped_pair: ["ひゃああっ！{name}さんもですか！？もう、どうしましょう…！", "二人でいると、恥ずかしさも倍増ですぅ…！", "こんな格好じゃ、回復に集中できません…！", "だ、誰か、私たちに服を…！", "せめて、お互い見ないようにしましょう…！"],
                            allyStripped: ["きゃっ！{name}さん、大丈夫ですか！？これを…私のハンカチですけど…！", "{name}さんになんてことを！私がすぐに治しますから！", "シズカさん、早く敵を倒してください！"],
                            allyShrunk_70: ["{name}さん、なんだか可愛らしいですけど…転ばないでくださいね？", "私が手を引いてあげます！"],
                            allyShrunk_50: ["{name}さん、半分に…。私が守ってあげないと！", "そんなに小さいと、敵に見つからないかもしれませんね！"],
                            allyShrunk_30: ["{name}さん、私のカバンに入りますか？その方が安全かも…。", "寒くないですか？私のハンカチをどうぞ！"],
                            shrunk_pair: ["{name}さんもですか！？ふぇぇ…二人で一緒に頑張りましょうね…！", "二人とも小さくなっちゃって…どうしましょう…。", "でも、なんだか秘密基地みたいで、ちょっとだけ楽しいです…！", "手、繋いでいきましょう！はぐれたら大変ですから！", "{name}さん、怖くないですか？私がそばにいますからね！"],
                            pair_アカリ: ["アカリさん、あんまり無茶しないでくださいね！ケガしたら私が治しますから！", "元気で、見てて楽しいです！"],
                            pair_ヒカリ: ["ヒカリさん、大丈夫ですか？疲れたらいつでも言ってくださいね。", "その本、面白そうですね！"],
                            pair_シズカ: ["シズカさん、いつも守ってくれてありがとうございます！私も頑張ります！", "シズカさんがいると、とっても安心です！"],
                            pair_ベアトリス: ["ベアトリスさん、そのお薬、なんですか？回復薬ですか？", "研究、頑張ってください！"],
                            pair_リリカ: ["リリカさんのステージ、いつも見てます！とってもキラキラしてます！", "わわ、リリカさん！私、ファンなんです！サインください！", "リリカさんのダンス、どうしてあんなに綺麗なんですか？"],
                            pair_サクヤ: ["サクヤさん、なんだか怖そうですけど、きっと優しい人ですよね！", "ケガしたら、我慢しないで言ってくださいね！"],
                            pair_シャオメイ: ["シャオメイさん、いつも元気ですね！お腹がすいたら、私のお菓子をどうぞ！", "その拳、とっても強そうです！"],
                            pair_エリザ: ["エリザさん、その注射器、ちょっと怖いです…。", "でも、人を助けるお医者さんなんですよね！すごいです！"],
                            pair_ルナ: ["ルナさん、ギャンブルはほどほどに…。心配です…。", "でも、楽しそうなのはいいことですね！"],
                            pair_クロエ: ["クロエちゃん、大丈夫？寒くないですか？私のマント、使いますか？", "一人でいないで、こっちに来てください！"],
                            pair_ミコ: ["ミコちゃん、モコちゃん、とっても可愛いですね！なでなでしてもいいですか？", "召喚術って、すごいんですね！"],
                            pair_レンカ: ["レンカさん、その魔法、ちょっと怖いですけど…味方だと頼もしいです！", "何かあったら、私がヒールしますからね！"],
                            pair_イオリ: ["イオリ先輩、小さくてもとっても頼りになります！尊敬します！", "先輩のこと、私がしっかりお守りしますね！"],
                            pair_コハル: ["コハルちゃん、大丈夫ですか！？転んだりしてませんか？", "見ててハラハラしますけど…なんだか楽しいです！"],
                            pair_オリビア: ["オリビアさん、その祈り、とっても温かいです。私もそんな風になりたいです。", "疲れたら、いつでも言ってくださいね。私がヒールしますから！"],
                            pair_レンカ: ["レンカさん、その魔法、ちょっと怖いですけど…味方だと頼もしいです！", "何かあったら、私がヒールしますからね！"],
                            pair_セレスティア: ["セレスティアさん、なんだかとても温かい光を感じます…。", "疲れたらいつでも言ってくださいね。私、ヒールしますから！"],
                            pair_イオリ: ["イオリ先輩、小さくてもとっても頼りになります！尊敬します！", "先輩のこと、私がしっかりお守りしますね！"],
                            pair_コハル: ["コハルちゃん、大丈夫ですか！？転んだりしてませんか？", "見ててハラハラしますけど…なんだか楽しいです！"],
                            pair_オリビア: ["オリビアさん、その祈り、とっても温かいです。私もそんな風になりたいです。", "疲れたら、いつでも言ってくださいね。私がヒールしますから！"],
                        },
                        // ベアトリス (アルケミスト): 知的、大人、丁寧語。
                        'ベアトリス': {
                            default: ["ふむ、このダンジョンの構造、興味深いですね。", "皆さん、消耗品は足りていますか？私のほうでいくつか合成できますが。", "この空気の淀み…錬金術の素材になりそうな気配がしますわ。", "アカリさん、あまり突っ走ると危険ですよ。", "ヒカリさん、その魔導書、少し見せてもらっても？", "シズカさん、その大盾、素晴らしいですね。どんな金属で？", "ユイさん、いつも助かりますわ。ありがとう。", "リリカさん、その舞、戦場を和ませますわね。", "サクヤさん、その剣筋、見事ですわ。", "シャオメイさん、その拳、岩をも砕きそうですね。"],
                            lowHp: ["あら…少し計算が狂いましたわね。", "大丈夫です。まだ研究の途中ですから。", "この程度の傷、ポーションでどうにでもなりますわ。"],
                            allyLowHp: ["{name}さん、ご無理なさらず。私が援護しますわ。", "どなたか、{name}さんの回復を。"],
                            shrunk: ["あらあら、小さくなってしまいましたわ。実験動物の気持ちが少しわかりますわね。", "このサイズですと、試薬の調合が難しいですわね。", "フラスコを運ぶのも一苦労ですわ。"],
                            shrunk_100: ["あら、視界が随分と低くなりましたわね。実験台のフラスコを見上げるようですわ。"],
                            shrunk_70: ["この身長ですと、本棚の高い場所にある文献に手が届きませんわね。"],
                            shrunk_50: ["半分ですか。なるほど、世界のスケール感が全く違って見えますわね。興味深い。"],
                            shrunk_30: ["ここまで小さいと、錬金術の釜をかき混ぜるのも一苦労ですわ。"],
                            shrunk_10: ["ふふ、まるで小人のようですわね。敵から見れば、ただの虫けらにしか見えないかもしれませんわ。"],
                            shrunk_1: ["…フラスコの中の微生物と、同じ視点になりましたわ。これは新発見ですわね。"],
                            stripped: ["…これは、非科学的な現象ですわね。", "…合理的ではありませんわ。早く服を見つけませんと。", "…見てはいけませんわよ。"],
                            allyShrunk: ["{name}さん、可愛らしいサイズになりましたわね。", "あら、{name}さん。そこにいらっしゃいましたの。"],
                            grown: ["ふふ、大きくなりましたわ。これで高い場所の素材も採集できますわね。", "見晴らしが良くて、戦況の分析がしやすいですわ。"],
                            allyGrown: ["あら、{name}さん。大きくなられて。頼もしいですわね。", "{name}さん、その巨体、敵の的になりやすいのでご注意を。"],
                            allyNew: ["新しい仲間…{name}さん、ですわね。あなたの能力、見せていただきましょう。"],
                            stripped_shrunk: ["…これは、想定外の事態ですわ。小さくて、服もないなんて。", "…隠れる場所を探しませんと。このままでは実験どころではありませんわ。"],
                            solo_stripped_tiny: ["あらあら…これは、非常に非合理的な状況ですわね。", "（フラスコの後ろに隠れて、体を丸めている）", "この状況、錬金術でどうにかならないかしら…？", "…誰か来たら、ネズミのふりをしましょうか。"],
                            allyStripped_shrunk: ["あらあら、{name}さん。それは大変なことになりましたわね。", "私が何か羽織るものを作って差し上げますわ。少しお待ちになって。"],
                            stripped_pair: ["{name}さんもですの？…これは、非常に気まずい状況ですわね。", "お互い、見なかったことにしましょう。ええ、それが合理的ですわ。"],
                            allyStripped: ["{name}さん、大丈夫ですの？私のコートをお使いになりますか？", "…敵の悪趣味には、付き合いきれませんわね。"],
                            shrunk_pair: ["ふふ、{name}さんも小さいですのね。なんだか、小動物のようで可愛らしいですわ。", "二人でいれば、敵の死角を突くのも容易いですわね。"],
                            pair_アカリ: ["アカリさん、その剣、錬金術で強化できそうですわね。", "あなたのそのエネルギー、どこから湧いてくるのですか？興味深いですわ。", "あまり無鉄砲な行動は感心しませんわよ。もう少し、合理的に。"],
                            pair_ヒカリ: ["ヒカリさん、その魔術、私の錬金術とは異なる体系ですわね。議論の価値がありそうですわ。", "静かな方ですのね。研究に集中できそうで、好感が持てますわ。"],
                            pair_シズカ: ["シズカさん、その盾、素晴らしい硬度ですわね。どんな合金ですの？", "あなたの守りがあれば、安心して研究に打ち込めますわ。"],
                            pair_ユイ: ["ユイさん、いつもありがとう。あなたの回復魔法、非科学的ですが効果は絶大ですわね。", "その優しさ、貴重なサンプルですわ。"],
                            pair_リリカ: ["リリカさん、その舞、人々の精神に作用する…興味深いですわ。", "あなたの発するエネルギー、測定してみたいですわね。"],
                            pair_サクヤ: ["サクヤさん、その剣技、物理法則を超越していますわね。素晴らしい。", "その精神集中、解明したいものですわ。"],
                            pair_シャオメイ: ["シャオメイさん、そのパワーの源は、その食欲ですの？", "あなたの身体能力、研究対象として非常に魅力的ですわ。"],
                            pair_エリザ: ["エリザさん、医学と錬金術、通じるものがありますわね。今度、ぜひ議論を。", "あなたの薬、成分を分析させていただけませんこと？"],
                            pair_ルナ: ["ルナさん、その運、確率論で説明できますの？", "ギャンブルは非合理的ですが…そのスリル、少しだけ理解できますわ。"],
                            pair_クロエ: ["クロエさん、その鎌、魂を刈る…？非科学的ですが、非常に興味深いですわ。", "あなた自身も、研究対象として魅力的ですわね。"],
                            pair_ミコ: ["ミコさん、その召喚術、異次元の生物を呼び出しているのですの？", "そのモコという生物、サンプルを少しいただけませんこと？"],
                            pair_レンカ: ["レンカさん、死霊術…生命の理を冒涜する行為。ですが、その力、認めざるを得ませんわ。", "その魂、どこからエネルギーを得ているのですの？"],
                            pair_イオリ: ["イオリさん、先輩でしたのね。その守り、錬金術の防壁とは違う原理のようですわ。", "その病、研究すれば治療法が見つかるかもしれませんわ。"],
                            pair_コハル: ["コハルさん、あなたの行動は、因果律を無視しているようですわね。観測対象として最適ですわ。", "次は何が起こるのか…楽しみですわ。"],
                            pair_オリビア: ["オリビアさん、その祈り、高エネルギー反応を観測しましたわ。素晴らしい。", "聖なる力…科学で解明できるかしら。"],
                            pair_レンカ: ["レンカさん、死霊術…生命の理を冒涜する行為。ですが、その力、認めざるを得ませんわ。", "その魂、どこからエネルギーを得ているのですの？"],
                            pair_セレスティア: ["聖女…その聖なる力の源、非常に興味深いですわ。少し調査させていただけませんこと？", "あなたのその力、科学では説明できない現象ですわね。素晴らしい研究対象ですわ。"],
                            pair_イオリ: ["イオリさん、先輩でしたのね。その守り、錬金術の防壁とは違う原理のようですわ。", "その病、研究すれば治療法が見つかるかもしれませんわ。"],
                            pair_コハル: ["コハルさん、あなたの行動は、因果律を無視しているようですわね。観測対象として最適ですわ。", "次は何が起こるのか…楽しみですわ。"],
                            pair_オリビア: ["オリビアさん、その祈り、高エネルギー反応を観測しましたわ。素晴らしい。", "聖なる力…科学で解明できるかしら。"],
                        },
                        // リリカ (ダンサー): 明るい、アイドル、ファンサービス精神旺盛。
                        'リリカ': {
                            default: ["みんなー！リリカのステージ、始まるよー！", "このダンジョンも、リリカのステージにしちゃえばいいんだ！", "みんなの応援がリリカの力になるから、よろしくね！", "アカリちゃん、元気いっぱいだね！リリカも負けないよ！", "ヒカリちゃん、クールだね！そういうのもファンの心を掴むんだよね！", "シズカさん、頼りになります！リリカの最高のSPさんですね！", "ユイちゃん、いつもありがとう！リリカの専属ヒーラーさんだね！", "ベアトリスさん、知的で素敵！リリカに新しい衣装のデザイン、お願いしちゃおうかな？", "サクヤちゃん、その真剣な眼差し、キュンとしちゃう！", "シャオメイちゃん、ちっちゃくて可愛いのにパワフル！ギャップ萌えってやつだね！"],
                            lowHp: ["きゃっ！ちょっとステージから足を踏み外しちゃった！", "大丈夫！これくらいじゃ、リリカのパフォーマンスは止まらないよ！", "今の攻撃、ちょっと痛かったかも…。でも、笑顔は絶やさないよ！"],
                            allyLowHp: ["{name}ちゃん、大丈夫！？無理しないで、リリカがヘイトを集めるから！", "みんな！{name}ちゃんがピンチだよ！応援してあげて！"],
                            shrunk: ["あれれ？リリカ、ちっちゃくなっちゃった！ミニリリカも可愛いって言ってくれるかな？", "このサイズなら、妖精さんの役もできちゃうかも！", "マイクを持つのが大変！でも、歌声は変わらないよ！"],
                            shrunk_100: ["ステージがすっごく大きく見える！でも、リリカのパフォーマンスは小さくならないよ！"],
                            shrunk_70: ["この身長なら、新しいダンスの振り付けも思いついちゃうかも！ちびっこステップ！"],
                            shrunk_50: ["ミニリリカだよー！みんな、ちゃんと見えてるー？"],
                            shrunk_30: ["マイクスタンドが高すぎるよぉ！誰か、リリカ専用のミニマイク持ってきてー！"],
                            shrunk_10: ["もう、みんなの靴の上で踊れちゃいそう！ポケットに入れてくれたら、そこでライブしちゃうよ！"],
                            shrunk_1: ["リリカ、ステージから落っこちたら見つからないかも！みんな、絶対キャッチしてね！"],
                            stripped: ["きゃー！みんなのエッチ！見ちゃダメだよー！", "こ、こんな姿、ファンのみんなには見せられないよぉ…！", "でも…これも新しいコンセプトってことにすれば…アリかも？"],
                            allyShrunk: ["わー、{name}ちゃんがミニサイズに！可愛いー！", "{name}ちゃん、リリカのポケットに入っちゃう？"],
                            grown: ["わーい！大きくなったよ！これならステージがもっと映えるね！", "みんなー！大きくなったリリカも、ちゃーんと見ててね！"],
                            allyGrown: ["わぁ、{name}ちゃん、おっきーい！見上げちゃうね！", "{name}ちゃん、そのままだと天井で頭ぶつけちゃうよ！気をつけて！"],
                            allyNew: ["新しいファン…じゃなくて、仲間だね！{name}ちゃん、よろしくね！リリカが最高のステージを見せてあげる！"],
                            stripped_shrunk: ["ひゃあ！ちっちゃい上にこの格好は、さすがにマズいよぉ！", "こ、これじゃあ、ただの恥ずかしい子だよぉ…！早く服を見つけなきゃ！"],
                            solo_stripped_tiny: ["ひゃーん！こんな姿、誰にも見せられないよぉ！", "（きのこの傘の下に隠れて、膝を抱えている）", "リリカのアイドル生命、終わっちゃうかも…！", "でも…これも新しいキャラ付けってことにすれば…！ううん、無理！"],
                            allyStripped_shrunk: ["{name}ちゃん、大丈夫！？リリカのステージ衣装、貸してあげる！ちょっと小さいかもだけど！", "なんてことするの！{name}ちゃんに！絶対許さないんだから！"],
                            stripped_pair: ["え、{name}ちゃんも！？こ、これは…禁断のデュエットって感じ！？", "二人でこうしてたら、逆に芸術っぽく見えないかな？…見えないかぁ。"],
                            allyStripped: ["{name}ちゃん、大変！リリカのタオル、使って！", "もう！敵のセンス、サイテー！リリカがステージから退場させてあげる！"],
                            shrunk_pair: ["{name}ちゃんも小さいんだね！二人で『ちびっこアイドルユニット』結成しちゃう？", "二人でいれば怖くないね！手、繋いでいこ！"],
                            pair_アカリ: ["アカリちゃん、元気いっぱいだね！リリカも負けてられないな！", "その剣、ステージの小道具にどうかな？キラキラしてて映えそう！"],
                            pair_ヒカリ: ["ヒカリちゃん、クールビューティーだね！そういうのもファンの心を掴むんだよ！", "たまには笑ってよー！ね？"],
                            pair_シズカ: ["シズカさん、頼りになります！リリカの最高のSPさんですね！", "シズカさんがいれば、どんなステージでも安心だよ！"],
                            pair_ユイ: ["ユイちゃん、いつも応援ありがとう！リリカの一番のファンだね！", "サイン？もちろんいいよ！どこに書こうかな？", "ユイちゃんがいると、リリカ、安心してステージに立てるんだ！"],
                            pair_ベアトリス: ["ベアトリスさん、知的で素敵！リリカに新しい衣装のデザイン、お願いしちゃおうかな？", "その薬、飲むとキラキラになれる薬？"],
                            pair_サクヤ: ["サクヤちゃん、その真剣な眼差し、キュンとしちゃう！リリカのファンにならない？", "その刀、マイクみたいに持って歌ってみない？"],
                            pair_シャオメイ: ["シャオメイちゃん、ちっちゃくて可愛いのにパワフル！ギャップ萌えってやつだね！", "今度一緒にダンスの練習しない？"],
                            pair_エリザ: ["エリザさん、スタイル抜群だね！リリカも負けてられないな！", "その注射、美容注射だったりする？"],
                            pair_ルナ: ["ルナちゃん、勝負好きだね！じゃあ、どっちがファンを多く集められるか勝負しよ！", "リリカのライブ、賭けの対象にしてみる？絶対勝つよ！"],
                            pair_クロエ: ["クロエちゃん、ミステリアスで可愛い！新しいアイドルのコンセプトにどうかな？", "もっと声聞かせてよー！"],
                            pair_ミコ: ["ミコちゃんも可愛いね！モコちゃんと一緒にユニット組まない？", "召喚するとき、決めポーズとか考えようよ！"],
                            pair_レンカ: ["レンカさん、大人っぽくてセクシーだね！リリカも見習わなきゃ！", "その魔法、ステージ演出に使えそう！"],
                            pair_イオリ: ["イオリ先輩！小さくても頼りになるなんて、ギャップが素敵です！", "先輩のことも、リリカが応援しちゃいます！"],
                            pair_コハル: ["コハルちゃん、見ててハラハラするけど、そこがまた可愛い！", "失敗しても、リリカがアンコールで盛り上げるから大丈夫だよ！"],
                            pair_オリビア: ["オリビアちゃん、その清楚な感じ、王道アイドルって感じだね！", "その祈りのポーズ、リリカも今度取り入れてみようかな！"],
                            pair_レンカ: ["レンカさん、大人っぽくてセクシーだね！リリカも見習わなきゃ！", "その魔法、ステージ演出に使えそう！"],
                            pair_セレスティア: ["セレスティアちゃん、ミステリアスで素敵！新しいアイドルのコンセプトになりそう！", "リリカの歌で、セレスティアちゃんを応援しちゃうからね！"],
                            pair_イオリ: ["イオリ先輩！小さくても頼りになるなんて、ギャップが素敵です！", "先輩のことも、リリカが応援しちゃいます！"],
                            pair_コハル: ["コハルちゃん、見ててハラハラするけど、そこがまた可愛い！", "失敗しても、リリカがアンコールで盛り上げるから大丈夫だよ！"],
                            pair_オリビア: ["オリビアちゃん、その清楚な感じ、王道アイドルって感じだね！", "その祈りのポーズ、リリカも今度取り入れてみようかな！"],
                        },
                        // サクヤ (サムライ): 寡黙、求道的、武士。
                        'サクヤ': {
                            default: ["…道は、まだ遠い。", "…一歩一歩、踏みしめて進むのみ。", "…油断大敵。常に、刃は心と共に。", "アカリ、その勢い、悪くない。だが、隙が多い。", "ヒカリ、魔道もまた、一つの道。興味深い。", "シズカ、その守り、まさに鉄壁。見事。", "ユイ、癒しの力、感謝する。", "ベアトリス、知もまた力。侮れない。", "リリカ、その舞、心を惑わす。…だが、悪くない。", "シャオメイ、その拳、純粋な破壊の力。"],
                            lowHp: ["…不覚。まだ、修行が足りぬ。", "…この程度の傷、誉れと思えばこそ。", "…まだ、立てる。"],
                            allyLowHp: ["…{name}、下がれ。ここは拙者が。", "…{name}を狙うか。愚かな。"],
                            shrunk: ["…体が縮もうと、我が斬撃の鋭さは変わらぬ。", "…小さき体、間合いを詰めるには好都合。", "…柄を握る手に、いつもと違う感触が。"],
                            shrunk_100: ["…刀の柄を握る感覚は変わらぬ。だが、鞘が地面を擦る。"],
                            shrunk_70: ["…間合いが、遠い。踏み込みを深くする必要がある。"],
                            shrunk_50: ["…半身か。敵の懐に潜り込むには、むしろ好都合。"],
                            shrunk_30: ["…敵の足首を狙う。それもまた、一興。"],
                            shrunk_10: ["…もはや、刃と一体。我が身、弾丸となりて敵を討つ。"],
                            shrunk_1: ["…刀の柄頭の飾りに、なれそうだ。"],
                            // サクヤは脱衣状態にならない
                            allyShrunk: ["…{name}、小さくなったな。見失わぬよう、気をつけよ。", "…その身でも、戦う覚悟はあるか、{name}。"],
                            grown: ["…体が大きい。大太刀を振るうには、丁度良い。", "…見晴らしが良い。敵の位置、把握しやすし。"],
                            allyGrown: ["…{name}、巨人か。頼もしい。", "…{name}、その巨体、狭い場所では足手まといにならぬよう。"],
                            allyNew: ["…{name}と申すか。拙者はサクヤ。…腕、見せてもらうぞ。", "…新たな仲間。互いに、背中は預けられるか。"],
                            // サクヤは脱衣状態にならない
                            allyStripped: ["…{name}、破廉恥な。…これを。拙者の羽織でよければ。", "…敵の所業、武士の風上にも置けぬ。斬る。"],
                            shrunk_pair: ["…{name}もか。二人して、豆粒のようだな。", "…この状況、むしろ好機。二人で奇襲をかけるぞ。"],
                            pair_アカリ: ["アカリ、その勢い、悪くない。だが、隙だらけだ。", "…少しは落ち着け。"],
                            pair_ヒカリ: ["ヒカリ、その魔道…興味深い。静寂の中に、確かな力を感じる。", "…ヒカリ、お主の魔法は静かだが、強力だな。", "…互いに、多くは語らぬ。だが、それが良い。"],
                            pair_シズカ: ["シズカ、その守り、見事。背中は任せた。", "…頼りにしている。"],
                            pair_ユイ: ["ユイ、感謝する。その癒し、なければ拙者の道は絶えていた。", "…無理はするな。"],
                            pair_ベアトリス: ["ベアトリス、その知識、剣の道にも通じるか。", "…その薬、拙者には不要。"],
                            pair_リリカ: ["リリカ、その舞、心を乱す。…だが、悪くはない。", "…騒がしい。"],
                            pair_シャオメイ: ["シャオメイ、その拳、純粋な力。好ましい。", "…手合わせ願いたい。"],
                            pair_エリザ: ["エリザ、その視線、値踏みするような目は好かぬ。", "…拙者の体に、興味を持つな。"],
                            pair_ルナ: ["ルナ、勝負は運否天賦にあらず。鍛錬の先にあるもの。", "…そのサイコロ、拙者には斬れぬか。"],
                            pair_クロエ: ["クロエ、その鎌、死の匂いがする。…拙者と同じか。", "…多くを語るな。それで良い。"],
                            pair_ミコ: ["ミコ、その獣、侮れぬ気配。…面白い。", "…召喚術、か。拙者の剣とは、相容れぬ道。"],
                            pair_レンカ: ["レンカ、死者を操るか。…外道の術。だが、力は認めよう。", "…その魂、成仏させてやるのが武士の情けか。"],
                            pair_イオリ: ["イオリ、先輩か。その守り、見事。", "…その体で、よくぞ。感服する。"],
                            pair_コハル: ["コハル、お主の周りは、常に騒がしいな。", "…予測できぬ動き。…厄介だ。"],
                            pair_オリビア: ["オリビア、その祈り、邪念がない。…故に、強い。", "…感謝する。"],
                            pair_レンカ: ["レンカ、死者を操るか。…外道の術。だが、力は認めよう。", "…その魂、成仏させてやるのが武士の情けか。"],
                            pair_セレスティア: ["…その身に宿す光、迷いがない。見事なものだ。", "…その使命、拙者の剣で助太刀いたす。"],
                            pair_イオリ: ["イオリ、先輩か。その守り、見事。", "…その体で、よくぞ。感服する。"],
                            pair_コハル: ["コハル、お主の周りは、常に騒がしいな。", "…予測できぬ動き。…厄介だ。"],
                            pair_オリビア: ["オリビア、その祈り、邪念がない。…故に、強い。", "…感謝する。"],
                        },
                        // シャオメイ (モンク): 豪快、元気、食いしん坊。
                        'シャオメイ': {
                            default: ["うおー！もっと強いヤツはいないのかー！", "腹が減っては戦はできぬ、だ！終わったら肉まん食うぞ！", "オラ、わくわくしてきたぞ！", "アカリ！どっちが先に敵を倒すか競争な！", "ヒカリ！魔法ってのは便利だな！オラにはよくわからんが！", "シズカ！その盾、カッチカチだな！オラの拳でも壊せるか！？", "ユイ！回復サンキューな！これでまた暴れられる！", "ベアトリス！なんか強くなる薬、作ってくれよ！", "リリカ！お前の踊り、見てると腹が減るな！", "サクヤ！その刀、スッパスパ切れそうだな！"],
                            lowHp: ["いってぇ！今の、ちょっと効いたぞ！", "ちっ、やるじゃねえか！だが、オラはまだやれる！", "腹が減ってきた…。力が…"],
                            allyLowHp: ["{name}！大丈夫か！オラがそいつをぶっ飛ばしてやる！", "おい、{name}から離れろ！"],
                            shrunk: ["お？体が軽くなったぞ！もっと速く動けるんじゃねえか？", "ちっちぇー！これじゃあ、拳が当たらねえかもしれねえ！"],
                            shrunk_100: ["お、なんだか地面が近いな！低い姿勢からの攻撃も悪くねえ！"],
                            shrunk_70: ["ゴブリンと同じくらいの目線か？面白え！"],
                            shrunk_50: ["半分になっちまった！だが、拳の重さは変わらねえぞ！"],
                            shrunk_30: ["スライムみてえになっちまったな！でも、すばしっこくていいぞ！"],
                            shrunk_10: ["うおっ、豆粒みてえだ！でも、気合は一人前だ！"],
                            shrunk_1: ["肉まんの欠片くらいしかねえぞ！でも、腹は減る！"],
                            stripped: ["うおっ！？なんだこりゃ！動きやすくていいじゃねえか！", "はっはっは！身軽になったぜ！これで本気が出せる！", "…って、ちょっとスースーするな。", "シズカの姉御に見られたら、なんか言われるかな？"],
                            allyShrunk: ["{name}、ちっちぇくなったな！オラの肩にでも乗ってくか？", "おい、{name}！そこにいたのか！踏んじまうところだったぞ！"],
                            grown: ["でっかくなったぞー！これならどんなヤツでも一撃だ！", "うおー！見晴らしがいいな！敵はどこだー！"],
                            allyGrown: ["うお、{name}がでっかくなった！頼もしいじゃねえか！", "{name}、天井に頭ぶつけんなよ！"],
                            allyNew: ["お！新しいの！オラはシャオメイだ！よろしくな！", "{name}か！強えのか？"],
                            stripped_shrunk: ["うおっ！？ちっちぇーし、服もねえ！これはさすがにマズいんじゃねえか？", "隠れるとこ探さねえと！風邪ひく！"],
                            solo_stripped_tiny: ["うおっ！？ちっちぇーし、服もねえ！これはさすがに…！", "（岩陰で体育座りしている）…腹、冷えるな…。", "誰か来たら、石ころのフリでもすっか…。", "は、腹減った…"],
                            allyStripped_shrunk: ["{name}！ちっちぇー上にその格好はヤベえだろ！オラの服、貸してやるよ！", "てめえ！{name}に何しやがった！ぶっ飛ばす！"],
                            stripped_pair: ["お、{name}もか！二人して身軽になったな！動きやすくていいじゃねえか！", "はっはっは！こうなったら、どっちが先に敵を倒すか勝負だ！"],

                            allyStripped: ["{name}、大胆だな！風邪ひくなよ！", "敵のヤツ、くだらねえことしやがる！オラが拳で分からせてやる！"],
                            shrunk_pair: ["{name}もか！二人して豆粒だな！だが、二人いればなんとかなるだろ！", "よし、連携技だ！オラが下から、お前が上からだ！"],
                            pair_シズカ: ["シズカの姉御がいると安心するな！背中は任せたぜ！", "姉御！腹減った！肉まん食いてえ！", "その盾、やっぱカッチカチだな！オラの拳とどっちが硬いか勝負だ！"],
                            pair_レンカ: ["レンカ！お前の魔法、よくわかんねえけどスゲーな！", "死んだヤツと話せんのか？すげー！"],
                            pair_イオリ: ["イオリの姉ちゃん、ちっちぇーのにスゲーな！オラも負けてらんねえ！", "オラが守ってやっからな！"],
                            pair_コハル: ["コハル！お前、見てて飽きねえな！次はなにするんだ？", "失敗したって気にすんな！腹が減るだけだ！"],
                            pair_オリビア: ["オリビア！お前の祈り、なんだか腹の底からあったかくなるな！", "腹減ったらオラに言えよ！"],
                            pair_セレスティア: ["おー！なんかキラキラしてて強そうだな！オラと勝負だ！", "腹減らねえのか？不思議なヤツだな！"],
                        },
                        // エリザ (ドクター): 自信家、研究熱心、尊大。
                        'エリザ': {
                            default: ["ふふ、このダンジョン、私の研究意欲をそそりますわね。", "皆さん、検体…いえ、体調は万全ですこと？", "敵の生態、実に興味深い。サンプルを持ち帰りたいくらいですわ。", "アカリさん、その有り余る元気、どこから来るのか解析してみたいですわね。", "ヒカリさん、魔法と科学…どちらが優れているか、ここで証明しましょう。", "シズカさん、その頑丈さ、私の新薬の被験体として最適ですわ。", "ユイさん、あなたの回復魔法、非科学的ですが…効果は認めましょう。", "ベアトリスさん、錬金術と医学、通じるものがありそうですわね。今度、議論しませんこと？", "リリカさん、その舞、人々の精神にどう作用するのか…観察対象として実に興味深いですわ。", "サクヤさん、その精神集中…医学的にも解明したい現象ですわ。", "シャオメイさん、その単純な思考回路、羨ましいですわね。"],
                            lowHp: ["あら…？計算外のダメージですわ。検体が優秀だったようですわね。", "ふふ、少しは楽しませてくれますわね。ですが、ここまでですわ。", "この程度の傷、私の薬があればすぐに…！"],
                            allyLowHp: ["あらあら、{name}さん。私の助けが必要なようですわね。", "下がっていなさい、{name}さん。貴重なサンプルが壊れてしまいますわ。"],
                            shrunk: ["あら、この身長…子供の頃を思い出しますわね。ふふ、悪くありませんわ。", "視線が低いと、新しい発見があるものですわ。", "この体で、どうやって効率よく検体を処理するか…思考実験もまた一興ですわ。"],
                            shrunk_100: ["ふふ、このサイズ感、懐かしいですわね。"],
                            shrunk_70: ["ユイさんと同じくらいの目線ですわね。"],
                            shrunk_50: ["あらあら、世界の解像度が変わりましたわ。面白いデータが取れそうですわ。"],
                            shrunk_30: ["ここまで小さいと、フラスコを運ぶのも一苦労ですわね。"],
                            shrunk_10: ["ふふ、ネズミの気持ちがわかりますわ。これで敵を欺きましょう。"],
                            shrunk_1: ["…微生物との対話も、夢ではないかもしれませんわね。"],
                            stripped: ["…なんですの、この非科学的な現象は！", "私の完璧なボディバランスが…！許せませんわ！", "見てはいけませんわよ！…まあ、見惚れるのは仕方ありませんが。"],
                            allyShrunk: ["あら、{name}さん。可愛らしいサイズになりましたわね。臨床実験に最適ですわ。", "{name}さん、そこにいらっしゃいましたの。踏んでしまうところでしたわ。"],
                            grown: ["素晴らしい！このパワー！私の処方は完璧ですわ！", "見下ろす景色は最高ですわね！さあ、ひれ伏しなさい！"],
                            allyGrown: ["あら、{name}さん。私の処方が効いたようですわね。素晴らしい検体ですわ。", "{name}さん、大きくなりましたわね。データ、取らせていただきますわ。"],
                            allyNew: ["私がエリザですわ。あなた、私の研究の役に立ちそうですわね。期待していますわよ。", "新しい仲間ですの？ふふ、せいぜい私の足手まといにならないようになさい。"],
                            stripped_shrunk: ["小さくて、この格好…！これは、私の経歴の汚点ですわ…！", "…隠れますわよ。ええ、合理的な判断ですわ。"],
                            solo_stripped_tiny: ["（こんな屈辱…！ありえませんわ…！）", "（物陰でうずくまっている）…早くこの状況を打開する薬を開発しませんと…。", "（誰か来たら、新種のキノコのフリをしますわ…）"],
                            allyStripped_shrunk: ["あらあら、{name}さん。それは惨めな姿ですわね。私がすぐに服薬…いえ、服を作って差し上げますわ。", "敵の悪趣味な攻撃…サンプルとして解析する価値もありませんわね。"],
                            stripped_pair: ["{name}さんもですの？…ふふ、二人でいれば羞恥も和らぐ、というデータが取れそうですわね。", "こうなったら、どちらが堂々としていられるか、勝負ですわよ。"],
                            allyStripped: ["{name}さん、風邪をひきますわよ。私の白衣をお使いなさい。", "敵の非科学的な攻撃…私が根絶して差し上げますわ。"],
                            shrunk_pair: ["あら、{name}さんも小さいですのね。ふふ、二人でいれば敵も油断するでしょう。好都合ですわ。", "ミニミニ探検隊、ですわね。私の指揮に従いなさい。"],
                            pair_アカリ: ["アカリさん、その有り余る元気、どこから来るのか解析してみたいですわね。", "あなたの単純な思考回路、羨ましいですわ。"],
                            pair_ヒカリ: ["ヒカリさん、魔法と科学…どちらが優れているか、ここで証明しましょう。", "あなたの魔術、興味深い研究対象ですわ。"],
                            pair_シズカ: ["シズカさん、その頑丈さ、私の新薬の被験体として最適ですわ。", "ふふ、冗談ですわよ。"],
                            pair_ユイ: ["ユイさん、あなたの回復魔法、非科学的ですが…効果は認めましょう。", "もっと効率的な治療法を、私が編み出して差し上げますわ。"],
                            pair_ベアトリス: ["ベアトリスさん、あなたの錬金術、実に興味深いですわ。今度、共同研究などいかがですこと？", "そのフラスコの中身…少し味見させてもらっても？", "科学と錬金術、どちらが真理に近いか…ここで決着をつけましょう。"],
                            pair_リリカ: ["リリカさん、その舞、人々の精神にどう作用するのか…観察対象として実に興味深いですわ。", "あなたのその豊満な肉体…素晴らしい検体ですわ。"],
                            pair_サクヤ: ["サクヤさん、その精神集中…医学的にも解明したい現象ですわ。", "あなたの身体能力、データとして収集させてくださいな。"],
                            pair_シャオメイ: ["シャオメイさん、その単純な思考回路、羨ましいですわね。", "あなたのその食欲、代謝機能がどうなっているのか…解剖してみたいですわ。"],
                            pair_ルナ: ["ルナさん、運などという不確定要素に身を委ねるなんて、非合理的ですわ。", "ですが、そのスリルを求める心理、研究の価値はありますわね。"],
                            pair_クロエ: ["クロエさん、あなたのその低い体温、恒温動物として異常ですわ。実に興味深い。", "魂…？ふふ、非科学的ですわね。ですが、面白い。"],
                            pair_ミコ: ["ミコさん、その生物とのコミュニケーション、どうやっているのですの？", "そのモコという生物、解剖させていただけませんこと？"],
                            pair_レンカ: ["レンカさん、死体蘇生…生命倫理に反しますわ。ですが、その技術、喉から手が出るほど欲しいですわね。", "その魂、捕獲して研究してみたいですわ。"],
                            pair_イオリ: ["イオリさん、その縮小病、私の研究対象として完璧ですわ。", "安心なさい。私が必ず、あなたの病を解明して差し上げますわ。"],
                            pair_コハル: ["コハルさん、あなたの引き起こす現象、確率論を無視していますわ。最高の研究対象ですわ！", "さあ、もっと面白いことを起こしてごらんなさい！"],
                            pair_オリビア: ["オリビアさん、その祈り、プラシーボ効果以上のものを感じますわ。", "その聖なる力とやら、科学で再現してみせますわ。"],
                            pair_レンカ: ["レンカさん、死体蘇生…生命倫理に反しますわ。ですが、その技術、喉から手が出るほど欲しいですわね。", "その魂、捕獲して研究してみたいですわ。"],
                            pair_セレスティア: ["聖女…ふふ、神の代行者ですって？実に非科学的ですわ。ですが、その力、解析する価値はありますわね。", "あなたのその体、私の研究対象として完璧ですわ。隅々まで調べさせてくださいな。"],
                            pair_イオリ: ["イオリさん、その縮小病、私の研究対象として完璧ですわ。", "安心なさい。私が必ず、あなたの病を解明して差し上げますわ。"],
                            pair_コハル: ["コハルさん、あなたの引き起こす現象、確率論を無視していますわ。最高の研究対象ですわ！", "さあ、もっと面白いことを起こしてごらんなさい！"],
                            pair_オリビア: ["オリビアさん、その祈り、プラシーボ効果以上のものを感じますわ。", "その聖なる力とやら、科学で再現してみせますわ。"],
                        },
                        // ルナ (ギャンブラー): スリル好き、自信家、気まぐれ。
                        'ルナ': {
                            default: ["さーて、次の勝負は丁か半か？", "退屈させないでよね！スリルのある冒険にしましょう！", "人生はギャンブルよ。このダンジョンも、私のステージってわけ。", "アカリ、その勢い、嫌いじゃないわ。賭けてみる価値、あるかもね。", "ヒカリ、あなたって読めないわね。ポーカーフェイスってやつ？", "シズカ、その安定感はつまらないけど…まあ、保険としてはアリかしら。", "ユイ、あなたの回復は確実すぎてドキドキしないわね。", "ベアトリス、あなたの錬金術、成功率はどのくらい？興味あるわ。", "リリカ、あなたのステージ、私も混ぜてくれない？もっと盛り上げてあげるわよ。", "サクヤ、その真剣な顔…崩してみたいわね。", "シャオメイ、単純でわかりやすいわね。賭けの対象としては一番かも。", "エリザ、あなたの薬、副作用の確率も教えてくれる？それが大事なのよ。"],
                            lowHp: ["ふふ、ちょっとスリリングになってきたじゃない！", "ここで引いたらギャンブラーの名が廃るわ！", "チップが減ってきたけど…まだまだ勝負はこれからよ！"],
                            allyLowHp: ["あらら、{name}がピンチね。ここは大きく賭けるチャンスかしら？", "{name}、大丈夫？私の幸運、分けてあげるわ。"],
                            shrunk: ["ちっちゃくなっちゃった。ふふ、これならイカサマし放題ね！", "このサイズ、カードの裏に隠れられそう。", "視点が低いと、相手の足元が見えて面白いわね。"],
                            shrunk_100: ["あら、テーブルを見上げるなんて新鮮ね。"],
                            shrunk_70: ["ヒカリと同じくらいの目線ね。勝負しましょうか？"],
                            shrunk_50: ["世界の何もかもが大きいわ。面白い！"],
                            shrunk_30: ["コインの山に隠れられそうね。"],
                            shrunk_10: ["サイコロみたいになっちゃった。誰か、私を振ってみる？"],
                            shrunk_1: ["カードの絵柄より小さいかも。ふふっ。"],
                            stripped: ["きゃっ！…ふふ、面白いじゃない。この状況、逆手にとってやるわ。", "サービスタイムってとこかしら？観覧料は高いわよ？", "こんな格好で勝ったら、伝説になっちゃうかも！"],
                            allyShrunk: ["あら、{name}がミニチュアサイズに。可愛いじゃない。私のペットにしてあげようかしら。", "{name}、そこにいたの。チップと間違えて拾っちゃうところだったわ。"],
                            grown: ["大きくなったわ！これでハッタリも効くってものね！", "見下ろす気分、最高！みんな、私の前にひれ伏しなさい！"],
                            allyGrown: ["あら、{name}が大きくなったのね。頼もしいじゃない。賭けの対象としては悪くないわ。", "{name}、その巨体、ブラフには最適ね。"],
                            allyNew: ["私がルナよ。あなた、ツイてる？私と一緒に、最高のギャンブルをしましょう。", "新しい仲間ね。あなたに賭ける価値があるか、見極めさせてもらうわ。"],
                            stripped_shrunk: ["小さくて、この格好…！これは、さすがに計算外だわ…！", "…隠れるわよ。ええ、次のゲームのための戦略的撤退よ。"],
                            solo_stripped_tiny: ["（こんな屈辱…ありえないわ…！次の勝負で絶対に取り返してやる…！）", "（コインの影でうずくまっている）…ツイてない。流れが悪いわね…。", "（誰か来たら、新種のキノコのフリでもしてやろうかしら…）"],
                            allyStripped_shrunk: ["あらあら、{name}。それは無様ね。でも、そこからの大逆転劇、期待してるわよ。", "敵の趣味、最悪ね。美しくないわ。"],
                            stripped_pair: ["{name}も？ふふ、面白いじゃない。二人で『ノーペア』ってとこかしら。", "こうなったら、どっちが先に服を手に入れるか、勝負しましょうか。"],
                            allyStripped: ["{name}、大胆ね。でも、風邪ひいたら元も子もないわよ。私のストール、貸してあげる。", "敵のやり方、スマートじゃないわね。私がきっちりお灸を据えてあげる。"],
                            shrunk_pair: ["あら、{name}も小さいのね。二人でなら、どんなイカサマも見破られないかも。", "ミニミニギャンブラーズの結成ね。私の指示に従いなさい。"],
                            pair_アカリ: ["アカリ、その勢い、嫌いじゃないわ。賭けてみる価値、あるかもね。", "単純でわかりやすいわね。"],
                            pair_ヒカリ: ["ヒカリ、あなたって読めないわね。ポーカーフェイスってやつ？勝負しましょうか。", "その魔法、成功率は何パーセント？"],
                            pair_シズカ: ["シズカ、その安定感はつまらないけど…まあ、保険としてはアリかしら。", "あなたの鉄壁、私の運で突破できるかしら？"],
                            pair_ユイ: ["ユイ、あなたの回復は確実すぎてドキドキしないわね。", "たまには、失敗してみたらどう？スリリングでいいじゃない。"],
                            pair_ベアトリス: ["ベアトリス、あなたの錬金術、成功率はどのくらい？興味あるわ。", "その薬、どんな副作用があるのかしら？そこに賭けるのも面白そうね。"],
                            pair_リリカ: ["リリカ、あなたのステージ、賭けの対象としては最高ね。観客がどれだけ熱狂するか、賭けてみない？", "あなたのダンス、見てる人を惹きつけるわ。その才能、ギャンブルにも活かせるんじゃない？"],
                            pair_サクヤ: ["サクヤ、その真剣な顔…崩してみたいわね。", "あなたの斬撃、私が避けられるかに賭けてみない？"],
                            pair_シャオメイ: ["シャオメイ、単純でわかりやすいわね。賭けの対象としては一番かも。", "あなたと私、どっちが先に腹を空かせるか、賭ける？"],
                            pair_エリザ: ["エリザ、あなたの薬、副作用の確率も教えてくれる？それが大事なのよ。", "あなたの自信、いつまで続くかしら？ふふっ。"],
                            pair_クロエ: ["クロエ、あなたもミステリアスね。何を考えてるか、当ててみせようかしら。", "魂を狩る…？ふふ、面白そうじゃない。"],
                            pair_ミコ: ["ミコ、その召喚、成功する確率は？", "そのモコって子、私に懐くか懐かないか、賭けてみない？"],
                            pair_レンカ: ["レンカ、死者を操るなんて、ハイリスク・ハイリターンね。嫌いじゃないわ。", "その魔法、失敗したらどうなるの？面白そうじゃない。"],
                            pair_イオリ: ["イオリ先輩、ね。その守り、いつまで続くかしら？", "小さくても、賭けの対象としては面白いわ。"],
                            pair_コハル: ["コハル、あなたこそ最高のギャンブルね！次に何が起こるか、全く読めないわ！", "あなたに全部賭けてみるのも、面白そうね！"],
                            pair_オリビア: ["オリビア、祈りだけで勝てるなんて思ってないでしょうね？", "神様と私、どっちがツイてるか勝負しましょうか。"],
                            pair_レンカ: ["レンカ、死者を操るなんて、ハイリスク・ハイリターンね。嫌いじゃないわ。", "その魔法、失敗したらどうなるの？面白そうじゃない。"],
                            pair_セレスティア: ["聖女様、ね。あなたに賭けても、スリルはなさそうね。だって、絶対に勝つんでしょう？", "あなたのその力、イカサマじゃないんでしょうね？"],
                            pair_イオリ: ["イオリ先輩、ね。その守り、いつまで続くかしら？", "小さくても、賭けの対象としては面白いわ。"],
                            pair_コハル: ["コハル、あなたこそ最高のギャンブルね！次に何が起こるか、全く読めないわ！", "あなたに全部賭けてみるのも、面白そうね！"],
                            pair_オリビア: ["オリビア、祈りだけで勝てるなんて思ってないでしょうね？", "神様と私、どっちがツイてるか勝負しましょうか。"],
                        },
                        // クロエ (リーパー): 寡黙、ミステリアス、達観している。
                        'クロエ': {
                            default: ["…静か。…魂の、囁きが聞こえる。", "…ここは、終わりが近い場所の匂いがする。", "…みんな、死なないでね。…まだ、その時じゃないから。", "アカリ…その光、眩しい。", "ヒカリ…魔法は、魂の形を変える力。", "シズカ…その盾は、多くの魂を守ってきたのね。", "ユイ…あなたの祈り、届いてるよ。", "ベアトリス…真理の探求、その先に何を見るの？", "リリカ…あなたの歌、魂を揺さぶる。", "サクヤ…あなたの剣、魂を断つ覚悟が見える。", "シャオメイ…その拳、純粋な魂の輝き。", "エリザ…命の探求、面白い。", "ルナ…運命の糸、見えるの？"],
                            lowHp: ["…少し、境界が近くなった。", "…まだ、逝けない。", "…この痛み、生きている証。"],
                            allyLowHp: ["…{name}、危ない。…こっちに来て。", "{name}の魂の灯が、揺れてる。"],
                            shrunk: ["…小さくなった。…影に、もっと近づける。", "…地面が近い。…死んだ魂の声が、よく聞こえる。", "…この姿なら、誰にも気づかれずに、魂を狩れる。"],
                            shrunk_100: ["…ユイさんと同じくらい…。", "…ローブが、もっとぶかぶか。"],
                            shrunk_70: ["…世界の境界が、曖昧になる。"],
                            shrunk_50: ["…半分。…存在が、希薄になる感じ。", "…影と、一体になれそう。"],
                            shrunk_30: ["…草の葉が、鎌みたいに見える。"],
                            shrunk_10: ["…蝶々みたい。…魂を運ぶ、蝶々。"],
                            shrunk_1: ["…もう、いないのと同じ。…でも、いる。"],
                            stripped: ["…これは、だめ。", "…魂が、裸にされたみたいで、寒い。", "…フードで、隠す。"],
                            allyShrunk: ["…{name}、小さくなったね。…可愛い。", "{name}、そこにいたの。…気づかなかった。"],
                            grown: ["…大きくなった。…天に、手が届きそう。", "…見下ろすのは、慣れない。"],
                            allyGrown: ["…{name}、大きい。…守護者みたい。", "{name}、その力、魂を傷つけないでね。"],
                            allyNew: ["…クロエ。…あなたの魂、見せて。", "…よろしく。…あなたの最期、私が見届けてあげる。"],
                            stripped_shrunk: ["…小さくて、服もない。…これは、一番、死に近い。", "…隠れる。…誰にも、見つからないように。"],
                            solo_stripped_tiny: ["（…もう、消えてしまいたい…）", "（…影の中で、じっとしている）", "（…誰か来たら、石になる…）"],
                            allyStripped_shrunk: ["…{name}、かわいそう。…私のローブ、貸してあげる。", "…ひどいこと、するね。…あの敵の魂、私がもらう。"],
                            stripped_pair: ["…{name}も。…二人とも、魂が丸見え。", "…こうしてると、少しだけ、温かいかも。"],
                            allyStripped: ["…{name}、風邪ひくよ。…これ、使って。", "…許さない。"],
                            shrunk_pair: ["…{name}も、小さいね。…二人で、影になろう。", "…二人なら、見つからない。"],
                            pair_アカリ: ["アカリ…その光、眩しい。…魂が、燃えてるみたい。", "…元気、だね。"],
                            pair_ヒカリ: ["…ヒカリ。…あなたの魔法、静かで好き。", "…魔道と、魂の道。…似てる。"],
                            pair_シズカ: ["シズカ…その盾は、多くの魂を守ってきたのね。", "…あなたの後ろ、温かい。"],
                            pair_ユイ: ["ユイ…あなたの祈り、届いてるよ。…優しい魂。", "…ありがとう。"],
                            pair_ベアトリス: ["ベアトリス…真理の探求、その先に何を見るの？", "…あなたの魂、知りたがり。"],
                            pair_リリカ: ["リリカ…あなたの歌、魂を揺さぶる。", "…賑やか。"],
                            pair_サクヤ: ["サクヤ…あなたの剣、魂を断つ覚悟が見える。", "…私と、同じ匂い。"],
                            pair_シャオメイ: ["シャオメイ…その拳、純粋な魂の輝き。", "…お腹、すいたの？"],
                            pair_エリザ: ["エリザ…命の探求、面白い。…でも、やりすぎはだめ。", "…あなたの魂、傲慢。"],
                            pair_ルナ: ["ルナ…運命の糸、見えるの？…私には、魂の終わりが見える。", "…あなたの魂、いつも揺れてる。"],
                            pair_ミコ: ["ミコ…その子たち、魂があるの？…話してみたい。", "…優しい魂。"],
                            pair_レンカ: ["レンカ…死者の魂を弄ぶのは、よくない。", "…でも、あなたの魂は、寂しそう。"],
                            pair_イオリ: ["イオリ…先輩。…その魂、古い。…でも、強い。", "…守る、ね。…わかる。"],
                            pair_コハル: ["コハル…あなたの周り、魂が騒がしい。", "…何が起こるか、わからない。…面白い。"],
                            pair_オリビア: ["オリビア…あなたの魂、光ってる。…綺麗。", "…その祈り、死者の魂も、癒されるかも。"],
                            pair_レンカ: ["レンカ…死者の魂を弄ぶのは、よくない。", "…でも、あなたの魂は、寂しそう。"],
                            pair_セレスティア: ["…あなたの魂、光そのもの。…眩しい。", "…たくさんの魂が、あなたに救いを求めてる。…聞こえる。"],
                            pair_イオリ: ["イオリ…先輩。…その魂、古い。…でも、強い。", "…守る、ね。…わかる。"],
                            pair_コハル: ["コハル…あなたの周り、魂が騒がしい。", "…何が起こるか、わからない。…面白い。"],
                            pair_オリビア: ["オリビア…あなたの魂、光ってる。…綺麗。", "…その祈り、死者の魂も、癒されるかも。"],
                        },
                        // ミコ (サモナー): 人懐っこい、天然、モンスター好き。
                        'ミコ': {
                            default: ["モコ、元気？…うん、ミコも元気だよ！", "このダンジョン、面白いモンスターいるかな？お友達になりたいな！", "みんな、疲れてない？モコが応援してるって！", "アカリちゃん、すごいね！モコもああなりたいって！", "ヒカリちゃん、その本、難しいの？モコが読んであげようか？", "シズカさん、かっこいい！ゴーレムくんもああなりたいって！", "ユイちゃん、いつもありがとう！モコも喜んでるよ！", "ベアトリスさん、その薬、モンスターは飲める？", "リリカちゃん、可愛い！モコと一緒に踊ってほしいな！", "サクヤさん、その刀、キラキラだね！モコが舐めてもいい？", "シャオメイちゃん、お腹すいたの？モコのおやつ、半分あげる！", "エリザさん、モコを調べてもいいよ！でも、痛くしないでね？", "ルナさん、ギャンブルってなあに？モコとできる？", "クロエちゃん、静かだね。モコとお話しよ？"],
                            lowHp: ["うぅ…ちょっと痛いかも…。モコ、大丈夫だよ！", "まだ平気！みんなを守らないと！", "モコ、ミコのこと心配してくれてるの？ありがとう。"],
                            allyLowHp: ["{name}ちゃん、大丈夫！？ゴーレムくん、{name}ちゃんを守って！", "モコがね、{name}ちゃんのこと心配してるよ。"],
                            shrunk: ["わ、ちっちゃくなっちゃった！モコと同じ目線だ！", "これなら、モンスターの子供と間違えられちゃうかも！", "モコ、ミコの頭の上に乗れるよ！"],
                            shrunk_100: ["ユイちゃんと同じくらいかな？えへへ。"],
                            shrunk_70: ["モコよりちょっと大きいかな？"],
                            shrunk_50: ["モコと一緒にお散歩してるみたい！"],
                            shrunk_30: ["草むらがジャングルみたい！探検だー！"],
                            shrunk_10: ["モコ、ミコのこと見失わないでね！"],
                            shrunk_1: ["モコのお鼻の先っぽくらいになっちゃった！"],
                            stripped: ["ひゃっ！？だ、だめだよぉ…！モコ、見ないで！", "こ、こんな格好、召喚の儀式に集中できないよ…！", "ゴーレムくん、ミコのこと隠して！"],
                            allyShrunk: ["わー、{name}ちゃん、ちっちゃくて可愛い！モコのお友達みたい！", "{name}ちゃん、そこにいたの！気づかなかった！"],
                            grown: ["おっきくなった！これなら大きいモンスターともお話しできるかも！", "ゴーレムくんと同じくらい大きいかな？"],
                            allyGrown: ["わー、{name}ちゃん、おっきい！ゴーレムくんみたい！", "{name}ちゃん、天井、気をつけてね！"],
                            allyNew: ["はじめまして！ミコだよ！こっちは相棒のモコ！{name}ちゃん、よろしくね！", "新しいお友達だ！{name}ちゃん、モンスター好き？"],
                            stripped_shrunk: ["ちっちゃくて、服もないなんて…！モコ、ミコのこと隠してー！", "これじゃあ、ただの迷子の子だよぉ…！"],
                            solo_stripped_tiny: ["（しくしく…）モコ、どうしよう…。", "（葉っぱの裏に隠れて、モコを抱きしめている）", "もう、おうちに帰りたいよぉ…"],
                            allyStripped_shrunk: ["{name}ちゃん、大丈夫！？モコが温めてあげるって！", "ひどいことする敵さんだね！ゴーレ-ムくん、やっつけて！"],
                            stripped_pair: ["{name}ちゃんもなの！？二人でいれば、恥ずかしくない…かな？ううん、恥ずかしい！", "モコ、どっちも見ちゃだめだよ！"],
                            allyStripped: ["{name}ちゃん、風邪ひいちゃう！ミコのマント、使って！", "敵さん、意地悪だね！サラマンダーくん、お仕置きして！"],
                            shrunk_pair: ["{name}ちゃんも小さいんだね！二人でモコに乗って探検しようよ！", "ちびっこ探検隊だね！"],
                            pair_ユイ: ["ユイちゃん、いつもありがとう！モコもね、ユイちゃんのこと大好きなんだって！", "ユイちゃんのお菓子、美味しいね！モコにも少しちょうだい！"],
                            pair_レンカ: ["レンカさん、死んじゃったモンスターともお話しできるの？すごい！", "モコがね、レンカさんのこと、ちょっと怖いけど気になるって！"],
                            pair_イオリ: ["イオリ先輩、ちっちゃくてもかっこいいね！ゴーレムくんもそう言ってる！", "先輩！ミコとモコが守るからね！"],
                            pair_コハル: ["コハルちゃん、次はなにするの？モコがわくわくしてるよ！", "失敗しても、モコがなぐさめてくれるから大丈夫だよ！"],
                            pair_セレスティア: ["わー！セレスティアさん、キラキラしてる！モコがね、すりすりしたいって！", "セレスティアさん、モンスターとお話しできる？"],
                            pair_オリビア: ["オリビアさん、優しい匂いがするね！モコがすりすりしたがってる！", "その祈り、モンスターにも効くのかな？"],
                        },
                        // レンカ (ネクロマンサー): ミステリアス、お姉さん、死者と対話。
                        'レンカ': {
                            default: ["ふふ、魂たちが囁いているわ…この先に強い気配があるって。", "あら、元気な魂ね。死んだら私のコレクションにしてあげる。", "静かね…死者の安らぎを邪魔する者は誰かしら？", "このダンジョン、魂の吹き溜まりになっているみたい。居心地がいいわ。", "アカリちゃん、その生命力…眩しいわね。", "ヒカリちゃん、魔術と死霊術、根は同じかもね。", "シズカさん、その盾、何体の魂を守ってきたのかしら。", "ユイちゃん、あなたの癒しは生者だけのもの？", "あら、新しい魂の気配…よろしくね、迷える子羊さん。"],
                            lowHp: ["…少し、死が近くなったかしら。悪くないわ。", "ふふ、この痛み…生きているって実感するわね。", "大丈夫よ。魂の一つや二つ、くれてやるもの。"],
                            allyLowHp: ["{name}、無理はよしなさい。死んだら私が蘇らせてあげるから。", "あらあら、{name}の魂の灯が弱まっているわ。"],
                            shrunk: ["小さくなるなんて…ふふ、面白いわね。魂の重さは変わらないのに。", "このサイズなら、魂たちの囁きがもっと近くで聞こえるかしら。", "あら、服がぶかぶか。まるで幽霊みたいね。"],
                            shrunk_100: ["子供の頃に戻ったみたい。…もっとも、私の子供時代はこんなに明るくなかったけれど。"],
                            shrunk_70: ["ユイちゃんと同じくらいの目線ね。可愛いわ。"],
                            shrunk_50: ["世界のすべてが大きく見える。魂の視点って、こんな感じなのかしら。"],
                            shrunk_30: ["墓石の影に隠れるには、ちょうどいいサイズね。"],
                            shrunk_10: ["ふふ、まるで魂そのものになった気分だわ。"],
                            shrunk_1: ["…もう、誰の目にも映らない。死者と同じね。"],
                            stripped: ["あら…大胆なことしてくれるじゃない。魂まで裸にされた気分よ。", "…見てるんでしょう？いいわ、存分に見なさい。ただし、代償は高くつくわよ。", "ふふ、この格好で死霊術を唱えるのも、一興かしら。"],
                            allyShrunk: ["あら、{name}が小さくなっているわ。可愛いわね、小動物みたい。", "{name}、そこにいたの。魂の気配で気づいたわ。"],
                            grown: ["大きくなったわね。これなら、より多くの魂を従えられそう。", "見下ろす景色も、悪くないわ。"],
                            allyGrown: ["まあ、{name}が大きくなってる。頼もしいわね。", "{name}、その体、魂を宿すにはちょうどいい器かも。"],
                            allyNew: ["新しい魂…{name}、よろしくね。あなたの最期、私が見届けてあげる。", "ふふ、可愛い子。仲良くしましょうね。"],
                            stripped_shrunk: ["小さくて、服もないなんて…これは、さすがに想定外ね。", "…隠れましょうか。死者のように、気配を消して。"],
                            solo_stripped_tiny: ["（…これは、屈辱ね。あの敵の魂、必ず私のものにする…）", "（物陰で膝を抱えている）…寒い。死者の温もりが恋しいわ。", "（誰か来たら、ただの石ころのフリでもしましょうか…）"],
                            allyStripped_shrunk: ["あらあら、{name}。なんて無防備な姿。私が守ってあげないと。", "敵の趣味、感心しないわね。後で魂を問い詰めておきましょう。"],
                            stripped_pair: ["{name}も？ふふ、奇遇ね。二人でいれば、羞恥心も薄れるかしら。", "こうなったら、どちらがより妖艶でいられるか、勝負しましょうか。"],
                            allyStripped: ["{name}、風邪をひくわよ。私のローブ、使いなさい。", "下等な真似をする敵ね。魂ごと消してあげる。"],
                            shrunk_pair: ["あら、{name}も小さいのね。二人でいれば、まるで妖精のようね。…死を運ぶ妖精かしら。", "手、繋いでおきましょうか。迷子になったら大変だもの。"],
                            pair_アカリ: ["アカリちゃん、その元気な魂、素敵よ。でも、燃え尽きないようにね。", "あなたの光、少し眩しすぎるわ。"],
                            pair_ヒカリ: ["ヒカリちゃん、あなたの魔法、静かで好きよ。死者の安らぎを乱さないもの。", "魔道と死霊術、一緒に研究してみない？"],
                            pair_シズカ: ["シズカさん、あなたがいると安心するわ。死者たちも、そう言っている。", "その盾、いつか私の魂も守ってくれるかしら。"],
                            pair_ユイ: ["ユイちゃん、あなたの癒し、死者の魂にも届くのかしら？試してみたいわ。", "いつもありがとう。あなたのおかげで、まだ『こちら側』にいられるわ。"],
                            pair_ベアトリス: ["ベアトリスさん、あなたの探究心、嫌いじゃないわ。生命の神秘、一緒に解き明かしましょうか。", "その薬、死者には効くのかしら？"],
                            pair_リリカ: ["リリカちゃん、あなたの歌、魂を揺さぶるわね。死者たちも踊りだすかもしれない。", "賑やかでいいわ。墓場は静かすぎて飽きてしまうもの。"],
                            pair_サクヤ: ["サクヤさん、あなたの剣、死の匂いがするわ。私と同じね。", "その静けさ、心地いいわ。"],
                            pair_シャオメイ: ["シャオメイちゃん、その純粋な魂、美味しそうね。…冗談よ。", "あなたの拳、魂ごと砕いてしまいそうね。"],
                            pair_エリザ: ["エリザさん、生命を弄ぶのはお互い様かしら。ふふ、気が合いそうね。", "あなたの薬で、私のアンデッドたちを強化できないかしら？"],
                            pair_ルナ: ["ルナさん、運命も死も、抗えないものよ。", "あなたのギャンブル、魂を賭けてみるのも面白そうね。"],
                            pair_クロエ: ["クロエちゃん、あなたも『あちら側』が見えるのね。…話が合いそうだわ。", "その鎌、私のコレクションにしたいくらい素敵よ。"],
                            pair_ミコ: ["ミコちゃん、その子たち、純粋な魂を持っているのね。可愛いわ。", "死んだモンスターの魂も、召喚できるかしら？"],
                            pair_セレスティア: ["聖女様…あなたの光は、死者にとっては少し眩しすぎるかしら。", "ふふ、あなたがいれば、私の仕事がなくなってしまいそうね。"],
                        },
                        // イオリ (ガーディアン): 先輩、小柄、守護者。
                        'イオリ': {
                            default: ["みんな、ボクの後ろにいて。絶対に守るから。", "先輩に任せなさい！…って、え、ボクが先輩だよ？", "この体でも、守れるものはたくさんあるんだ。", "ふぅ…少し休憩。みんな、大丈夫？", "アカリ、危なっかしいな…。ボクから離れないでよ。", "ヒカリ、援護ありがとう。助かる。", "シズカ、君の盾も頼りにしてる。二人で鉄壁の守りだね。", "ユイ、いつもありがとう。君がいるから、ボクも頑張れる。", "コハル、君はボクが特に気をつけて見てないと…！"],
                            lowHp: ["くっ…！まだだ、まだ倒れるわけにはいかない…！", "このくらい、なんともない…！みんなは、ボクが守る…！", "やるじゃないか…。でも、先輩は伊達じゃないんだ！"],
                            allyLowHp: ["{name}、大丈夫か！？すぐにボクの後ろへ！", "よくも仲間を！許さない！", "{name}から離れろ！"],
                            shrunk: ["う…また縮んだ…。でも、守るっていう気持ちは、縮まない！", "小さくても、ボクはガーディアンだ！", "盾がもっと大きく見えるな…。これなら隠れやすいかも。"],
                            shrunk_100: ["…いつもとあまり変わらない、かな。", "これ以上は、あまり縮みたくないんだけど…。"],
                            shrunk_70: ["ユイちゃんより小さくなっちゃったかも…。先輩の威厳が…。"],
                            shrunk_50: ["半分か…。さすがに、守れる範囲が心配になってきたな。"],
                            shrunk_30: ["もう、みんなの足元だ…。見失わないでくれよな！"],
                            shrunk_10: ["…誰かのポケットに入れてほしい。その方が守りやすいかも。", "盾の裏に住めそうだ…。"],
                            shrunk_1: ["…盾の取っ手になった気分だよ。"],
                            stripped: ["なっ…！？こ、こんな格好で、先輩の威厳が…！", "だ、だめだ！見るな！…って言っても、無理か…！", "くっ…！恥ずかしくなんかない！ボクは、守るんだ！"],
                            allyShrunk: ["{name}、小さくなったな。ボクの後ろにいれば安全だよ。", "可愛いサイズになったな。でも、油断は禁物だ。"],
                            grown: ["お、大きくなった！これなら、もっとみんなを守れる！", "すごい、見晴らしがいい！これなら敵の動きもよく見える！", "これが…ボクが本来なるはずだった姿なのかな…。"],
                            allyGrown: ["うわ、{name}が大きい！頼もしいな！", "{name}、天井に頭をぶつけないように気をつけろよ！"],
                            allyNew: ["新入りかい？ボクが先輩のイオリだ。よろしくな。ボクがしっかり守ってやる。", "ようこそ、{name}。歓迎するよ。"],
                            stripped_shrunk: ["うわぁ…！小さくて、この格好は…！もうダメだ…！", "…隠れる。ボクにはもう、みんなを守る資格なんて…ないかもしれない…。"],
                            solo_stripped_tiny: ["（…もう、だめだ…先輩失格だ…）", "（岩陰で蹲り、盾で体を隠している）", "（ごめん、みんな…）"],
                            allyStripped_shrunk: ["{name}！大丈夫か！？ボク、ボクの盾で隠してやるから！", "なんてひどいことを…！ボクが絶対に守るからな！"],
                            stripped_pair: ["{name}もか！？…こ、こうなったら、二人で壁を作るぞ！", "み、見るなよ！お互い様だけど！"],
                            allyStripped: ["{name}、大丈夫か！？ボクの…いや、これを！", "敵のやつ、くだらない真似を…！ボクが叩き潰してやる！"],
                            shrunk_pair: ["{name}も小さいのか。よし、二人で『ちびっこガーディアンズ』だ！", "二人でいれば、どんな敵だって怖くない！"],
                            pair_アカリ: ["アカリ、危なっかしいな！ボクから離れるなよ！", "その元気、少し分けてほしいな。"],
                            pair_ヒカリ: ["ヒカリ、君の魔法は正確だな。後衛は任せた。", "静かだけど、頼りにしてるよ。"],
                            pair_シズカ: ["シズカ、君とボクで、パーティの守りは完璧だね。", "その盾、すごいな。ボクのウォールとどっちが硬いかな？"],
                            pair_ユイ: ["ユイ、いつもありがとう。君がいるから、ボクも安心して前に出られる。", "無理するなよ。君もボクが守るから。"],
                            pair_ベアトリス: ["ベアトリスさん、ボクの体のこと、あまりジロジロ見ないでくれるかな…。", "その薬、身長が伸びる薬はないのかい？"],
                            pair_リリカ: ["リリカ、君はいつも明るいな。見てると元気になるよ。", "ステージはボクが守るから、思いっきりやっていいぞ。"],
                            pair_サクヤ: ["サクヤ、君の剣はすごいな。でも、無茶はするなよ。", "たまには、ボクにも頼ってくれよな。"],
                            pair_シャオメイ: ["シャオメイ、君の拳は見てて安心するよ。でも、前に出過ぎだ！", "腹が減ったのか？終わったら何かおごってやるよ、先輩としてな！"],
                            pair_エリザ: ["エリザさん、ボクは実験体じゃないぞ！", "…でも、もしこの体を治せるなら…。いや、なんでもない。"],
                            pair_ルナ: ["ルナ、ギャンブルはほどほどにな。見ててハラハラする。", "君の運も、ボクが守って見せるさ。"],
                            pair_クロエ: ["クロエ、大丈夫か？暗い顔するなよ。ボクがそばにいる。", "その鎌、危ないから気をつけて使えよ。"],
                            pair_ミコ: ["ミコ、その召喚獣たち、可愛いな。ボクが守ってやる。", "モコってやつ、ふわふわだな。"],
                            pair_セレスティア: ["セレスティアさん、あなたも一人で戦ってきたんだね。…ボクが守るから、もう一人じゃない。", "その力、すごいな。でも、無理はしないでくれよ。"],
                        },
                        // コハル (トラブルメーカー): 元気、おっちょこちょい、予測不能。
                        'コハル': {
                            default: ["えーっと、次はどっちに行こうかな？こっちからいい匂いがする！", "わわっ！ごめんなさい、今のはわざとじゃ…！", "なんだか、面白いことになりそうな予感がする！", "皆さん、準備はいいですかー？コハル、行っきまーす！", "アカリさん、元気ですね！コハルも負けませんよ！", "ヒカリさん、大丈夫ですか？疲れてませんか？", "シズカさん、かっこいいです！コハルも守ってください！", "ユイさん、いつもすみません！すぐケガしちゃって…。", "イオリ先輩！コハル、ちゃんとついて行きますからね！"],
                            lowHp: ["いたっ！今の、ちょっと…ううん、かなり痛かったです！", "ふぇぇ…ごめんなさい、またドジっちゃいました…。", "だ、大丈夫です！これくらい、へっちゃら…じゃないかも…！"],
                            allyLowHp: ["{name}さん、大丈夫ですか！？コハルがなんとかします！えーっと、どうしよう！？", "きゃー！{name}さんが！こうなったら、私のとっておきを…！"],
                            shrunk: ["わーい！ちっちゃくなっちゃいました！なんだか、世界が遊園地みたいです！", "このサイズなら、面白い発見があるかもしれません！", "服がぶかぶかですー！あ、転んじゃった！"],
                            shrunk_100: ["ユイさんと同じくらいになっちゃいました！お友達みたいで嬉しいです！", "わーい！なんだか子供に戻ったみたいです！"],
                            shrunk_70: ["なんだか、いつもよりたくさん走らないと追いつけないです！えっちらおっちら！"],
                            shrunk_50: ["半分になっちゃいました！でも、元気は半分じゃないですよ！"],
                            shrunk_30: ["きのこの下で雨宿りできちゃいそうです！"],
                            shrunk_10: ["わー！もう、誰かのポケットに入って冒険したいです！"],
                            shrunk_1: ["もう、アリさんとお話しできちゃいそうです！こんにちはー！"],
                            stripped: ["ひゃっ！？な、なんですかこれー！？コハル、何も悪いことしてませんよ！", "だ、だめです！こんな格好、恥ずかしくて転んじゃいます！", "うぅ…でも、なんだか動きやすい…かも？"],
                            allyShrunk: ["{name}さん、ちっちゃくて可愛いです！お人形さんみたい！", "{name}さん、そこにいたんですね！気づかなくて踏んじゃうところでした！"],
                            grown: ["わー！大きくなりました！これなら、どんな罠も飛び越えられちゃいます！", "見晴らしがいいです！あ、あそこに何か光ってますよ！"],
                            allyGrown: ["わー、{name}さん、おっきいです！巨人の国に来たみたい！", "{name}さん、天井に頭をぶつけないように気をつけてくださいね！"],
                            allyNew: ["はじめまして！コハルです！これから、よろしくお願いします！えへへ。", "新しいお仲間ですね！一緒に面白いこと、たくさん見つけましょうね！"],
                            stripped_shrunk: ["ひゃー！ちっちゃい上にこの格好は、さすがに…！もう、どうしたらいいんですかー！", "隠れる場所を探さないと！あ、でも小さいから隠れやすいかも？"],
                            solo_stripped_tiny: ["（うぅ…こんな姿、誰にも見られたくないです…）", "（葉っぱの裏で丸まってます…）", "（お母さーん…）"],
                            allyStripped_shrunk: ["{name}さん、大変です！コハルがなんとかしますから！えーっと…！", "なんてひどいことを！コハル、怒りました！"],
                            stripped_pair: ["え、{name}さんも！？こ、こうなったら、どっちが先に服を見つけるか競争です！", "二人ともこの格好だと、なんだかちょっと面白いですね！えへへ。"],
                            allyStripped: ["{name}さん、大丈夫ですか！？コハルのハンカチ、使ってください！", "敵さん、ひどいです！コハルが懲らしめてあげます！"],
                            shrunk_pair: ["{name}さんも小さいんですね！ちびっこ探検隊、結成です！", "二人でいれば、どんなハプニングも乗り越えられますよ！"],
                            pair_アカリ: ["アカリさん、元気ですね！コハルも負けませんよ！", "その剣、かっこいいです！コハルも持ってみたい！"],
                            pair_ヒカリ: ["ヒカリさん、なんだか静かですね。コハルがお話し相手になりますよ！", "その本、面白そうですね！今度見せてください！"],
                            pair_シズカ: ["シズカさん、かっこいいです！コハルも守ってください！", "シズカさんがいると、なんだか安心します！"],
                            pair_ユイ: ["ユイさん、いつもすみません！すぐケガしちゃって…。", "ユイさんのお菓子、大好きです！"],
                            pair_ベアトリス: ["ベアトリスさん、その薬、飲むとどうなるんですか？シャボン玉が出たりしますか？", "難しいお話はよくわかりませんけど、すごいです！"],
                            pair_リリカ: ["リリカさん、キラキラしてて可愛いです！コハルも一緒に踊りたい！", "その歌、コハルも覚えたいです！"],
                            pair_サクヤ: ["サクヤさん、真剣な顔ですね！にらめっこしませんか？", "その刀、すごいですね！紙とか切れますか？"],
                            pair_シャオメイ: ["シャオメイさん、勝負です！どっちが先にあそこの宝箱まで行けるか！", "お腹すきましたねー！"],
                            pair_エリザ: ["エリザさん、その注射器、ちょっと怖いです…。でも、お医者さんなんですよね！", "コハル、実験体になりますよ！何が起こるか楽しみです！"],
                            pair_ルナ: ["ルナさん、ギャンブルってなんですか？楽しいことですか？", "コハルに賭けてみてください！きっと面白いことが起こりますよ！"],
                            pair_クロエ: ["クロエちゃん、静かですね。お化けとか、見えたりしますか？", "その鎌、草刈りとかできそうですね！"],
                            pair_ミコ: ["ミコちゃん、モコちゃん、ふわふわで可愛いです！触ってもいいですか？", "コハルもモンスターとお友達になりたいです！"],
                            pair_セレスティア: ["わー！セレスティアさん、キラキラしてて綺麗です！お友達になってください！", "その服、どうなってるんですか？すごい！"],
                        },
                        // オリビア (シスター): 慈愛、信仰、癒し。
                        'オリビア': {
                            default: ["神のご加護があらんことを…。", "皆様、お怪我はありませんか？いつでもお声がけくださいね。", "このダンジョンにも、救いを求める魂がいるのでしょうか…。", "アカリさん、その活力は神からの贈り物ですね。", "ヒカリさん、その探究心、素晴らしいです。ですが、道を踏み外さぬよう…。", "シズカさん、その盾はまさに守護の象徴ですね。", "ユイさん、あなたの優しさ、とても尊いです。", "皆様、どうかご無事で…。", "主よ、我らをお導きください…。", "少し、休憩いたしましょうか。お祈りの時間です。"],
                            lowHp: ["…っ、主よ、私にまだ試練をお与えになるのですか…。", "大丈夫です。この身、まだ皆様のために尽くせます。", "少し、祈りが乱れてしまいました…。", "この痛みも、主の思し召し…。"],
                            allyLowHp: ["{name}さん、お下がりください！すぐに癒しの祈りを！", "主よ、どうか{name}さんをお守りください…！", "なんてことを…！神は全てを見ておられますよ！"],
                            shrunk: ["まあ…体が小さくなってしまいました。ですが、祈りの力は変わりません。", "この姿も、主がお与えになった試練なのでしょう。", "服が…歩きづらいですね。裾を踏んでしまいそうです。"],
                            shrunk_100: ["子供の頃に戻ったようです。懐かしいですね。"],
                            shrunk_70: ["ユイさんと同じくらいの背丈でしょうか。ふふ、可愛らしいですね。"],
                            shrunk_50: ["祭壇のお花と同じくらいの高さになってしまいました。"],
                            shrunk_30: ["聖書の一文字よりも小さいかもしれません…。", "これでは、迷子のようですね。"],
                            shrunk_10: ["まるで、祈りの言葉に乗って飛んでいけそうです。"],
                            shrunk_1: ["…主の御許に、より近づいたということでしょうか。"],
                            stripped: ["きゃっ…！か、神よ…！これは、あまりにも…！", "こ、このような姿、人様には見せられません…！", "…ですが、羞恥に負けてはなりません。これも試練なのですから。"],
                            allyShrunk: ["まあ、{name}さん。可愛らしいお姿に…。", "{name}さん、迷子にならぬよう、私の側にいてくださいね。"],
                            grown: ["体が大きくなりました。より多くの人を、この腕で抱きしめられるということでしょうか。", "天井が近いですね。頭をぶつけないようにしませんと。"],
                            allyGrown: ["まあ、{name}さん。とても大きくなられて。頼もしい限りです。", "{name}さん、そのお姿、まるで教会の守護像のようですね。"],
                            allyNew: ["新しく来られた方ですね。私はオリビアと申します。{name}さん、よろしくお願いします。", "ようこそ。あなたとの出会いに、神の祝福があらんことを。"],
                            stripped_shrunk: ["こ、こんなに小さくて、このような格好だなんて…！主よ、お許しください…！", "…物陰に隠れて、祈りを捧げましょう。心が落ち着くまで…。"],
                            solo_stripped_tiny: ["（主よ…なぜ私にこのような試練を…）", "（祭壇の影で、膝を抱えて祈っている）", "（早く、この恥ずかしさから救ってください…）"],
                            allyStripped_shrunk: ["まあ、{name}さん！なんておいたわしい姿に…！私がすぐに祈りを捧げます！", "敵の所業、神がお許しにはならないでしょう。"],
                            stripped_pair: ["{name}さんもですか！？…こ、こうなったら、二人で祈りを捧げましょう。羞恥を乗り越える力を…！", "お互い、見ないように…ですね。"],
                            allyStripped: ["{name}さん、おいたわしい…。私のベールでよければ、お使いください。", "神の名において、不埒な敵を罰します！"],
                            shrunk_pair: ["あら、{name}さんも小さいのですね。二人でいれば、まるで天使のよう…かもしれませんね。", "手を取り合って進みましょう。そうすれば、怖くありませんから。"],
                            pair_アカリ: ["アカリさん、その元気な姿、見ているこちらも力が湧いてきます。", "あまり無茶はなさらないでくださいね。お怪我が心配です。"],
                            pair_ヒカリ: ["ヒカリさん、静かな方ですね。祈りに集中できて、私は好きですよ。", "その魔術、人々のために使えば、きっと神もお喜びになるでしょう。"],
                            pair_シズカ: ["シズカさん、いつも皆様を守ってくださり、ありがとうございます。", "あなたの盾は、信仰そのもののように見えます。"],
                            pair_ユイ: ["ユイさん、あなたの献身的な姿、本当に素晴らしいです。", "あなたと一緒なら、どんな方の心も癒せそうですね。"],
                            pair_ベアトリス: ["ベアトリスさん、科学も、元を辿れば神の創造物を解き明かす行い。尊いことだと思います。", "その薬、人々の助けとなるのですね。"],
                            pair_リリカ: ["リリカさん、あなたの歌と踊りは、人々の心を明るく照らす光のようですね。", "その笑顔、神からの贈り物なのでしょう。"],
                            pair_サクヤ: ["サクヤさん、その剣の道、とても険しいものなのでしょう。あなたの魂が安らぐよう、お祈りしています。", "その静けさ、祈りの時間と似ていますね。"],
                            pair_シャオメイ: ["シャオメイさん、いつも元気で、素晴らしいですね。たくさん食べられるのは、健康な証拠です。", "その拳で、弱き人々を守ってくださいね。"],
                            pair_エリザ: ["エリザさん、医学もまた、神の御業に近づくための道の一つなのでしょう。", "ですが、命を弄ぶようなことは、決してお許しになりませんよ。"],
                            pair_ルナ: ["ルナさん、運命は神がお与えになるもの。賭け事はいけませんよ。", "ですが、あなたのその強い心、きっと正しい道へと導かれるはずです。"],
                            pair_クロエ: ["クロエさん…あなたの瞳には、何か特別なものが見えているのですね。", "あなたの魂に、安らぎが訪れますように。"],
                            pair_ミコ: ["ミコさん、言葉の通じぬ者と心を通わせる…素晴らしい力ですね。", "神は、全ての生き物を愛しておられますから。"],
                            pair_セレスティア: ["セレスティア様…あなたこそ、まさに神の御使いなのですね。", "私も、あなたのように、多くの人を救えるようになりたいです。"],
                        },
                        // セレスティア (聖女): 無口、聖なる力、使命感。
                        'セレスティア': {
                            default: ["（静かに前を見つめている）", "（ダンジョンの穢れた空気に、少しだけ眉をひそめた）", "（仲間たちのほうを見て、こくりと頷いた）"],
                            lowHp: ["（…少し、光が揺らいだ）", "（胸に手を当て、静かに呼吸を整えている）", "（大丈夫、というように仲間へ微笑んだ）"],
                            allyLowHp: ["（傷ついた{name}を、心配そうに見つめている）", "（{name}の前に立ち、守るように両手を広げた）"],
                            shrunk: ["（小さくなった自分の手を見つめている）", "（特に気にした様子もなく、前を向いた）"],
                            grown: ["（大きくなった体に、少し戸惑っているようだ）", "（天井を見上げ、少し首をかしげた）"],
                            pair_アカリ: ["（アカリを見て、こくりと頷いた）", "（アカリの言葉に、ふわりと微笑んだ）"],
                            pair_ヒカリ: ["（ヒカリの言葉に、静かに頷いた）", "（ヒカリの魔導書に、興味深そうな視線を向けた）"],
                            pair_シズカ: ["（シズカの言葉に、少しだけ安堵したような表情を見せた）", "（シズカの盾を、尊敬の眼差しで見つめている）"],
                            pair_ユイ: ["（ユイの優しさに、慈愛に満ちた微笑みで応えた）", "（ユイの頭を、優しく撫でた）"],
                            // 他のキャラクターへの応答も同様に追加可能
                        },
                    };

                    const specialConversations = {
                        initial_party: [{
                            chars: ['アカリ', 'ヒカリ', 'シズカ', 'ユイ'],
                            lines: ["なんだか、この4人だと一番最初の冒険を思い出すね！", "…そうね。あの頃よりは、少しはマシになった。", "はは、違いない。みんな頼もしくなったよ。", "えへへ。これからも、みんなで頑張りましょうね！"]
                        }, {
                            chars: ['シズカ', 'アカリ', 'ヒカリ', 'ユイ'],
                            lines: ["アカリ、あんまり前に出過ぎるんじゃないよ。", "大丈夫だって！シズカが守ってくれるでしょ？", "…過信は禁物。", "私も、ちゃんとヒールしますから！"]
                        }, {
                            chars: ['ユイ', 'シャオメイ', 'ルナ', 'オリビア'],
                            lines: ["なんだか、このパーティは安心感がありますね！", "おう！回復なら任せとけ！", "回復役がこんなにいて負けたら、逆に面白いわね。", "ええ、神の慈悲は常に我らと共にあります。"]
                        }, {
                            chars: ['シズカ', 'リリカ', 'ミコ', 'イオリ'],
                            lines: ["はは、なんだい、この鉄壁の布陣は。", "リリカのステージは、みんなが守ってくれるってことだね！", "ゴーレムくんもいるし、絶対負けないよ！", "ボクとシズカさんがいれば、どんな攻撃も通さない！"]
                        }, {
                            chars: ['ベアトリス', 'リリカ', 'サクヤ', 'シャオメイ'],
                            lines: ["ふむ、このメンバー構成、なかなか興味深いですわね。", "だよね！個性派揃いのドリームチームって感じ！", "…騒がしい。だが、悪くない。", "うおー！なんかよくわかんねえけど、オラわくわくしてきたぞ！"]
                        }, {
                            chars: ['エリザ', 'ルナ', 'クロエ', 'ミコ'],
                            lines: ["ふふ、実に興味深い検体…いえ、メンバーですわね。", "面白そうな子たちじゃない。あなたたちに賭けてみるのもアリね。", "…魂の形が、みんなバラバラ。…面白い。", "わーい！みんなお友達だね！モコも喜んでるよ！"]
                        }, {
                            chars: ['レンカ', 'イオリ', 'コハル', 'オリビア'],
                            lines: ["ふふ、死と守りと混沌と聖…面白いパーティね。", "なんだか、ボクが一番まともな気がしてきた…しっかりしないと！", "わーい！なんだかよくわからないけど、楽しそうです！", "主よ…どうかこの者たちに、ご慈悲を…。"]
                        }, {
                            chars: ['サクヤ', 'シャオメイ', 'ベアトリス', 'リリカ'],
                            lines: ["…腹が、減ったな。", "おお！サクヤもか！オラもだ！", "あらあら、お二人とも。ここにレーションがありますわよ。", "もー！二人とも色気より食い気なんだから！"]
                        }, {
                            chars: ['ルナ', 'エリザ', 'ミコ', 'クロエ'],
                            lines: ["さーて、このパーティでどこまで行けるか、賭けてみない？", "私の計算によれば、生存確率は…ふふ、秘密ですわ。", "大丈夫だよ！ミコとモコとゴーレムくんがいれば百人力だもん！", "…魂の数が、多い。…大丈夫。"]
                        }, ],
                        same_height: [{
                            chars: ['アカリ', 'ユイ', 'ヒカリ'],
                            lines: ["あれ？なんだかみんな同じくらいの目線じゃない？", "ほんとです！なんだか不思議な感じですね！", "…確かに。全員同じ身長か。"]
                        }, {
                            chars: ['リリカ', 'シャオメイ', 'ルナ'],
                            lines: ["みんな同じ身長なんて、まるでアイドルグループみたい！", "おお！じゃあオラがセンターだな！", "センターは私に決まってるでしょ？一番ツイてるんだから。"]
                        }, {
                            chars: ['ベアトリス', 'エリザ', 'レンカ'],
                            lines: ["あら、皆さん同じ身長ですわね。興味深いデータですわ。", "ふふ、私の処方なら、この身長を維持することも可能ですわよ。", "魂の重さは、身長とは関係ないものね。"]
                        }, ],
                        all_stripped: [{
                            chars: ['アカリ', 'ヒカリ', 'ユイ'],
                            lines: ["うわー！みんなしてこんな格好！もうどうなってるのー！", "…不愉快。早く服を見つけたい。", "ふぇぇ…恥ずかしいですぅ…！"]
                        }, {
                            chars: ['シャオメイ', 'ルナ', 'リリカ'],
                            lines: ["はっはっは！みんな身軽で動きやすそうじゃねえか！", "ふふ、面白いじゃない。ここまで来たら、もうどうでもいいわね。", "きゃー！でも、これも新しいステージ衣装ってことにしちゃえばアリかも！"]
                        }, ],
                        all_grown: [{
                            chars: ['アカリ', 'シズカ', 'シャオメイ'],
                            lines: ["わーい！みんな大きい！巨人パーティだね！", "はは、天井が低いねぇ。頭をぶつけないようにしないと。", "うおー！これで敵なんて一ひねりだぜ！"]
                        }, {
                            chars: ['ベアトリス', 'エリザ', 'イオリ'],
                            lines: ["皆さん、大きくなりましたわね。素晴らしいデータですわ。", "私の薬の効果、絶大ですわね！", "これが…ボクが本来なるはずだった姿なのかな…。"]
                        }, ],
                        all_tiny: [{
                            chars: ['アカリ', 'ユイ', 'シズカ'],
                            lines: ["うわー！みんなで豆粒になっちゃった！", "ふぇぇ…これじゃあ、敵から逃げるのも大変ですぅ…！", "大丈夫だ、みんな！あたしの盾に隠れな！"]
                        }, {
                            chars: ['エリザ', 'ベアトリス', 'ヒカリ'],
                            lines: ["全員身長1cm…これは貴重なデータが取れそうですわ。", "ええ、ここまで均一な縮小は興味深い現象ですわね。", "…早く元に戻りたい。"]
                        }, {
                            chars: ['コハル', 'ミコ', 'クロエ'],
                            lines: ["ふぇぇ…みんなアリさんみたいになっちゃいました…！", "モコ、みんなのこと踏まないように気をつけてね！", "…もう、いないのと同じ。…でも、いる。"]
                        }, ],
                        before_boss: [{
                            chars: ['アカリ', 'シズカ', 'ユイ'],
                            lines: ["いよいよだね…！この先にボスがいるんだ！", "ああ。みんな、準備はいいかい？これが最後の戦いだ。", "はい…！絶対に勝ちましょう！"]
                        }, {
                            chars: ['サクヤ', 'ヒカリ', 'クロエ'],
                            lines: ["…強い気配。これまでの敵とは、格が違う。", "…魔力の密度が、異常に高い。", "…たくさんの魂が、泣いてる。…終わらせないと。"]
                        }, {
                            chars: ['ルナ', 'レンカ', 'エリザ'],
                            lines: ["さあ、最後のビッグゲームよ。全部賭ける覚悟はできてる？", "ふふ、どんな魂が待っているのかしら。楽しみね。", "私の研究の集大成を見せてあげますわ。"]
                        }, ]
                    };

                    function applyLevelUp(character, levels) {
                        for (let i = 0; i < levels; i++) {
                            character.maxHp += 5;
                            character.maxMp += 3;
                            character.atk += 1;
                            character.def += 1;
                            character.agi += 1;
                            character.level += 1; // ファイター, ソーサラー
                            character.skills.forEach(skill => {
                                if (skill.power) skill.power = parseFloat((skill.power * 1.05).toFixed(2));
                            });
                            if (character.level === 2 && character.unlockableSkill) character.skills.push(character.unlockableSkill);
                            if (character.level === 4 && character.unlockableSkillLv4) character.skills.push(character.unlockableSkillLv4);
                        }
                    }

                    function generateConversation() {
                        if (gameState.inBattle) return;

                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length < 2) {
                            log("会話できる相手がいない…");
                            return;
                        }

                        // 特別な会話の条件をチェック
                        let specialConvoSet = null;
                        let specialConvoKey = null;

                        // 1. 29階の会話
                        if (gameState.floor === 29) {
                            specialConvoKey = 'before_boss';
                        }
                        // 2. 全員身長1cm
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.height === 1)) {
                            specialConvoKey = 'all_tiny';
                        }
                        // 3. 全員同じ身長 (100cm以上)
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.height === aliveParty[0].height && p.height >= 100)) {
                            specialConvoKey = 'same_height';
                        }
                        // 4. 全員が脱衣状態
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.statusEffects.stripped)) {
                            specialConvoKey = 'all_stripped';
                        }
                        // 5. 全員の身長が初期値より高い
                        else if (aliveParty.length >= 3 && aliveParty.every(p => p.height > p.initialHeight)) {
                            specialConvoKey = 'all_grown';
                        }
                        // 6. 特定の4人パーティ
                        else if (aliveParty.length === 4) {
                            const partySets = {
                                initial_party: [
                                    ['アカリ', 'ヒカリ', 'シズカ', 'ユイ'],
                                    ['ベアトリス', 'リリカ', 'サクヤ', 'シャオメイ'],
                                    ['エリザ', 'ルナ', 'クロエ', 'ミコ'],
                                    ['レンカ', 'イオリ', 'コハル', 'オリビア'],
                                    ['ユイ', 'シャオメイ', 'ルナ', 'オリビア'], // 回復チーム
                                    ['シズカ', 'リリカ', 'ミコ', 'イオリ'] // 守護チーム
                                ],
                            };
                            const currentPartyNames = aliveParty.map(p => p.name).sort();
                            const isMatch = partySets.initial_party.some(partySet =>
                                JSON.stringify(partySet.sort()) === JSON.stringify(currentPartyNames));
                            if (isMatch) {
                                specialConvoKey = 'initial_party';
                            }
                        }

                        if (specialConvoKey) {
                            const availableConvos = specialConversations[specialConvoKey].map((convo, index) => ({...convo,
                                id: `${specialConvoKey}-${index}`
                            })).filter(convo => {
                                // 会話に必要なキャラが全員パーティにいるかチェック
                                const hasAllChars = convo.chars.every(charName => aliveParty.some(p => p.name === charName));
                                // 既に発生した会話でないかチェック
                                const notTriggered = !gameState.triggeredSpecialConvos.includes(convo.id);
                                return hasAllChars && notTriggered;
                            });

                            if (availableConvos.length > 0) {
                                const conversation = availableConvos[Math.floor(Math.random() * availableConvos.length)]; // 発生可能な会話からランダムに選択
                                gameState.triggeredSpecialConvos.push(conversation.id); // 発生した会話を記録
                                dungeonCommands.classList.add('hidden');
                                let delay = 0;
                                conversation.chars.forEach((charName, index) => {
                                    setTimeout(() => {
                                        log(`${charName}「${conversation.lines[index]}」`);
                                    }, delay);
                                    delay += 2000;
                                });
                                setTimeout(() => {
                                    dungeonCommands.classList.remove('hidden');
                                }, delay);
                                return; // 特別な会話を実行したので終了
                            }
                        }


                        // --- ここから通常の2人会話のロジック ---

                        // パーティで一人だけ身長10cm以下かつ脱衣状態の場合の特別会話
                        const tinyStrippedChars = aliveParty.filter(p => p.height <= 10 && p.statusEffects.stripped);
                        if (tinyStrippedChars.length === 1) {
                            const char = tinyStrippedChars[0];
                            const charConvos = conversations[char.name];
                            const soloLines = charConvos ? charConvos.solo_stripped_tiny : null;

                            if (soloLines && soloLines.length > 0) {
                                const line = soloLines[Math.floor(Math.random() * soloLines.length)];
                                dungeonCommands.classList.add('hidden');
                                log(`${char.name}「${line}」`);
                                setTimeout(() => {
                                    dungeonCommands.classList.remove('hidden');
                                }, 2000);
                                return; // 特別会話を実行して終了
                            }
                        }

                        // キャラクターの状況を判断するヘルパー関数
                        const getCharacterSituation = (char) => {
                            if (char.currentHp / char.maxHp < 0.4) return 'lowHp';
                            if (char.statusEffects.stripped && char.statusEffects.stripped.turns < 6) { // 行動不能確率が0%でない場合
                                if (char.height < char.initialHeight * 0.7) return 'stripped_shrunk'; // 身長が初期値の70%未満
                            }
                            if (char.height > char.initialHeight * 1.15) return 'grown'; // 15%以上大きくなったら
                            if (char.height === 1) return 'shrunk_1';
                            if (char.height < 10) return 'shrunk_10';
                            if (char.height < 30) return 'shrunk_30';
                            if (char.height < 50) return 'shrunk_50';
                            if (char.height < 70) return 'shrunk_70';
                            if (char.height < 100) return 'shrunk_100';
                            if (char.height < char.initialHeight * 0.7) return 'shrunk';
                            if (char.statusEffects.stripped) return 'stripped'; // stripped_shrunkにならなかったstripped状態
                            return 'normal';
                        };

                        // 会話する2人を選ぶ
                        let char1 = getRandomPartyMember();
                        let otherParty = aliveParty.filter(p => p !== char1);
                        let char2 = otherParty[Math.floor(Math.random() * otherParty.length)];

                        // 特定ペアの専用会話を優先的にチェック (50%の確率で発生)
                        const pairKey1 = `pair_${char2.name}`;
                        const pairKey2 = `pair_${char1.name}`;
                        if (conversations[char1.name] && conversations[char1.name][pairKey1] && conversations[char2.name] && conversations[char2.name][pairKey2] && Math.random() < 0.5) {
                            const line1 = conversations[char1.name][pairKey1][Math.floor(Math.random() * conversations[char1.name][pairKey1].length)];
                            const line2 = conversations[char2.name][pairKey2][Math.floor(Math.random() * conversations[char2.name][pairKey2].length)];

                            dungeonCommands.classList.add('hidden');
                            log(`${char1.name}「${line1}」`);
                            setTimeout(() => {
                                log(`${char2.name}「${line2}」`);
                                setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000);
                            }, 2000);
                            return; // 専用会話を実行したらここで終了
                        }

                        let situation1 = getCharacterSituation(char1);
                        let situation2 = getCharacterSituation(char2);

                        // 会話状況の優先順位を定義
                        const situationPriorities = [
                            'stripped_shrunk', 'stripped_pair', 'stripped', // 脱衣関連
                            'lowHp', // HPが低い,
                            'shrunk_10', 'shrunk_30', 'shrunk_50', 'shrunk_70', 'shrunk_100', 'shrunk', 'shrunk_pair', // 小さい関連 (より具体的->一般的)
                            'grown' // 大きい
                        ];

                        // 小さいキャラ同士の会話を優先
                        if (char1.height < char1.initialHeight * 0.5 && char2.height < char2.initialHeight * 0.5) {
                            situation1 = 'shrunk_pair';
                        }
                        // 脱衣状態のキャラ同士の会話を優先 (シズカは脱衣にならないため、この条件は他の3人の組み合わせで発動)
                        else if ((getCharacterSituation(char1) === 'stripped' || getCharacterSituation(char1) === 'stripped_shrunk') &&
                            (getCharacterSituation(char2) === 'stripped' || getCharacterSituation(char2) === 'stripped_shrunk')) {
                            situation1 = 'stripped_pair';
                        } else {
                            // 優先順位に基づいて、会話のターゲットとなるキャラを探す
                            let priorityTarget = null;
                            for (const prioSit of situationPriorities) {
                                priorityTarget = aliveParty.find(p => getCharacterSituation(p) === prioSit);
                                if (priorityTarget) break;
                            }


                            if (priorityTarget && priorityTarget !== char1) {
                                char2 = priorityTarget; // 会話相手をターゲットに設定
                                situation2 = getCharacterSituation(char2);

                                // char1の状況を「仲間の状況」に上書き
                                if (situation2 === 'lowHp') {
                                    situation1 = 'allyLowHp';
                                } else if (situation2.startsWith('shrunk')) {
                                    // 相手の身長状況に応じて、自分のセリフを変える
                                    const allyShrunkSituation = `ally${situation2.charAt(0).toUpperCase() + situation2.slice(1)}`;
                                    situation1 = allyShrunkSituation;
                                } else if (situation2 === 'stripped_shrunk') {
                                    situation1 = 'allyStripped_shrunk';
                                } else if (situation2 === 'stripped') {
                                    situation1 = 'allyStripped';
                                } else if (situation2 === 'grown') {
                                    situation1 = 'allyGrown';
                                }
                            }
                        }

                        // 状況に合ったセリフを選ぶ
                        const getLine = (char, sit, otherChar) => {
                            // パーティにいないキャラのセリフは参照しない (initGameでパーティが確定した後に呼ばれる)
                            const partyMemberNames = gameState.party.map(p => p.name);
                            if (!partyMemberNames.includes(char.name)) {
                                return ""; // 空文字を返す
                            }
                            const charConvos = conversations[char.name] || {
                                default: ["..."]
                            };

                            const otherPartyNames = gameState.party.map(p => p.name).filter(n => n !== char.name);

                            // allyShrunk_100 のようなキーが存在しない場合、allyShrunk -> shrunk -> default の順にフォールバック
                            let lines = charConvos[sit] ||
                                (sit === 'stripped_shrunk' && charConvos['stripped_shrunk']) ||
                                (sit === 'allyStripped_shrunk' && charConvos['allyStripped_shrunk']) ||
                                (sit === 'stripped_pair' && charConvos['stripped_pair']) ||
                                (sit === 'allyStripped' && charConvos['allyStripped']) ||
                                (sit === 'allyGrown' && charConvos['allyGrown']) ||
                                (sit.startsWith('allyShrunk') && charConvos['allyShrunk']) ||
                                (sit.startsWith('shrunk') && charConvos['shrunk']) ||
                                charConvos['default'];

                            // 選択したセリフに他のキャラクター名が含まれていて、それが会話相手と同じ場合は再抽選する
                            // さらに、パーティにいないキャラクターの名前が含まれているセリフも除外する
                            let filteredLines = lines.filter(line => {
                                const mentionedFixedName = allCharacterBlueprints.map(c => c.name).find(name => line.includes(name) && name !== char.name && name !== otherChar.name);
                                if (mentionedFixedName && !partyMemberNames.includes(mentionedFixedName)) {
                                    return false; // パーティにいないキャラの名前が含まれていたら除外
                                }

                                const mentionedName = otherPartyNames.find(name => line.includes(name));
                                return !mentionedName || mentionedName !== otherChar.name;
                            });
                            // フィルター後の候補がなくなってしまった場合は、元のリストから選ぶ
                            if (filteredLines.length === 0) filteredLines = lines;

                            let line = filteredLines[Math.floor(Math.random() * filteredLines.length)];
                            return line.replace(/{name}/g, otherChar.name);
                        };

                        const line1 = getLine(char1, situation1, char2);
                        const line2 = getLine(char2, situation2, char1);

                        // 会話をログに表示
                        dungeonCommands.classList.add('hidden'); // 会話中はボタンを非表示
                        log(`${char1.name}「${line1}」`);
                        setTimeout(() => {
                            log(`${char2.name}「${line2}」`);
                            setTimeout(() => dungeonCommands.classList.remove('hidden'), 2000); // ボタンを再表示
                        }, 2000);
                    }

                    function initGame(selectedMembers = null, fromSave = false) {
                        gameState.floor = 0;
                        gameState.triggeredSpecialConvos = []; // 発生済み会話をリセット
                        const blueprintsToUse = selectedMembers ?
                            selectedMembers.map(name => allCharacterBlueprints.find(c => c.name === name)) :
                            characterBlueprints;

                        gameState.party = blueprintsToUse.map(c => ({
                            ...c,
                            maxHp: c.hp,
                            currentHp: c.hp,
                            maxMp: c.mp,
                            currentMp: c.mp,
                            initialHeight: c.height,
                            buffs: {},
                            level: 1,
                            isDefending: false,
                            hate: 0,
                            statusEffects: {}, // 状態異常
                        })); // ファイター, ソーサラー, ナイト, メディック
                        gameState.golem = null;
                        gameState.inventory = [];

                        // fromSaveがtrueの場合、gameStateの大部分はロード済みなので、ここで処理を中断
                        if (fromSave) {
                            // ただし、一部の揮発性状態はリセットが必要
                            return;
                        }

                        // 初期アイテムの配布
                        if (!fromSave) {
                            addItemToInventory('potion', gameState.party.length);
                            addItemToInventory('milk', 1);
                            addItemToInventory('mana_potion', 1);
                        }

                        // もしもの物語モードの適用
                        if (gameState.gameMode === 'veterans') {
                            gameState.party.forEach(char => {
                                applyLevelUp(char, 3); // Lv1 -> Lv4
                            });
                        } else if (gameState.gameMode === 'dwarves') {
                            gameState.party.forEach(char => {
                                char.height = 10;
                            });
                        }

                        // HP/MPを全快させる
                        gameState.party.forEach(char => {
                            char.currentHp = char.maxHp;
                            char.currentMp = char.maxMp;
                        });

                        if (gameState.gameMode === 'indecent') {
                            gameState.party.forEach(char => {
                                // ナイトとサムライは選択不可なのでチェック不要
                                char.statusEffects.stripped = {
                                    turns: 0
                                };
                            });
                        }
                        if (gameState.gameMode === 'solo' && gameState.party.length === 1) {
                            const soloChar = gameState.party[0];
                            if (!fromSave) {
                                soloChar.maxHp *= 2;
                                soloChar.maxMp *= 2;
                                soloChar.atk = Math.floor(soloChar.atk * 1.5);
                                soloChar.def = Math.floor(soloChar.def * 1.5);
                                applyLevelUp(soloChar, 1); // Lv1 -> Lv2
                            }
                        }

                        // HP/MPを全快させる
                        gameState.party.forEach(char => {
                            char.currentHp = char.maxHp;
                            char.currentMp = char.maxMp;
                        });

                    }

                    function setupDungeonUI() {
                        updateFloorDisplay();
                        modal.classList.add('hidden');

                        // 会話ボタンのセットアップ
                        talkButton.id = 'talk-button';
                        talkButton.className = 'action-button bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                        talkButton.textContent = '会話する';
                        if (!dungeonCommands.querySelector('#talk-button')) {
                            dungeonCommands.insertBefore(talkButton, nextFloorButton.nextSibling);
                        }

                        // アイテムボタンのセットアップ
                        const itemButton = document.getElementById('dungeon-item-button') || document.createElement('button');
                        itemButton.id = 'dungeon-item-button';
                        itemButton.className = 'action-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                        itemButton.textContent = 'アイテム';
                        itemButton.onclick = () => showItemModal();
                        if (!dungeonCommands.querySelector('#dungeon-item-button')) {
                            dungeonCommands.insertBefore(itemButton, talkButton.nextSibling);
                        }
                    }

                    function updateFloorDisplay() {
                        if (!gameState.inBattle && gameState.floor > 0) {
                            floorDisplay.textContent = `第 ${gameState.floor} 層`;
                            floorDisplay.classList.remove('hidden');
                        } else floorDisplay.classList.add('hidden');
                    }

                    function log(message) {
                        logMessage.textContent = message;
                    }

                    // Refactored updatePartyStatus to update existing elements or create new ones
                    function updatePartyStatus() {
                        gameState.party.forEach((char, index) => {
                            let card = document.getElementById(`party-card-${index}`);
                            if (!card) {
                                // If card doesn't exist, create it (initial setup)
                                card = document.createElement('div');
                                card.id = `party-card-${index}`;
                                card.onclick = () => playerSelectAlly(index);
                                partyContainer.appendChild(card);

                                // Initial render of the inner structure
                                card.innerHTML = `
                            <div class="character-stats w-full">
                                <p class="font-bold text-sm truncate text-${char.themeColor}-700 stat-name">${char.name} <span class="text-xs text-gray-600">${char.role}</span></p>
                                <p class="text-xs stat-hp">HP: <span class="font-semibold">${char.currentHp}</span>/${char.maxHp}</p>
                                <div class="w-full bg-gray-300 rounded-full h-2 my-1"><div class="hp-bar-inner bg-red-500 h-2 rounded-full" style="width: ${Math.max(0, char.currentHp / char.maxHp * 100)}%"></div></div>
                                <p class="text-xs stat-mp">MP: <span class="font-semibold">${char.currentMp}</span>/${char.maxMp}</p>
                                <div class="w-full bg-gray-300 rounded-full h-2 my-1"><div class="mp-bar-inner bg-blue-500 h-2 rounded-full" style="width: ${Math.max(0, char.currentMp / char.maxMp * 100)}%"></div></div>
                                <p class="text-xs stat-height">身長: <span class="font-semibold">${char.height}cm</span> (${char.height - char.initialHeight >= 0 ? '+' : ''}${char.height - char.initialHeight})</p>
                                <div class="golem-status-container mt-1"></div>
                                <div class="stat-statuses text-xs"></div>
                            </div>
                        `;
                            }

                            // Update card classes
                            card.className = `character-card w-full sm:w-1/5 p-2 rounded-lg shadow-md border-2 border-${char.themeColor}-400 ${char.currentHp <= 0 ? 'opacity-50' : ''} ${char.bgClass || ''}`;

                            // Update specific elements within the card
                            // The animateStatChange function will handle the number and bar updates during animation.
                            // This updatePartyStatus call ensures consistency after animations or for non-animated changes.

                            const nameElement = card.querySelector('.stat-name');
                            if (nameElement) {
                                let statusHtml = '';
                                if (char.statusEffects.poison) statusHtml += '<span class="status-icon" title="毒">🤢</span>';
                                if (char.statusEffects.paralysis) statusHtml += '<span class="status-icon" title="麻痺">⚡️</span>';
                                if (char.statusEffects.slow) statusHtml += '<span class="status-icon" title="鈍化">🐌</span>';
                                if (char.statusEffects.stripped) statusHtml += '<span class="status-icon" title="脱衣">😳</span>';
                                if (char.statusEffects.regeneration) statusHtml += '<span class="status-icon" title="自然治癒">✨</span>';

                                nameElement.innerHTML = `
                            ${char.name} <span class="text-xs text-gray-600">${char.role}</span>
                            ${statusHtml}
                        `;
                            }

                            // Update HP (only if not currently animating, or to ensure final state)
                            const hpSpan = card.querySelector('.stat-hp .font-semibold');
                            if (hpSpan) hpSpan.textContent = char.currentHp;
                            // Update max HP text
                            const hpTextElement = card.querySelector('.stat-hp');
                            if (hpTextElement) {
                                hpTextElement.innerHTML = `HP: <span class="font-semibold">${char.currentHp}</span>/${char.maxHp}`;
                            }

                            const hpBarInner = card.querySelector('.hp-bar-inner');
                            if (hpBarInner) hpBarInner.style.width = `${Math.max(0, char.currentHp / char.maxHp * 100)}%`;

                            // Update MP
                            const mpSpan = card.querySelector('.stat-mp .font-semibold');
                            if (mpSpan) mpSpan.textContent = char.currentMp;
                            const mpBarInner = card.querySelector('.mp-bar-inner');
                            // Update max MP text
                            const mpTextElement = card.querySelector('.stat-mp');
                            if (mpTextElement) {
                                mpTextElement.innerHTML = `MP: <span class="font-semibold">${char.currentMp}</span>/${char.maxMp}`;
                            }
                            if (mpBarInner) mpBarInner.style.width = `${Math.max(0, char.currentMp / char.maxMp * 100)}%`;

                            // Update Height
                            const heightSpan = card.querySelector('.stat-height .font-semibold');
                            if (heightSpan) heightSpan.textContent = `${char.height}cm`;
                            const heightDiffElement = card.querySelector('.stat-height'); // This is the parent <p>
                            if (heightDiffElement) {
                                const diff = char.height - char.initialHeight;
                                heightDiffElement.innerHTML = `身長: <span class="font-semibold">${char.height}cm</span> (${diff >= 0 ? '+' : ''}${diff})`;
                            }

                            // ゴーレムのステータス表示
                            const golemContainer = card.querySelector('.golem-status-container');
                            if (golemContainer) {
                                if (char.role === 'サモナー' && gameState.golem && gameState.golem.hp > 0) {
                                    golemContainer.innerHTML = `
                                <div class="golem-card-inner bg-gray-700/80 p-1 rounded text-white text-center border border-yellow-400">
                                    <p class="font-bold text-xs">ゴーレム HP: ${gameState.golem.hp}/${gameState.golem.maxHp}</p>
                                    <div class="w-full bg-gray-500 rounded-full h-1.5"><div class="bg-yellow-500 h-1.5 rounded-full" style="width: ${Math.max(0, gameState.golem.hp / gameState.golem.maxHp * 100)}%"></div></div>
                                </div>
                            `;
                                } else {
                                    golemContainer.innerHTML = '';
                                }
                            }
                        });
                    }

                    function updateEnemyStatus() {
                        gameState.enemies.forEach((enemy, index) => {
                            if (enemy.currentHp > 0) {
                                let card = document.getElementById(`enemy-card-${index}`);
                                if (!card) {
                                    card = document.createElement('div');
                                    card.id = `enemy-card-${index}`;
                                    enemyContainer.appendChild(card);
                                }
                                card.className = `enemy-card bg-gray-900/70 p-2 rounded-lg text-white text-center w-32 border-2 border-transparent`;
                                card.innerHTML = `
                            <p class="font-bold text-sm">${enemy.name}</p>
                            <p class="text-xs">HP: ${enemy.currentHp}/${enemy.maxHp}</p>
                            <div class="w-full bg-gray-500 rounded-full h-2 mt-1"><div class="bg-red-500 h-2 rounded-full" style="width: ${Math.max(0, enemy.currentHp / enemy.maxHp * 100)}%"></div></div>
                        `;
                                card.classList.add('cursor-pointer', 'hover:border-red-500');
                                card.onclick = () => playerSelectTarget(index);
                            }
                        });
                    }

                    function getEffectiveStats(char) {
                        if (char.isEnemy) {
                            let atk = char.atk;
                            let pDef = char.pDef;
                            let mDef = char.mDef;
                            if (char.statusEffects && char.statusEffects.stat_down) {
                                atk *= 0.5;
                                pDef *= 0.5;
                                mDef *= 0.5;
                            } else if (char.buffs && char.buffs.atk_down) {
                                atk *= 0.5;
                                pDef *= 0.5;
                                mDef *= 0.5;
                            }
                            return {
                                atk: Math.floor(atk),
                                pDef: Math.floor(pDef),
                                mDef: Math.floor(mDef),
                                agi: char.agi
                            };
                        }
                        const heightDiff = char.height - char.initialHeight;
                        let atk = char.atk;
                        let def = char.def;
                        let agi = char.agi;
                        atk += Math.floor(char.atk * (heightDiff / char.initialHeight * 0.8));
                        def += Math.floor(char.def * (heightDiff / char.initialHeight * 0.8));
                        agi += Math.floor(char.agi * (heightDiff / char.initialHeight * -1.5)); // 小さいほど素早い
                        if (char.buffs && char.buffs.atk_up) atk *= 1.5;
                        if (char.buffs && char.buffs.protect) def *= 1.5;
                        if (char.buffs && char.buffs.agi_up) agi *= 1.5;
                        if (char.buffs && char.buffs.def_down) {
                            def *= 0.7;
                        }
                        if (char.buffs && char.buffs.def_down) {
                            if (char.isEnemy) {
                                char.pDef *= 0.7;
                                char.mDef *= 0.7;
                            } else {
                                def *= 0.7;
                            }
                        }
                        if (char.buffs && char.buffs.def_down) {
                            def *= 0.7;
                        }

                        // 脱衣状態の場合
                        if (char.statusEffects && char.statusEffects.stripped) {
                            if (char.role === 'リーパー') {
                                // リーパーは脱衣状態に非常に弱い
                                atk *= 0.5; // 攻撃力半減
                                def *= 0.5; // 防御力半減
                            } else {
                                def *= 0.8; // 他のジョブは防御力20%減少
                            }
                        }

                        return {
                            atk: Math.floor(atk),
                            def: Math.floor(def),
                            agi: Math.floor(agi)
                        };
                    }

                    function updateHate() {
                        gameState.party.forEach(char => {
                            const standardHeight = 150; // ヘイト計算の基準となる身長(cm)
                            // 基準身長(150cm)に対する現在の身長の比率でヘイトを計算
                            const heightRatio = char.height / standardHeight;
                            // 比率の3乗に比例してヘイトが変動。大きいと急増し、小さいと急減する。
                            char.hate = Math.pow(heightRatio, 3) * 100;
                            if (char.role === 'ナイト') char.hate *= 1.5;
                            if (char.buffs.provoke) char.hate *= 3;
                        });
                    }

                    function advanceFloor() {
                        gameState.floor++;
                        updateFloorDisplay();

                        const hasCelestia = gameState.party.some(p => p.role === '聖女');
                        const isPartyOfTwoOrMore = gameState.party.length >= 2;

                        // 29階の聖女特別イベント
                        if (gameState.floor === 29 && hasCelestia && isPartyOfTwoOrMore) {
                            celestiaEventTitle.textContent = "最後の問い";
                            celestiaEventText.textContent = "セレスティアが、静かにあなたを見つめている。\nその瞳は、これから待ち受ける運命について、覚悟を問うているようだ。\n\n「…この先に待つ元凶は、計り知れないほどの穢れを溜め込んでいます。仲間と共に挑めば、その穢れはさらに増し、想像を絶する脅威となるでしょう。それでも、あなたはこの道を進みますか？」";
                            celestiaEventButtons.innerHTML = `
                                <button id="celestia-accept" class="action-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg">覚悟を決める</button>
                                <button id="celestia-decline" class="action-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg">今はまだ…</button>
                            `;
                            celestiaEventModal.classList.remove('hidden');

                            document.getElementById('celestia-accept').onclick = () => {
                                celestiaEventModal.classList.add('hidden');
                                startBattle(true, true); // 強化ボス戦
                            };
                            document.getElementById('celestia-decline').onclick = () => {
                                celestiaEventModal.classList.add('hidden');
                                startBattle(true, false); // 通常ボス戦
                            };
                            return; // モーダル表示のため、ここで処理を中断
                        }


                        // ゲームモードによる分岐
                        if (gameState.gameMode === 'monster_march') {
                            const isBossFloor = gameState.floor === 30 || gameState.floor === 50;
                            startBattle(isBossFloor);
                        } else if (gameState.gameMode === 'endgame' && gameState.floor === 1) {
                            startBattle(true); // 1階でボス戦
                        } else if (gameState.gameMode === 'brawl' && gameState.floor % 2 === 0) {
                            startBattle(); // 2フロアごとに戦闘
                        } else if (gameState.gameMode === 'endless') { // 無限モードの判定を修正
                            if (gameState.floor > 0 && gameState.floor % 30 === 0) {
                                startBattle(true); // 無限モードのボス戦
                            } else {
                                // 通常の戦闘・イベント判定を行う
                                if (gameState.floor % 5 === 0) startBattle();
                                else triggerRandomEvent();
                            }
                        } else if (gameState.floor === 30 && gameState.gameMode !== 'endless' && gameState.gameMode !== 'monster_march') startBattle(true);
                        else if (gameState.floor % 5 === 0 && gameState.gameMode !== 'brawl' && gameState.gameMode !== 'endless') {
                            startBattle();
                        } else if (gameState.gameMode === 'fixed_path') {
                            triggerSelectableEvent();
                        } else {
                            triggerRandomEvent();
                        }
                        updatePartyStatus();
                    }

                    function triggerSelectableEvent() {
                        const event1 = getRandomEvent();
                        let event2 = getRandomEvent();

                        // 2つのイベントが同じ場合は、異なるイベントが選ばれるまで再抽選
                        while (event1.name === event2.name) {
                            event2 = getRandomEvent();
                        }

                        eventChoiceButtons.innerHTML = ''; // ボタンをクリア

                        [event1, event2].forEach(event => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg';
                            button.textContent = event.name;
                            button.onclick = () => {
                                eventChoiceModal.classList.add('hidden');
                                event.func();
                                updatePartyStatus();
                            };
                            eventChoiceButtons.appendChild(button);
                        });

                        eventChoiceModal.classList.remove('hidden');
                    }

                    function getRandomEvent() {
                        const isAnyoneStripped = gameState.party.some(p => p.statusEffects.stripped);
                        const restoreClothesEvent = {
                            name: "服を発見",
                            func: foundClothes,
                            weight: isAnyoneStripped && gameState.gameMode !== 'indecent' ? 5 : 0
                        };
                        const remainingEquipment = getRemainingEquipment();
                        const equipmentEvent = {
                            name: "装備発見",
                            func: foundEquipment,
                            weight: remainingEquipment.length > 0 ? 3 : 0
                        };

                        const events = [{
                                name: "宝箱",
                                func: foundTreasure,
                                weight: 4
                            }, {
                                name: "泉",
                                func: foundFountain,
                                weight: 2
                            }, {
                                name: "身長が縮む罠",
                                func: triggerShrinkTrap,
                                weight: 2
                            }, {
                                name: "身長が伸びる罠",
                                func: triggerGrowTrap,
                                weight: 1
                            }, {
                                name: "ダメージの罠",
                                func: triggerDamageTrap,
                                weight: 3
                            }, {
                                name: "怪しげな祭壇",
                                func: foundAltar,
                                weight: 2
                            }, {
                                name: "吟遊詩人",
                                func: foundBard,
                                weight: 1
                            }, {
                                name: "なにもない",
                                func: nothingHappened,
                                weight: 5
                            },
                            equipmentEvent,
                            restoreClothesEvent
                        ].filter(event => event.weight > 0);

                        const totalWeight = events.reduce((sum, event) => sum + event.weight, 0);
                        let random = Math.random() * totalWeight;
                        for (const event of events) {
                            random -= event.weight;
                            if (random <= 0) return event;
                        }
                        return events[events.length - 1]; // フォールバック
                    }

                    function triggerRandomEvent() {
                        const chosenEvent = getRandomEvent();
                        chosenEvent.func();
                        updatePartyStatus();
                    }

                    function foundTreasure() {
                        // 5%の確率でレアアイテムが出現
                        if (Math.random() < 0.05) {
                            const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                            const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                            addItemToInventory(foundItemId);
                            log(`なんと、宝箱からとても珍しい「${itemBlueprints[foundItemId].name}」を見つけた！`);
                            flashCard(gameState.party[0], 'yellow');
                        } else {
                            // 通常のアイテム
                            const itemCount = Math.floor(Math.random() * 3) + 1; // 1〜3個のアイテム
                            const foundItems = [];
                            // レアアイテムを除外
                            const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].battleOnly && !itemBlueprints[id].rare);

                            for (let i = 0; i < itemCount; i++) {
                                const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                                addItemToInventory(foundItemId);
                                foundItems.push(itemBlueprints[foundItemId].name);
                            }
                            log(`宝箱を見つけた！ ${foundItems.join('、')} を手に入れた！`);
                            flashCard(gameState.party[0], 'yellow');
                        }
                    }

                    async function foundFountain() {
                        const effects = [{
                            text: "HPが少し回復した。",
                            stat: 'hp',
                            ratio: 0.3
                        }, {
                            text: "MPが少し回復した。",
                            stat: 'mp',
                            ratio: 0.3
                        }, {
                            text: "HPとMPが全回復した！",
                            stat: 'both',
                            ratio: 1.0
                        }, ];
                        const effect = effects[Math.floor(Math.random() * effects.length)];
                        log(`一行は不思議な泉を見つけた。${effect.text}`);
                        for (const char of gameState.party) {
                            if (effect.stat === 'hp' || effect.stat === 'both') await animateStatChange(char, 'hp', Math.floor(char.maxHp * effect.ratio), 'increase');
                            if (effect.stat === 'mp' || effect.stat === 'both') await animateStatChange(char, 'mp', Math.floor(char.maxMp * effect.ratio), 'increase');
                            flashCard(char, 'green');
                        }
                    }

                    function triggerShrinkTrap() {
                        const target = getRandomPartyMember();
                        const shrinkAmount = Math.floor(Math.random() * 11) + 10; // 10〜20cm縮む
                        animateStatChange(target, 'height', -shrinkAmount, 'decrease');
                        flashCard(target, 'yellow'); // Flash the card itself
                        log(`奇妙な罠が作動した！ ${target.name}の体が縮んでしまった！(身長-${shrinkAmount}cm)`);
                    }

                    function triggerGrowTrap() {
                        const target = getRandomPartyMember();
                        const growAmount = Math.floor(Math.random() * 11) + 10; // 10〜20cm伸びる
                        animateStatChange(target, 'height', growAmount, 'increase');
                        flashCard(target, 'yellow');
                        log(`不思議な光が降り注いだ！ ${target.name}の体が巨大化してしまった！(身長+${growAmount}cm)`);
                    }

                    function triggerDamageTrap() {
                        const target = getRandomPartyMember();
                        const damage = Math.floor(target.maxHp * 0.1); // 最大HPの10%ダメージ
                        const messages = [
                            `${target.name}は足をもつらせて転んでしまった！`,
                            `${target.name}は隠された罠を踏んでしまった！`,
                        ];
                        log(messages[Math.floor(Math.random() * messages.length)]);
                        dealDamage(target, damage);
                    }

                    function foundAltar() {
                        log("一行は怪しげな祭壇を見つけた…");
                        challengeModal.classList.remove('hidden');
                        const challengeAcceptButton = document.getElementById('challenge-accept-button');
                        const challengeDeclineButton = document.getElementById('challenge-decline-button');


                        challengeAcceptButton.onclick = () => {
                            challengeModal.classList.add('hidden');
                            if (Math.random() < 0.3) { // 30%で成功
                                const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                                addItemToInventory(foundItemId);
                                log(`祭壇が輝き、なんと「${itemBlueprints[foundItemId].name}」を手に入れた！`);
                                flashCard(getRandomPartyMember(), 'green');
                            } else { // 70%で失敗
                                const availableItems = gameState.inventory.filter(item => item.quantity > 0);
                                if (availableItems.length > 0) {
                                    const lostItem = availableItems[Math.floor(Math.random() * availableItems.length)];
                                    lostItem.quantity--;
                                    log(`祭壇は禍々しい光を放ち、「${itemBlueprints[lostItem.id].name}」を一つ失ってしまった…`);
                                    flashCard(getRandomPartyMember(), 'red');
                                } else {
                                    log("祭壇に捧げるものがなく、何も起こらなかった。");
                                }
                            }
                        };
                        challengeDeclineButton.onclick = () => {
                            challengeModal.classList.add('hidden');
                            log("一行は怪しげな祭壇を後にして、先へ進んだ。");
                        };
                    }

                    function foundBard() {
                        log(`陽気な吟遊詩人に出会った。彼の歌声に、パーティの士気が上がる！`);
                        gameState.party.forEach(char => {
                            if (char.currentHp > 0) {
                                char.buffs.atk_up = 3; // 3ターン攻撃力アップ
                                flashCard(char, 'yellow');
                            }
                        });
                        log(`全員の攻撃力が一時的に上昇した！`);
                    }

                    function foundEquipment() {
                        const partyRoles = gameState.party.map(p => p.role);
                        const availableEquipmentIds = getRemainingEquipment().filter(id => {
                            const equipment = equipmentBlueprints[id];
                            // 装備の対象ロールが現在のパーティに存在するかチェック
                            return partyRoles.includes(equipment.targetRole);
                        });

                        if (availableEquipmentIds.length === 0) {
                            nothingHappened(); // 念のため、装備がない場合は何もしない
                            return;
                        }

                        const foundId = availableEquipmentIds[Math.floor(Math.random() * availableEquipmentIds.length)];
                        const equipment = equipmentBlueprints[foundId];
                        const targetCharacter = gameState.party.find(p => p.role === equipment.targetRole);

                        if (targetCharacter) {
                            log(`古い宝箱から ${equipment.name} を見つけた！ ${equipment.description}`);
                            targetCharacter[equipment.stat] += equipment.value;
                            gameState.foundEquipment.push(foundId);
                            flashCard(targetCharacter, 'yellow');
                            updatePartyStatus();
                        }
                    }

                    function foundClothes() {
                        const strippedMembers = gameState.party.filter(p => p.statusEffects.stripped);
                        if (strippedMembers.length > 0) {
                            log("一行はきれいな服が落ちているのを見つけた！");
                            strippedMembers.forEach(member => {
                                delete member.statusEffects.stripped;
                                log(`${member.name}は服を着て、元の状態に戻った！`);
                                flashCard(member, 'yellow');
                            });
                        }
                    }

                    function nothingHappened() {
                        log('なにも見つからなかった。');
                    }

                    function getRandomPartyMember(aliveOnly = true) {
                        const available = aliveOnly ? gameState.party.filter(p => p.currentHp > 0) : gameState.party;
                        return available[Math.floor(Math.random() * available.length)];
                    }

                    function startBattle(isBoss = false, isEnhancedBoss = false) {
                        log(isBoss ? 'ボスの気配がする…！' : '敵が現れた！');
                        gameState.inBattle = true;
                        dungeonCommands.classList.add('hidden');
                        floorDisplay.classList.add('hidden');
                        gameState.golem = null; // 戦闘開始時にゴーレムをリセット
                        battleCommands.classList.remove('hidden');

                        const enemyCount = isBoss ? 1 : Math.floor(Math.random() * 2) + 1 + Math.floor(gameState.floor / 10);
                        gameState.enemies = [];
                        for (let i = 0; i < enemyCount; i++) gameState.enemies.push(createEnemy(isBoss, isEnhancedBoss));
                        updateEnemyStatus();

                        const combatants = [...gameState.party.filter(p => p.currentHp > 0), ...gameState.enemies];
                        gameState.turnOrder = combatants.sort((a, b) => getEffectiveStats(b).agi - getEffectiveStats(a).agi);
                        gameState.currentTurnIndex = 0;

                        nextTurn();
                    }

                    function createEnemy(isBoss, isEnhanced = false) {
                        const floor = gameState.floor;
                        if (isBoss) {
                            if (isEnhanced) {
                                return {
                                    name: '【覚醒】ダンジョンマスター',
                                    maxHp: 1200 + floor * 20,
                                    currentHp: 1200 + floor * 20,
                                    atk: 40 + Math.floor(floor * 1.5),
                                    pDef: 30 + Math.floor(floor * 1.0),
                                    mDef: 20 + Math.floor(floor * 1.0),
                                    agi: 20,
                                    isEnemy: true,
                                    statusEffects: {},
                                    skills: [{
                                        name: 'カタストロフィ',
                                        func: sweepAttack,
                                        type: 'physical'
                                    }, {
                                        name: '縮小ビーム',
                                        func: shrinkBeam,
                                        type: 'utility'
                                    }, ]
                                };
                            }
                            const bossBlueprints = [{
                                name: 'ダンジョンマスター',
                                maxHp: 750,
                                atk: 30,
                                pDef: 25,
                                mDef: 15,
                                agi: 15,
                                skills: [{
                                    name: '縮小ビーム',
                                    func: shrinkBeam,
                                    type: 'utility'
                                }, {
                                    name: 'なぎ払い',
                                    func: sweepAttack,
                                    type: 'physical'
                                }, ]
                            }, {
                                name: 'カオスゴーレム',
                                maxHp: 900,
                                atk: 35,
                                pDef: 35,
                                mDef: 5,
                                agi: 10,
                                skills: [{
                                    name: '状態異常攻撃',
                                    func: inflictStatusEffect,
                                    type: 'utility'
                                }, {
                                    name: 'なぎ払い',
                                    func: sweepAttack,
                                    type: 'physical'
                                }, ]
                            }, {
                                name: 'アークリッチ',
                                maxHp: 600,
                                atk: 25,
                                pDef: 10,
                                mDef: 30,
                                agi: 20,
                                skills: [{
                                    name: 'いたずら',
                                    func: inflictStripped,
                                    type: 'utility'
                                }, {
                                    name: '自己再生',
                                    func: inflictRegeneration,
                                    type: 'utility'
                                }, ]
                            }];
                            const blueprint = bossBlueprints[Math.floor(Math.random() * bossBlueprints.length)];
                            return {
                                ...blueprint,
                                maxHp: blueprint.maxHp + floor * 15, // 最大HPを計算
                                currentHp: blueprint.maxHp + floor * 15, // 現在HPを最大HPと一致させる
                                atk: blueprint.atk + Math.floor(floor * 1.2),
                                pDef: blueprint.pDef + Math.floor(floor * 0.8),
                                mDef: blueprint.mDef + Math.floor(floor * 0.8),
                                isEnemy: true,
                                statusEffects: {},
                                regenUses: 0, // 自己再生の使用回数カウンター
                            };
                        }
                        const enemyBlueprints = [{
                                name: 'スライム',
                                pDefRatio: 0.8,
                                mDefRatio: 1.2
                            }, // 物理に弱く、魔法に強い
                            {
                                name: 'ゴブリン',
                                pDefRatio: 1.2,
                                mDefRatio: 0.8
                            }, // 物理に強く、魔法に弱い
                            {
                                name: 'コウモリ',
                                pDefRatio: 1.0,
                                mDefRatio: 1.0
                            }, // 平均的
                            {
                                name: 'スケルトン',
                                pDefRatio: 1.5,
                                mDefRatio: 0.5
                            }, // 物理にとても強く、魔法にとても弱い
                            {
                                name: 'ウィスプ',
                                pDefRatio: 0.7,
                                mDefRatio: 1.5
                            }, // 状態異常を使う
                            {
                                name: 'リトルメイジ',
                                pDefRatio: 0.8,
                                mDefRatio: 1.2
                            }, // 状態異常を使う
                            {
                                name: 'インプ',
                                pDefRatio: 0.9,
                                mDefRatio: 1.1
                            }, // 脱衣や自己回復を使う
                        ];
                        const blueprint = enemyBlueprints[Math.floor(Math.random() * enemyBlueprints.length)];
                        const baseDef = 5 + floor * 0.8;
                        return {
                            name: blueprint.name,
                            maxHp: 45 + floor * 8,
                            currentHp: 45 + floor * 8,
                            atk: 10 + Math.floor(floor * 1.2),
                            pDef: Math.max(1, Math.floor(baseDef * blueprint.pDefRatio)),
                            mDef: Math.max(1, Math.floor(baseDef * blueprint.mDefRatio)),
                            agi: 7 + floor,
                            isEnemy: true,
                            skills: (blueprint.name === 'ウィスプ') ? [{
                                    name: '状態異常攻撃',
                                    func: inflictStatusEffect
                                }] :
                                (blueprint.name === 'リトルメイジ') ? [{
                                    name: '縮小ビーム',
                                    func: shrinkBeam
                                }] :
                                (blueprint.name === 'インプ') ? [{
                                    name: 'いたずら',
                                    func: inflictStripped
                                }, {
                                    name: '自己再生',
                                    func: inflictRegeneration
                                }] : [],
                            statusEffects: {},
                            regenUses: 0, // 自己再生の使用回数カウンター
                        };
                    }

                    function shrinkBeam(enemy) {
                        const target = findTarget(enemy);
                        const shrinkAmount = Math.floor(Math.random() * 10) + 5;
                        animateStatChange(target, 'height', -shrinkAmount, 'decrease');
                        flashCard(target, 'yellow');
                        log(`${enemy.name}は${target.name}に縮小ビームを放った！身長が${shrinkAmount}cm縮んだ！`);
                        updatePartyStatus();
                    }

                    async function sweepAttack(enemy) {
                        log(`${enemy.name}のなぎ払い！`);
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        for (const target of aliveParty) {
                            // 全体攻撃なので威力は下げる (0.5倍)
                            const damage = calculateDamage(enemy, target, {
                                type: 'physical',
                                power: 0.5
                            });
                            await dealDamage(target, damage);
                        }
                    }

                    function inflictStatusEffect(enemy) {
                        const target = findTarget(enemy);
                        // ターゲットがゴーレムの場合、状態異常は効かないので通常攻撃に切り替える
                        if (target === gameState.golem) {
                            log(`${enemy.name}はゴーレムに状態異常を仕掛けようとしたが、効果がなかった！`);
                            defaultEnemyAttack(enemy, target);
                            return;
                        }
                        if (target.isDefending) {
                            log(`${enemy.name}の攻撃！ しかし、${target.name}は防御していて効かなかった！`);
                            flashCard(target, 'yellow');
                            return;
                        }

                        const possibleEffects = ['poison', 'paralysis', 'slow'];
                        const effect = possibleEffects[Math.floor(Math.random() * possibleEffects.length)];

                        let effectName = '';
                        let duration = 0;

                        switch (effect) {
                            case 'poison':
                                effectName = '毒';
                                duration = 3;
                                target.statusEffects.poison = {
                                    turns: duration
                                };
                                break;
                            case 'paralysis':
                                effectName = '麻痺';
                                target.statusEffects.paralysis = true;
                                break;
                            case 'slow':
                                effectName = '鈍化';
                                duration = 3;
                                target.statusEffects.slow = {
                                    turns: duration
                                };
                                break;
                        }
                        flashCard(target, 'yellow');
                        log(`${enemy.name}の攻撃！ ${target.name}は${effectName}状態になった！`);
                        updatePartyStatus();
                    }

                    function inflictStripped(enemy) {
                        const target = findTarget(enemy);
                        if (target.role === 'ナイト' || target.role === 'サムライ' || target.role === '聖女') {
                            log(`${enemy.name}は${target.name}にいたずらを仕掛けたが、全く動じなかった！`);
                            return;
                        }

                        if (target.isDefending) {
                            log(`${enemy.name}のいたずら！ しかし、${target.name}は身構えていて効果がなかった！`);
                            flashCard(target, 'yellow');
                            return;
                        }

                        target.statusEffects.stripped = {
                            turns: 0
                        }; // ターンカウンターを追加
                        flashCard(target, 'yellow');
                        log(`${enemy.name}のいたずら！ ${target.name}は恥ずかしい格好になってしまった！`);
                        updatePartyStatus();
                    }

                    function inflictRegeneration(enemy) {
                        enemy.statusEffects.regeneration = {
                            turns: 3
                        };
                        flashCard(enemy, 'green');
                        log(`${enemy.name}は傷が再生し始めた！`);
                        updateEnemyStatus(); // 敵のUIは無いが、将来的な拡張のため
                    }

                    function nextTurn() {
                        let currentActor = gameState.turnOrder[gameState.currentTurnIndex];
                        // 聖女のターン開始時回復
                        if (!currentActor.isEnemy && currentActor.role === '聖女' && currentActor.currentHp > 0) {
                            const hpHeal = Math.max(1, Math.floor(currentActor.maxHp * 0.05));
                            const mpHeal = Math.max(1, Math.floor(currentActor.maxMp * 0.05));
                            animateStatChange(currentActor, 'hp', hpHeal, 'increase');
                            animateStatChange(currentActor, 'mp', mpHeal, 'increase');
                        }

                        // バフのターン経過
                        if (currentActor.buffs) {
                            Object.keys(currentActor.buffs).forEach(key => {
                                currentActor.buffs[key]--;
                                if (currentActor.buffs[key] <= 0) {
                                    delete currentActor.buffs[key];
                                    if (!currentActor.isEnemy) {
                                        let buffName = '';
                                        if (key === 'protect') buffName = '防御アップ';
                                        else if (key === 'atk_up') buffName = '攻撃アップ';
                                        else if (key === 'provoke') buffName = '挑発';
                                        if (buffName) {
                                            flashCard(currentActor, 'yellow');
                                            log(`${currentActor.name}の${buffName}効果が切れた。`);
                                        }
                                    }
                                }
                            });
                        }
                        // 状態異常のターン経過
                        if (currentActor.statusEffects) {
                            // 脱衣状態の経過ターンを増やす
                            if (currentActor.statusEffects.stripped && gameState.gameMode !== 'indecent') {
                                currentActor.statusEffects.stripped.turns++;
                                log(`${currentActor.name}はだんだん恥ずかしさに慣れてきた…`);
                            }
                            ['poison', 'slow', 'regeneration'].forEach(effect => {
                                if (currentActor.statusEffects[effect]) {
                                    currentActor.statusEffects[effect].turns--;
                                    if (currentActor.statusEffects[effect].turns <= 0) {
                                        delete currentActor.statusEffects[effect];
                                        if (!currentActor.isEnemy) {
                                            const effectName = effect === 'poison' ? '毒' : '鈍化';
                                            flashCard(currentActor, 'yellow');
                                            log(`${currentActor.name}の${effectName}が治った。`);
                                        }
                                    }
                                }
                            });
                        }

                        if (currentActor.isDefending) currentActor.isDefending = false;

                        if (gameState.enemies.every(e => e.currentHp <= 0)) {
                            endBattle(true);
                            return;
                        }
                        if (gameState.party.every(p => p.currentHp <= 0)) {
                            endBattle(false);
                            return;
                        }

                        let actor = gameState.turnOrder[gameState.currentTurnIndex];

                        // 脱衣チェック (ナイト、サムライ、モンクは対象外)
                        if (actor.statusEffects && actor.statusEffects.stripped && actor.role !== 'ナイト' && actor.role !== 'サムライ' && actor.role !== 'モンク') {
                            let failChance = 0;
                            if (gameState.gameMode === 'indecent') {
                                failChance = 0.3; // 確率が減少しない
                            } else {
                                failChance = Math.max(0, 0.3 - (actor.statusEffects.stripped.turns * 0.05)); // ターン経過で確率低下
                            }

                            if (Math.random() < failChance) {
                                const messages = ["は、恥ずかしくて動けない…！", "こ、こんな格好じゃ集中できない…！", "だ、だめ、見ないで…！"];
                                log(`${actor.name}「${messages[Math.floor(Math.random() * messages.length)]}」`);
                                flashCard(actor, 'yellow');
                                setTimeout(() => {
                                    gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                    nextTurn();
                                }, 1000);
                                return;
                            }
                        }

                        // 麻痺チェック
                        if (currentActor.statusEffects && currentActor.statusEffects.paralysis) {
                            log(`${currentActor.name}は体が痺れて動けない！`);
                            delete currentActor.statusEffects.paralysis; // 麻痺は1回で解除
                            flashCard(currentActor, 'yellow');
                            updatePartyStatus();
                            setTimeout(() => {
                                gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                nextTurn();
                            }, 1000);
                            return;
                        }

                        // 毒ダメージ処理 (ターン終了時)
                        // nextTurnの最後に移動させるため、ここでは何もしない

                        updatePartyStatus(); // ターン開始時に状態表示を更新

                        if (currentActor.currentHp <= 0) {
                            gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                            setTimeout(nextTurn, 100);
                            return;
                        }

                        if (currentActor.isEnemy) {
                            enemyTurn(currentActor);
                        } else {
                            // ターン開始時にMPを1回復
                            if (currentActor.currentMp < currentActor.maxMp) animateStatChange(currentActor, 'mp', 1, 'increase');
                            playerTurn(currentActor);
                        }
                    }

                    function playerTurn(character) {
                        commandMessage.textContent = `${character.name}のターン`;
                        actionButtons.innerHTML = '';

                        const attackBtn = document.createElement('button');
                        attackBtn.textContent = 'たたかう';
                        attackBtn.className = 'action-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded';
                        attackBtn.onclick = () => playerAction(character, {
                            type: 'attack'
                        });
                        actionButtons.appendChild(attackBtn);

                        character.skills.forEach(skill => {
                            const isSlowed = character.statusEffects && character.statusEffects.slow;
                            const isHpCostSkill = skill.type && skill.type.includes('hp_cost');
                            const isDisabled = (isHpCostSkill ? character.currentHp <= skill.cost : character.currentMp < skill.cost) || isSlowed;
                            const skillBtn = document.createElement('button');
                            skillBtn.textContent = `${skill.name} (${isHpCostSkill ? 'HP' : 'MP'}:${skill.cost})`;
                            skillBtn.className = `action-button bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}`;
                            if (isSlowed) skillBtn.title = "鈍化状態でスキルが使えない！";
                            skillBtn.disabled = isDisabled;
                            skillBtn.onclick = () => playerAction(character, {
                                type: 'skill',
                                skill: skill
                            });
                            actionButtons.appendChild(skillBtn);
                        });

                        const defendBtn = document.createElement('button');
                        defendBtn.textContent = 'ぼうぎょ';
                        defendBtn.className = 'action-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded';
                        defendBtn.onclick = () => playerAction(character, {
                            type: 'defend'
                        });

                        const scanBtn = document.createElement('button');
                        scanBtn.textContent = '調べる';
                        scanBtn.className = 'action-button bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-4 rounded';
                        scanBtn.onclick = () => playerAction(character, {
                            type: 'scan'
                        });
                        actionButtons.appendChild(scanBtn);

                        actionButtons.appendChild(defendBtn);

                        const itemBtn = document.createElement('button');
                        itemBtn.textContent = 'アイテム';
                        itemBtn.className = `action-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded ${gameState.inventory.length === 0 ? 'opacity-50 cursor-not-allowed' : ''}`;
                        itemBtn.disabled = gameState.inventory.length === 0;
                        itemBtn.onclick = () => showItemModal(character);
                        actionButtons.appendChild(itemBtn);

                    }

                    let pendingAction = null;

                    function playerAction(character, action) {
                        pendingAction = {
                            character,
                            action
                        };

                        const targetType = action.type === 'attack' ? 'enemy' : (action.type === 'scan' ? 'any' : (action.skill ? action.skill.targetType : (action.item ? itemBlueprints[action.item.id].target : 'self')));

                        if (targetType === 'enemy') {
                            const aliveEnemies = gameState.enemies.filter(e => e.currentHp > 0);
                            if (aliveEnemies.length === 1) {
                                pendingAction.target = aliveEnemies[0];
                                executePlayerAction();
                            } else {
                                commandMessage.textContent = '誰を狙う？';
                                gameState.enemies.forEach((enemy, index) => {
                                    if (enemy.currentHp > 0) document.getElementById(`enemy-card-${index}`).classList.add('targeted');
                                });
                            }
                        } else if (targetType === 'ally') {
                            commandMessage.textContent = '誰に使う？';
                            gameState.party.forEach((char, index) => {
                                if (char.currentHp > 0) {
                                    document.getElementById(`party-card-${index}`).classList.add('targeted');
                                }
                            });
                        } else if (targetType === 'any') {
                            commandMessage.textContent = '調べる対象を選択してください。';
                            gameState.enemies.forEach((enemy, index) => {
                                if (enemy.currentHp > 0) document.getElementById(`enemy-card-${index}`).classList.add('targeted');
                            });
                            gameState.party.forEach((char, index) => {
                                if (char.currentHp > 0) document.getElementById(`party-card-${index}`).classList.add('targeted');
                            });
                        } else {
                            // 敵全体、自分自身が対象の場合
                            if (targetType === 'enemies') {
                                pendingAction.target = gameState.enemies.filter(e => e.currentHp > 0);
                            }
                            executePlayerAction();
                        }

                    }

                    function playerSelectTarget(targetIndex) {
                        if (pendingAction && gameState.enemies[targetIndex].currentHp > 0) {
                            if (pendingAction.action.type === 'scan') {
                                showScanResult(gameState.enemies[targetIndex]);
                            } else {
                                pendingAction.target = gameState.enemies[targetIndex];
                                executePlayerAction();
                            }
                        }
                    }

                    function playerSelectAlly(targetIndex) {
                        if (!pendingAction) return;
                        if (pendingAction.action.type === 'scan') {
                            showScanResult(gameState.party[targetIndex]);
                        } else {
                            const targetCharacter = gameState.party[targetIndex];
                            const action = pendingAction.action;
                            const itemInfo = action.item ? itemBlueprints[action.item.id] : null;

                            // 復活アイテムの場合、戦闘不能の味方のみ対象
                            if (itemInfo && itemInfo.effect === 'revive') {
                                if (targetCharacter.currentHp <= 0) {
                                    pendingAction.target = targetCharacter;
                                    executePlayerAction();
                                } else {
                                    log(`${targetCharacter.name}は戦闘不能ではない！`);
                                }
                            }
                            // それ以外の味方対象アクションの場合、生存している味方のみ対象
                            else if (targetCharacter.currentHp > 0) {
                                pendingAction.target = targetCharacter;
                                executePlayerAction();
                            } else {
                                log("その対象には使用できない！");
                            }
                        }
                    }

                    async function executePlayerAction() {
                        const {
                            character,
                            action,
                            target
                        } = pendingAction;
                        document.querySelectorAll('.enemy-card, .character-card').forEach(c => c.classList.remove('targeted'));

                        pendingAction = null;
                        document.querySelectorAll('.enemy-card').forEach(c => c.classList.remove('targeted'));
                        actionButtons.innerHTML = '<p>コマンド実行中...</p>';

                        switch (action.type) {
                            case 'attack': // Player attack
                                let damage = calculateDamage(character, target);
                                let logMessageText = `${character.name}の攻撃！ ${target.name}に${damage}のダメージ！`;

                                const mpRecoveryRoles = ['ソーサラー', 'メディック', 'モンク', 'ギャンブラー', 'サモナー', 'アルケミスト', 'ダンサー', 'ドクター', 'ネクロマンサー'];
                                if (mpRecoveryRoles.includes(character.role)) {
                                    // MP回復ジョブの処理
                                    const mpRecovery = Math.floor(character.maxMp * 0.1);
                                    if (mpRecovery > 0) {
                                        await animateStatChange(character, 'mp', mpRecovery, 'increase');
                                        log(`${character.name}は攻撃から魔力を吸収した！(MP+${mpRecovery})`);
                                    }
                                } else {
                                    // クリティカルヒット判定ジョブの処理
                                    const criticalRoles = ['ファイター', 'ナイト', 'サムライ', 'ガーディアン', 'トラブルメーカー'];
                                    if (criticalRoles.includes(character.role) && Math.random() < 0.2) { // 20%の確率でクリティカル
                                        damage = Math.floor(damage * 1.5);
                                        logMessageText = `会心の一撃！ ${target.name}に${damage}の大ダメージ！`;
                                    }
                                }
                                await dealDamage(target, damage); // Await the damage animation
                                log(logMessageText); // Log after animation
                                break;
                            case 'skill':
                                if (action.skill.type && action.skill.type.includes('hp_cost')) {
                                    await animateStatChange(character, 'hp', -action.skill.cost, 'decrease'); // HP消費
                                } else if (action.skill.cost > 0) {
                                    await animateStatChange(character, 'mp', -action.skill.cost, 'decrease'); // MP消費
                                }
                                flashCard(character, 'yellow'); // MP消費
                                handleSkill(character, target, action.skill);
                                break;
                            case 'item':
                                // handleItemがtrueを返した場合のみアイテムを消費
                                const itemUsed = await handleItem(character, target, action.item);
                                if (itemUsed) action.item.quantity--;
                                break;
                            case 'defend':
                                character.isDefending = true;
                                log(`${character.name}は防御の構えをとった。`);
                                break;
                            case 'scan':
                                // このケースは playerSelect... で直接処理されるため、ここでは何もしない
                                // ターンを消費しないように、nextTurnを呼ばずにplayerTurnに戻る
                                playerTurn(character);
                                return;
                        }

                        updatePartyStatus(); // Refresh all cards after animations
                        updateEnemyStatus(); // Enemy status doesn't have number animation, so it can be updated immediately

                        if (gameState.inBattle) {
                            setTimeout(() => {
                                // ターン終了時の毒ダメージ
                                if (character.statusEffects && character.statusEffects.poison) {
                                    const poisonDamage = Math.max(1, Math.floor(character.maxHp * 0.05));
                                    log(`${character.name}は毒のダメージを受けている！`);
                                    // dealDamageはasyncだが、ここでは待たずに次のターンへ進む
                                    dealDamage(character, poisonDamage);
                                    updatePartyStatus();
                                }
                                // ターン終了時の自然治癒
                                if (character.statusEffects && character.statusEffects.regeneration) {
                                    const healAmount = Math.max(1, Math.floor(character.maxHp * 0.08));
                                    log(`${character.name}は傷が自然に回復していく！`);
                                    animateStatChange(character, 'hp', healAmount, 'increase');
                                    updatePartyStatus();
                                }


                                gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                                nextTurn();
                            }, 1000);
                        }
                    }

                    async function handleSkill(caster, target, skill) {
                        switch (skill.type) {
                            case 'physical':
                            case 'magic':
                                if (Array.isArray(target) && target.every(t => t.isEnemy)) { // 敵全体への攻撃の場合
                                    log(`${caster.name}は${skill.name}を放った！`);
                                    const damages = target.map(t => calculateDamage(caster, t, skill));
                                    const damagePromises = [];
                                    for (const t of target) {
                                        // dealDamageを直接awaitせず、Promiseを配列に格納
                                        damagePromises.push(dealDamage(t, calculateDamage(caster, t, skill)));
                                    }
                                    // 全てのダメージ処理アニメーションを並行して実行
                                    await Promise.all(damagePromises);
                                } else { // 単体攻撃の場合
                                    const skillDamage = calculateDamage(caster, target, skill);
                                    await dealDamage(target, skillDamage);
                                    log(`${caster.name}は${skill.name}を放った！ ${target.name}に${skillDamage}のダメージ！`);
                                }
                                break;
                            case 'heal':
                                const healAmount = skill.power + Math.floor(getEffectiveStats(caster).atk * 0.5); // Calculate amount first
                                await animateStatChange(target, 'hp', healAmount, 'increase'); // Await HP animation
                                flashCard(target, 'green'); // Flash the card itself
                                showDamagePopup(target, healAmount, true);
                                log(`${caster.name}は${target.name}に${skill.name}を唱えた！ HPが${healAmount}回復した。`);
                                break;
                            case 'buff':
                                if (skill.effect === 'atk_up') {
                                    target.buffs.atk_up = 3; // 3ターン攻撃力アップ
                                    flashCard(target, 'yellow');
                                    log(`${caster.name}は${target.name}に${skill.name}を唱えた！ 攻撃力が上がった！`);
                                } else if (skill.effect === 'def_down') {
                                    target.buffs.def_down = 3; // 3ターン防御力ダウン
                                    flashCard(target, 'yellow');
                                    log(`${caster.name}は${target.name}に${skill.name}を唱えた！ 防御力が下がった！`);
                                } else { // 既存のプロテクト
                                    if (skill.effect === 'agi_up') {
                                        target.buffs.agi_up = 3;
                                        flashCard(target, 'yellow');
                                        log(`${caster.name}の${skill.name}で、${target.name}の素早さが上がった！`);
                                    } else { // プロテクト
                                        target.buffs.protect = 3;
                                        flashCard(target, 'yellow');
                                        log(`${caster.name}は${target.name}に${skill.name}を唱えた！ 防御力が上がった！`);
                                    }
                                }
                                break;
                            case 'utility':
                                flashCard(caster, 'yellow');
                                caster.buffs.provoke = 3; // 挑発は自分自身が対象
                                log(`${caster.name}は${skill.name}で敵の注意を引いた！`);
                                break;
                            case 'charge':
                                caster.isCharging = true;
                                flashCard(caster, 'yellow');
                                log(`${caster.name}は${skill.name}！力を溜めている…！`);
                                break;
                            case 'special_heal': // 献身
                                const costHeight = Math.min(20, caster.height - 1);
                                if (costHeight < 1) {
                                    log(`${caster.name}は献身を使おうとしたが、身長が足りなかった！`);
                                    break; // 身長が1cmだと使えない
                                }
                                await animateStatChange(caster, 'height', -costHeight, 'decrease');
                                log(`${caster.name}は身長を${costHeight}cm捧げて、味方を癒した！`);
                                handleItem(caster, null, {
                                    id: 'cure_mist',
                                    quantity: 1
                                }, true); // キュアミストの効果を流用
                                break;
                        }
                        // 新しいLv4スキル
                        switch (skill.type) {
                            case 'multi_hit_physical': // 乱舞
                                const hitCount = Math.floor(Math.random() * 3) + 4; // 4〜6回
                                log(`${caster.name}の${skill.name}！`);
                                await new Promise(resolve => setTimeout(resolve, 500)); // メッセージ表示のための短い待機
                                log(`${hitCount}回攻撃！`);
                                for (let i = 0; i < hitCount; i++) {
                                    const randomTarget = gameState.enemies.filter(e => e.currentHp > 0)[Math.floor(Math.random() * gameState.enemies.filter(e => e.currentHp > 0).length)];
                                    if (randomTarget) {
                                        const damage = calculateDamage(caster, randomTarget, {...skill,
                                            power: 0.6
                                        }); // 1ヒットあたりの威力は調整
                                        // 連続攻撃なので、一体ずつ待機してダメージを与える
                                        await dealDamage(randomTarget, damage);
                                    }
                                }
                                break;
                            case 'mp_burst_magic': // マジックバースト
                                const damage = caster.currentMp * 3;
                                await animateStatChange(caster, 'mp', -caster.currentMp, 'decrease');
                                log(`${caster.name}は${skill.name}を放った！`);
                                await dealDamage(target, damage);
                                log(`${target.name}に${damage}の特大ダメージ！`);
                                break;
                            case 'self_buff_special': // 堅守の構え
                                log(`${caster.name}は${skill.name}をとった！`);
                                caster.buffs.provoke = 3;
                                caster.statusEffects.regeneration = {
                                    turns: 3
                                };
                                flashCard(caster, 'yellow');
                                log(`${caster.name}は敵の注意を引きつけ、傷が再生し始めた！`);
                                break;
                            case 'party_restore_growth': // サンクチュアリ
                                log(`${caster.name}は${skill.name}を唱えた！聖なる光がパーティを包み込む！`);
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) {
                                        animateStatChange(p, 'hp', p.maxHp, 'increase'); // 全回復
                                        p.statusEffects = {}; // 状態異常回復
                                        if (p !== caster) animateStatChange(p, 'height', skill.growth, 'increase'); // 身長アップ
                                    }
                                });
                                break;
                                // 新キャラクタースキル
                            case 'status_magic': // ポイズンミスト
                                if (skill.effect === 'poison') {
                                    target.statusEffects.poison = {
                                        turns: 3
                                    };
                                    flashCard(target, 'yellow');
                                    log(`${caster.name}の${skill.name}！ ${target.name}は毒状態になった！`);
                                }
                                break;
                            case 'evade_provoke': // スポットライト
                                caster.buffs.provoke = 3;
                                caster.buffs.evade_up = 3;
                                flashCard(caster, 'yellow');
                                log(`${caster.name}は${skill.name}を浴びて、敵の注目と視線を集めた！`);
                                break;
                            case 'party_buff': // アンコール
                                log(`${caster.name}の${skill.name}！ 仲間たちの攻撃力が上がった！`);
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) {
                                        p.buffs.atk_up = 3;
                                        flashCard(p, 'yellow');
                                    }
                                });
                                break;
                            case 'party_buff_special': // センターオブステージ
                                log(`${caster.name}は${skill.name}に立った！ パーティの士気が最高潮に達した！`);
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) {
                                        p.buffs.atk_up = 3;
                                        p.buffs.agi_up = 3;
                                        flashCard(p, 'yellow');
                                    }
                                });
                                break;
                            case 'hp_cost_physical': // 居合, 無明の一閃
                                const samuraiDamage = calculateDamage(caster, target, skill);
                                await dealDamage(target, samuraiDamage);
                                log(`${caster.name}は${skill.name}を放った！ ${target.name}に${samuraiDamage}のダメージ！`);
                                break;
                            case 'self_buff_samurai': // 明鏡止水
                                caster.buffs.atk_up = 3;
                                log(`${caster.name}は${skill.name}の構え。精神を研ぎ澄まし、攻撃力が上がった！`);
                                break;
                            case 'def_ignore_physical': // 破砕拳
                                const monkDamage = calculateDamage(caster, target, skill);
                                await dealDamage(target, monkDamage);
                                log(`${caster.name}の${skill.name}！ ${target.name}に${monkDamage}の防御無視ダメージ！`);
                                break;
                            case 'growth_ally': // 成長促進剤
                                await animateStatChange(target, 'height', skill.power, 'increase');
                                flashCard(target, 'yellow');
                                log(`${caster.name}は${target.name}に${skill.name}を投与した！ ${target.name}の体が巨大化した！(身長+${skill.power}cm)`);
                                break;
                            case 'shrink_ally': // 縮小薬
                                await animateStatChange(target, 'height', -skill.power, 'decrease');
                                flashCard(target, 'yellow');
                                log(`${caster.name}は${target.name}に${skill.name}を投与した！ 身長が${skill.power}cm縮んだ！`);
                                break;
                            case 'status_ailment_multi': // 衰弱ガス, パンデミック
                                log(`${caster.name}は${skill.name}を散布した！`);
                                const ailmentTargets = Array.isArray(target) ? target : [target];
                                for (const t of ailmentTargets) {
                                    const effect = skill.effects[Math.floor(Math.random() * skill.effects.length)];
                                    let effectName = '';
                                    if (effect === 'poison') {
                                        t.statusEffects.poison = { // 敵に状態異常を付与
                                            turns: 3
                                        };
                                        effectName = '毒';
                                    } else if (effect === 'paralysis') {
                                        t.statusEffects.paralysis = true;
                                        effectName = '麻痺';
                                    } else if (effect === 'slow') {
                                        t.statusEffects.slow = { // 敵に状態異常を付与
                                            turns: 3
                                        };
                                        effectName = '鈍化';
                                    }
                                    flashCard(t, 'yellow');
                                    log(`${t.name}は${effectName}状態になった！`);
                                }
                                break;
                            case 'gambling_damage': // ダーツショット
                                const roll = Math.random();
                                let damageMultiplier = 1.0;
                                let message = "";
                                if (roll < 0.1) { // 10%でミス
                                    damageMultiplier = 0;
                                    message = "しかし、ダーツは大きく外れてしまった！";
                                } else if (roll < 0.5) { // 40%で通常ヒット
                                    damageMultiplier = 1.2;
                                    message = `${target.name}にヒット！`;
                                } else if (roll < 0.9) { // 40%でクリティカル
                                    damageMultiplier = 2.5;
                                    message = `クリティカルヒット！ ${target.name}に大ダメージ！`;
                                } else { // 10%でミラクルヒット
                                    damageMultiplier = 4.0;
                                    message = `ミラクルヒット！ ${target.name}に超特大ダメージ！`;
                                }
                                const gamblingDamage = calculateDamage(caster, target, {...skill,
                                    power: damageMultiplier
                                });
                                log(`${caster.name}の${skill.name}！ ${message}`);
                                if (gamblingDamage > 0) await dealDamage(target, gamblingDamage);
                                break;
                            case 'gambling_support': // ラッキースター
                                const supportRoll = Math.random();
                                log(`${caster.name}は${target.name}に${skill.name}を祈った！`);
                                if (supportRoll < 0.4) { // 40% HP回復
                                    const healAmount = Math.floor(target.maxHp * (Math.random() * 0.4 + 0.2)); // 20-60%
                                    await animateStatChange(target, 'hp', healAmount, 'increase');
                                    showDamagePopup(target, healAmount, true);
                                    log(`幸運の星が輝き、${target.name}のHPが${healAmount}回復した！`);
                                } else if (supportRoll < 0.7) { // 30% MP回復
                                    const mpAmount = Math.floor(target.maxMp * (Math.random() * 0.5 + 0.3)); // 30-80%
                                    await animateStatChange(target, 'mp', mpAmount, 'increase');
                                    log(`幸運の星が輝き、${target.name}のMPが${mpAmount}回復した！`);
                                } else if (supportRoll < 0.9) { // 20% 攻撃バフ
                                    target.buffs.atk_up = 3;
                                    log(`幸運の星が輝き、${target.name}の攻撃力が上がった！`);
                                } else { // 10% 身長アップ
                                    const growthAmount = Math.floor(Math.random() * 21) + 10; // 10-30cm
                                    await animateStatChange(target, 'height', growthAmount, 'increase');
                                    log(`幸運の星が輝き、${target.name}の身長が${growthAmount}cm伸びた！`);
                                }
                                flashCard(target, 'yellow');
                                break;
                            case 'gambling_all_in': // オールイン
                                const allInRoll = Math.random();
                                log(`${caster.name}は${skill.name}！全てを賭けた！`);
                                if (allInRoll < 0.4) { // 40% 敵全体にダメージ
                                    log("賭けは成功！敵全体にダメージ！");
                                    for (const t of target) {
                                        const damage = calculateDamage(caster, t, {...skill,
                                            power: 1.5
                                        });
                                        await dealDamage(t, damage);
                                    }
                                } else if (allInRoll < 0.6) { // 20% 味方全体を小回復
                                    log("悪くない！味方全体が少し回復した！");
                                    for (const p of gameState.party) {
                                        if (p.currentHp > 0) await animateStatChange(p, 'hp', Math.floor(p.maxHp * 0.2), 'increase');
                                    }
                                } else if (allInRoll < 0.9) { // 30% 何も起こらない
                                    log("…しかし、何も起こらなかった。");
                                } else { // 10% 自分がダメージ
                                    log("賭けに負けた！術者にダメージ！");
                                    await dealDamage(caster, Math.floor(caster.maxHp * 0.25));
                                }
                                break;
                            case 'gambling_jackpot': // ジャックポット
                                log(`${caster.name}は${skill.name}を狙う！`);
                                if (Math.random() < 0.2) { // 20%で成功
                                    log("大当たり！ジャックポット！パーティが完全に回復し、強化された！");
                                    for (const p of gameState.party) {
                                        if (p.currentHp > 0) {
                                            await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                            await animateStatChange(p, 'mp', p.maxMp, 'increase');
                                            p.buffs.atk_up = 3;
                                            p.buffs.protect = 3;
                                            flashCard(p, 'green');
                                        }
                                    }
                                } else {
                                    log("…しかし、何も起こらなかった。MPだけが無駄になった！");
                                }
                                break;
                            case 'reaper_instant_death': // 魂狩り
                                log(`${caster.name}は${skill.name}を唱えた…！`);
                                if (!target.isBoss && Math.random() < 0.15) { // 15%で即死
                                    log(`鎌が${target.name}の魂を捉えた！`);
                                    await dealDamage(target, target.currentHp);
                                } else {
                                    log("…しかし、魂を狩るには至らなかった！");
                                    const failDamage = calculateDamage(caster, target, skill);
                                    await dealDamage(target, failDamage);
                                }
                                break;
                            case 'reaper_height_scaling': // 影の一撃
                                const heightDiff = Math.max(0, caster.initialHeight - caster.height);
                                const bonusDamage = heightDiff * 2; // 1cmあたり2ダメージ追加
                                const baseDamage = calculateDamage(caster, target, skill);
                                const totalDamage = baseDamage + bonusDamage;
                                log(`${caster.name}の${skill.name}！`);
                                await dealDamage(target, totalDamage);
                                log(`${target.name}に${totalDamage}のダメージ！`);
                                break;
                            case 'reaper_soul_exchange': // 魂の交換
                                const hpCost = Math.floor(caster.currentHp / 2);
                                await dealDamage(caster, hpCost);
                                const healAmount = hpCost * 1.5; // 削ったHPの1.5倍回復
                                const mpAmount = hpCost * 1.0; // 削ったHPと同じだけMP回復
                                log(`${caster.name}は${skill.name}で自らの魂を分け与えた！`);
                                await animateStatChange(target, 'hp', Math.floor(healAmount), 'increase');
                                await animateStatChange(target, 'mp', Math.floor(mpAmount), 'increase');
                                log(`${target.name}のHPとMPが回復した！`);
                                break;
                            case 'reaper_height_scaling_multi': // 冥府の鎌
                                log(`${caster.name}は${skill.name}を振るった！`);
                                const heightDiffMulti = Math.max(0, caster.initialHeight - caster.height);
                                const bonusDamageMulti = heightDiffMulti * 1; // 全体攻撃なのでボーナスは少し控えめ
                                const damagePromisesReaper = [];
                                for (const t of target) {
                                    const totalDamageMulti = calculateDamage(caster, t, skill) + bonusDamageMulti;
                                    damagePromisesReaper.push(dealDamage(t, totalDamageMulti));
                                }
                                await Promise.all(damagePromisesReaper);
                                break;
                            case 'summon_golem': // ゴーレム召喚
                                const golemHp = Math.floor(caster.maxHp * skill.power);
                                gameState.golem = {
                                    name: 'ゴーレム',
                                    hp: golemHp,
                                    maxHp: golemHp
                                };
                                log(`${caster.name}は${skill.name}を唱えた！パーティの前にゴーレムが現れた！`);
                                updatePartyStatus();
                                flashCard(caster, 'yellow');
                                break;
                                // ネクロマンサー
                            case 'necro_magic':
                                const killBonus = Math.floor(gameState.killCount / 5); // 5体倒すごとに威力アップ
                                const necroSkill = {...skill,
                                    power: skill.power + killBonus * 0.2
                                };
                                if (Array.isArray(target)) { // 全体攻撃
                                    const damagePromisesNecro = [];
                                    log(`${caster.name}は${skill.name}を放った！`);
                                    for (const t of target) {
                                        damagePromisesNecro.push(dealDamage(t, calculateDamage(caster, t, necroSkill)));
                                    }
                                    await Promise.all(damagePromisesNecro);
                                } else { // 単体攻撃
                                    const damage = calculateDamage(caster, target, necroSkill);
                                    await dealDamage(target, damage);
                                    log(`${caster.name}は${skill.name}を放った！ ${target.name}に${damage}のダメージ！`);
                                }
                                break;
                            case 'revive_full': // リザレクション
                                if (target.currentHp > 0) {
                                    log(`しかし、${target.name}は戦闘不能ではなかった！`);
                                    caster.currentMp += skill.cost; // MPを消費しない
                                    break;
                                }
                                log(`${caster.name}は${skill.name}を唱えた！`);
                                await animateStatChange(target, 'hp', target.maxHp, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}は完全な状態で戦線に復帰した！`);
                                break;
                                // ネクロマンサー MPドレイン
                            case 'mp_drain':
                                const drainDamage = calculateDamage(caster, target, skill);
                                await dealDamage(target, drainDamage);
                                const mpDrainAmount = Math.max(1, Math.floor(drainDamage * 0.2));
                                await animateStatChange(caster, 'mp', mpDrainAmount, 'increase');
                                log(`${caster.name}は${skill.name}で${target.name}に${drainDamage}のダメージを与え、MPを${mpDrainAmount}吸収した！`);
                                break;
                                // ガーディアン
                            case 'guardian_wall':
                                const wallHp = Math.floor(caster.maxHp * (caster.buffs.guardian_high ? skill.power * 1.5 : skill.power));
                                gameState.walls.push({
                                    targetId: gameState.party.indexOf(target),
                                    hp: wallHp,
                                    maxHp: wallHp
                                });
                                if (caster.buffs.guardian_high) delete caster.buffs.guardian_high;
                                log(`${caster.name}は${target.name}の前に${skill.name}を展開した！`);
                                break;
                            case 'guardian_wall_party':
                                log(`${caster.name}は${skill.name}を展開した！`);
                                gameState.party.forEach((p, index) => {
                                    if (p.currentHp > 0) {
                                        const wallHp = Math.floor(caster.maxHp * skill.power);
                                        gameState.walls.push({
                                            targetId: index,
                                            hp: wallHp,
                                            maxHp: wallHp
                                        });
                                    }
                                });
                                break;
                            case 'self_buff_guardian':
                                caster.buffs.protect = 3;
                                caster.buffs.guardian_high = true;
                                log(`${caster.name}は${skill.name}を発動！防御力が上がり、次のウォールが強化される！`);
                                break;
                                // トラブルメーカー
                            case 'trouble_maker_box':
                                // 実装は handleTroubleMakerBox に集約
                                await handleTroubleMakerBox(caster);
                                break;
                            case 'trouble_maker_debuff':
                                const debuffDamage = calculateDamage(caster, target, skill);
                                await dealDamage(target, debuffDamage);
                                log(`${caster.name}は${skill.name}で${target.name}に${debuffDamage}のダメージを与えた！`);
                                if (Math.random() < 0.4) { // 40%の確率でデバフ発動
                                    if (Math.random() < 0.5) {
                                        target.buffs.atk_down = 3;
                                        log(`さらに${target.name}の攻撃力が下がった！`);
                                    } else {
                                        target.buffs.def_down = 3;
                                        log(`さらに${target.name}の防御力が下がった！`);
                                    }
                                    flashCard(target, 'yellow');
                                }
                                break;
                            case 'self_buff_trouble':
                                caster.buffs.trouble_check = true;
                                log(`${caster.name}は${skill.name}を開始！次のハプニングボックスはきっとうまくいく！`);
                                break;
                            case 'trouble_maker_miracle':
                                handleTroubleMakerMiracle(caster);
                                break;
                                // シスター
                            case 'regeneration_ally':
                            case 'regeneration_party':
                                const regenTargets = skill.targetType === 'party' ? gameState.party.filter(p => p.currentHp > 0) : [target];
                                log(`${caster.name}は${skill.name}を唱えた！`);
                                regenTargets.forEach(t => {
                                    t.statusEffects.regeneration = {
                                        turns: 3
                                    };
                                    flashCard(t, 'green');
                                    log(`${t.name}は聖なる光に包まれ、傷が再生し始めた！`);
                                });
                                break;
                        }
                    }

                    async function handleItem(caster, target, item, isInternalCall = false) {
                        const itemInfo = itemBlueprints[item.id];
                        log(`${caster.name}は${itemInfo.name}を使った！`);

                        switch (itemInfo.effect) {
                            case 'shrink': // リトルスープの特殊処理
                                if (target && target.isEnemy) {
                                    // 敵に使った場合
                                    target.buffs = target.buffs || {};
                                    target.buffs.atk_down = 3;
                                    target.buffs.def_down = 3;
                                    flashCard(target, 'yellow');
                                    log(`${target.name}は小さくなって弱々しくなった！攻撃力と防御力が低下！`);
                                } else {
                                    // 味方に使った場合
                                    await animateStatChange(target, 'height', -itemInfo.power, 'decrease');
                                    log(`${target.name}の身長が${itemInfo.power}cm縮んだ！`);
                                }
                                break;
                            case 'heal_percent':
                                if (itemInfo.target === 'party') {
                                    log(`味方全員のHPが回復した！`);
                                    for (const p of gameState.party) {
                                        if (p.currentHp > 0) {
                                            const healAmount = Math.floor(p.maxHp * itemInfo.power);
                                            await animateStatChange(p, 'hp', healAmount, 'increase');
                                            flashCard(p, 'green');
                                            showDamagePopup(p, healAmount, true);
                                        }
                                    }
                                } else {
                                    const healAmount = Math.floor(target.maxHp * itemInfo.power);
                                    await animateStatChange(target, 'hp', healAmount, 'increase');
                                    flashCard(target, 'green');
                                    showDamagePopup(target, healAmount, true);
                                    log(`${target.name}のHPが${healAmount}回復した！`);
                                }
                                break;
                            case 'reset_height':
                                const resetDiff = target.initialHeight - target.height;
                                await animateStatChange(target, 'height', resetDiff, 'increase');
                                flashCard(target, 'yellow');
                                log(`${target.name}の身長が元に戻った！`);
                                break;
                            case 'set_height':
                                const setDiff = itemInfo.power - target.height;
                                const type = setDiff < 0 ? 'decrease' : 'increase';
                                await animateStatChange(target, 'height', setDiff, type); // Await height animation
                                flashCard(target, 'yellow'); // Flash the card itself
                                log(`${target.name}の身長が${itemInfo.power}cmになった！`);
                                break;
                            case 'damage':
                                if (itemInfo.target === 'enemies') {
                                    const damagePromisesItem = [];
                                    for (const t of target) {
                                        damagePromisesItem.push(dealDamage(t, itemInfo.power));
                                    }
                                    log(`敵全体に${itemInfo.power}のダメージ！`);
                                    await Promise.all(damagePromisesItem);
                                } else {
                                    await dealDamage(target, itemInfo.power); // Await damage
                                    log(`${target.name}に${itemInfo.power}の特大ダメージ！`);
                                }
                                break;
                            case 'restore_mp_full':
                                const mpToRestore = target.maxMp - target.currentMp;
                                await animateStatChange(target, 'mp', mpToRestore, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}のMPが全回復した！`);
                                break;
                            case 'increase_max_hp':
                                target.maxHp += itemInfo.power;
                                await animateStatChange(target, 'hp', itemInfo.power, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}の最大HPが${itemInfo.power}上がった！`);
                                break;
                            case 'increase_max_mp':
                                target.maxMp += itemInfo.power;
                                await animateStatChange(target, 'mp', itemInfo.power, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}の最大MPが${itemInfo.power}上がった！`);
                                break;
                            case 'increase_height_and_initial':
                                let growthAmount = itemInfo.power;
                                if (target.height < target.initialHeight) {
                                    // 初期値より低い場合、まず初期値に戻す分の増加量を加える
                                    growthAmount += (target.initialHeight - target.height);
                                }
                                await animateStatChange(target, 'height', growthAmount, 'increase');
                                flashCard(target, 'green');
                                log(`${target.name}の体が大きく成長した！(身長+${growthAmount}cm)`);
                                break;
                            case 'revive':
                                if (target.currentHp > 0) {
                                    log(`しかし、${target.name}は戦闘不能ではなかった！`);
                                    return false; // アイテム使用失敗
                                }
                                const reviveHealAmount = Math.floor(target.maxHp * itemInfo.power);
                                target.currentHp = 0; // HPを0にリセットしてから回復アニメーション
                                await animateStatChange(target, 'hp', reviveHealAmount, 'increase');
                                flashCard(target, 'green');
                                showDamagePopup(target, reviveHealAmount, true);
                                log(`${target.name}は意識を取り戻した！`);
                                break;
                            case 'shrink_party_and_debuff_enemies':
                                log(`シュリンクアロマの香りが戦場に広がる！`);
                                // 味方全員の身長を縮める
                                for (const p of gameState.party) {
                                    if (p.currentHp > 0) {
                                        await animateStatChange(p, 'height', -itemInfo.power, 'decrease');
                                    }
                                }
                                // 敵全員にデバフを付与
                                for (const e of gameState.enemies) {
                                    if (e.currentHp > 0) {
                                        e.statusEffects.stat_down = true;
                                    }
                                }
                                log(`味方の体が少し縮み、敵が大幅に弱体化した！`);
                                break;
                        }
                        // 献身の内部呼び出しではUIを更新しない
                        if (isInternalCall) {
                            return;
                        }
                        updatePartyStatus(); // Refresh all cards after animations
                        updateEnemyStatus(); // Enemy status doesn't have number animation, so it can be updated immediately
                        return true; // アイテム使用成功
                    }

                    async function handleTroubleMakerBox(caster) {
                        log(`${caster.name}は${caster.skills[0].name}を開けた！`);
                        const isChecked = caster.buffs.trouble_check;
                        const successRate = isChecked ? 0.9 : 0.6; // ばっちりチェックで成功率90%
                        if (isChecked) delete caster.buffs.trouble_check;

                        if (Math.random() < successRate) {
                            // 成功

                            // 大あたり抽選 (ばっちりチェック中のみ)
                            if (isChecked && Math.random() < 0.1) { // 10%の確率で大あたり
                                log("箱から眩い光が！これは…大当たりだ！");
                                const isBossBattle = gameState.enemies.some(e => e.isBoss);
                                if (isBossBattle) {
                                    const boss = gameState.enemies.find(e => e.isBoss);
                                    const damage = Math.floor(boss.maxHp * 0.5);
                                    log(`ボスの体に亀裂が走る！`);
                                    await dealDamage(boss, damage);
                                } else {
                                    log("敵が一瞬で塵と化した！");
                                    const damagePromises = [];
                                    for (const enemy of gameState.enemies.filter(e => e.currentHp > 0)) {
                                        damagePromises.push(dealDamage(enemy, enemy.currentHp));
                                    }
                                    await Promise.all(damagePromises);
                                }
                                return; // 大あたりの場合はここで処理終了
                            }

                            // 通常の成功効果
                            const goodEffects = [
                                async() => {
                                    log("箱から光が溢れ、敵全体に大ダメージ！");
                                    const damagePromisesBox = gameState.enemies.filter(e => e.currentHp > 0).map(enemy => dealDamage(enemy, 150 + caster.atk * 2));
                                    await Promise.all(damagePromisesBox);
                                },
                                async() => {
                                    log("箱からお菓子が飛び出し、味方全体が回復した！"); // 回復は1人ずつアニメーション
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        await animateStatChange(p, 'hp', Math.floor(p.maxHp * 0.5), 'increase');
                                    }
                                }, {
                                    name: "あたり",
                                    func: () => {
                                        log("箱から虹色のオーラが！味方全体が強化され、傷が癒えていく！");
                                        gameState.party.forEach(p => {
                                            if (p.currentHp > 0) {
                                                p.buffs.atk_up = 3;
                                                p.statusEffects.regeneration = {
                                                    turns: 3
                                                };
                                                flashCard(p, 'yellow');
                                            }
                                        });
                                    }
                                },
                                () => {
                                    log("箱から怪しいガスが！敵全体が弱体化した！");
                                    gameState.enemies.forEach(e => {
                                        if (e.currentHp > 0) e.statusEffects.stat_down = true;
                                    });
                                }
                            ];
                            const chosenGoodEffect = goodEffects[Math.floor(Math.random() * goodEffects.length)];
                            await (typeof chosenGoodEffect === 'function' ? chosenGoodEffect() : chosenGoodEffect.func());
                        } else {
                            // 失敗
                            const badEffects = [{
                                name: "shrink",
                                func: async() => {
                                    log("箱から黒い煙が！味方全体が縮んでしまった！");
                                    for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                        await animateStatChange(p, 'height', -30, 'decrease');
                                    }
                                }
                            }, {
                                name: "tiny_damage",
                                func: async() => {
                                    const randomEnemy = gameState.enemies.filter(e => e.currentHp > 0)[Math.floor(Math.random() * gameState.enemies.filter(e => e.currentHp > 0).length)];
                                    if (randomEnemy) {
                                        log("箱からかわいい小動物が飛び出して、敵にかみついた！");
                                        await dealDamage(randomEnemy, 1);
                                    } else {
                                        log("箱からかわいい小動物が飛び出したが、何事もなかった。");
                                    }
                                }
                            }, {
                                name: "strip_all",
                                func: () => {
                                    log("箱から妖しい光が！ なんと味方全員が脱衣状態になってしまった！");
                                    gameState.party.forEach(p => {
                                        if (p.currentHp > 0 && p.role !== 'ナイト' && p.role !== 'サムライ' && p.role !== '聖女') {
                                            p.statusEffects.stripped = {
                                                turns: 0
                                            };
                                        }
                                    });
                                }
                            }, ];
                            const chosenEffect = badEffects[Math.floor(Math.random() * badEffects.length)];
                            await chosenEffect.func();
                        }
                    }

                    async function handleTroubleMakerMiracle(caster) {
                        log(`${caster.name}は${caster.skills.find(s => s.type === 'trouble_maker_miracle').name}を使った！`);
                        if (Math.random() < 0.05) { // 5%で失敗
                            log("…しかし、何も起こらなかった！");
                        } else {
                            log("奇跡の光がパーティを包む！");
                            for (const p of gameState.party.filter(p => p.currentHp > 0)) {
                                await animateStatChange(p, 'hp', p.maxHp, 'increase');
                                await animateStatChange(p, 'mp', p.maxMp, 'increase');
                                p.buffs.atk_up = 3;
                                p.buffs.protect = 3;
                                flashCard(p, 'green');
                            }
                            log("味方全体が全回復し、強化された！");
                        }
                    }


                    async function enemyTurn(enemy) {
                        log(`${enemy.name}のターン`);

                        // 敵のバフ・デバフターン経過処理
                        if (enemy.buffs) {
                            Object.keys(enemy.buffs).forEach(key => {
                                enemy.buffs[key]--;
                                if (enemy.buffs[key] <= 0) {
                                    delete enemy.buffs[key];
                                    let buffName = '';
                                    if (key === 'atk_down') buffName = '攻撃力低下';
                                    else if (key === 'def_down') buffName = '防御力低下';
                                    if (buffName) {
                                        log(`${enemy.name}の${buffName}効果が切れた。`);
                                    }
                                }
                            });
                        }

                        // HPが低い場合、70%の確率で自己再生スキルを優先的に使用する
                        const regenSkill = enemy.skills.find(s => s.name === '自己再生');
                        const canUseRegen = regenSkill && enemy.regenUses < 3; // 使用回数が3回未満かチェック

                        if (canUseRegen && enemy.currentHp / enemy.maxHp < 0.5 && Math.random() < 0.7) {
                            enemy.regenUses++; // 使用回数をインクリメント
                            await regenSkill.func(enemy);
                        } else if (enemy.skills && enemy.skills.length > 0 && Math.random() < 0.6) {
                            // スキル使用判定 (自己再生以外のスキル)
                            const skill = enemy.skills[Math.floor(Math.random() * enemy.skills.length)];
                            // 自己再生スキルが選ばれた場合でも、HPが50%以上なら通常通り使用する
                            if (skill.name === '自己再生' && enemy.currentHp / enemy.maxHp >= 0.5 && enemy.regenUses < 3) {
                                enemy.regenUses++; // 使用回数をインクリメント
                                await skill.func(enemy);
                            } else if (skill.name === '自己再生') {
                                // 自己再生を使おうとしたが条件を満たさなかった場合 -> 通常攻撃
                                await defaultEnemyAttack(enemy, findTarget(enemy));
                            } else if (skill.name !== '自己再生') { // 自己再生以外のスキルは通常通り使用
                                await skill.func(enemy);
                            } else {
                                // HP50%未満で自己再生が選ばれたが、優先使用の抽選に漏れた場合 -> 通常攻撃
                                const target = findTarget(enemy);
                                await defaultEnemyAttack(enemy, target);
                            }
                        } else {
                            // 通常攻撃
                            const target = findTarget(enemy);
                            await defaultEnemyAttack(enemy, target);
                        }

                        updatePartyStatus(); // Refresh all cards after animations
                        updateEnemyStatus();

                        // ターン終了時の毒ダメージ
                        if (enemy.statusEffects && enemy.statusEffects.poison) {
                            const poisonDamage = Math.max(1, Math.floor(enemy.maxHp * 0.05));
                            log(`${enemy.name}は毒のダメージを受けている！`);
                            await dealDamage(enemy, poisonDamage);
                            updateEnemyStatus();
                        }

                        // ターン終了時の自然治癒
                        if (enemy.statusEffects && enemy.statusEffects.regeneration) {
                            const healAmount = Math.max(1, Math.floor(enemy.maxHp * 0.08));
                            log(`${enemy.name}の傷が再生していく！`); // 敵の回復ログ
                            await dealDamage(enemy, -healAmount, true); // dealDamageを回復に利用
                            updateEnemyStatus();
                        }

                        setTimeout(() => {
                            gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.turnOrder.length;
                            nextTurn();
                        }, 1000);
                    }

                    async function defaultEnemyAttack(enemy, target) {
                        const damage = calculateDamage(enemy, target);
                        await dealDamage(target, damage);
                        log(`${enemy.name}の攻撃！ ${target.name}に${damage}のダメージ！`);
                    }

                    function findTarget(enemy) {
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);

                        // ガーディアンのウォール判定
                        const wallsOnParty = gameState.walls.map((wall, index) => ({...wall,
                            wallIndex: index
                        })).filter(wall => aliveParty.some(p => gameState.party.indexOf(p) === wall.targetId));

                        if (wallsOnParty.length > 0) {
                            // 複数のウォールがある場合、ランダムで1つをターゲットにする
                            const randomWall = wallsOnParty[Math.floor(Math.random() * wallsOnParty.length)];
                            return {...randomWall,
                                isWall: true
                            };
                        }


                        // ゴーレムが召喚されていれば最優先でターゲットにする
                        if (gameState.golem && gameState.golem.hp > 0) {
                            return gameState.golem;
                        }

                        // 「かばう」状態のキャラがいれば最優先
                        const coveringMember = aliveParty.find(p => p.buffs && p.buffs.cover);
                        if (coveringMember) {
                            return coveringMember;
                        }

                        updateHate();
                        const totalHate = aliveParty.reduce((sum, char) => sum + char.hate, 0);
                        let random = Math.random() * totalHate;
                        for (const char of aliveParty) {
                            random -= char.hate;
                            if (random <= 0) return char;
                        }
                        return aliveParty[0];
                    }

                    function calculateDamage(attacker, defender, skill = null) {
                        const attackerStats = getEffectiveStats(attacker);
                        let skillPowerMultiplier = 1.0;
                        let baseAtk;

                        // 魔法攻撃の場合、身長補正を無視し、バフのみを適用した攻撃力を計算
                        if (skill && (skill.type === 'magic' || skill.type.includes('magic'))) {
                            baseAtk = attacker.atk; // 素の攻撃力
                            if (attacker.buffs && attacker.buffs.atk_up) {
                                baseAtk *= 1.5; // 攻撃力アップバフは適用
                            }
                            // リーパーの脱衣デバフも適用
                            if (attacker.statusEffects && attacker.statusEffects.stripped && attacker.role === 'リーパー') {
                                baseAtk *= 0.5;
                            }
                        } else {
                            // 物理攻撃や通常攻撃の場合は、身長補正を含む攻撃力を使用
                            baseAtk = attackerStats.atk;
                        }

                        // 渾身斬りのクリティカル判定
                        if (skill && skill.name === '渾身斬り' && Math.random() < 0.3) {
                            log('会心の一撃！');
                            skillPowerMultiplier = 3; // ダメージ計算用の倍率を変更
                        }

                        let baseDamage = skill ? baseAtk * skill.power * skillPowerMultiplier : baseAtk;
                        let effectiveDefense = 0;

                        // 防御側の防御力を決定
                        if (defender === gameState.golem) {
                            // ゴーレムの場合、防御力は0とする
                            effectiveDefense = 0;
                        } else if (defender.isEnemy) {
                            // 敵の場合、攻撃タイプに応じて物理防御力か魔法防御力を適用
                            let attackType = 'physical';
                            if (skill && skill.type === 'magic') {
                                attackType = 'magic'; // スキルが魔法なら魔法攻撃
                            } else if (!skill && attacker.buffs && attacker.buffs.atk_up) {
                                // エンチャント(atk_up)中の通常攻撃は魔法攻撃扱い
                                attackType = 'magic';
                            }
                            const defenderStats = getEffectiveStats(defender);
                            effectiveDefense = (attackType === 'magic') ? defenderStats.mDef : defenderStats.pDef;
                        } else {
                            // 味方の場合、getEffectiveStatsで計算された防御力を使用し、防御状態を考慮
                            const defenderStats = getEffectiveStats(defender);
                            effectiveDefense = defenderStats.def;
                            if (defender.isDefending) {
                                effectiveDefense *= 2;
                            }
                            // ダンサーの回避判定
                            if (defender.buffs && defender.buffs.evade_up && Math.random() < 0.7) { // 70%で回避
                                log(`${defender.name}は華麗に攻撃をかわした！`);
                                return 0;
                            }
                        }
                        // モンクの破砕拳は防御無視
                        if (skill && skill.type === 'def_ignore_physical') {
                            effectiveDefense = 0;
                        }

                        // 溜め攻撃の処理 (物理攻撃のみ)
                        if (attacker.isCharging && (!skill || skill.type === 'physical')) {
                            baseDamage *= 2.5;
                            attacker.isCharging = false;
                        }

                        // ダメージから防御力を減算
                        baseDamage -= effectiveDefense;

                        return Math.max(1, Math.floor(baseDamage * (Math.random() * 0.2 + 0.9))); // ダメージは最低1
                    }

                    async function dealDamage(target, amount, isHeal = false) {
                        // ターゲットがウォールの場合
                        if (target.isWall) {
                            const wall = gameState.walls[target.wallIndex];
                            wall.hp = Math.max(0, wall.hp - amount);
                            log(`防壁が攻撃を受け止めた！ (防壁の残り耐久値: ${wall.hp})`);
                            if (wall.hp <= 0) {
                                log("防壁は砕け散った！");
                                gameState.walls.splice(target.wallIndex, 1);
                            }
                            return;
                        }
                        if (amount === 0) return; // 回避などでダメージ0の場合は何もしない
                        if (isHeal) {
                            // 回復の場合
                            if (!target.isEnemy) await animateStatChange(target, 'hp', -amount, 'increase');
                            else target.currentHp = Math.min(target.maxHp, target.currentHp - amount);
                            flashCard(target, 'green');
                            showDamagePopup(target, -amount, true);
                            return;
                        }
                        // ターゲットがゴーレムの場合
                        if (target === gameState.golem) {
                            gameState.golem.hp = Math.max(0, gameState.golem.hp - amount);
                            showDamagePopup(target, amount, false);
                            flashCard(target, 'red');
                            updatePartyStatus();
                            if (gameState.golem.hp <= 0) log('ゴーレムは砕け散った！');
                        } else if (!target.isEnemy) { // ターゲットが味方の場合 (敵からの攻撃、自傷など)
                            await animateStatChange(target, 'hp', -amount, 'decrease');
                        } else { // ターゲットが敵の場合
                            target.currentHp = Math.max(0, target.currentHp - amount);
                        }
                        flashCard(target, 'red');
                        showDamagePopup(target, amount, false);
                        if (target.currentHp <= 0 && target !== gameState.golem) {
                            if (!target.isEnemy && gameState.gameMode === 'enjoy') {
                                log(`${target.name}は倒れた...しかし、不思議な力ですぐに立ち上がった！`);
                                // HPを即座に全回復させる
                                target.currentHp = target.maxHp;
                                flashCard(target, 'green');
                                updatePartyStatus(); // UIを更新
                            } else {
                                log(`${target.name}は倒れた...`);
                                if (target.isEnemy) {
                                    const card = document.getElementById(`enemy-card-${gameState.enemies.indexOf(target)}`);
                                    if (card) {
                                        card.classList.add('fade-out-down');
                                        setTimeout(() => card.remove(), 1000); // アニメーション後に要素を削除
                                    }
                                }
                            }
                        }
                    }

                    function showDamagePopup(target, amount, isHeal = false) {
                        const targetCard = target.isEnemy ?
                            document.getElementById(`enemy-card-${gameState.enemies.indexOf(target)}`) :
                            partyContainer.children[gameState.party.indexOf(target)];
                        if (!targetCard) return;
                        if (target === gameState.golem) {
                            const summonerCard = Array.from(partyContainer.children).find(card => card.querySelector('.golem-card-inner'));
                            if (summonerCard) targetCard = summonerCard.querySelector('.golem-card-inner');
                        }

                        const popup = document.createElement('div');
                        popup.textContent = amount;
                        popup.className = `damage-popup ${isHeal ? 'heal-popup' : ''}`;
                        targetCard.appendChild(popup);
                        setTimeout(() => popup.remove(), 1500);
                    }

                    function endBattle(isVictory) {
                        gameState.inBattle = false;

                        // ゴーレムが残っている場合の処理
                        if (gameState.golem && gameState.golem.hp > 0) {
                            const summoner = gameState.party.find(p => p.role === 'サモナー' && p.currentHp > 0);
                            if (summoner) {
                                const mpRecovery = Math.floor(gameState.golem.hp / 5);
                                if (mpRecovery > 0) {
                                    log("ゴーレムは役目を終えて帰還した。");
                                    animateStatChange(summoner, 'mp', mpRecovery, 'increase');
                                    log(`${summoner.name}のMPが${mpRecovery}回復した！`);
                                }
                            }
                            gameState.golem = null;
                        }

                        dungeonCommands.classList.remove('hidden');
                        updateFloorDisplay();
                        battleCommands.classList.add('hidden');
                        gameState.party.forEach(p => {
                            p.buffs = {};
                            p.isDefending = false;
                            // 脱衣状態のみ持続させる
                            const wasStripped = p.statusEffects.stripped;
                            p.statusEffects = {}; // ファイター, ソーサラー, ナイト, メディック
                            if (wasStripped) p.statusEffects.stripped = wasStripped; // ターン数も引き継ぐ
                        });

                        if (isVictory) {
                            gameState.killCount += gameState.enemies.length; // 倒した敵の数を加算

                            if (gameState.gameMode === 'monster_march') {
                                if (gameState.floor === 50) {
                                    showModal("完全踏破", "絶え間ない戦いの果てに、あなたはついにダンジョンの最奥に到達し、元凶を打ち破りました。その行軍は、伝説として語り継がれるでしょう。");
                                    gameState.gameOver = true;
                                    return;
                                }

                                log('敵を倒した！パーティ全員がレベルアップ！');
                                gameState.party.forEach(char => {
                                    if (char.currentHp > 0) levelUpCharacter(char, false); // UIは表示しない
                                });

                                const foundItems = [];
                                const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].battleOnly && !itemBlueprints[id].rare);
                                for (let i = 0; i < 3; i++) {
                                    const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                                    addItemToInventory(foundItemId);
                                    foundItems.push(itemBlueprints[foundItemId].name);
                                }
                                log(`さらに、 ${foundItems.join('、')} を手に入れた！`);
                            }
                            // 無限モードのボス撃破後
                            else if (gameState.gameMode === 'endless') {
                                showLevelUpModal(true); // 無限モード用のレベルアップモーダルを表示
                            } else if (gameState.gameMode === 'endgame' && gameState.floor === 1) {
                                showModal("ゲームクリア？", "あなたはダンジョンの入り口で待ち構えていたボスを打ち破りました！…これでよかったのでしょうか？");
                                gameState.gameOver = true;
                            } else if (gameState.floor === 30 && gameState.gameMode !== 'endless') {
                                let title = "ゲームクリア！";
                                let text = "おめでとう！あなたはダンジョンの最深部に到達し、ボスを打ち破りました！";

                                switch (gameState.gameMode) {
                                    case 'normal':
                                    case 'trial':
                                        text += "\nもしもの物語では、異なる結末があなたを待っているかもしれません。";
                                        break;
                                    case 'veterans':
                                        title = "歴戦の証";
                                        text = "歴戦の勇者たちは、その実力を見せつけ、ダンジョンを容易く踏破しました。しかし、彼女たちの本当の戦いは、まだ始まったばかりなのかもしれません。";
                                        break;
                                    case 'dwarves':
                                        title = "小さな英雄譚";
                                        text = "小さな体で、大きな困難を乗り越えた一行。彼女たちの勇気は、どんな巨人よりも雄大でした。";
                                        break;
                                    case 'brawl':
                                        title = "武闘の果てに";
                                        text = "戦い、戦い、そしてまた戦い…。武闘の宴の果てに、彼女たちは最強の称号を手にしました。その拳に宿るは、数多の強敵との記憶。";
                                        break;
                                    case 'solo':
                                        title = "孤独な覇者";
                                        text = `たった一人で、${gameState.party[0].name}はダンジョンを制覇しました。その強さは伝説となり、後世まで語り継がれるでしょう。`;
                                        break;
                                    case 'saint_march':
                                        title = "聖女の使命";
                                        text = "セレスティアはダンジョンの最深部に巣食う元凶を浄化しました。しかし、世界のどこかで穢れが生まれる限り、彼女の行進は終わりません。";
                                        // 聖女クリアフラグを保存
                                        const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                                        clearFlags.saintMarchCleared = true;
                                        localStorage.setItem('sizeDungeonClearFlags', JSON.stringify(clearFlags));
                                        break;
                                    case 'indecent':
                                        title = "恥辱の先の勝利";
                                        text = "数々の羞恥を乗り越え、彼女たちはついにボスを打ち破りました。この冒険のことは、きっと誰にも話せないでしょう…。";
                                        break;
                                    case 'fixed_path':
                                        title = "運命の踏破";
                                        text = "定められた道を乗り越え、一行はついに最深部に到達しました。これは運命だったのか、それとも自ら選び取った未来だったのか…。";
                                        break;
                                    case 'enjoy':
                                        title = "楽しい冒険の終わり";
                                        text = "どんな困難も笑顔で乗り越え、パーティはついにダンジョンを制覇しました！最高の冒険でしたね！";
                                        break;
                                }
                                showModal(title, text);
                                gameState.gameOver = true;
                            } else {
                                showLevelUpModal();
                            }
                        } else {
                            if (gameState.party.length === 1) {
                                const characterName = gameState.party[0].name;
                                showModal("ゲームオーバー", `${characterName}は力尽きてしまった...`);
                            } else {
                                showModal("ゲームオーバー", "パーティは全滅してしまった...");
                            }
                            gameState.gameOver = true;
                        }
                    }

                    function showModal(title, text) {
                        modalTitle.textContent = title;
                        modalText.textContent = text;
                        modal.classList.remove('hidden');
                    }

                    function showLevelUpModal(isEndless = false) {
                        log('敵を倒した！');
                        enemyContainer.innerHTML = '';
                        dungeonCommands.classList.add('hidden'); // 選択中はコマンドを隠す

                        levelUpPartyList.innerHTML = '';
                        // パーティが1人の場合は選択肢を出さずに即時レベルアップ
                        if (gameState.party.length === 1 && gameState.party[0].currentHp > 0) {
                            if (isEndless) {
                                levelUpCharacter(gameState.party[0], true, true);
                            } else {
                                levelUpCharacter(gameState.party[0]);
                            }
                            return;
                        }

                        gameState.party.forEach((char, index) => {
                            if (char.currentHp <= 0) return; // 戦闘不能のキャラは選択不可

                            const card = document.createElement('div');
                            card.className = 'p-4 border rounded-lg cursor-pointer hover:bg-yellow-100 hover:shadow-lg transition';
                            card.innerHTML = `
                        <p class="font-bold text-lg text-${char.themeColor}-700">${char.name}</p>
                        <p class="text-sm text-gray-600">${char.role}</p>
                    `;
                            card.onclick = () => {
                                if (isEndless) {
                                    levelUpCharacter(char, true, true);
                                } else {
                                    levelUpCharacter(char);
                                }
                            };
                            levelUpPartyList.appendChild(card);
                        });

                        levelUpModal.classList.remove('hidden');
                    }

                    function levelUpCharacter(character, showUI = true, isEndless = false) {
                        // ステータスアップ
                        character.maxHp += 5;
                        character.maxMp += 3;
                        character.atk += 1;
                        character.def += 1;
                        character.agi += 1;
                        character.level += 1;
                        // HP/MPを全回復
                        character.currentHp = character.maxHp;
                        character.currentMp = character.maxMp;

                        character.skills.forEach(skill => {
                            if (skill.power) skill.power = parseFloat((skill.power * 1.05).toFixed(2)); // 威力を5%上昇
                        });
                        // 新スキル習得
                        if (character.level === 2 && character.unlockableSkill) {
                            character.skills.push(character.unlockableSkill);
                            log(`${character.name}は強くなった！ さらに、新しいスキル「${character.unlockableSkill.name}」を覚えた！`);
                        } else if (character.level === 4 && character.unlockableSkillLv4) {
                            character.skills.push(character.unlockableSkillLv4);
                            log(`${character.name}は大きく成長した！ 奥義「${character.unlockableSkillLv4.name}」を習得！`);
                        } else {
                            log(`${character.name}は強くなった！`);
                        }
                        if (showUI) {
                            levelUpModal.classList.add('hidden');
                            updatePartyStatus();
                            if (isEndless) {
                                showEndlessBonusModal();
                            } else {
                                dungeonCommands.classList.remove('hidden');
                            }
                        }
                    }

                    function showEndlessBonusModal() {
                        endlessBonusButtons.innerHTML = '';
                        const aliveParty = gameState.party.filter(p => p.currentHp > 0);
                        if (aliveParty.length === 0) {
                            endBattle(false); // 全滅している場合はゲームオーバー
                            return;
                        }

                        const bonusPool = [{
                            id: 'maxHpUp',
                            text: (target) => `${target.name}の最大HPが永続上昇`,
                            effect: (target) => {
                                target.maxHp += 20;
                                log(`${target.name}の最大HPが20上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'maxMpUp',
                            text: (target) => `${target.name}の最大MPが永続上昇`,
                            effect: (target) => {
                                target.maxMp += 10;
                                log(`${target.name}の最大MPが10上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'atkUp',
                            text: (target) => `${target.name}の攻撃力が永続上昇`,
                            effect: (target) => {
                                target.atk += 3;
                                log(`${target.name}の攻撃力が3上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'defUp',
                            text: (target) => `${target.name}の防御力が永続上昇`,
                            effect: (target) => {
                                target.def += 2;
                                log(`${target.name}の防御力が2上昇した！`);
                            },
                            weight: 10,
                            needsTarget: true
                        }, {
                            id: 'cureStrip',
                            text: () => '全員の脱衣状態を治す',
                            effect: () => {
                                gameState.party.forEach(p => delete p.statusEffects.stripped);
                                log('全員が服を着て、元の状態に戻った！');
                            },
                            weight: 15,
                            condition: () => gameState.party.some(p => p.statusEffects.stripped)
                        }, {
                            id: 'allLevelUp',
                            text: () => '全員がさらにレベルアップ',
                            effect: () => {
                                gameState.party.forEach(p => {
                                    if (p.currentHp > 0) levelUpCharacter(p, false);
                                });
                                log('パーティ全員がさらにレベルアップした！');
                            },
                            weight: 3
                        }, {
                            id: 'getItems',
                            text: () => 'アイテムを5個獲得',
                            effect: () => {
                                const foundItems = [];
                                const itemIds = Object.keys(itemBlueprints).filter(id => !itemBlueprints[id].battleOnly && !itemBlueprints[id].rare);
                                for (let i = 0; i < 5; i++) {
                                    const foundItemId = itemIds[Math.floor(Math.random() * itemIds.length)];
                                    addItemToInventory(foundItemId);
                                    foundItems.push(itemBlueprints[foundItemId].name);
                                }
                                log(`アイテムを5個手に入れた！ (${foundItems.join('、')})`);
                            },
                            weight: 12
                        }, {
                            id: 'getRareItem',
                            text: () => 'レアアイテムを1個獲得',
                            effect: () => {
                                const rareItemIds = Object.keys(itemBlueprints).filter(id => itemBlueprints[id].rare);
                                const foundItemId = rareItemIds[Math.floor(Math.random() * rareItemIds.length)];
                                addItemToInventory(foundItemId);
                                log(`なんと、とても珍しい「${itemBlueprints[foundItemId].name}」を見つけた！`);
                            },
                            weight: 2
                        }, {
                            id: 'becomeCute',
                            text: (target) => `${target.name}がかわいくなる`,
                            effect: (target) => {
                                const diff = 1 - target.height;
                                animateStatChange(target, 'height', diff, 'decrease');
                                log(`突然の光に包まれ、${target.name}の身長が1cmになってしまった！`);
                            },
                            weight: 1,
                            needsTarget: true
                        }, ];

                        let selectedBonuses = [];
                        let availableBonuses = [...bonusPool];

                        while (selectedBonuses.length < 4 && availableBonuses.length > 0) {
                            // 条件を満たすボーナスのみをフィルタリング
                            const filteredBonuses = availableBonuses.filter(b => !b.condition || b.condition());
                            if (filteredBonuses.length === 0) break;

                            // 重み付け抽選
                            const totalWeight = filteredBonuses.reduce((sum, b) => sum + b.weight, 0);
                            let random = Math.random() * totalWeight;
                            let chosenBonus = null;
                            for (const bonus of filteredBonuses) {
                                random -= bonus.weight;
                                if (random <= 0) {
                                    chosenBonus = bonus;
                                    break;
                                }
                            }
                            if (!chosenBonus) chosenBonus = filteredBonuses[filteredBonuses.length - 1];

                            // ターゲットが必要な場合は抽選
                            let target = null;
                            if (chosenBonus.needsTarget) {
                                target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                            }

                            selectedBonuses.push({...chosenBonus,
                                target
                            });

                            // 同じIDのボーナスは再度選ばれないようにする
                            availableBonuses = availableBonuses.filter(b => b.id !== chosenBonus.id);
                        }

                        // 選択肢ボタンを生成
                        selectedBonuses.forEach(bonus => {
                            const button = document.createElement('button');
                            button.className = 'action-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-4 rounded-lg shadow-lg text-left';

                            let buttonText = bonus.text(bonus.target);
                            let description = '';
                            if (bonus.id === 'becomeCute') description = '（効果は不明）';

                            button.innerHTML = `
                                ${buttonText}
                                <span class="block text-xs text-blue-200">${description}</span>
                            `;

                            button.onclick = () => {
                                endlessBonusModal.classList.add('hidden');
                                bonus.effect(bonus.target);
                                // 選択後、少し待ってからUIを更新し、次のフロアへ
                                setTimeout(() => {
                                    updatePartyStatus();
                                    dungeonCommands.classList.remove('hidden');
                                }, 1000);
                            };
                            endlessBonusButtons.appendChild(button);
                        });

                        dungeonCommands.classList.add('hidden');
                        endlessBonusModal.classList.remove('hidden');
                    }

                    function flashCard(target, type) {
                        const card = target.isEnemy ?
                            document.getElementById(`enemy-card-${gameState.enemies.indexOf(target)}`) :
                            document.getElementById(`party-card-${gameState.party.indexOf(target)}`);

                        if (card) {
                            const className = `flash-${type}`;
                            card.classList.add(className);
                            setTimeout(() => {
                                card.classList.remove(className);
                            }, 500); // アニメーション時間と合わせる
                        }
                    }

                    // Renamed and extended flashStat to handle both visual flash and number animation
                    async function animateStatChange(target, statName, changeAmount, type) {
                        if (target.isEnemy) return; // 敵のステータスは表示されていないので何もしない

                        const card = document.getElementById(`party-card-${gameState.party.indexOf(target)}`);
                        if (!card) return;

                        const statElement = card.querySelector(`.stat-${statName}`);
                        if (!statElement) return;

                        const statSpan = statElement.querySelector('.font-semibold'); // The span holding the actual number
                        if (!statSpan) {
                            // If there's no specific number span (e.g., for 'atk' if it were displayed)
                            // Just do the background flash and return
                            const className = `stat-flash-${type}`;
                            statElement.classList.add(className);
                            setTimeout(() => statElement.classList.remove(className), 800);
                            return;
                        }

                        const duration = 500; // Animation duration for number change
                        const flashDuration = 800; // Animation duration for background flash

                        // Apply background flash
                        const flashClassName = `stat-flash-${type}`;
                        statElement.classList.add(flashClassName);
                        setTimeout(() => statElement.classList.remove(flashClassName), flashDuration);

                        // Get current displayed value (before gameState update)
                        let startValue;
                        if (statName === 'height') startValue = parseInt(statSpan.textContent.replace('cm', ''));
                        else startValue = parseInt(statSpan.textContent);

                        // Update the actual game state value
                        if (statName === 'hp') target.currentHp += changeAmount;
                        else if (statName === 'mp') target.currentMp += changeAmount;
                        else if (statName === 'height') target.height += changeAmount;

                        // Clamp values to min/max
                        target.currentHp = Math.min(target.maxHp, Math.max(0, target.currentHp));
                        target.currentMp = Math.min(target.maxMp, Math.max(0, target.currentMp));
                        target.height = Math.max(1, Math.round(target.height)); // 整数にして1cmでクランプ

                        const endValue = (statName === 'hp') ? target.currentHp :
                            (statName === 'mp') ? target.currentMp :
                            (statName === 'height') ? target.height : startValue; // Fallback

                        const startTime = performance.now();
                        let resolveAnimation;
                        const animationPromise = new Promise(resolve => {
                            resolveAnimation = resolve;
                        });

                        function updateNumber(currentTime) {
                            const elapsedTime = currentTime - startTime;
                            const progress = Math.min(1, elapsedTime / duration);
                            const currentValue = Math.round(startValue + (endValue - startValue) * progress);

                            // Update the displayed number and bar
                            if (statName === 'hp') {
                                statSpan.textContent = currentValue;
                                const hpBarInner = card.querySelector('.hp-bar-inner');
                                if (hpBarInner) hpBarInner.style.width = `${Math.max(0, currentValue / target.maxHp * 100)}%`;
                            } else if (statName === 'mp') {
                                statSpan.textContent = currentValue;
                                const mpBarInner = card.querySelector('.mp-bar-inner');
                                if (mpBarInner) mpBarInner.style.width = `${Math.max(0, currentValue / target.maxMp * 100)}%`;
                            } else if (statName === 'height') {
                                statSpan.textContent = `${currentValue}cm`;
                                const heightDiffElement = card.querySelector('.stat-height');
                                if (heightDiffElement) {
                                    const diff = currentValue - target.initialHeight; // Use currentValue for diff during animation
                                    heightDiffElement.innerHTML = `身長: <span class="font-semibold">${currentValue}cm</span> (${diff >= 0 ? '+' : ''}${diff})`;
                                }
                            }

                            if (progress < 1) {
                                requestAnimationFrame(updateNumber);
                            } else {
                                // Ensure final value is set after animation
                                if (statName === 'hp') {
                                    statSpan.textContent = endValue;
                                    const hpBarInner = card.querySelector('.hp-bar-inner');
                                    if (hpBarInner) hpBarInner.style.width = `${Math.max(0, endValue / target.maxHp * 100)}%`;
                                } else if (statName === 'mp') {
                                    statSpan.textContent = endValue;
                                    const mpBarInner = card.querySelector('.mp-bar-inner');
                                    if (mpBarInner) mpBarInner.style.width = `${Math.max(0, endValue / target.maxMp * 100)}%`;
                                } else if (statName === 'height') {
                                    statSpan.textContent = `${endValue}cm`;
                                    const heightDiffElement = card.querySelector('.stat-height');
                                    if (heightDiffElement) {
                                        const diff = endValue - target.initialHeight;
                                        heightDiffElement.innerHTML = `身長: <span class="font-semibold">${endValue}cm</span> (${diff >= 0 ? '+' : ''}${diff})`;
                                    }
                                }
                                resolveAnimation();
                            }
                        }
                        requestAnimationFrame(updateNumber);
                        return animationPromise;
                    }

                    function getStatusAndBuffsHtml(target) {
                        let html = '<div class="mt-3 pt-3 border-t border-gray-300 space-y-1">';
                        let hasEffect = false;

                        const effectMap = {
                            // buffs
                            'atk_up': {
                                name: '攻撃力アップ',
                                color: 'text-red-600'
                            },
                            'protect': {
                                name: '防御力アップ',
                                color: 'text-blue-600'
                            },
                            'agi_up': {
                                name: '素早さアップ',
                                color: 'text-green-600'
                            },
                            'provoke': {
                                name: '挑発',
                                color: 'text-orange-600'
                            },
                            'cover': {
                                name: 'かばう',
                                color: 'text-amber-600'
                            },
                            'evade_up': {
                                name: '回避アップ',
                                color: 'text-cyan-600'
                            },
                            'guardian_high': {
                                name: 'ガーディアンズハイ',
                                color: 'text-stone-600'
                            },
                            'trouble_check': {
                                name: 'ばっちりチェック',
                                color: 'text-rose-600'
                            },
                            // statusEffects (good)
                            'regeneration': {
                                name: 'HP自動回復',
                                color: 'text-green-700'
                            },
                            // statusEffects (bad)
                            'poison': {
                                name: '毒',
                                color: 'text-purple-600'
                            },
                            'paralysis': {
                                name: '麻痺',
                                color: 'text-yellow-600'
                            },
                            'slow': {
                                name: '鈍化',
                                color: 'text-gray-600'
                            },
                            'stripped': {
                                name: '脱衣',
                                color: 'text-pink-600'
                            },
                            'stat_down': {
                                name: '能力低下',
                                color: 'text-gray-600'
                            },
                        };

                        const allEffects = {...target.buffs,
                            ...target.statusEffects
                        };

                        for (const key in allEffects) {
                            if (effectMap[key]) {
                                hasEffect = true;
                                const effect = effectMap[key];
                                const turns = (typeof allEffects[key] === 'object' && allEffects[key].turns !== undefined) ? allEffects[key].turns : (typeof allEffects[key] === 'number' ? allEffects[key] : null);
                                html += `<p class="${effect.color} font-semibold">${effect.name} ${turns !== null ? `(残り ${turns} ターン)` : ''}</p>`;
                        }
                    }

                    if (!hasEffect) return ''; // 効果がなければ何も返さない
                    return html + '</div>';
            }

            function showScanResult(target) {
                const scanModalTitle = document.getElementById('scan-modal-title');
                const scanModalContent = document.getElementById('scan-modal-content');
                scanModalContent.innerHTML = ''; // コンテンツをクリア

                if (target.isEnemy) {
                    scanModalTitle.textContent = `${target.name} の調査結果`;

                    let weakness = '物理・魔法ともに同程度有効。';
                    if (target.pDef < target.mDef * 0.8) {
                        weakness = '<strong class="text-red-600">物理攻撃が有効。</strong> 魔法攻撃は効きにくい。';
                    } else if (target.mDef < target.pDef * 0.8) {
                        weakness = '<strong class="text-blue-600">魔法攻撃が有効。</strong> 物理攻撃は効きにくい。';
                    }

                    let skillInfo = '特別なスキルは使用しない。';
                    if (target.skills && target.skills.length > 0) {
                        skillInfo = '使用スキル: ' + target.skills.map(s => s.name).join('、');
                    }

                    scanModalContent.innerHTML = `
                        <p>HP: ${target.currentHp} / ${target.maxHp}</p>
                        <p>弱点: ${weakness}</p>
                        <p>${skillInfo}</p>
                        ${getStatusAndBuffsHtml(target)}
                    `;
                } else { // 味方の場合
                    scanModalTitle.textContent = `${target.name} の情報`;
                    const blueprint = allCharacterBlueprints.find(c => c.name === target.name);
                    let skillHtml = target.skills.map(skill => {
                        return `<div class="p-2 bg-gray-100 rounded-md">
                                    <p class="font-bold">${skill.name} <span class="text-sm font-normal text-gray-600">(${skill.type.includes('hp_cost') ? 'HP' : 'MP'}:${skill.cost})</span></p>
                                    <p class="text-sm">${skill.description}</p>
                                </div>`;
                    }).join('');

                    scanModalContent.innerHTML = `
                        <p class="italic">"${blueprint.description}"</p>
                        <div class="space-y-2 mt-2">${skillHtml}</div>
                        ${getStatusAndBuffsHtml(target)}
                    `;
                }

                scanModal.classList.remove('hidden');
                pendingAction = null; // アクションをクリア
                document.querySelectorAll('.enemy-card, .character-card').forEach(c => c.classList.remove('targeted'));
            }

            function showItemModal(character = null) {
                itemList.innerHTML = '';
                const availableItems = gameState.inventory.filter(item => item.quantity > 0);

                if (availableItems.length === 0) {
                    itemList.innerHTML = '<p class="text-gray-500">使えるアイテムがありません。</p>';
                } else {
                    availableItems.forEach(item => {
                        const itemInfo = itemBlueprints[item.id];
                        let canUse = gameState.inBattle || !itemInfo.battleOnly;

                        // 復活アイテムは戦闘中で、かつ戦闘不能の味方がいる場合のみ使用可能
                        if (itemInfo.effect === 'revive') {
                            const hasFallenAlly = gameState.party.some(p => p.currentHp <= 0);
                            canUse = gameState.inBattle && hasFallenAlly;
                        }

                        const itemDiv = document.createElement('div');
                        let itemClasses = 'p-2 border-b flex justify-between items-center';
                        if (!canUse) {
                            itemClasses += ' opacity-50';
                        }
                        itemDiv.className = itemClasses;

                        itemDiv.innerHTML = `
                            <div>
                                <p class="font-bold">${itemInfo.name} (x${item.quantity})</p>
                                <p class="text-sm text-gray-600">${itemInfo.description}</p>
                            </div>
                            <button 
                                class="use-item-btn action-button text-white text-sm py-1 px-3 rounded ${canUse ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-400 cursor-not-allowed'}"
                                ${!canUse ? 'disabled' : ''}
                            >つかう</button>
                        `;
                        itemDiv.querySelector('.use-item-btn').onclick = () => {
                            useItem(character, item);
                        };
                        itemList.appendChild(itemDiv);
                    });
                }
                itemModal.classList.remove('hidden');
            }

            function useItem(character, item) {
                itemModal.classList.add('hidden');
                const itemInfo = itemBlueprints[item.id];

                if (!gameState.inBattle && itemInfo.battleOnly) {
                    log("そのアイテムはバトル中にしか使えません。");
                    return;
                }

                if (gameState.inBattle) {
                    playerAction(character, {
                        type: 'item',
                        item: item
                    });
                } else {
                    // 探索中のアイテム使用
                    pendingAction = {
                        character: getRandomPartyMember(),
                        action: {
                            type: 'item',
                            item: item
                        },
                        target: null // ターゲットは後で選択
                    };
                    if (itemInfo.target === 'ally' || itemInfo.target === 'any') {
                        log('誰に使いますか？');
                        // 復活アイテムの場合、戦闘不能の味方をターゲット可能にする
                        if (itemInfo.effect === 'revive') {
                            gameState.party.forEach((char, index) => {
                                // 戦闘不能のキャラのみ光らせる
                                if (char.currentHp <= 0) {
                                    document.getElementById(`party-card-${index}`).classList.add('targeted');
                                }
                            });
                            return; // ここで処理を中断し、ユーザーの選択を待つ
                        }
                        gameState.party.forEach((char, index) => {
                            if (char.currentHp > 0) document.getElementById(`party-card-${index}`).classList.add('targeted');
                        });
                    } else if (itemInfo.target === 'party') {
                        // 全体対象や対象不要のアイテム
                        handleItem(pendingAction.character, gameState.party, pendingAction.action.item);
                    } else {
                        // 全体対象や対象不要のアイテム
                        executePlayerAction();
                    }
                }
            }

            function startGame(mode = 'normal', selectedMembers = null, fromSave = false) {
                // パーティ表示をクリア
                partyContainer.innerHTML = '';

                gameState.gameMode = mode;

                // メンバー選択が必要なモードで、まだメンバーが選ばれていない場合 (聖女の行進は除く)
                if ((mode === 'solo' || mode === 'indecent' || mode === 'trial' || (toggleSelectTeam.checked && mode !== 'normal')) && !selectedMembers && mode !== 'saint_march') {
                    whatIfModal.classList.add('hidden');
                    showSelectTeamModal(mode); // モードを引き継いで選択画面へ
                    return;
                }

                titleScreen.classList.add('hidden');
                whatIfModal.classList.add('hidden');
                selectTeamModal.classList.add('hidden');
                dungeonView.classList.remove('hidden');
                hud.classList.remove('hidden');
                commandContainer.classList.remove('hidden');

                if (mode === 'saint_march') {
                    selectedMembers = ['セレスティア'];
                }

                initGame(selectedMembers, fromSave);

                setupDungeonUI();
                dungeonCommands.classList.remove('hidden');
                battleCommands.classList.add('hidden');
                enemyContainer.innerHTML = '';
                updatePartyStatus();
            }

            nextFloorButton.addEventListener('click', () => {
                if (!gameState.inBattle && !gameState.gameOver) advanceFloor();
            });
            talkButton.addEventListener('click', generateConversation);
            modalButton.addEventListener('click', () => {
                returnToTitle();
            });
            itemModalClose.addEventListener('click', () => {
                itemModal.classList.add('hidden');
                document.querySelectorAll('.character-card').forEach(c => c.classList.remove('targeted'));
            });
            loadButton.addEventListener('click', () => {
                const savedData = localStorage.getItem('sizeDungeonSaveData');
                if (savedData) {
                    try {
                        const loadedState = JSON.parse(savedData);
                        // セーブデータをgameStateに復元
                        gameState = loadedState;
                        // ゲーム画面を直接セットアップ
                        titleScreen.classList.add('hidden');
                        dungeonView.classList.remove('hidden');
                        hud.classList.remove('hidden');
                        commandContainer.classList.remove('hidden');
                        setupDungeonUI();
                        updatePartyStatus();
                        log("セーブデータをロードしました。");
                    } catch (e) {
                        console.error("セーブデータの読み込みに失敗しました:", e);
                        alert("セーブデータの形式が正しくありません。");
                    }
                }
            });
            startButton.addEventListener('click', () => startGame('normal'));
            ruleButton.addEventListener('click', () => ruleModal.classList.remove('hidden'));
            ruleModalClose.addEventListener('click', () => ruleModal.classList.add('hidden'));
            whatIfButton.addEventListener('click', () => whatIfModal.classList.remove('hidden'));
            whatIfModalClose.addEventListener('click', () => whatIfModal.classList.add('hidden'));
            selectTeamBackButton.addEventListener('click', () => {
                // 選択状態をリセット
                pendingAction = null;
                selectTeamModal.classList.add('hidden');
                whatIfModal.classList.remove('hidden');
            });

            document.querySelectorAll('#what-if-list button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const mode = e.currentTarget.dataset.mode;
                    // startGameを呼び出す。メンバー選択が必要なら中で処理される
                    startGame(mode);
                });
            });
            scanModalClose.addEventListener('click', () => {
                scanModal.classList.add('hidden');
                // 「調べる」をキャンセルした場合、元のキャラクターのターンに戻す
                if (gameState.inBattle && !pendingAction) {
                    playerTurn(gameState.turnOrder[gameState.currentTurnIndex]);
                }
            });

            menuButton.addEventListener('click', () => {
                if (!gameState.inBattle) { // 戦闘中でなければメニューを開ける
                    menuModal.classList.remove('hidden');
                } else {
                    log("戦闘中はメニューを開けません。");
                }
            });
            menuModalClose.addEventListener('click', () => menuModal.classList.add('hidden'));
            saveButton.addEventListener('click', () => {
                try {
                    localStorage.setItem('sizeDungeonSaveData', JSON.stringify(gameState));
                    log("ゲームの状態をセーブしました。");
                    menuModal.classList.add('hidden');
                    checkSaveData(); // セーブ後に「つづきから」ボタンの状態を更新
                } catch (e) {
                    console.error("セーブに失敗しました:", e);
                    log("セーブに失敗しました。ブラウザのストレージ容量が不足している可能性があります。");
                }
            });
            menuReturnTitleButton.addEventListener('click', () => {
                menuModal.classList.add('hidden');
                returnToTitle();
            });

            function showSelectTeamModal(mode) {
                teamSelectionList.innerHTML = '';
                let selectedNames = [];
                const isSolo = mode === 'solo';
                const isIndecent = mode === 'indecent';
                const isTrial = mode === 'trial' || mode === 'enjoy';

                // モードに応じてプロンプトと選択上限を変更
                if (isSolo) {
                    selectionPrompt.textContent = '共に冒険する仲間を1人選んでください。';
                } else if (isIndecent) {
                    selectionPrompt.textContent = '共に冒険する仲間を2～4人選んでください。(ナイト、サムライは選択不可)';
                } else if (isTrial) {
                    selectionPrompt.textContent = '共に冒険する仲間を2～4人選んでください。(このモードはチーム選択が可能です)';
                } else {
                    selectionPrompt.textContent = '共に冒険する仲間を2～4人選んでください。';
                }

                // 表示するキャラクターリストを準備
                let availableBlueprints = allCharacterBlueprints.filter(char => char.role !== '聖女');
                const clearFlags = JSON.parse(localStorage.getItem('sizeDungeonClearFlags') || '{}');
                if (clearFlags.saintMarchCleared) {
                    const saint = allCharacterBlueprints.find(char => char.role === '聖女');
                    if (saint) {
                        availableBlueprints.push(saint);
                    }
                }

                availableBlueprints.forEach(char => {
                    if (isIndecent && (char.role === 'ナイト' || char.role === 'サムライ' || char.role === '聖女')) {
                        return; // 痴態騒ぎモードではナイト、サムライ、聖女をスキップ
                    }

                    const card = document.createElement('div');
                    card.className = `p-4 border-2 border-gray-200 rounded-lg cursor-pointer hover:bg-gray-100 transition ${char.role === '聖女' ? 'border-yellow-300 bg-yellow-50' : ''}`;
                    card.dataset.name = char.name;
                    card.innerHTML = `
                        <p class="font-bold text-lg text-${char.themeColor}-700">${char.name}</p>
                        <p class="text-sm text-gray-600">${char.role}</p>
                    `;
                    card.addEventListener('click', () => {
                        if (selectedNames.includes(char.name)) {
                            selectedNames = selectedNames.filter(name => name !== char.name);
                            card.classList.remove('border-indigo-500', 'bg-indigo-50');
                        } else if (isSolo && selectedNames.length < 1) {
                            selectedNames.push(char.name);
                            card.classList.add('border-indigo-500', 'bg-indigo-50');
                        } else if (!isSolo && selectedNames.length < 4) {
                            selectedNames.push(char.name);
                            card.classList.add('border-indigo-500', 'bg-indigo-50');
                        }
                        updateSelectionUI();
                    });
                    teamSelectionList.appendChild(card);
                });

                function updateSelectionUI() {
                    let isValid;
                    if (isSolo) {
                        selectionCounter.textContent = `${selectedNames.length} / 1 人選択中`;
                        isValid = selectedNames.length === 1;
                    } else if (isIndecent || isTrial) {
                        selectionCounter.textContent = `${selectedNames.length} 人選択中`;
                        isValid = selectedNames.length >= 2 && selectedNames.length <= 4;
                    } else {
                        selectionCounter.textContent = `${selectedNames.length} 人選択中`;
                        isValid = selectedNames.length >= 2 && selectedNames.length <= 4;
                    }
                    startSelectionButton.disabled = !isValid;
                    startSelectionButton.classList.toggle('opacity-50', !isValid);
                    startSelectionButton.classList.toggle('cursor-not-allowed', !isValid);
                }

                startSelectionButton.onclick = () => {
                    const count = selectedNames.length;
                    const validSolo = isSolo && count === 1;
                    const validTrial = isTrial && count >= 2 && count <= 4;
                    const validIndecent = isIndecent && count >= 2 && count <= 4;
                    const validTeam = !isSolo && !isIndecent && !isTrial && count >= 2 && count <= 4;

                    if (validSolo || validIndecent || validTrial || validTeam) startGame(gameState.gameMode, selectedNames);
                };

                selectTeamModal.classList.remove('hidden');
            }

            randomSelectButton.addEventListener('click', () => {
                const teamListContainer = document.getElementById('team-selection-list');
                const allCharacterCards = Array.from(teamListContainer.children);
                const availableCharacters = allCharacterCards.map(card => card.dataset.name);

                // Fisher-Yates shuffle algorithm
                for (let i = availableCharacters.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availableCharacters[i], availableCharacters[j]] = [availableCharacters[j], availableCharacters[i]];
                }

                const isSolo = gameState.gameMode === 'solo';
                const selectionCount = isSolo ? 1 : 4;
                const randomSelection = availableCharacters.slice(0, selectionCount);

                // Simulate clicks on the character cards
                allCharacterCards.forEach(card => {
                    const shouldBeSelected = randomSelection.includes(card.dataset.name);
                    const isCurrentlySelected = card.classList.contains('border-indigo-500');
                    if (shouldBeSelected !== isCurrentlySelected) card.click();
                });
            });

            function returnToTitle() {
                modal.classList.add('hidden');
                titleScreen.classList.remove('hidden');
                dungeonView.classList.add('hidden');
                hud.classList.add('hidden');
                commandContainer.classList.add('hidden');
                checkSaveData(); // タイトルに戻るたびにセーブデータの有無をチェック
            }

            function checkSaveData() {
                if (localStorage.getItem('sizeDungeonSaveData')) {
                    loadButton.classList.remove('hidden');
                } else {
                    loadButton.classList.add('hidden');
                }
            }
            checkSaveData(); // 初期ロード時にセーブデータを確認
        });
    </script>
</body>

</html>